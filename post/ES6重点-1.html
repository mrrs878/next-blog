<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-ES6重点-1</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c254d3655a5edcea.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c254d3655a5edcea.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd1d19dd7237c4c.js" defer=""></script><script src="/_next/static/chunks/443-78ba638de598a708.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-8e525edef48fb7d5.js" defer=""></script><script src="/_next/static/uQJHLsOjU_t-1I9pLYt1c/_buildManifest.js" defer=""></script><script src="/_next/static/uQJHLsOjU_t-1I9pLYt1c/_ssgManifest.js" defer=""></script><script src="/_next/static/uQJHLsOjU_t-1I9pLYt1c/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/">分类</a></li><li class="ml-4 hover:text-yellow"><a href="/">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">ES6重点-1</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-02-19 23:01:48</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h2 id="字符串新增方法">字符串新增方法</h2>
<ul>
<li><p><code>padStart</code></p>
<p>用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>)); <span class="hljs-comment">//补全位数，有需要会重复或截取</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 不传第二个参数默认使用空格补全</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 补全后的长度小于源字符串长度则不做任何改变</span>

<span class="hljs-comment">// abax</span>
<span class="hljs-comment">// axxx</span>
<span class="hljs-comment">//    x</span>
<span class="hljs-comment">// xxx</span>
</code></pre>
</li>
<li><p><code>padEnd</code></p>
<p>和<code>padStart</code>效果相反，从尾部开始补全</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;abc&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">4</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">2</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>));

<span class="hljs-comment">// xabca</span>
<span class="hljs-comment">// x   </span>
<span class="hljs-comment">// xxx</span>
<span class="hljs-comment">// xxxa</span>
</code></pre>
</li>
</ul>
<h2 id="对象新增扩展">对象新增扩展</h2>
<ul>
<li><p>链判断运算符</p>
<p>在ES5中，取对象属性时，往往需要判断以下该对象是否存在。如下</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> name = (store 
    &amp;&amp; store.<span class="hljs-property">state</span> 
    &amp;&amp; store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span> 
    &amp;&amp; store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span>) || <span class="hljs-string">&quot;tom&quot;</span>
</code></pre>
<p>这种层层判断过于麻烦，因此ES2020引入链判断运算符<code>?.</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> name = store?.<span class="hljs-property">state</span>?.<span class="hljs-property">user</span>?.<span class="hljs-property">name</span>
</code></pre>
<p>如果左侧的对象为<code>null</code>或<code>undefined</code>则直接返回<code>undefined</code>，不再往下运算</p>
</li>
<li><p><code>null</code>判断运算符</p>
<p>独去对象属性时，如果某个属性的值时<code>null</code>或<code>undefined</code>，有时需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> name = user.<span class="hljs-property">name</span> || <span class="hljs-string">&quot;tom&quot;</span>
<span class="hljs-keyword">const</span> age = user.<span class="hljs-property">age</span> || <span class="hljs-number">20</span>
</code></pre>
<p>原意是属性值为<code>null</code>或<code>undefined</code>时默认值就生效，但当<code>user.name</code>为空串或<code>user.age</code>为0时默认值也会生效</p>
<p>为此ES2020引入新的<code>null</code>判断运算符<code>??</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> name = user.<span class="hljs-property">name</span> ?? <span class="hljs-string">&quot;tom&quot;</span>
<span class="hljs-keyword">const</span> age = user.<span class="hljs-property">age</span> ?? <span class="hljs-number">20</span>
</code></pre>
</li>
</ul>
<h2 id="对象新增方法">对象新增方法</h2>
<ul>
<li><p><code>Object.is</code></p>
<p>用来替代 <code>==</code>和<code>===</code></p>
<p><code>==</code> 会进行自动类型转换，<code>===</code> 在比较+0和-0时返回<code>true</code>，<code>NaN</code>不等于自身</p>
</li>
<li><p><code>Object.assign</code></p>
<p>用于对象合并</p>
<ul>
<li>只拷贝源对象的<strong>自身、可枚举属性（含Symbol）</strong></li>
<li>浅拷贝</li>
<li>同名属性会被覆盖</li>
<li>除首参数外（<code>null</code>、<code>undefined</code>会报错），非对象会被转换为对象</li>
</ul>
</li>
<li><p><code>Object.keys</code></p>
<p>返回对象<strong>自身的</strong>、<strong>可遍历的</strong>属性的键名<strong>数组</strong></p>
</li>
<li><p><code>Object.fromEntries/Object.entries</code></p>
<p><code>Object.fromEntries</code>将一个键值对数组转换为一个对象，适合将<code>Map</code>转换为<code>Object</code></p>
<p><code>Object.entries</code>逆操作，用于将<code>Object</code>转换为键值对数组</p>
</li>
</ul>
<h2 id="array扩展">Array扩展</h2>
<ul>
<li><p><code>Array.of</code></p>
<p>弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Array</span>() <span class="hljs-comment">//[]</span>
<span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//[ , , ]</span>
<span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">//[3, 4, 5]</span>

<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">// []</span>
<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//[3]</span>
<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">//[3, 4, 5]</span>
</code></pre>
</li>
<li><p><code>Array.prototype.copyWithin()</code></p>
<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">copyWithin</span>(target, start = <span class="hljs-number">0</span>, end = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>)

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
<span class="hljs-comment">// [4, 5, 3, 4, 5]</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-comment">// [4, 2, 3, 4, 5]</span>
</code></pre>
</li>
<li><p><code>Array.prototype.flat() &amp;&amp; Array.prototype.flatMap()</code></p>
<p><code>flat()</code>用于将数据降维，参数为降低的维数（默认为1）,如果不管有多少层维，都要转为一维数组，可使用<code>Infinity</code>关键字作为参数</p>
<p>如果原数组有空位<code>flat()</code>会跳过</p>
<pre><code class="hljs language-js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]].<span class="hljs-title function_">flat</span>()
<span class="hljs-comment">// [1, 2, 1, 2]</span>

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>]]].<span class="hljs-title function_">flat</span>()
<span class="hljs-comment">// [1, 2, 1, 2, 1, [2]]</span>

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>]]].<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)
<span class="hljs-comment">// [1, 2, 1, 2, 1, 2]</span>

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>]]].<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>)
<span class="hljs-comment">// [1, 2, 1, 2, 1, 2]</span>
</code></pre>
<p><code>flatMap()</code>相当于<code>Array.prorotype.Map</code> + <code>Array.prorotype.flat</code></p>
<pre><code class="hljs language-js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x, x * <span class="hljs-number">2</span>])
<span class="hljs-comment">// [1, 2, 2, 4, 3, 6]</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>)
<span class="hljs-comment">// [2, 4, 6]</span>
</code></pre>
</li>
</ul>
<h2 id="iterator">iterator</h2>
<p><strong>WHAT</strong></p>
<p>遍历器（<code>iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了<code>iterator</code>接口，就可以完成<strong>遍历</strong>操作</p>
<p><strong>WHY</strong></p>
<p>JavaScript原有的表示集合的数据结构主要是数组（Array）和对象（Object），ES6又添加了<code>Map</code>、<code>Set</code>。这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样需要一种统一的接口机制来处理不同的数据结构</p>
<p>主要作用</p>
<ul>
<li><p>为各种数据结构提供一个统一的、简便的访问接口</p>
</li>
<li><p>使得数据结构的成员能够按某种次序排列</p>
</li>
<li><p>为<code>for...of</code>所使用</p>
<p>适合遍历Array，既有<code>forEach</code>的简洁又有<code>for</code>的<code>break</code>、<code>return</code>、<code>continue</code></p>
</li>
</ul>
<p><strong>HOW</strong></p>
<p><code>iterator</code>的遍历过程</p>
<ol>
<li>创建一个指针对象，指向当前的数据结构的起始位置。也就是说遍历器对象本质上就是一个指针对象</li>
<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</li>
<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</li>
</ol>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象，其中<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示是否遍历结束</p>
<p>ES6规定，默认的<code>iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是可遍历的（<code>iterable</code>）</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">data</span>: [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>],
    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](): {
        <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>
        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {
                <span class="hljs-keyword">if</span> (index &lt; self.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>) {
                    <span class="hljs-keyword">return</span> {
                        <span class="hljs-attr">value</span>: self.<span class="hljs-property">data</span>[index++]
                        <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>
                    }
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,
                    <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>
                }
            }
        }
    }
}
</code></pre>
<p>原生具备iterator接口的数据结构：<code>Map、Array、Set、String、TypedArray、arguments、NodeList对象</code></p>
<h2 id="let-vs-const">let VS const</h2>
<p>在let和const之间，建议优先使用const，尤其是在全局环境。const优于let的几个原因：</p>
<ul>
<li>const可以提醒阅读程序的人，这个变量不应该改变</li>
<li>const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式计算</li>
<li>JavaScript编译器会对const进行优化</li>
<li>长远来看，JavaScript可能会有多线程的实现，这时let表示的变量只应出现在单线程运行的代码中，不是多线程共享的，这样有利于线程安全</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>
<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span>;
<span class="hljs-comment">// best</span>
<span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</code></pre>
<h2 id="generator">generator</h2>
<p>ES6提供的一种异步编程解决方案</p>
<p>形式上，<code>generator</code>函数是一个状态机，封装了多个内部状态。执行<code>generator</code>函数会返回一个<strong>遍历器对象</strong>。</p>
<p>语法上，<code>generator</code>函数是一个普通函数。<code>function</code>关键字与函数名之间有一个<code>*</code>；函数体内部使用<code>yield</code>表达式定义不同的内部状态</p>
<p>与普通函数不同，generator函数被调用后并不执行，返回的是一个指向内部状态的指针对象，也就是<strong>遍历器对象</strong>。下一步，必须调用遍历器对象的<code>next</code>方法使得指针移向下一个状态。也就是说每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> str1 = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;hello&quot;</span>
  <span class="hljs-comment">// str1 = 222</span>
  <span class="hljs-keyword">const</span> str2 = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;world&quot;</span>
  <span class="hljs-comment">// str2 = 333</span>
  <span class="hljs-keyword">return</span> str2
}

<span class="hljs-keyword">const</span> iter = <span class="hljs-title function_">gen</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>())
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>(<span class="hljs-number">222</span>))
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iter.<span class="hljs-title function_">next</span>(<span class="hljs-number">333</span>))
</code></pre>
<p>第一次调用，<code>generator</code>函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>值就是当前<code>yield</code>表达式的值，done的值为<code>false</code></p>
<p>第二次调用，<code>generator</code>从上次yield表达式停下来的地方一直执行到下一个<code>yield</code>表达式 👆 ……</p>
<p>第三次调用，<code>generator</code>函数从上次<code>yield</code>表达式停下来的地方一直执行到<code>return</code>语句，next返回的<code>value</code>值就是<code>return</code>后面表达式的值，<code>done</code>为true（如果是<code>yield</code>则为<code>false</code>）</p>
<p><code>yield</code>表达式本身没有返回值（或者说总是返回undefined）。<code>next</code>方法可以带一个参数，该参数会被当作<strong>上一个</strong><code>yield</code>表达式的返回值</p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><div class="flex items-center justify-center"><span>本网站由 </span><a class="cdn-logo-c" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img class="call-me" src="https://blog.mrrs.top/img/cdn_logo.png" style="width:40px" alt=""/></a><span>提供CDN加速/云存储服务</span></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ES6重点-1","tags":["ES6"],"categories":"JavaScript","description":"## 字符串新增方法\n\n- `padStart`\n\n  用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全\n\n  ```js\n  console.log('xxx'.padStart(4, 'ab'));\n  console.log('x'.padStart(4, 'ab')); //补全位数，有需要会重复或截取\n  console.log('x'.padStart(4));","createDate":"2020-02-19 23:01:48","updateDate":"10/1/2021, 3:34:43 AM","body":"\u003ch2 id=\"字符串新增方法\"\u003e字符串新增方法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003epadStart\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;xxx\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadStart\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;ab\u0026#x27;\u003c/span\u003e));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;x\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadStart\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;ab\u0026#x27;\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e//补全位数，有需要会重复或截取\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;x\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadStart\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 不传第二个参数默认使用空格补全\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;xxx\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadStart\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 补全后的长度小于源字符串长度则不做任何改变\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// abax\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// axxx\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//    x\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// xxx\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003epadEnd\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e和\u003ccode\u003epadStart\u003c/code\u003e效果相反，从尾部开始补全\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;x\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadEnd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;abc\u0026#x27;\u003c/span\u003e));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;x\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadEnd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;xxx\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadEnd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;xxx\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadEnd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;ab\u0026#x27;\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// xabca\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// x   \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// xxx\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// xxxa\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"对象新增扩展\"\u003e对象新增扩展\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e链判断运算符\u003c/p\u003e\n\u003cp\u003e在ES5中，取对象属性时，往往需要判断以下该对象是否存在。如下\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = (store \n    \u0026amp;\u0026amp; store.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e \n    \u0026amp;\u0026amp; store.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e \n    \u0026amp;\u0026amp; store.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e) || \u003cspan class=\"hljs-string\"\u003e\u0026quot;tom\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种层层判断过于麻烦，因此ES2020引入链判断运算符\u003ccode\u003e?.\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = store?.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果左侧的对象为\u003ccode\u003enull\u003c/code\u003e或\u003ccode\u003eundefined\u003c/code\u003e则直接返回\u003ccode\u003eundefined\u003c/code\u003e，不再往下运算\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e判断运算符\u003c/p\u003e\n\u003cp\u003e独去对象属性时，如果某个属性的值时\u003ccode\u003enull\u003c/code\u003e或\u003ccode\u003eundefined\u003c/code\u003e，有时需要为它们指定默认值。常见做法是通过\u003ccode\u003e||\u003c/code\u003e运算符指定默认值\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = user.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e\u0026quot;tom\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e age = user.\u003cspan class=\"hljs-property\"\u003eage\u003c/span\u003e || \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原意是属性值为\u003ccode\u003enull\u003c/code\u003e或\u003ccode\u003eundefined\u003c/code\u003e时默认值就生效，但当\u003ccode\u003euser.name\u003c/code\u003e为空串或\u003ccode\u003euser.age\u003c/code\u003e为0时默认值也会生效\u003c/p\u003e\n\u003cp\u003e为此ES2020引入新的\u003ccode\u003enull\u003c/code\u003e判断运算符\u003ccode\u003e??\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = user.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e\u0026quot;tom\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e age = user.\u003cspan class=\"hljs-property\"\u003eage\u003c/span\u003e ?? \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"对象新增方法\"\u003e对象新增方法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eObject.is\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e用来替代 \u003ccode\u003e==\u003c/code\u003e和\u003ccode\u003e===\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e==\u003c/code\u003e 会进行自动类型转换，\u003ccode\u003e===\u003c/code\u003e 在比较+0和-0时返回\u003ccode\u003etrue\u003c/code\u003e，\u003ccode\u003eNaN\u003c/code\u003e不等于自身\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eObject.assign\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e用于对象合并\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e只拷贝源对象的\u003cstrong\u003e自身、可枚举属性（含Symbol）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e浅拷贝\u003c/li\u003e\n\u003cli\u003e同名属性会被覆盖\u003c/li\u003e\n\u003cli\u003e除首参数外（\u003ccode\u003enull\u003c/code\u003e、\u003ccode\u003eundefined\u003c/code\u003e会报错），非对象会被转换为对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eObject.keys\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e返回对象\u003cstrong\u003e自身的\u003c/strong\u003e、\u003cstrong\u003e可遍历的\u003c/strong\u003e属性的键名\u003cstrong\u003e数组\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eObject.fromEntries/Object.entries\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eObject.fromEntries\u003c/code\u003e将一个键值对数组转换为一个对象，适合将\u003ccode\u003eMap\u003c/code\u003e转换为\u003ccode\u003eObject\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eObject.entries\u003c/code\u003e逆操作，用于将\u003ccode\u003eObject\u003c/code\u003e转换为键值对数组\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"array扩展\"\u003eArray扩展\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eArray.of\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e弥补数组构造函数\u003ccode\u003eArray()\u003c/code\u003e的不足。因为参数个数的不同，会导致\u003ccode\u003eArray()\u003c/code\u003e的行为有差异\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e//[]\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//[ , , ]\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//[3, 4, 5]\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e// []\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//[3]\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//[3, 4, 5]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eArray.prototype.copyWithin()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecopyWithin\u003c/span\u003e(target, start = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, end = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e)\n\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ecopyWithin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// [4, 5, 3, 4, 5]\u003c/span\u003e\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ecopyWithin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// [4, 2, 3, 4, 5]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eArray.prototype.flat() \u0026amp;\u0026amp; Array.prototype.flatMap()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eflat()\u003c/code\u003e用于将数据降维，参数为降低的维数（默认为1）,如果不管有多少层维，都要转为一维数组，可使用\u003ccode\u003eInfinity\u003c/code\u003e关键字作为参数\u003c/p\u003e\n\u003cp\u003e如果原数组有空位\u003ccode\u003eflat()\u003c/code\u003e会跳过\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]].\u003cspan class=\"hljs-title function_\"\u003eflat\u003c/span\u003e()\n\u003cspan class=\"hljs-comment\"\u003e// [1, 2, 1, 2]\u003c/span\u003e\n\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]]].\u003cspan class=\"hljs-title function_\"\u003eflat\u003c/span\u003e()\n\u003cspan class=\"hljs-comment\"\u003e// [1, 2, 1, 2, 1, [2]]\u003c/span\u003e\n\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]]].\u003cspan class=\"hljs-title function_\"\u003eflat\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// [1, 2, 1, 2, 1, 2]\u003c/span\u003e\n\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]]].\u003cspan class=\"hljs-title function_\"\u003eflat\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eInfinity\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// [1, 2, 1, 2, 1, 2]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eflatMap()\u003c/code\u003e相当于\u003ccode\u003eArray.prorotype.Map\u003c/code\u003e + \u003ccode\u003eArray.prorotype.flat\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eflatMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u0026gt;\u003c/span\u003e [x, x * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n\u003cspan class=\"hljs-comment\"\u003e// [1, 2, 2, 4, 3, 6]\u003c/span\u003e\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eflatMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u0026gt;\u003c/span\u003e x * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// [2, 4, 6]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"iterator\"\u003eiterator\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eWHAT\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e遍历器（\u003ccode\u003eiterator\u003c/code\u003e）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了\u003ccode\u003eiterator\u003c/code\u003e接口，就可以完成\u003cstrong\u003e遍历\u003c/strong\u003e操作\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWHY\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJavaScript原有的表示集合的数据结构主要是数组（Array）和对象（Object），ES6又添加了\u003ccode\u003eMap\u003c/code\u003e、\u003ccode\u003eSet\u003c/code\u003e。这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是\u003ccode\u003eMap\u003c/code\u003e，\u003ccode\u003eMap\u003c/code\u003e的成员是对象。这样需要一种统一的接口机制来处理不同的数据结构\u003c/p\u003e\n\u003cp\u003e主要作用\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e为各种数据结构提供一个统一的、简便的访问接口\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e使得数据结构的成员能够按某种次序排列\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e为\u003ccode\u003efor...of\u003c/code\u003e所使用\u003c/p\u003e\n\u003cp\u003e适合遍历Array，既有\u003ccode\u003eforEach\u003c/code\u003e的简洁又有\u003ccode\u003efor\u003c/code\u003e的\u003ccode\u003ebreak\u003c/code\u003e、\u003ccode\u003ereturn\u003c/code\u003e、\u003ccode\u003econtinue\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eHOW\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eiterator\u003c/code\u003e的遍历过程\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建一个指针对象，指向当前的数据结构的起始位置。也就是说遍历器对象本质上就是一个指针对象\u003c/li\u003e\n\u003cli\u003e第一次调用指针对象的\u003ccode\u003enext\u003c/code\u003e方法，可以将指针指向数据结构的第一个成员\u003c/li\u003e\n\u003cli\u003e第二次调用指针对象的\u003ccode\u003enext\u003c/code\u003e方法，指针就指向数据结构的第二个成员\u003c/li\u003e\n\u003cli\u003e不断调用指针对象的\u003ccode\u003enext\u003c/code\u003e方法，直到它指向数据结构的结束位置\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e每一次调用\u003ccode\u003enext\u003c/code\u003e方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含\u003ccode\u003evalue\u003c/code\u003e和\u003ccode\u003edone\u003c/code\u003e两个属性的对象，其中\u003ccode\u003evalue\u003c/code\u003e属性是当前成员的值，\u003ccode\u003edone\u003c/code\u003e属性是一个布尔值，表示是否遍历结束\u003c/p\u003e\n\u003cp\u003eES6规定，默认的\u003ccode\u003eiterator\u003c/code\u003e接口部署在数据结构的\u003ccode\u003eSymbol.iterator\u003c/code\u003e属性，或者说，一个数据结构只要具有\u003ccode\u003eSymbol.iterator\u003c/code\u003e属性，就可以认为是可遍历的（\u003ccode\u003eiterable\u003c/code\u003e）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = {\n    \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;hello\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;world\u0026#x27;\u003c/span\u003e],\n    [\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eiterator\u003c/span\u003e](): {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e self = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e index = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index \u0026lt; self.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n                        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: self.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[index++]\n                        \u003cspan class=\"hljs-attr\"\u003edone\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n                    }\n                }\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n                    \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n                    \u003cspan class=\"hljs-attr\"\u003edone\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n                }\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原生具备iterator接口的数据结构：\u003ccode\u003eMap、Array、Set、String、TypedArray、arguments、NodeList对象\u003c/code\u003e\u003c/p\u003e\n\u003ch2 id=\"let-vs-const\"\u003elet VS const\u003c/h2\u003e\n\u003cp\u003e在let和const之间，建议优先使用const，尤其是在全局环境。const优于let的几个原因：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econst可以提醒阅读程序的人，这个变量不应该改变\u003c/li\u003e\n\u003cli\u003econst比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式计算\u003c/li\u003e\n\u003cli\u003eJavaScript编译器会对const进行优化\u003c/li\u003e\n\u003cli\u003e长远来看，JavaScript可能会有多线程的实现，这时let表示的变量只应出现在单线程运行的代码中，不是多线程共享的，这样有利于线程安全\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// bad\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, b = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, c = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// good\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e b = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e c = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// best\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [a, b, c] = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"generator\"\u003egenerator\u003c/h2\u003e\n\u003cp\u003eES6提供的一种异步编程解决方案\u003c/p\u003e\n\u003cp\u003e形式上，\u003ccode\u003egenerator\u003c/code\u003e函数是一个状态机，封装了多个内部状态。执行\u003ccode\u003egenerator\u003c/code\u003e函数会返回一个\u003cstrong\u003e遍历器对象\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e语法上，\u003ccode\u003egenerator\u003c/code\u003e函数是一个普通函数。\u003ccode\u003efunction\u003c/code\u003e关键字与函数名之间有一个\u003ccode\u003e*\u003c/code\u003e；函数体内部使用\u003ccode\u003eyield\u003c/code\u003e表达式定义不同的内部状态\u003c/p\u003e\n\u003cp\u003e与普通函数不同，generator函数被调用后并不执行，返回的是一个指向内部状态的指针对象，也就是\u003cstrong\u003e遍历器对象\u003c/strong\u003e。下一步，必须调用遍历器对象的\u003ccode\u003enext\u003c/code\u003e方法使得指针移向下一个状态。也就是说每次调用\u003ccode\u003enext\u003c/code\u003e方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个\u003ccode\u003eyield\u003c/code\u003e表达式（或\u003ccode\u003ereturn\u003c/code\u003e语句）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e* \u003cspan class=\"hljs-title function_\"\u003egen\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e str1 = \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// str1 = 222\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e str2 = \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;world\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// str2 = 333\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e str2\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e iter = \u003cspan class=\"hljs-title function_\"\u003egen\u003c/span\u003e()\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(iter.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e())\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(iter.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e222\u003c/span\u003e))\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(iter.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第一次调用，\u003ccode\u003egenerator\u003c/code\u003e函数开始执行，直到遇到第一个\u003ccode\u003eyield\u003c/code\u003e表达式为止。\u003ccode\u003enext\u003c/code\u003e方法返回一个对象，它的\u003ccode\u003evalue\u003c/code\u003e值就是当前\u003ccode\u003eyield\u003c/code\u003e表达式的值，done的值为\u003ccode\u003efalse\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e第二次调用，\u003ccode\u003egenerator\u003c/code\u003e从上次yield表达式停下来的地方一直执行到下一个\u003ccode\u003eyield\u003c/code\u003e表达式 👆 ……\u003c/p\u003e\n\u003cp\u003e第三次调用，\u003ccode\u003egenerator\u003c/code\u003e函数从上次\u003ccode\u003eyield\u003c/code\u003e表达式停下来的地方一直执行到\u003ccode\u003ereturn\u003c/code\u003e语句，next返回的\u003ccode\u003evalue\u003c/code\u003e值就是\u003ccode\u003ereturn\u003c/code\u003e后面表达式的值，\u003ccode\u003edone\u003c/code\u003e为true（如果是\u003ccode\u003eyield\u003c/code\u003e则为\u003ccode\u003efalse\u003c/code\u003e）\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e表达式本身没有返回值（或者说总是返回undefined）。\u003ccode\u003enext\u003c/code\u003e方法可以带一个参数，该参数会被当作\u003cstrong\u003e上一个\u003c/strong\u003e\u003ccode\u003eyield\u003c/code\u003e表达式的返回值\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"ES6重点-1"},"buildId":"uQJHLsOjU_t-1I9pLYt1c","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>