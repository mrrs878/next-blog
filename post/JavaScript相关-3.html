<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-JavaScript相关-3</title><meta name="next-head-count" content="3"/><link rel="preload" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" as="style"/><link rel="stylesheet" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/next-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/next-blog/_next/static/chunks/webpack-cf185e4b59cdddcf.js" defer=""></script><script src="/next-blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/next-blog/_next/static/chunks/main-1c9e93b8392c1bc9.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/next-blog/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/post/%5Btitle%5D-406bad804ceffd1d.js" defer=""></script><script src="/next-blog/_next/static/OxTEt_YhStn7hb0to8717/_buildManifest.js" defer=""></script><script src="/next-blog/_next/static/OxTEt_YhStn7hb0to8717/_ssgManifest.js" defer=""></script><script src="/next-blog/_next/static/OxTEt_YhStn7hb0to8717/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/next-blog">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/next-blog/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">JavaScript相关-3</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-02-14 23:22:46</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h2 id="执行上下文">执行上下文</h2>
<h3 id="什么是执行上下文">什么是执行上下文</h3>
<p>执行上下文就是当前JavaScript代码被解析和执行时所在环境的抽象概念。JavaScript中任何的代码都是在执行上下文中运行。</p>
<p>执行上下文创建过程中，需要做以下几件事：</p>
<ol>
<li>创建变量对象：首先初始化函数的参数<code>arguments</code>，提升变量声明和函数声明</li>
<li>创建作用域链（<code>scope chain</code>）：在执行上下文的创建阶段，作用域链是在变量对象之后创建的</li>
<li>确定<code>this</code>的值，即<code>resolve thisbinding</code></li>
</ol>
<p>每个执行上下文中都有三种重要的属性：</p>
<ul>
<li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局执行上下文中访问（函数执行上下文中为AO）</li>
<li>作用域链（<code>scope chain</code>），JavaScript采用词法作用域，也就是说变量的作用域实在定义的时候就决定了，包含自身变量对象和上级变量对象的列表，通过<code>[[Scope]]</code>属性查找上级变量</li>
<li><code>this</code></li>
</ul>
<h3 id="执行上下文的分类">执行上下文的分类</h3>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
</ul>
<h2 id="执行栈">执行栈</h2>
<p>执行栈，也叫做调用栈，具有LIFO结构，用于存储在代码执行期间创建的所有执行上下文</p>
<p>有如下规则：</p>
<ul>
<li>首次运行JavaScript代码的时候会创建一个全局执行的上下文并push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并push当前执行栈的栈顶</li>
<li>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中pop，上下文的控制权移动到当前执行栈的下一个执行上下文</li>
</ul>
<h2 id="作用域">作用域</h2>
<p>作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</p>
<p>作用域有两种工作模型：<strong>词法作用域</strong>和<strong>动态作用域</strong>。JavaScript采用的时<strong>词法作用域</strong>，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。</p>
<h3 id="作用域的分类">作用域的分类</h3>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h3 id="作用域链">作用域链</h3>
<p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到全局作用域链</p>
<h2 id="变量提升">变量提升</h2>
<p>通俗解释：</p>
<p>将声明的代码移动到了顶部</p>
<p>准确解释：👍</p>
<ol>
<li>在生成执行上下文时，具体步骤是创建VO，JavaScript解释器会找出需要提升的变量和函数，并且给它们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量之生命并且赋值为<code>undefined</code></li>
<li>代码执行阶段（可以直接使用变量/函数）</li>
</ol>
<h2 id="防抖">防抖</h2>
<p>在一定时间多次触发但内只调用一次</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span> (func, wait = <span class="hljs-number">50</span>, immediate = <span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> timer, context, args;

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">later</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    timer = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (!immediate) {
      func.<span class="hljs-title function_">apply</span>(context, args)
    }
  }, wait)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...params</span>) {
    <span class="hljs-keyword">if</span> (timer) {
      <span class="hljs-built_in">clearTimeout</span>(timer)
      timer = <span class="hljs-title function_">later</span>()
    } <span class="hljs-keyword">else</span> {
      timer = <span class="hljs-title function_">later</span>()
      <span class="hljs-keyword">if</span> (immediate) {
        func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, params)
      } <span class="hljs-keyword">else</span> {
        context = <span class="hljs-variable language_">this</span>
        args = params
      }
    }
  }
}
</code></pre>
<h2 id="可迭代对象">可迭代对象</h2>
<p>ES6规定，默认的<code>Iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性上，换个角度，也可以认为一个数据结构只要具有<code>Symbol.iterator</code>属性那么就可以认为其是可迭代的</p>
<h3 id="可迭代对象的特点">可迭代对象的特点</h3>
<ul>
<li>具有<code>Symbol.iterator</code>属性，返回的是一个遍历器对象</li>
<li>可以使用<code>for...of</code>循环遍历</li>
<li>可以通过<code>Array.from</code>转换为数组</li>
</ul>
<h3 id="原生具有iterator接口的数据结构">原生具有<code>Iterator</code>接口的数据结构</h3>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的arguments对象</li>
<li>NodeList对象</li>
</ul>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript相关-3","tags":["JavaScript"],"categories":"JavaScript","description":"## 执行上下文\n\n### 什么是执行上下文\n\n执行上下文就是当前JavaScript代码被解析和执行时所在环境的抽象概念。JavaScript中任何的代码都是在执行上下文中运行。\n\n执行上下文创建过程中，需要做以下几件事：\n\n1. 创建变量对象：首先初始化函数的参数`arguments`，提升变量声明和函数声明\n2. 创建作用域链（`scope chain`）：在执行上下文的创建阶段，作用域链","createDate":"2020-02-14 23:22:46","updateDate":"10/1/2021, 3:34:43 AM","body":"\u003ch2 id=\"执行上下文\"\u003e执行上下文\u003c/h2\u003e\n\u003ch3 id=\"什么是执行上下文\"\u003e什么是执行上下文\u003c/h3\u003e\n\u003cp\u003e执行上下文就是当前JavaScript代码被解析和执行时所在环境的抽象概念。JavaScript中任何的代码都是在执行上下文中运行。\u003c/p\u003e\n\u003cp\u003e执行上下文创建过程中，需要做以下几件事：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建变量对象：首先初始化函数的参数\u003ccode\u003earguments\u003c/code\u003e，提升变量声明和函数声明\u003c/li\u003e\n\u003cli\u003e创建作用域链（\u003ccode\u003escope chain\u003c/code\u003e）：在执行上下文的创建阶段，作用域链是在变量对象之后创建的\u003c/li\u003e\n\u003cli\u003e确定\u003ccode\u003ethis\u003c/code\u003e的值，即\u003ccode\u003eresolve thisbinding\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e每个执行上下文中都有三种重要的属性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局执行上下文中访问（函数执行上下文中为AO）\u003c/li\u003e\n\u003cli\u003e作用域链（\u003ccode\u003escope chain\u003c/code\u003e），JavaScript采用词法作用域，也就是说变量的作用域实在定义的时候就决定了，包含自身变量对象和上级变量对象的列表，通过\u003ccode\u003e[[Scope]]\u003c/code\u003e属性查找上级变量\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethis\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"执行上下文的分类\"\u003e执行上下文的分类\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e全局执行上下文\u003c/li\u003e\n\u003cli\u003e函数执行上下文\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"执行栈\"\u003e执行栈\u003c/h2\u003e\n\u003cp\u003e执行栈，也叫做调用栈，具有LIFO结构，用于存储在代码执行期间创建的所有执行上下文\u003c/p\u003e\n\u003cp\u003e有如下规则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首次运行JavaScript代码的时候会创建一个全局执行的上下文并push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并push当前执行栈的栈顶\u003c/li\u003e\n\u003cli\u003e当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中pop，上下文的控制权移动到当前执行栈的下一个执行上下文\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"作用域\"\u003e作用域\u003c/h2\u003e\n\u003cp\u003e作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限\u003c/p\u003e\n\u003cp\u003e作用域有两种工作模型：\u003cstrong\u003e词法作用域\u003c/strong\u003e和\u003cstrong\u003e动态作用域\u003c/strong\u003e。JavaScript采用的时\u003cstrong\u003e词法作用域\u003c/strong\u003e，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。\u003c/p\u003e\n\u003ch3 id=\"作用域的分类\"\u003e作用域的分类\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e全局作用域\u003c/li\u003e\n\u003cli\u003e函数作用域\u003c/li\u003e\n\u003cli\u003e块级作用域\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"作用域链\"\u003e作用域链\u003c/h3\u003e\n\u003cp\u003e作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到全局作用域链\u003c/p\u003e\n\u003ch2 id=\"变量提升\"\u003e变量提升\u003c/h2\u003e\n\u003cp\u003e通俗解释：\u003c/p\u003e\n\u003cp\u003e将声明的代码移动到了顶部\u003c/p\u003e\n\u003cp\u003e准确解释：👍\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在生成执行上下文时，具体步骤是创建VO，JavaScript解释器会找出需要提升的变量和函数，并且给它们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量之生命并且赋值为\u003ccode\u003eundefined\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e代码执行阶段（可以直接使用变量/函数）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"防抖\"\u003e防抖\u003c/h2\u003e\n\u003cp\u003e在一定时间多次触发但内只调用一次\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edebounce\u003c/span\u003e (func, wait = \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, immediate = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e timer, context, args;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elater\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u0026gt; \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n    timer = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!immediate) {\n      func.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(context, args)\n    }\n  }, wait)\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e...params\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (timer) {\n      \u003cspan class=\"hljs-built_in\"\u003eclearTimeout\u003c/span\u003e(timer)\n      timer = \u003cspan class=\"hljs-title function_\"\u003elater\u003c/span\u003e()\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      timer = \u003cspan class=\"hljs-title function_\"\u003elater\u003c/span\u003e()\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (immediate) {\n        func.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, params)\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        context = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e\n        args = params\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"可迭代对象\"\u003e可迭代对象\u003c/h2\u003e\n\u003cp\u003eES6规定，默认的\u003ccode\u003eIterator\u003c/code\u003e接口部署在数据结构的\u003ccode\u003eSymbol.iterator\u003c/code\u003e属性上，换个角度，也可以认为一个数据结构只要具有\u003ccode\u003eSymbol.iterator\u003c/code\u003e属性那么就可以认为其是可迭代的\u003c/p\u003e\n\u003ch3 id=\"可迭代对象的特点\"\u003e可迭代对象的特点\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e具有\u003ccode\u003eSymbol.iterator\u003c/code\u003e属性，返回的是一个遍历器对象\u003c/li\u003e\n\u003cli\u003e可以使用\u003ccode\u003efor...of\u003c/code\u003e循环遍历\u003c/li\u003e\n\u003cli\u003e可以通过\u003ccode\u003eArray.from\u003c/code\u003e转换为数组\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"原生具有iterator接口的数据结构\"\u003e原生具有\u003ccode\u003eIterator\u003c/code\u003e接口的数据结构\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eArray\u003c/li\u003e\n\u003cli\u003eMap\u003c/li\u003e\n\u003cli\u003eSet\u003c/li\u003e\n\u003cli\u003eString\u003c/li\u003e\n\u003cli\u003eTypedArray\u003c/li\u003e\n\u003cli\u003e函数的arguments对象\u003c/li\u003e\n\u003cli\u003eNodeList对象\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"JavaScript相关-3"},"buildId":"OxTEt_YhStn7hb0to8717","assetPrefix":"/next-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>