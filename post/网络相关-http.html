<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-网络相关-http</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/6RrOOE7sAs7hvIKGX_KFv/_buildManifest.js" defer=""></script><script src="/_next/static/6RrOOE7sAs7hvIKGX_KFv/_ssgManifest.js" defer=""></script><script src="/_next/static/6RrOOE7sAs7hvIKGX_KFv/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">网络相关-http</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-04-16 21:00:05</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>10/1/2021, 3:34:43 AM</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write">
      <h1>
        <span class="prefix"></span>
        <span class="content">HTTP协议</span>
        <span class="suffix"></span>
      </h1>
    <p><strong>超文本传输协议（HTTP）</strong> 是一个用于传输超媒体文档（例如 HTML）的<a href="https://en.wikipedia.org/wiki/Application_Layer">应用层</a>协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的<a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">客户端-服务端模型</a>，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是<a href="http://en.wikipedia.org/wiki/Stateless_protocol">无状态协议</a>，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。<a href="https://en.wikipedia.org/wiki/Reliable_User_Datagram_Protocol">RUDP</a>——作为 UDP 的可靠化升级版本——是一种合适的替代选择。</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">HTTP版本</span>
        <span class="suffix"></span>
      </h1>
    
      <h2>
        <span class="prefix"></span>
        <span class="content">HTTP/1.0</span>
        <span class="suffix"></span>
      </h2>
    <p>最初的http只是使用在一些较为简单的网页和请求上，所以比较简单，每次请求都打开一个新的TCP连接，收到响应后立即断开连接</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">HTTP/1.1</span>
        <span class="suffix"></span>
      </h2>
    <ul>
<li>HTTP/1.1引入了更多的缓存控制策略，如Entity tag、If-Unmidified-Since、If-Match、If-None-Match等</li>
<li>HTTP/1.1允许范围请求，即在请求头中加入<code>Range</code>头部</li>
<li>HTTP/1.1的请求消息和响应消息都必须包含<code>Host</code>头部，以区分同一个物理主机中的不同虚拟终极的域名</li>
<li>HTTP/1.1默认开启持久连接，在一个TCP连接上可以传输多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">HTTP/2.0</span>
        <span class="suffix"></span>
      </h2>
    <p>在HTTP/2.0中，有两个非常重要的概念，帧（frame）和流（stream），理解这两个概念是理解下面多路复用的前提。帧代表数据传输的最小单位，每个帧都又序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。</p>
<ul>
<li>新的二进制格式
HTTP/1.x的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景 必然很多。二进制则不同，只识别0和1的组合。基于这种考虑HTTP/2.0的协议解析采用二进制格式，方便且强大</li>
<li>多路复用
HTTP/2.0支持多路复用，这是HTTP/1.1持久连接的升级版。多路复用，就是在一个TCP连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发地发起多个请求，每个请求及该请求地响应不需要等待其他地请求和响应，避免了线头阻塞问题。这样某个请求任务好事严重并不会影响到其他连接地正常执行，极大地提高了传输性能</li>
<li>头部压缩
HTTP/1.x的请求和响应头部带有大量信息，并且每次请求都要重新发送，HTTP/2.0使用encoder来减少需要传输的头部大小，通讯双方各自cache一份头部fields表，既避免了重复头部的传输，又减小了需要传输的大小</li>
<li>服务端推送
这里的服务端推送指的是和把客户端需要的css/js/img资源伴随着html一起发送到客户端，省去了客户端重复请求的步骤</li>
</ul>

      <h1>
        <span class="prefix"></span>
        <span class="content">HTTP报文</span>
        <span class="suffix"></span>
      </h1>
    <p>用户HTTP协议交互的信息被称为HTTP报文。客户端的HTTP报文称为请求报文，服务端的HTTP报文称为响应报文</p>
<p>请求报文是由请求行（请求方法、协议版本）、请求首部（请求URI、客户端信息）和内容实体（用户信息和资源信息，可为空）构成</p>
<p>响应报文是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">请求方法</span>
        <span class="suffix"></span>
      </h2>
    <ul>
<li>GET
GET方法请求一个指定资源的表示形式，使用GET请求应该之被用于获取数据</li>
<li>POST
POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</li>
<li>PUT
PUT方法用请求有效载荷替换目标的所有当前表示</li>
<li>DELETE
DELETE方法删除指定的资源</li>
<li>HEAD
HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体</li>
<li>OPTIONS
OPTIONS方法用于描述目标资源的通信选项</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">状态码</span>
        <span class="suffix"></span>
      </h2>
    <p>响应分为五类：信息响应(<code>100</code>–<code>199</code>)，成功响应(<code>200</code>–<code>299</code>)，重定向(<code>300</code>–<code>399</code>)，客户端错误(<code>400</code>–<code>499</code>)和服务器错误 (<code>500</code>–<code>599</code>)</p>
<p><a href="https://www.jianguoyun.com/static/stackedit/%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)">具体参照</a></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">首部字段</span>
        <span class="suffix"></span>
      </h2>
    <p>根据不同上下文，可将消息头分为：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/General_header">General headers</a>: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Request_header">Request headers</a>: 包含更多有关要获取的资源或客户端本身信息的消息头。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Response_header">Response headers</a>: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Entity_header">Entity headers</a>: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</li>
</ul>
<p><a href="https://www.jianguoyun.com/static/stackedit/%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)">具体参照</a></p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"网络相关-http","tags":["网络相关","http"],"categories":"网络","description":"# HTTP协议\n\n**超文本传输协议（HTTP）** 是一个用于传输超媒体文档（例如 HTML）的[应用层](https://en.wikipedia.org/wiki/Application_Layer)协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的[客户端-服务端模型](https://en.wikipedia.org/wik","createDate":"2020-04-16 21:00:05","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eHTTP协议\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e\u003cstrong\u003e超文本传输协议（HTTP）\u003c/strong\u003e 是一个用于传输超媒体文档（例如 HTML）的\u003ca href=\"https://en.wikipedia.org/wiki/Application_Layer\"\u003e应用层\u003c/a\u003e协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的\u003ca href=\"https://en.wikipedia.org/wiki/Client%E2%80%93server_model\"\u003e客户端-服务端模型\u003c/a\u003e，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是\u003ca href=\"http://en.wikipedia.org/wiki/Stateless_protocol\"\u003e无状态协议\u003c/a\u003e，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的\u003ca href=\"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82\"\u003e传输层\u003c/a\u003e上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。\u003ca href=\"https://en.wikipedia.org/wiki/Reliable_User_Datagram_Protocol\"\u003eRUDP\u003c/a\u003e——作为 UDP 的可靠化升级版本——是一种合适的替代选择。\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eHTTP版本\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eHTTP/1.0\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e最初的http只是使用在一些较为简单的网页和请求上，所以比较简单，每次请求都打开一个新的TCP连接，收到响应后立即断开连接\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eHTTP/1.1\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cul\u003e\n\u003cli\u003eHTTP/1.1引入了更多的缓存控制策略，如Entity tag、If-Unmidified-Since、If-Match、If-None-Match等\u003c/li\u003e\n\u003cli\u003eHTTP/1.1允许范围请求，即在请求头中加入\u003ccode\u003eRange\u003c/code\u003e头部\u003c/li\u003e\n\u003cli\u003eHTTP/1.1的请求消息和响应消息都必须包含\u003ccode\u003eHost\u003c/code\u003e头部，以区分同一个物理主机中的不同虚拟终极的域名\u003c/li\u003e\n\u003cli\u003eHTTP/1.1默认开启持久连接，在一个TCP连接上可以传输多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eHTTP/2.0\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e在HTTP/2.0中，有两个非常重要的概念，帧（frame）和流（stream），理解这两个概念是理解下面多路复用的前提。帧代表数据传输的最小单位，每个帧都又序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e新的二进制格式\nHTTP/1.x的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景 必然很多。二进制则不同，只识别0和1的组合。基于这种考虑HTTP/2.0的协议解析采用二进制格式，方便且强大\u003c/li\u003e\n\u003cli\u003e多路复用\nHTTP/2.0支持多路复用，这是HTTP/1.1持久连接的升级版。多路复用，就是在一个TCP连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发地发起多个请求，每个请求及该请求地响应不需要等待其他地请求和响应，避免了线头阻塞问题。这样某个请求任务好事严重并不会影响到其他连接地正常执行，极大地提高了传输性能\u003c/li\u003e\n\u003cli\u003e头部压缩\nHTTP/1.x的请求和响应头部带有大量信息，并且每次请求都要重新发送，HTTP/2.0使用encoder来减少需要传输的头部大小，通讯双方各自cache一份头部fields表，既避免了重复头部的传输，又减小了需要传输的大小\u003c/li\u003e\n\u003cli\u003e服务端推送\n这里的服务端推送指的是和把客户端需要的css/js/img资源伴随着html一起发送到客户端，省去了客户端重复请求的步骤\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eHTTP报文\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e用户HTTP协议交互的信息被称为HTTP报文。客户端的HTTP报文称为请求报文，服务端的HTTP报文称为响应报文\u003c/p\u003e\n\u003cp\u003e请求报文是由请求行（请求方法、协议版本）、请求首部（请求URI、客户端信息）和内容实体（用户信息和资源信息，可为空）构成\u003c/p\u003e\n\u003cp\u003e响应报文是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e请求方法\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cul\u003e\n\u003cli\u003eGET\nGET方法请求一个指定资源的表示形式，使用GET请求应该之被用于获取数据\u003c/li\u003e\n\u003cli\u003ePOST\nPOST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用\u003c/li\u003e\n\u003cli\u003ePUT\nPUT方法用请求有效载荷替换目标的所有当前表示\u003c/li\u003e\n\u003cli\u003eDELETE\nDELETE方法删除指定的资源\u003c/li\u003e\n\u003cli\u003eHEAD\nHEAD方法请求一个与GET请求的响应相同的响应，但没有响应体\u003c/li\u003e\n\u003cli\u003eOPTIONS\nOPTIONS方法用于描述目标资源的通信选项\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e状态码\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e响应分为五类：信息响应(\u003ccode\u003e100\u003c/code\u003e–\u003ccode\u003e199\u003c/code\u003e)，成功响应(\u003ccode\u003e200\u003c/code\u003e–\u003ccode\u003e299\u003c/code\u003e)，重定向(\u003ccode\u003e300\u003c/code\u003e–\u003ccode\u003e399\u003c/code\u003e)，客户端错误(\u003ccode\u003e400\u003c/code\u003e–\u003ccode\u003e499\u003c/code\u003e)和服务器错误 (\u003ccode\u003e500\u003c/code\u003e–\u003ccode\u003e599\u003c/code\u003e)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)\"\u003e具体参照\u003c/a\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e首部字段\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e根据不同上下文，可将消息头分为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Glossary/General_header\"\u003eGeneral headers\u003c/a\u003e: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Glossary/Request_header\"\u003eRequest headers\u003c/a\u003e: 包含更多有关要获取的资源或客户端本身信息的消息头。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Glossary/Response_header\"\u003eResponse headers\u003c/a\u003e: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Glossary/Entity_header\"\u003eEntity headers\u003c/a\u003e: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)\"\u003e具体参照\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"网络相关-http"},"buildId":"6RrOOE7sAs7hvIKGX_KFv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>