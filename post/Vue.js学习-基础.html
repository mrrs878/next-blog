<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-Vue.js学习-基础</title><meta name="next-head-count" content="3"/><link rel="preload" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" as="style"/><link rel="stylesheet" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/next-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/next-blog/_next/static/chunks/webpack-cf185e4b59cdddcf.js" defer=""></script><script src="/next-blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/next-blog/_next/static/chunks/main-1c9e93b8392c1bc9.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/next-blog/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/post/%5Btitle%5D-406bad804ceffd1d.js" defer=""></script><script src="/next-blog/_next/static/bTutFgu_o3xiiI_26US75/_buildManifest.js" defer=""></script><script src="/next-blog/_next/static/bTutFgu_o3xiiI_26US75/_ssgManifest.js" defer=""></script><script src="/next-blog/_next/static/bTutFgu_o3xiiI_26US75/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/next-blog">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/next-blog/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">Vue.js学习-基础</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-04-18 21:04:39</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h1 id="生命周期钩子函数">生命周期钩子函数</h1>
<ul>
<li><p>beforeCreate</p>
<p>获取不到props/data</p>
</li>
<li><p>created</p>
<p>可以获取到props/data，组件未挂载</p>
</li>
<li><p>beforeMount</p>
<p>开始创建VDOM</p>
</li>
<li><p>mounted</p>
<p>将VDOM渲染为真实DOM并渲染数据，组件中如果有子组件的话会递归挂载子组件，只有当所有子组件全部挂载完毕才会执行跟组件的挂载钩子</p>
</li>
<li><p>beforeUpdate/updated</p>
<p>分别在数据更新前/更新时调用。不能在updated里做更新，会造成死循环</p>
</li>
<li><p>beforeDestory</p>
<p>适合移移除事件、定时器等</p>
</li>
<li><p>destoryed</p>
<p>所有子组件都销毁完毕后会执行根组件的destoryed</p>
</li>
</ul>
<h1 id="组件通信">组件通信</h1>
<ul>
<li><p><code>props/$emit</code>
通过props将数据自伤而下传递；通过$emit/v-on来向上传递消息</p>
</li>
<li><p>eventbus
通过eventbus进行消息的发布订阅</p>
</li>
<li><p>vuex
全局数据管理库，可通过vuex管理全局的数据流</p>
</li>
<li><pre><code>$attrs/$listeners
</code></pre>
<p>可以进行跨级的组件通信</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 父组件</span>
&lt;template&gt;
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">m-input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;姓名&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">m-input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MInput</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/MInput.vue&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,
    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>
        };
    },
    <span class="hljs-attr">components</span>: {
        <span class="hljs-title class_">MInput</span>
    }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="hljs-comment">// 子组件</span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;input&#x27;,$event.target.value)&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-title class_">String</span>,
        <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;&quot;</span>
    }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
</li>
<li><p>proveded/inject
允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并且在其上下游关系成立的时间内始终有效</p>
</li>
</ul>
<h1 id="mixin和mixins的区别">mixin和mixins的区别</h1>
<ul>
<li>mixin用于全局混入，会影响到每个组件实例（vuex、vue-router等插件实现核心机制）</li>
<li>mixins常用来扩展组件</li>
</ul>
<h1 id="computed和watch的区别">computed和watch的区别</h1>
<ul>
<li>computed是计算属性，依赖其他属性计算值，并且computed的值有缓存，只有当计算值发生变化才返回内容</li>
<li>watch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作</li>
</ul>
<p>一般来说需要依赖别的属性来动态获得值得时候可以使用computed，对于监听到值的变化需要做一些<strong>复杂业务逻辑</strong>的情况可以使用watch</p>
<p><a href="https://www.jianguoyun.com/static/stackedit/%5Bhttp://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/%5D(http://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/)">实现原理</a></p>
<h2 id="computed如何知道依赖">computed如何知道依赖</h2>
<ol>
<li>Vue.js实例初始化过程中，将所有计算属性包装为lazy watcher</li>
<li>首次访问计算属性时，watcher为dirty，此时开始计算watcher的值</li>
<li>计算开始之前，此watcher将被设置为依赖目标，开始收集依赖</li>
<li>计算watcher值的过程中，被访问到属性的getter中会检查是否存在依赖目标，若存在依赖目标就会创建依赖关系</li>
<li>watcher的值计算完成后，新的依赖被设置，旧的依赖会被删除，依赖收集完成</li>
<li>当依赖属性更新时，会通知自身的依赖目标，watcher被设置为dirty</li>
<li>再次访问该计算属性，重复计算及依赖收集步骤（3-6）</li>
</ol>
<h1 id="keep-alive有什么作用">keep-alive有什么作用</h1>
<p>如果需要在组件切换的时候<strong>保存一些组件的状态防止多次渲染</strong>，就可以使用<code>keep-alive</code>组件包裹需要保存的组件。对于<code>keep-alive</code>组件来说，它有两个独有的声明周期钩子函数，分别为<code>activated</code>、和<code>deactivated</code>。用<code>keep-alive</code>包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行<code>deactivated</code>钩子函数，命中缓存渲染后会执行<code>activated</code>钩子函数。</p>
<h1 id="v-show和v-if的区别">v-show和v-if的区别</h1>
<ul>
<li><code>v-show</code>只是在<code>display:none</code>和<code>display:block</code>之间切换，无论初始条件是什么DOM都会被创建，后面只需切换CSS。所以总的来说<code>v-show</code>在初始渲染时有着更高的开销，但切换开销很小，适合频繁切换的场景。</li>
<li><code>v-if</code>的话关于到Vue底层的编译。当初始属性为<code>false</code>时，组件就不会被渲染，直到条件为<code>true</code>。并且切换条件时会触发销毁/挂载组件及回流。所以总的来说在<strong>创建时开销较小，切换时开销大，适合不经常切换的场景</strong>，并且基于<code>v-if</code>这种惰性渲染机制，可以在必要的时候才去渲染组件，<strong>减少整个页面的初始渲染开销</strong></li>
</ul>
<h1 id="data为什么使用函数">data为什么使用函数</h1>
<p><strong>组件复用时所有组件实例都会共享data</strong>，如果data是对象的话，就会造成一个组件修改data后影响其他组件，所以有必要将data写成函数，每次用到就调用一次函数获得新的数据</p>
<p>当使用<code>new Vue()</code>的方式时，无论我们将data设置为对象函数函数都是可以的，因为<code>new Vue()</code>的方式是生成一个根组件，该组件不会被复用也就不会存在共享data的情况了</p>
<h1 id="vuejs响应式原理">Vue.js响应式原理</h1>
<p>对于Object，基于发布订阅模式，使用<code>Object.defineProperty</code>，在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖。当一个vue组件实例创建的时候，vue会遍历<code>data</code>选项的属性，用<code>Object.defineProperty</code>将它们转换为<code>getter/setter</code>并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的<code>watcher</code>实例，它会在组件渲染的过程中把属性记录为依赖，只有当依赖项的<code>setter</code>被调用时，会通知<code>watcher</code>重新计算从而使它管理的组件得以更新</p>
<p>对于Array，基于函数劫持，改写数组原型方法，并遍历数组，对于是对象的项使用👆的方法进行观测</p>
<h1 id="vuejs的特点">Vue.js的特点</h1>
<ul>
<li>简洁</li>
<li>数据驱动，自动计算属性和追踪依赖的模板表达式</li>
<li>组件化，高科服用、解耦的组件来构建页面</li>
<li>快速，精确有效批量DOM更新</li>
<li>模板友好</li>
</ul>
<h1 id="nexttick"><code>$nextTick</code></h1>
<p>Vue.js实现响应式并不是在数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。nextTick是在下次dom更新循环结束之后执行延迟回调，在修改数据之后使用<em>n<strong>e</strong>x<strong>t</strong>T<strong>i</strong>c**k</em>是在下次<em>d<strong>o</strong>m</em>更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的dom</p>
<p>渲染节流</p>
<h1 id="v-for中key的作用"><code>v-for</code>中<code>key</code>的作用</h1>
<p>当vue更新通过v-for渲染的元素时，它默认使用<strong>就地复用</strong>的策略，如果数据项的顺序被改变，vue将不是移动dom元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定的索引下显示已经被渲染过的每个元素。为了给vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序所有元素，需要给vue提供一个唯一key属性</p>
<p>key <strong>主要用在vue的虚拟dom算法</strong>，在新旧node对比时辨识vnodes。如果不使用key，vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法，使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素</p>
<h1 id="router和route"><code>$router</code>和<code>$route</code></h1>
<ul>
<li><code>$router</code>是路由信息对象，包括<code>path、params、hash、query、fullPath、matched、name</code>等路由信息参数</li>
<li><code>$route</code>是路由实例，包括了路由跳转方法、钩子函数等</li>
</ul>
<h1 id="clicknative中native的作用"><code>@click.native</code>中<code>native</code>的作用</h1>
<p>对于普通标签，<code>@click</code>会监听点击事件，而对于写在组件上的<code>@click</code>，如果不加<code>native</code>，则代表坚挺的是组件的点击事件，而不是组件内的点击事件，因此，在组件内写的<code>click handler</code>不会被执行</p>
<h1 id="v-model"><code>v-model</code></h1>
<p><code>v-model</code>常用于表单元素上进行数据的双向绑定，比如``。除了原生的元素，它还能在自定义组件中使用</p>
<pre><code>v-model`是一个语法糖，可以拆解为`props: value`和`events:input`。就是说组件必须提供一个名为`value`的`prop`以及名为`input`的自定义事件，满足这两个条件就能在自定义组件上使用`v-model
</code></pre>
<h1 id="作用域插槽">作用域插槽</h1>
<p>一种带有数据的插槽</p>
<p>普通插槽 = 父组件设置的样式 + 父组件通过props传递的数据</p>
<p>作用域插槽 = 父组件设置的样式 + <strong>自身的数据</strong>（该数据父组件也可以访问得到）</p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Vue.js学习-基础","tags":["Vue.js"],"categories":"Vue.js","description":"# 生命周期钩子函数\n\n- beforeCreate\n\n  获取不到props/data\n\n- created\n\n  可以获取到props/data，组件未挂载\n\n- beforeMount\n\n  开始创建VDOM\n\n- mounted\n\n  将VDOM渲染为真实DOM并渲染数据，组件中如果有子组件的话会递归挂载子组件，只有当所有子组件全部挂载完毕才会执行跟组件的挂载钩子\n\n- beforeU","createDate":"2020-04-18 21:04:39","updateDate":"10/1/2021, 3:34:43 AM","body":"\u003ch1 id=\"生命周期钩子函数\"\u003e生命周期钩子函数\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003ebeforeCreate\u003c/p\u003e\n\u003cp\u003e获取不到props/data\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ecreated\u003c/p\u003e\n\u003cp\u003e可以获取到props/data，组件未挂载\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ebeforeMount\u003c/p\u003e\n\u003cp\u003e开始创建VDOM\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003emounted\u003c/p\u003e\n\u003cp\u003e将VDOM渲染为真实DOM并渲染数据，组件中如果有子组件的话会递归挂载子组件，只有当所有子组件全部挂载完毕才会执行跟组件的挂载钩子\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ebeforeUpdate/updated\u003c/p\u003e\n\u003cp\u003e分别在数据更新前/更新时调用。不能在updated里做更新，会造成死循环\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ebeforeDestory\u003c/p\u003e\n\u003cp\u003e适合移移除事件、定时器等\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003edestoryed\u003c/p\u003e\n\u003cp\u003e所有子组件都销毁完毕后会执行根组件的destoryed\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"组件通信\"\u003e组件通信\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eprops/$emit\u003c/code\u003e\n通过props将数据自伤而下传递；通过$emit/v-on来向上传递消息\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eeventbus\n通过eventbus进行消息的发布订阅\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003evuex\n全局数据管理库，可通过vuex管理全局的数据流\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cpre\u003e\u003ccode\u003e$attrs/$listeners\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以进行跨级的组件通信\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 父组件\u003c/span\u003e\n\u0026lt;template\u0026gt;\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;home\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003em-input\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;姓名\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-model\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003em-input\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026lt;/template\u0026gt;\n\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMInput\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@/components/MInput.vue\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;home\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003edata\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n            \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;zhangsan\u0026quot;\u003c/span\u003e\n        };\n    },\n    \u003cspan class=\"hljs-attr\"\u003ecomponents\u003c/span\u003e: {\n        \u003cspan class=\"hljs-title class_\"\u003eMInput\u003c/span\u003e\n    }\n};\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 子组件\u003c/span\u003e\n\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-bind\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;$attrs\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-bind\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;$attrs\u0026quot;\u003c/span\u003e @\u003cspan class=\"hljs-attr\"\u003einput\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;$emit(\u0026#x27;input\u0026#x27;,$event.target.value)\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e:value\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;value\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003einheritAttrs\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\n    }\n};\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eproveded/inject\n允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并且在其上下游关系成立的时间内始终有效\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"mixin和mixins的区别\"\u003emixin和mixins的区别\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003emixin用于全局混入，会影响到每个组件实例（vuex、vue-router等插件实现核心机制）\u003c/li\u003e\n\u003cli\u003emixins常用来扩展组件\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"computed和watch的区别\"\u003ecomputed和watch的区别\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003ecomputed是计算属性，依赖其他属性计算值，并且computed的值有缓存，只有当计算值发生变化才返回内容\u003c/li\u003e\n\u003cli\u003ewatch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e一般来说需要依赖别的属性来动态获得值得时候可以使用computed，对于监听到值的变化需要做一些\u003cstrong\u003e复杂业务逻辑\u003c/strong\u003e的情况可以使用watch\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttp://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/%5D(http://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/)\"\u003e实现原理\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"computed如何知道依赖\"\u003ecomputed如何知道依赖\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eVue.js实例初始化过程中，将所有计算属性包装为lazy watcher\u003c/li\u003e\n\u003cli\u003e首次访问计算属性时，watcher为dirty，此时开始计算watcher的值\u003c/li\u003e\n\u003cli\u003e计算开始之前，此watcher将被设置为依赖目标，开始收集依赖\u003c/li\u003e\n\u003cli\u003e计算watcher值的过程中，被访问到属性的getter中会检查是否存在依赖目标，若存在依赖目标就会创建依赖关系\u003c/li\u003e\n\u003cli\u003ewatcher的值计算完成后，新的依赖被设置，旧的依赖会被删除，依赖收集完成\u003c/li\u003e\n\u003cli\u003e当依赖属性更新时，会通知自身的依赖目标，watcher被设置为dirty\u003c/li\u003e\n\u003cli\u003e再次访问该计算属性，重复计算及依赖收集步骤（3-6）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"keep-alive有什么作用\"\u003ekeep-alive有什么作用\u003c/h1\u003e\n\u003cp\u003e如果需要在组件切换的时候\u003cstrong\u003e保存一些组件的状态防止多次渲染\u003c/strong\u003e，就可以使用\u003ccode\u003ekeep-alive\u003c/code\u003e组件包裹需要保存的组件。对于\u003ccode\u003ekeep-alive\u003c/code\u003e组件来说，它有两个独有的声明周期钩子函数，分别为\u003ccode\u003eactivated\u003c/code\u003e、和\u003ccode\u003edeactivated\u003c/code\u003e。用\u003ccode\u003ekeep-alive\u003c/code\u003e包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行\u003ccode\u003edeactivated\u003c/code\u003e钩子函数，命中缓存渲染后会执行\u003ccode\u003eactivated\u003c/code\u003e钩子函数。\u003c/p\u003e\n\u003ch1 id=\"v-show和v-if的区别\"\u003ev-show和v-if的区别\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ev-show\u003c/code\u003e只是在\u003ccode\u003edisplay:none\u003c/code\u003e和\u003ccode\u003edisplay:block\u003c/code\u003e之间切换，无论初始条件是什么DOM都会被创建，后面只需切换CSS。所以总的来说\u003ccode\u003ev-show\u003c/code\u003e在初始渲染时有着更高的开销，但切换开销很小，适合频繁切换的场景。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ev-if\u003c/code\u003e的话关于到Vue底层的编译。当初始属性为\u003ccode\u003efalse\u003c/code\u003e时，组件就不会被渲染，直到条件为\u003ccode\u003etrue\u003c/code\u003e。并且切换条件时会触发销毁/挂载组件及回流。所以总的来说在\u003cstrong\u003e创建时开销较小，切换时开销大，适合不经常切换的场景\u003c/strong\u003e，并且基于\u003ccode\u003ev-if\u003c/code\u003e这种惰性渲染机制，可以在必要的时候才去渲染组件，\u003cstrong\u003e减少整个页面的初始渲染开销\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"data为什么使用函数\"\u003edata为什么使用函数\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e组件复用时所有组件实例都会共享data\u003c/strong\u003e，如果data是对象的话，就会造成一个组件修改data后影响其他组件，所以有必要将data写成函数，每次用到就调用一次函数获得新的数据\u003c/p\u003e\n\u003cp\u003e当使用\u003ccode\u003enew Vue()\u003c/code\u003e的方式时，无论我们将data设置为对象函数函数都是可以的，因为\u003ccode\u003enew Vue()\u003c/code\u003e的方式是生成一个根组件，该组件不会被复用也就不会存在共享data的情况了\u003c/p\u003e\n\u003ch1 id=\"vuejs响应式原理\"\u003eVue.js响应式原理\u003c/h1\u003e\n\u003cp\u003e对于Object，基于发布订阅模式，使用\u003ccode\u003eObject.defineProperty\u003c/code\u003e，在\u003ccode\u003egetter\u003c/code\u003e中收集依赖，在\u003ccode\u003esetter\u003c/code\u003e中通知依赖。当一个vue组件实例创建的时候，vue会遍历\u003ccode\u003edata\u003c/code\u003e选项的属性，用\u003ccode\u003eObject.defineProperty\u003c/code\u003e将它们转换为\u003ccode\u003egetter/setter\u003c/code\u003e并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的\u003ccode\u003ewatcher\u003c/code\u003e实例，它会在组件渲染的过程中把属性记录为依赖，只有当依赖项的\u003ccode\u003esetter\u003c/code\u003e被调用时，会通知\u003ccode\u003ewatcher\u003c/code\u003e重新计算从而使它管理的组件得以更新\u003c/p\u003e\n\u003cp\u003e对于Array，基于函数劫持，改写数组原型方法，并遍历数组，对于是对象的项使用👆的方法进行观测\u003c/p\u003e\n\u003ch1 id=\"vuejs的特点\"\u003eVue.js的特点\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e简洁\u003c/li\u003e\n\u003cli\u003e数据驱动，自动计算属性和追踪依赖的模板表达式\u003c/li\u003e\n\u003cli\u003e组件化，高科服用、解耦的组件来构建页面\u003c/li\u003e\n\u003cli\u003e快速，精确有效批量DOM更新\u003c/li\u003e\n\u003cli\u003e模板友好\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"nexttick\"\u003e\u003ccode\u003e$nextTick\u003c/code\u003e\u003c/h1\u003e\n\u003cp\u003eVue.js实现响应式并不是在数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。nextTick是在下次dom更新循环结束之后执行延迟回调，在修改数据之后使用\u003cem\u003en\u003cstrong\u003ee\u003c/strong\u003ex\u003cstrong\u003et\u003c/strong\u003eT\u003cstrong\u003ei\u003c/strong\u003ec**k\u003c/em\u003e是在下次\u003cem\u003ed\u003cstrong\u003eo\u003c/strong\u003em\u003c/em\u003e更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的dom\u003c/p\u003e\n\u003cp\u003e渲染节流\u003c/p\u003e\n\u003ch1 id=\"v-for中key的作用\"\u003e\u003ccode\u003ev-for\u003c/code\u003e中\u003ccode\u003ekey\u003c/code\u003e的作用\u003c/h1\u003e\n\u003cp\u003e当vue更新通过v-for渲染的元素时，它默认使用\u003cstrong\u003e就地复用\u003c/strong\u003e的策略，如果数据项的顺序被改变，vue将不是移动dom元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定的索引下显示已经被渲染过的每个元素。为了给vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序所有元素，需要给vue提供一个唯一key属性\u003c/p\u003e\n\u003cp\u003ekey \u003cstrong\u003e主要用在vue的虚拟dom算法\u003c/strong\u003e，在新旧node对比时辨识vnodes。如果不使用key，vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法，使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素\u003c/p\u003e\n\u003ch1 id=\"router和route\"\u003e\u003ccode\u003e$router\u003c/code\u003e和\u003ccode\u003e$route\u003c/code\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e$router\u003c/code\u003e是路由信息对象，包括\u003ccode\u003epath、params、hash、query、fullPath、matched、name\u003c/code\u003e等路由信息参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$route\u003c/code\u003e是路由实例，包括了路由跳转方法、钩子函数等\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"clicknative中native的作用\"\u003e\u003ccode\u003e@click.native\u003c/code\u003e中\u003ccode\u003enative\u003c/code\u003e的作用\u003c/h1\u003e\n\u003cp\u003e对于普通标签，\u003ccode\u003e@click\u003c/code\u003e会监听点击事件，而对于写在组件上的\u003ccode\u003e@click\u003c/code\u003e，如果不加\u003ccode\u003enative\u003c/code\u003e，则代表坚挺的是组件的点击事件，而不是组件内的点击事件，因此，在组件内写的\u003ccode\u003eclick handler\u003c/code\u003e不会被执行\u003c/p\u003e\n\u003ch1 id=\"v-model\"\u003e\u003ccode\u003ev-model\u003c/code\u003e\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003ev-model\u003c/code\u003e常用于表单元素上进行数据的双向绑定，比如``。除了原生的元素，它还能在自定义组件中使用\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ev-model`是一个语法糖，可以拆解为`props: value`和`events:input`。就是说组件必须提供一个名为`value`的`prop`以及名为`input`的自定义事件，满足这两个条件就能在自定义组件上使用`v-model\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"作用域插槽\"\u003e作用域插槽\u003c/h1\u003e\n\u003cp\u003e一种带有数据的插槽\u003c/p\u003e\n\u003cp\u003e普通插槽 = 父组件设置的样式 + 父组件通过props传递的数据\u003c/p\u003e\n\u003cp\u003e作用域插槽 = 父组件设置的样式 + \u003cstrong\u003e自身的数据\u003c/strong\u003e（该数据父组件也可以访问得到）\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"Vue.js学习-基础"},"buildId":"bTutFgu_o3xiiI_26US75","assetPrefix":"/next-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>