<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-函数式编程-纯函数</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/l4Gu6cYmDduUyiYLzAoNw/_buildManifest.js" defer=""></script><script src="/_next/static/l4Gu6cYmDduUyiYLzAoNw/_ssgManifest.js" defer=""></script><script src="/_next/static/l4Gu6cYmDduUyiYLzAoNw/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">函数式编程-纯函数</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2019-10-15 13:43:45</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>10/1/2021, 3:34:43 AM</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write">
      <h1>
        <span class="prefix"></span>
        <span class="content">纯函数的基本概念</span>
        <span class="suffix"></span>
      </h1>
    <p>纯函数是这样一种函数，相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>
<p>可能会导致不纯的情况：</p>
<ul>
<li><p>修改调用/传入的参数</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-comment">// 纯的</span>
array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//[1, 2, 3]</span>
array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//[1, 2, 3]</span>

<span class="hljs-comment">// 不纯的 --&gt; 会修改array</span>
array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//[1, 2, 3]</span>
array.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//[4, 5]</span>
</code></pre>
</li>
<li><p>依赖外部环境</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 纯的</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span>(<span class="hljs-params">minmun, age</span>) {
  <span class="hljs-keyword">return</span> age &gt; minmun;
}

<span class="hljs-comment">// 不纯的 --&gt; 引入了外部的环境，从而增加了认知负荷(cognitive load)</span>
<span class="hljs-keyword">let</span> minmum = <span class="hljs-number">21</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAge</span>(<span class="hljs-params">age</span>) {
  <span class="hljs-keyword">return</span> age &gt; minmun;
}
</code></pre>
</li>
</ul>

      <h1>
        <span class="prefix"></span>
        <span class="content">副作用</span>
        <span class="suffix"></span>
      </h1>
    <p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p>
<p>副作用可能包括：</p>
<ul>
<li>更改文件系统</li>
<li>往数据库插入记录</li>
<li>发送一个 http 请求</li>
<li>修改传入的数据</li>
<li>打印/log</li>
<li>获取用户输入</li>
<li>DOM 查询</li>
<li>访问系统状态</li>
<li>......</li>
</ul>

      <h1>
        <span class="prefix"></span>
        <span class="content">追求纯的理由</span>
        <span class="suffix"></span>
      </h1>
    <ul>
<li><p>可缓存性(cacheable)</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">f</span>) {
  <span class="hljs-keyword">let</span> cache = {};
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> arg_str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">arguments</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache[arg_str]);
    cache[arg_str] = cache[arg_str] || f.<span class="hljs-title function_">apply</span>(f, <span class="hljs-variable language_">arguments</span>);
    <span class="hljs-keyword">return</span> cache[arg_str];
  };
}

<span class="hljs-keyword">const</span> squareNumber = <span class="hljs-title function_">memoize</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);

<span class="hljs-title function_">squareNumber</span>(<span class="hljs-number">3</span>);
<span class="hljs-title function_">squareNumber</span>(<span class="hljs-number">3</span>);
</code></pre>
</li>
<li><p>可移植性/自文档化(portable/self-documenting)</p>
</li>
<li><p>可测试性(testable)</p>
</li>
<li><p>合理性(reasonable)</p>
<p>使用纯函数的最大好处是<a href="https://en.wikipedia.org/wiki/Referential_transparency">引用透明性(referential transparency)</a>。</p>
<p>如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么就认为这段代码是引用透明的。由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。对于引用透明的代码，可以使用&quot;等式推导&quot;(equational reasoning)的技术来分析代码，所谓&quot;等式推导&quot;就是&quot;一对一&quot;替换，有点像在不考虑程序行执行的怪异行为(quirks of programmatic evaluation)的情况下手动执行相关代码。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Immutable</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;immutable&quot;</span>);

<span class="hljs-comment">// decrementHP是纯函数！！！因为player的来源是immutable.Map，set方法不会使map改变，而是返回一个新的map对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">decrementHP</span>(<span class="hljs-params">player</span>) {
  <span class="hljs-keyword">return</span> player.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;hp&quot;</span>, player.<span class="hljs-property">hp</span> - <span class="hljs-number">1</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">isSameTeam</span>(<span class="hljs-params">player1, player2</span>) {
  <span class="hljs-keyword">return</span> player1.<span class="hljs-property">team</span> === player2.<span class="hljs-property">team</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">punch</span>(<span class="hljs-params">player, target</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSameTeam</span>(player, target)) {
    <span class="hljs-keyword">return</span> target;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">decrementHP</span>(target);
  }
}

<span class="hljs-keyword">let</span> jobe = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title class_">Map</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jobe&quot;</span>, <span class="hljs-attr">hp</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">team</span>: <span class="hljs-string">&quot;red&quot;</span> });
<span class="hljs-keyword">let</span> michael = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title class_">Map</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Michael&quot;</span>, <span class="hljs-attr">hp</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">team</span>: <span class="hljs-string">&quot;green&quot;</span> });

<span class="hljs-title function_">punch</span>(jobe, michael);
<span class="hljs-comment">//=&gt; Immutable.Map({name:&quot;Michael&quot;, hp:19, team: &quot;green&quot;})</span>
</code></pre>
<p><a href="https://github.com/MostlyAdequate/mostly-adequate-guide/issues/244">关于 decrementHP 是不是纯函数的讨论</a></p>
</li>
<li><p>并行代码</p>
<p>可以并行运行任意纯函数，因为纯函数根本不需要访问共享内存，而且根据其定义，纯函数也不会因副作用而进入<a href="https://en.wikipedia.org/wiki/Race_condition">竞态(race condition)</a></p>
</li>
</ul>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"函数式编程-纯函数","tags":["函数式编程","纯函数"],"categories":"函数式编程","description":"# 纯函数的基本概念\n\n纯函数是这样一种函数，相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。\n\n可能会导致不纯的情况：\n\n- 修改调用/传入的参数\n\n  ```javascript\n  let array = [1, 2, 3, 4, 5];\n\n  // 纯的\n  array.slice(0, 3); //[1, 2, 3]\n  array.slice(0, 3); //[1,","createDate":"2019-10-15 13:43:45","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e纯函数的基本概念\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e纯函数是这样一种函数，相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。\u003c/p\u003e\n\u003cp\u003e可能会导致不纯的情况：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e修改调用/传入的参数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e array = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\n\u003cspan class=\"hljs-comment\"\u003e// 纯的\u003c/span\u003e\narray.\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e//[1, 2, 3]\u003c/span\u003e\narray.\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e//[1, 2, 3]\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 不纯的 --\u0026gt; 会修改array\u003c/span\u003e\narray.\u003cspan class=\"hljs-title function_\"\u003esplice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e//[1, 2, 3]\u003c/span\u003e\narray.\u003cspan class=\"hljs-title function_\"\u003esplice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e//[4, 5]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e依赖外部环境\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 纯的\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckAge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eminmun, age\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e age \u0026gt; minmun;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 不纯的 --\u0026gt; 引入了外部的环境，从而增加了认知负荷(cognitive load)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e minmum = \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckAge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eage\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e age \u0026gt; minmun;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e副作用\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。\u003c/p\u003e\n\u003cp\u003e副作用可能包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e更改文件系统\u003c/li\u003e\n\u003cli\u003e往数据库插入记录\u003c/li\u003e\n\u003cli\u003e发送一个 http 请求\u003c/li\u003e\n\u003cli\u003e修改传入的数据\u003c/li\u003e\n\u003cli\u003e打印/log\u003c/li\u003e\n\u003cli\u003e获取用户输入\u003c/li\u003e\n\u003cli\u003eDOM 查询\u003c/li\u003e\n\u003cli\u003e访问系统状态\u003c/li\u003e\n\u003cli\u003e......\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e追求纯的理由\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cul\u003e\n\u003cli\u003e\u003cp\u003e可缓存性(cacheable)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ememoize\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ef\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cache = {};\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e arg_str = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(cache[arg_str]);\n    cache[arg_str] = cache[arg_str] || f.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(f, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cache[arg_str];\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e squareNumber = \u003cspan class=\"hljs-title function_\"\u003ememoize\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u0026gt;\u003c/span\u003e x * x);\n\n\u003cspan class=\"hljs-title function_\"\u003esquareNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003esquareNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e可移植性/自文档化(portable/self-documenting)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e可测试性(testable)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e合理性(reasonable)\u003c/p\u003e\n\u003cp\u003e使用纯函数的最大好处是\u003ca href=\"https://en.wikipedia.org/wiki/Referential_transparency\"\u003e引用透明性(referential transparency)\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么就认为这段代码是引用透明的。由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。对于引用透明的代码，可以使用\u0026quot;等式推导\u0026quot;(equational reasoning)的技术来分析代码，所谓\u0026quot;等式推导\u0026quot;就是\u0026quot;一对一\u0026quot;替换，有点像在不考虑程序行执行的怪异行为(quirks of programmatic evaluation)的情况下手动执行相关代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImmutable\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;immutable\u0026quot;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// decrementHP是纯函数！！！因为player的来源是immutable.Map，set方法不会使map改变，而是返回一个新的map对象\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edecrementHP\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eplayer\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e player.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;hp\u0026quot;\u003c/span\u003e, player.\u003cspan class=\"hljs-property\"\u003ehp\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisSameTeam\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eplayer1, player2\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e player1.\u003cspan class=\"hljs-property\"\u003eteam\u003c/span\u003e === player2.\u003cspan class=\"hljs-property\"\u003eteam\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epunch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eplayer, target\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eisSameTeam\u003c/span\u003e(player, target)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e target;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edecrementHP\u003c/span\u003e(target);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e jobe = \u003cspan class=\"hljs-title class_\"\u003eImmutable\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Jobe\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ehp\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eteam\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;red\u0026quot;\u003c/span\u003e });\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e michael = \u003cspan class=\"hljs-title class_\"\u003eImmutable\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Michael\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ehp\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eteam\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;green\u0026quot;\u003c/span\u003e });\n\n\u003cspan class=\"hljs-title function_\"\u003epunch\u003c/span\u003e(jobe, michael);\n\u003cspan class=\"hljs-comment\"\u003e//=\u0026gt; Immutable.Map({name:\u0026quot;Michael\u0026quot;, hp:19, team: \u0026quot;green\u0026quot;})\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/MostlyAdequate/mostly-adequate-guide/issues/244\"\u003e关于 decrementHP 是不是纯函数的讨论\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e并行代码\u003c/p\u003e\n\u003cp\u003e可以并行运行任意纯函数，因为纯函数根本不需要访问共享内存，而且根据其定义，纯函数也不会因副作用而进入\u003ca href=\"https://en.wikipedia.org/wiki/Race_condition\"\u003e竞态(race condition)\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"函数式编程-纯函数"},"buildId":"l4Gu6cYmDduUyiYLzAoNw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>