<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-JavaScript复习-0</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-d89e1712c82a34ac.js" defer=""></script><script src="/_next/static/reYDWUTQtfBCgygk8zhe7/_buildManifest.js" defer=""></script><script src="/_next/static/reYDWUTQtfBCgygk8zhe7/_ssgManifest.js" defer=""></script><script src="/_next/static/reYDWUTQtfBCgygk8zhe7/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">JavaScript复习-0</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2021-05-07 14:34:34</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2021-06-21 23:49:44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write">
      <h2>
        <span class="prefix"></span>
        <span class="content">JavaScript数据类型</span>
        <span class="suffix"></span>
      </h2>
    <p>原始Primitive类型：</p>
<p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Undefined</code>、<code>Null</code>、<code>Symbol</code>、<code>Bigint</code></p>
<p>引用类型</p>
<p><code>Object</code>、<code>Array</code>、<code>Date</code>、<code>Function</code> </p>

      <h2>
        <span class="prefix"></span>
        <span class="content">Symbol和Bigint</span>
        <span class="suffix"></span>
      </h2>
    <p><code>Symbol</code>表示唯一、不可变的值。用于确保对象属性使用唯一标识符，不会发生属性名冲突的危险</p>
<p><code>BigInt</code>是一种数字类型的数据，它可以表示任意精度格式的整数，使用<code>BigInt</code>可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">var vs let/const</span>
        <span class="suffix"></span>
      </h2>
    <ul>
<li>作用域问题</li>
<li>重复声明/赋值问题</li>
<li>变量提升</li>
<li>暂时性死区</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">数据属性/访问器属性</span>
        <span class="suffix"></span>
      </h2>
    <p>对象的属性有两种类型，<strong>数据属性</strong>和<strong>访问器属性</strong></p>
<ul>
<li>创建对象时默认就存在的属性为数据属性</li>
<li>通过<code>Object.defineProperty</code>设置的属性描述符中含有<code>set/get</code>的属性为访问器属性</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">内部属性[[Class]]</span>
        <span class="suffix"></span>
      </h2>
    <p><a href="">Object.prototype.toString传送门</a></p>
<p><del>所有对象(<code>typeof</code>返回为<code>object</code>)都包含有一个内部属性<code>[[Class]]</code>，该属性不能直接访问，
可使用<code>Object.prototype.toString</code>来查看</del></p>
<p><strong>ES6移除了这个属性</strong></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([])  
<span class="hljs-comment">//&quot;[object Array]&quot;</span>

<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-function">() =&gt;</span> {})
<span class="hljs-comment">// &quot;[object Function]&quot;</span>
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">Object.prototype.toString</span>
        <span class="suffix"></span>
      </h2>
    <p>拿到变量准确的类型</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([])  
<span class="hljs-comment">//&quot;[object Array]&quot;</span>

<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-function">() =&gt;</span> {})
<span class="hljs-comment">// &quot;[object Function]&quot;</span>

<span class="hljs-comment">/*
基本类型值string、number、boolean都可以打印这是因为JavaScript为基本类型值包装
了一个封装对象使它们变成了对象，而String()、Number()、Boolean()上有属性[[Class]]
*/</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">2</span>)
<span class="hljs-comment">// &quot;[object Number]&quot;</span>

<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;a&quot;</span>)
<span class="hljs-comment">// &quot;[object String]&quot;</span>
</code></pre>
<p>可通过重写变量的toString方法修改输出</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> a = {
    get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;
    }
}

<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;a&quot;</span>)
<span class="hljs-comment">// &quot;[object A]&quot;</span>
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">上下文、作用域链、闭包</span>
        <span class="suffix"></span>
      </h2>
    <p>上下文：每个上下文都有一个关联的<strong>变量对象(variable object)<strong>，存储这个上下文中定义的所有变量和函数。函数局部上下文中的叫做</strong>活动对象(activity object)</strong>(活动对象最初只有一个定义变量<code>arguments</code>，全局上下文中没有这个变量)。上下文会在其所有代码都执行完毕后被销毁（全局上下文会在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）</p>
<p>作用域链：执行上下文的集合。上下文中的代码在执行时会创建变量对象的一个<strong>作用域链</strong>，代码正在执行的上下文的变量对象始终位于作用域链的最前端。全局上下文的变量对象始终位于作用域链尾部</p>
<p>闭包（JS高程4）：指那些引用了另一个函数作用域中变量的<strong>函数</strong>。在一个函数内定义的函数会把其包含函数的活动(变量)对象添加到自己的作用域链中，外部函数的活动(变量)对象是内部函数作用域链上的第二个对象。闭包的本质是内部函数加长了其作用域链</p>
<p>闭包（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN</a>）：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createComparisonFunction</span>(<span class="hljs-params">propertyName</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">object1, object2</span>) {
        <span class="hljs-keyword">let</span> value1 = object1[propertyName];
        <span class="hljs-keyword">let</span> values = object2[propertyName];
        
        <span class="hljs-keyword">if</span> (value1 &lt; value2) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value1 &gt; value2) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
}

<span class="hljs-keyword">let</span> compare = <span class="hljs-title function_">createComparisonFunction</span>(<span class="hljs-string">&quot;name&quot;</span>);
<span class="hljs-keyword">let</span> result = <span class="hljs-title function_">compare</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;&quot;</span><span class="hljs-title class_">Matt</span> });
</code></pre>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/closure.png" alt="closure"></p>
<p>作用域和上下文的区别：</p>
<p>作用域是静态的，只要函数定义好了就一直存在并且不再发生变化。执行上下文是动态的，调用函数时创建，调用结束后会释放</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">this</span>
        <span class="suffix"></span>
      </h2>
    <p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/this.png" alt="this"></p>
<ul>
<li>先判断函数类型(箭头函数？bind生成？普通函数？)</li>
<li>普通函数判断调用方式(new？foo()？obj.foo()？)</li>
<li>不管 <code>bind</code> 几次，<code>fn</code>中的<code>this</code>始终由第一次<code>bind</code>决定</li>
<li>箭头函数中的<code>this</code>一旦被绑定就不会再改变</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>?.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">let</span> a = <span class="hljs-number">12</span>;

<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">13</span>,
  fn
};

<span class="hljs-keyword">const</span> obj2 = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">14</span>,
  <span class="hljs-attr">fn</span>: obj.<span class="hljs-property">fn</span>,
  <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>) {
      <span class="hljs-title function_">fn</span>();
  },
};

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// undefined</span>
obj.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 13</span>
obj2.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 14</span>
obj2.<span class="hljs-title function_">fn2</span>(); <span class="hljs-comment">// undefined</span>
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">==时的类型转换</span>
        <span class="suffix"></span>
      </h2>
    <p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%3D%3D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="==时的类型转换"></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">对象转原始类型</span>
        <span class="suffix"></span>
      </h2>
    <p>对象转原始类型会调用内置的[[ToPrimitive]]函数：</p>
<ol>
<li>如果存在<code>Symbol.toPrimitive()</code>方法，调用后返回</li>
<li>调用<code>valueOf()</code>，如果转换为原始类型则返回（使用<code>obj.valueOf = xxx</code>来定义）</li>
<li>调用<code>toString()</code>，如果转换为原始类型则返回</li>
<li>如果都没有返回原始类型则报错</li>
</ol>

      <h2>
        <span class="prefix"></span>
        <span class="content">原型</span>
        <span class="suffix"></span>
      </h2>
    <p>每个构造函数都有(<code>prototype</code>)一个原型对象，原型有一个属性(<code>constructor</code>)指回构造函数，而实例有一个内部指针(<code>__proto__</code>)指向原型</p>
<p>如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地如果另一个原型也有一个指针指向另一个构造函数。这样就在原型和实例之间构造了一条原型链。</p>
<p><code>__proto_</code>_指向<strong>构造函数</strong>的原型，存在于<strong>对象</strong>中，指向<strong>原型</strong></p>
<p><code>prototype</code>存在于<strong>函数</strong>中，指向<strong>原型</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params"></span>) {}

<span class="hljs-keyword">const</span> tom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();

tom.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span>
<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">User</span> <span class="hljs-comment">// true</span>
</code></pre>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/prototype.png" alt="原型"></p>
<p><a href="">new的原理及手动实现</a>
<a href="">继承</a></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">new</span>
        <span class="suffix"></span>
      </h2>
    <p>过程：</p>
<ol>
<li>在内存中创建一个新的空对象</li>
<li>这个新对象内部的<code>__proto__</code>指针被赋值为构造函数的<code>prototype</code>值</li>
<li>构造函数内部的<code>this</code>被赋值为这个新对象（即<code>this</code>指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-title class_">Con</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)
    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Con</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Con</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj
}
</code></pre>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript复习-0","tags":["JavaScript"],"categories":"2021复习","description":"## JavaScript数据类型\n\n原始Primitive类型：\n\n`Number`、`String`、`Boolean`、`Undefined`、`Null`、`Symbol`、`Bigint`\n\n引用类型\n\n`Object`、`Array`、`Date`、`Function` \n\n## Symbol和Bigint\n\n`Symbol`表示唯一、不可变的值。用于确保对象属性使用唯一标识符，不","createDate":"2021-05-07 14:34:34","updateDate":"2021-06-21 23:49:44","body":"\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eJavaScript数据类型\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e原始Primitive类型：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNumber\u003c/code\u003e、\u003ccode\u003eString\u003c/code\u003e、\u003ccode\u003eBoolean\u003c/code\u003e、\u003ccode\u003eUndefined\u003c/code\u003e、\u003ccode\u003eNull\u003c/code\u003e、\u003ccode\u003eSymbol\u003c/code\u003e、\u003ccode\u003eBigint\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e引用类型\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eObject\u003c/code\u003e、\u003ccode\u003eArray\u003c/code\u003e、\u003ccode\u003eDate\u003c/code\u003e、\u003ccode\u003eFunction\u003c/code\u003e \u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eSymbol和Bigint\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ccode\u003eSymbol\u003c/code\u003e表示唯一、不可变的值。用于确保对象属性使用唯一标识符，不会发生属性名冲突的危险\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBigInt\u003c/code\u003e是一种数字类型的数据，它可以表示任意精度格式的整数，使用\u003ccode\u003eBigInt\u003c/code\u003e可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003evar vs let/const\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cul\u003e\n\u003cli\u003e作用域问题\u003c/li\u003e\n\u003cli\u003e重复声明/赋值问题\u003c/li\u003e\n\u003cli\u003e变量提升\u003c/li\u003e\n\u003cli\u003e暂时性死区\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e数据属性/访问器属性\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e对象的属性有两种类型，\u003cstrong\u003e数据属性\u003c/strong\u003e和\u003cstrong\u003e访问器属性\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建对象时默认就存在的属性为数据属性\u003c/li\u003e\n\u003cli\u003e通过\u003ccode\u003eObject.defineProperty\u003c/code\u003e设置的属性描述符中含有\u003ccode\u003eset/get\u003c/code\u003e的属性为访问器属性\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e内部属性[[Class]]\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ca href=\"\"\u003eObject.prototype.toString传送门\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cdel\u003e所有对象(\u003ccode\u003etypeof\u003c/code\u003e返回为\u003ccode\u003eobject\u003c/code\u003e)都包含有一个内部属性\u003ccode\u003e[[Class]]\u003c/code\u003e，该属性不能直接访问，\n可使用\u003ccode\u003eObject.prototype.toString\u003c/code\u003e来查看\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eES6移除了这个属性\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e([])  \n\u003cspan class=\"hljs-comment\"\u003e//\u0026quot;[object Array]\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {})\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;[object Function]\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eObject.prototype.toString\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e拿到变量准确的类型\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e([])  \n\u003cspan class=\"hljs-comment\"\u003e//\u0026quot;[object Array]\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {})\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;[object Function]\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e/*\n基本类型值string、number、boolean都可以打印这是因为JavaScript为基本类型值包装\n了一个封装对象使它们变成了对象，而String()、Number()、Boolean()上有属性[[Class]]\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;[object Number]\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;a\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;[object String]\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可通过重写变量的toString方法修改输出\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a = {\n    get [\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoStringTag\u003c/span\u003e]() {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;A\u0026#x27;\u003c/span\u003e;\n    }\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;a\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;[object A]\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e上下文、作用域链、闭包\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e上下文：每个上下文都有一个关联的\u003cstrong\u003e变量对象(variable object)\u003cstrong\u003e，存储这个上下文中定义的所有变量和函数。函数局部上下文中的叫做\u003c/strong\u003e活动对象(activity object)\u003c/strong\u003e(活动对象最初只有一个定义变量\u003ccode\u003earguments\u003c/code\u003e，全局上下文中没有这个变量)。上下文会在其所有代码都执行完毕后被销毁（全局上下文会在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）\u003c/p\u003e\n\u003cp\u003e作用域链：执行上下文的集合。上下文中的代码在执行时会创建变量对象的一个\u003cstrong\u003e作用域链\u003c/strong\u003e，代码正在执行的上下文的变量对象始终位于作用域链的最前端。全局上下文的变量对象始终位于作用域链尾部\u003c/p\u003e\n\u003cp\u003e闭包（JS高程4）：指那些引用了另一个函数作用域中变量的\u003cstrong\u003e函数\u003c/strong\u003e。在一个函数内定义的函数会把其包含函数的活动(变量)对象添加到自己的作用域链中，外部函数的活动(变量)对象是内部函数作用域链上的第二个对象。闭包的本质是内部函数加长了其作用域链\u003c/p\u003e\n\u003cp\u003e闭包（\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\"\u003eMDN\u003c/a\u003e）：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateComparisonFunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epropertyName\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobject1, object2\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e value1 = object1[propertyName];\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e values = object2[propertyName];\n        \n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value1 \u0026lt; value2) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value1 \u0026gt; value2) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n        }\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e compare = \u003cspan class=\"hljs-title function_\"\u003ecreateComparisonFunction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003ecompare\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Nicholas\u0026quot;\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eMatt\u003c/span\u003e });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/closure.png\" alt=\"closure\"\u003e\u003c/p\u003e\n\u003cp\u003e作用域和上下文的区别：\u003c/p\u003e\n\u003cp\u003e作用域是静态的，只要函数定义好了就一直存在并且不再发生变化。执行上下文是动态的，调用函数时创建，调用结束后会释放\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003ethis\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/this.png\" alt=\"this\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先判断函数类型(箭头函数？bind生成？普通函数？)\u003c/li\u003e\n\u003cli\u003e普通函数判断调用方式(new？foo()？obj.foo()？)\u003c/li\u003e\n\u003cli\u003e不管 \u003ccode\u003ebind\u003c/code\u003e 几次，\u003ccode\u003efn\u003c/code\u003e中的\u003ccode\u003ethis\u003c/code\u003e始终由第一次\u003ccode\u003ebind\u003c/code\u003e决定\u003c/li\u003e\n\u003cli\u003e箭头函数中的\u003ccode\u003ethis\u003c/code\u003e一旦被绑定就不会再改变\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e,\n  fn\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj2 = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efn\u003c/span\u003e: obj.\u003cspan class=\"hljs-property\"\u003efn\u003c/span\u003e,\n  \u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n  },\n};\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\nobj.\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 13\u003c/span\u003e\nobj2.\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 14\u003c/span\u003e\nobj2.\u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e==时的类型转换\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%3D%3D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png\" alt=\"==时的类型转换\"\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e对象转原始类型\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e对象转原始类型会调用内置的[[ToPrimitive]]函数：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果存在\u003ccode\u003eSymbol.toPrimitive()\u003c/code\u003e方法，调用后返回\u003c/li\u003e\n\u003cli\u003e调用\u003ccode\u003evalueOf()\u003c/code\u003e，如果转换为原始类型则返回（使用\u003ccode\u003eobj.valueOf = xxx\u003c/code\u003e来定义）\u003c/li\u003e\n\u003cli\u003e调用\u003ccode\u003etoString()\u003c/code\u003e，如果转换为原始类型则返回\u003c/li\u003e\n\u003cli\u003e如果都没有返回原始类型则报错\u003c/li\u003e\n\u003c/ol\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e原型\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e每个构造函数都有(\u003ccode\u003eprototype\u003c/code\u003e)一个原型对象，原型有一个属性(\u003ccode\u003econstructor\u003c/code\u003e)指回构造函数，而实例有一个内部指针(\u003ccode\u003e__proto__\u003c/code\u003e)指向原型\u003c/p\u003e\n\u003cp\u003e如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地如果另一个原型也有一个指针指向另一个构造函数。这样就在原型和实例之间构造了一条原型链。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__proto_\u003c/code\u003e_指向\u003cstrong\u003e构造函数\u003c/strong\u003e的原型，存在于\u003cstrong\u003e对象\u003c/strong\u003e中，指向\u003cstrong\u003e原型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprototype\u003c/code\u003e存在于\u003cstrong\u003e函数\u003c/strong\u003e中，指向\u003cstrong\u003e原型\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tom = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e();\n\ntom.\u003cspan class=\"hljs-property\"\u003e__proto__\u003c/span\u003e === \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econstructor\u003c/span\u003e === \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/prototype.png\" alt=\"原型\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"\"\u003enew的原理及手动实现\u003c/a\u003e\n\u003ca href=\"\"\u003e继承\u003c/a\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003enew\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e过程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在内存中创建一个新的空对象\u003c/li\u003e\n\u003cli\u003e这个新对象内部的\u003ccode\u003e__proto__\u003c/code\u003e指针被赋值为构造函数的\u003ccode\u003eprototype\u003c/code\u003e值\u003c/li\u003e\n\u003cli\u003e构造函数内部的\u003ccode\u003ethis\u003c/code\u003e被赋值为这个新对象（即\u003ccode\u003ethis\u003c/code\u003e指向新对象）\u003c/li\u003e\n\u003cli\u003e执行构造函数内部的代码（给新对象添加属性）\u003c/li\u003e\n\u003cli\u003e如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e obj = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCon\u003c/span\u003e = [].\u003cspan class=\"hljs-property\"\u003eshift\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e)\n    obj.\u003cspan class=\"hljs-property\"\u003e__proto__\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eCon\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = \u003cspan class=\"hljs-title class_\"\u003eCon\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(obj, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e result === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;object\u0026#x27;\u003c/span\u003e ? result : obj\n}\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"JavaScript复习-0"},"buildId":"reYDWUTQtfBCgygk8zhe7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>