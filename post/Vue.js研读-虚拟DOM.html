<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-Vue.js研读-虚拟DOM</title><meta name="next-head-count" content="3"/><link rel="preload" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" as="style"/><link rel="stylesheet" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/next-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/next-blog/_next/static/chunks/webpack-cf185e4b59cdddcf.js" defer=""></script><script src="/next-blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/next-blog/_next/static/chunks/main-1c9e93b8392c1bc9.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/next-blog/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/post/%5Btitle%5D-406bad804ceffd1d.js" defer=""></script><script src="/next-blog/_next/static/iP4y6L48AljdMF4jEsFqW/_buildManifest.js" defer=""></script><script src="/next-blog/_next/static/iP4y6L48AljdMF4jEsFqW/_ssgManifest.js" defer=""></script><script src="/next-blog/_next/static/iP4y6L48AljdMF4jEsFqW/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/next-blog">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/next-blog/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">Vue.js研读-虚拟DOM</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-03-04 23:18:13</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h2 id="vuejs为什么要引入虚拟dom">Vue.js为什么要引入虚拟DOM</h2>
<p>虚拟DOM是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上次生成的虚拟节点树进行对比，只渲染不同的部分</p>
<p>在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对（Vue.js 1.0）。但这样做缺点很明显：因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及依赖追踪的开销。当状态被越来越多的节点使用时，开销就越大。</p>
<p>因此Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入虚拟DOM。组件级别是一个watcher实例。就是说即使一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对渲染，这是一个折中方案</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-0.png" alt="虚拟DOM"></p>
<h2 id="vnode">VNode</h2>
<p>vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后再插入到页面渲染视图</p>
<p>vnode的类型包括：注释节点(isComment=true)、文本节点、元素节点(具有tag属性)、组件节点、函数式组件、克隆节点</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-1.png" alt="虚拟DOM"></p>
<h2 id="patch">patch</h2>
<p>对比两个vnode之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的是修改DOM节点，也可以理解为渲染视图。包括：创建新增的节点、删除已经废弃的节点、修改需要更新的节点</p>
<p>path的核心算法diff是通过<strong>同层</strong>的树节点进行比较而非对树进行逐层遍历的方式，所以时间复杂度只有O(n)</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/patch-0.png" alt=""></p>
<ul>
<li><p>创建新节点</p>
<p>事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点、文本节点</p>
<ul>
<li>oldVnode中不存在而vnode中存在</li>
<li>oldVnode和vnode完全不是同一个节点</li>
</ul>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-2.png" alt="创建节点"></p>
</li>
<li><p>删除节点</p>
<p>某个节点只在oldVnode中存在</p>
</li>
<li><p>更新节点</p>
<p>oldVnode和vnode相同（通过sameVnode判断）</p>
<p>判断依据：key、tag、isComment、data、input的type均相同</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-3.png" alt="更新节点"></p>
</li>
</ul>
<h2 id="dom-diff过程">DOM Diff过程</h2>
<p>简单来说，diff有以下过程：</p>
<ol>
<li>同级比较，再比较子节点</li>
<li>先判断一方有子节点而另一方没有子节点的情况</li>
<li>比较都有子节点的情况（核心diff算法）</li>
<li>递归比较子节点</li>
</ol>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-0.png" alt="diff过程"></p>
<h2 id="核心diff算法">核心DIFF算法</h2>
<p>Vue2.0采用了<strong>双端比较</strong>的算法：同时从新旧children的两端开始进行比较，借助key值可以找到可复用的节点，再进行相关操作。
<img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-1.png" alt="diff-1"></p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Vue.js研读-虚拟DOM","tags":["Vue.js","虚拟DOM"],"categories":"Vue.js","description":"## Vue.js为什么要引入虚拟DOM\n\n虚拟DOM是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上次生成的虚拟节点树进行对比，只渲染不同的部分\n\n在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对（Vue.js 1.0）。但这样做缺点很明显：因为粒度太细，每一个绑定都会有","createDate":"2020-03-04 23:18:13","updateDate":"10/1/2021, 3:34:43 AM","body":"\u003ch2 id=\"vuejs为什么要引入虚拟dom\"\u003eVue.js为什么要引入虚拟DOM\u003c/h2\u003e\n\u003cp\u003e虚拟DOM是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上次生成的虚拟节点树进行对比，只渲染不同的部分\u003c/p\u003e\n\u003cp\u003e在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对（Vue.js 1.0）。但这样做缺点很明显：因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及依赖追踪的开销。当状态被越来越多的节点使用时，开销就越大。\u003c/p\u003e\n\u003cp\u003e因此Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入虚拟DOM。组件级别是一个watcher实例。就是说即使一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对渲染，这是一个折中方案\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-0.png\" alt=\"虚拟DOM\"\u003e\u003c/p\u003e\n\u003ch2 id=\"vnode\"\u003eVNode\u003c/h2\u003e\n\u003cp\u003evnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后再插入到页面渲染视图\u003c/p\u003e\n\u003cp\u003evnode的类型包括：注释节点(isComment=true)、文本节点、元素节点(具有tag属性)、组件节点、函数式组件、克隆节点\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-1.png\" alt=\"虚拟DOM\"\u003e\u003c/p\u003e\n\u003ch2 id=\"patch\"\u003epatch\u003c/h2\u003e\n\u003cp\u003e对比两个vnode之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的是修改DOM节点，也可以理解为渲染视图。包括：创建新增的节点、删除已经废弃的节点、修改需要更新的节点\u003c/p\u003e\n\u003cp\u003epath的核心算法diff是通过\u003cstrong\u003e同层\u003c/strong\u003e的树节点进行比较而非对树进行逐层遍历的方式，所以时间复杂度只有O(n)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/patch-0.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e创建新节点\u003c/p\u003e\n\u003cp\u003e事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点、文本节点\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eoldVnode中不存在而vnode中存在\u003c/li\u003e\n\u003cli\u003eoldVnode和vnode完全不是同一个节点\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-2.png\" alt=\"创建节点\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e删除节点\u003c/p\u003e\n\u003cp\u003e某个节点只在oldVnode中存在\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e更新节点\u003c/p\u003e\n\u003cp\u003eoldVnode和vnode相同（通过sameVnode判断）\u003c/p\u003e\n\u003cp\u003e判断依据：key、tag、isComment、data、input的type均相同\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-3.png\" alt=\"更新节点\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"dom-diff过程\"\u003eDOM Diff过程\u003c/h2\u003e\n\u003cp\u003e简单来说，diff有以下过程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e同级比较，再比较子节点\u003c/li\u003e\n\u003cli\u003e先判断一方有子节点而另一方没有子节点的情况\u003c/li\u003e\n\u003cli\u003e比较都有子节点的情况（核心diff算法）\u003c/li\u003e\n\u003cli\u003e递归比较子节点\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-0.png\" alt=\"diff过程\"\u003e\u003c/p\u003e\n\u003ch2 id=\"核心diff算法\"\u003e核心DIFF算法\u003c/h2\u003e\n\u003cp\u003eVue2.0采用了\u003cstrong\u003e双端比较\u003c/strong\u003e的算法：同时从新旧children的两端开始进行比较，借助key值可以找到可复用的节点，再进行相关操作。\n\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-1.png\" alt=\"diff-1\"\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"Vue.js研读-虚拟DOM"},"buildId":"iP4y6L48AljdMF4jEsFqW","assetPrefix":"/next-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>