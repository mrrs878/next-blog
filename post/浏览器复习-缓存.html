<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-浏览器复习-缓存</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-d89e1712c82a34ac.js" defer=""></script><script src="/_next/static/Ip8spgQZ45ji8gLKlLTAu/_buildManifest.js" defer=""></script><script src="/_next/static/Ip8spgQZ45ji8gLKlLTAu/_ssgManifest.js" defer=""></script><script src="/_next/static/Ip8spgQZ45ji8gLKlLTAu/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">浏览器复习-缓存</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2021-05-16 08:10:35</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2021-06-11 10:55:56</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。直接使用缓存而不发起请求或发起了请求但后端存储的数据与浏览器缓存中的一致那就没必要将数据传输回来，直接读取缓存中的数据节省网络传输开销</p>
<p>缓存的意义在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也能减轻服务器压力。所以最佳实践就是<strong>尽可能命中强缓存，同时能在版本更新的时候让客户端的缓存失效</strong></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">缓存位置</span>
        <span class="suffix"></span>
      </h2>
    
      <h3>
        <span class="prefix"></span>
        <span class="content">memory cache</span>
        <span class="suffix"></span>
      </h3>
    <p>memory cache就是内存中的缓存，读取数据的速度比较快。虽然内存缓存高效，但是缓存持续性很短，会<strong>随着进程的释放而释放</strong>，一旦我们关闭页面，内存中的数据也就被释放了。（刷新页面不会丢失）</p>

      <h3>
        <span class="prefix"></span>
        <span class="content">disk cache</span>
        <span class="suffix"></span>
      </h3>
    <p>存储在硬盘中的缓存，读取速度较内存慢，但存储量大，存储时间长。较<code>memory cache</code>胜在容量和时效性上</p>
<p>在所有浏览器缓存中，disk cache覆盖面基本是最大的。它会根据 <code>http header</code>中的某些字段判断哪些资源需要被缓存，哪些资源可以直接从缓存取而不用发送请求去获取。<strong>即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来就不会再去请求数据</strong></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">push cache</span>
        <span class="suffix"></span>
      </h2>
    <p>http/2中的内容，仅在会话(session)中存在</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">缓存策略</span>
        <span class="suffix"></span>
      </h2>
    <p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置http header来实现的</p>
<ol>
<li>浏览器每次发起请求，都会先在浏览器中查找该请求的结果及缓存标识</li>
<li>浏览器每次拿到返回的结果请求都会将该结果和缓存标识存入浏览器缓存中</li>
</ol>
<p>发起请求及缓存处理流程：</p>
<ol>
<li>浏览器在加载资源时，现根据这个资源的一些http header字段判断它是否命中强缓存，强缓存如果命中，浏览器会直接从自己的缓存中读取资源不会发送请求到服务器</li>
<li>当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据http header中的一些字段判断这个资源是否命中协商缓存，如果协商缓存命中，服务器会以<strong>304</strong>响应这个请求，不会返回该资源，告诉浏览器可以从缓存中读取；如果没命中则返回该资源</li>
</ol>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_cache.png" alt="浏览器缓存策略"></p>

      <h3>
        <span class="prefix"></span>
        <span class="content">强缓存</span>
        <span class="suffix"></span>
      </h3>
    <p>强缓存可以通过设置两种http header来实现：<code>Expires</code>和<code>Cache-Control</code></p>
<ul>
<li>Expires</li>
</ul>
<p><code>Expires: Web, 22 Oct 2021 08:41:00 GMT</code></p>
<p><code>Expires</code>是http/1的产物，表示资源会在<code>Web, 22 Oct 2021 08:41:00 GMT</code>后过期，需要再次请求。<code>Expires</code>受限于本地时间，如果修改了本地时间可能会造成缓存失效</p>
<ul>
<li>Cache-Control</li>
</ul>
<p><code>Cache-Control: public, max-age=31536000</code></p>
<p><code>Cache-Control</code>出现在http/1.1，优先级高于Expires。该属性表示资源会在31536000秒后失效需要再次请求</p>
<p><code>Cache-Control</code>可以在请求或响应头中设置，并且可以组合使用多种指令</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/cache_1.png" alt="cache-control"></p>

      <h3>
        <span class="prefix"></span>
        <span class="content">协商缓存</span>
        <span class="suffix"></span>
      </h3>
    <p>协商缓存可以通过设置两种http header实现：<code>Last-Modified</code>和<code>ETag</code></p>
<ul>
<li><code>Last-Modified</code>和<code>If-Modified-Since</code></li>
</ul>
<p><code>Last-Modified</code>会随着访问资源时返回，表示该资源在浏览器上最后修改时间。浏览器再次请求资源时，<code>If-Modified-Since</code>会将<code>Last-Modified</code>的值携带上，询问服务器在该日期后资源是否有更新，有的话就会将新的资源送回来，否则返回<strong>304</strong>，即命中缓存</p>
<p>和<code>Expires</code>一样，本地打开缓存文件一样会导致缓存失效。此外，Last-Modified以秒计时，如果以更细粒度的时间内修改文件，服务器还是认为文件没有更新告诉浏览器可以使用缓存中的文件</p>
<ul>
<li><code>ETag</code>和<code>If-None-Match</code></li>
</ul>
<p><code>ETag</code>类似文件指纹，也会随着请求资源时返回(浏览器生成)。浏览器再次请求资源时，<code>If-None-Match</code>会将<code>ETag</code>的值携带上，询问该资源的<code>ETag</code>是否有过变动，有变动的话就将最新的资源返回，否则返回<strong>304</strong>，即命中缓存</p>
<p><code>ETag</code>的优先级高于<code>Last-Modified</code></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">强缓存和协商缓存的异同</span>
        <span class="suffix"></span>
      </h2>
    <p>强缓存和协商缓存的共同点是如果命中都是从缓存中读取资源数据；区别是协商缓存总是会发送一个请求而强缓存不会</p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2024</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"浏览器复习-缓存","tags":["浏览器缓存"],"categories":"2021复习","description":"对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。直接使用缓存而不发起请求或发起了请求但后端存储的数据与浏览器缓存中的一致那就没必要将数据传输回来，直接读取缓存中的数据节省网络传输开销\n\n缓存的意义在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也能减轻服务器压力。所以最佳实践就是**尽可能命中强缓存，同时能","createDate":"2021-05-16 08:10:35","updateDate":"2021-06-11 10:55:56","body":"\u003cp\u003e对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。直接使用缓存而不发起请求或发起了请求但后端存储的数据与浏览器缓存中的一致那就没必要将数据传输回来，直接读取缓存中的数据节省网络传输开销\u003c/p\u003e\n\u003cp\u003e缓存的意义在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也能减轻服务器压力。所以最佳实践就是\u003cstrong\u003e尽可能命中强缓存，同时能在版本更新的时候让客户端的缓存失效\u003c/strong\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e缓存位置\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \n      \u003ch3\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003ememory cache\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h3\u003e\n    \u003cp\u003ememory cache就是内存中的缓存，读取数据的速度比较快。虽然内存缓存高效，但是缓存持续性很短，会\u003cstrong\u003e随着进程的释放而释放\u003c/strong\u003e，一旦我们关闭页面，内存中的数据也就被释放了。（刷新页面不会丢失）\u003c/p\u003e\n\n      \u003ch3\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003edisk cache\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h3\u003e\n    \u003cp\u003e存储在硬盘中的缓存，读取速度较内存慢，但存储量大，存储时间长。较\u003ccode\u003ememory cache\u003c/code\u003e胜在容量和时效性上\u003c/p\u003e\n\u003cp\u003e在所有浏览器缓存中，disk cache覆盖面基本是最大的。它会根据 \u003ccode\u003ehttp header\u003c/code\u003e中的某些字段判断哪些资源需要被缓存，哪些资源可以直接从缓存取而不用发送请求去获取。\u003cstrong\u003e即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来就不会再去请求数据\u003c/strong\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003epush cache\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003ehttp/2中的内容，仅在会话(session)中存在\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e缓存策略\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置http header来实现的\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e浏览器每次发起请求，都会先在浏览器中查找该请求的结果及缓存标识\u003c/li\u003e\n\u003cli\u003e浏览器每次拿到返回的结果请求都会将该结果和缓存标识存入浏览器缓存中\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e发起请求及缓存处理流程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e浏览器在加载资源时，现根据这个资源的一些http header字段判断它是否命中强缓存，强缓存如果命中，浏览器会直接从自己的缓存中读取资源不会发送请求到服务器\u003c/li\u003e\n\u003cli\u003e当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据http header中的一些字段判断这个资源是否命中协商缓存，如果协商缓存命中，服务器会以\u003cstrong\u003e304\u003c/strong\u003e响应这个请求，不会返回该资源，告诉浏览器可以从缓存中读取；如果没命中则返回该资源\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_cache.png\" alt=\"浏览器缓存策略\"\u003e\u003c/p\u003e\n\n      \u003ch3\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e强缓存\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h3\u003e\n    \u003cp\u003e强缓存可以通过设置两种http header来实现：\u003ccode\u003eExpires\u003c/code\u003e和\u003ccode\u003eCache-Control\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExpires\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eExpires: Web, 22 Oct 2021 08:41:00 GMT\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eExpires\u003c/code\u003e是http/1的产物，表示资源会在\u003ccode\u003eWeb, 22 Oct 2021 08:41:00 GMT\u003c/code\u003e后过期，需要再次请求。\u003ccode\u003eExpires\u003c/code\u003e受限于本地时间，如果修改了本地时间可能会造成缓存失效\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCache-Control\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eCache-Control: public, max-age=31536000\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCache-Control\u003c/code\u003e出现在http/1.1，优先级高于Expires。该属性表示资源会在31536000秒后失效需要再次请求\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCache-Control\u003c/code\u003e可以在请求或响应头中设置，并且可以组合使用多种指令\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/cache_1.png\" alt=\"cache-control\"\u003e\u003c/p\u003e\n\n      \u003ch3\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e协商缓存\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h3\u003e\n    \u003cp\u003e协商缓存可以通过设置两种http header实现：\u003ccode\u003eLast-Modified\u003c/code\u003e和\u003ccode\u003eETag\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLast-Modified\u003c/code\u003e和\u003ccode\u003eIf-Modified-Since\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eLast-Modified\u003c/code\u003e会随着访问资源时返回，表示该资源在浏览器上最后修改时间。浏览器再次请求资源时，\u003ccode\u003eIf-Modified-Since\u003c/code\u003e会将\u003ccode\u003eLast-Modified\u003c/code\u003e的值携带上，询问服务器在该日期后资源是否有更新，有的话就会将新的资源送回来，否则返回\u003cstrong\u003e304\u003c/strong\u003e，即命中缓存\u003c/p\u003e\n\u003cp\u003e和\u003ccode\u003eExpires\u003c/code\u003e一样，本地打开缓存文件一样会导致缓存失效。此外，Last-Modified以秒计时，如果以更细粒度的时间内修改文件，服务器还是认为文件没有更新告诉浏览器可以使用缓存中的文件\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eETag\u003c/code\u003e和\u003ccode\u003eIf-None-Match\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eETag\u003c/code\u003e类似文件指纹，也会随着请求资源时返回(浏览器生成)。浏览器再次请求资源时，\u003ccode\u003eIf-None-Match\u003c/code\u003e会将\u003ccode\u003eETag\u003c/code\u003e的值携带上，询问该资源的\u003ccode\u003eETag\u003c/code\u003e是否有过变动，有变动的话就将最新的资源返回，否则返回\u003cstrong\u003e304\u003c/strong\u003e，即命中缓存\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eETag\u003c/code\u003e的优先级高于\u003ccode\u003eLast-Modified\u003c/code\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e强缓存和协商缓存的异同\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e强缓存和协商缓存的共同点是如果命中都是从缓存中读取资源数据；区别是协商缓存总是会发送一个请求而强缓存不会\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"浏览器复习-缓存"},"buildId":"Ip8spgQZ45ji8gLKlLTAu","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>