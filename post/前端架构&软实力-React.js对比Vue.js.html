<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-前端架构&amp;软实力-React.js对比Vue.js</title><meta name="next-head-count" content="3"/><link rel="preload" href="/next-blog/_next/static/css/69a53a8e7e466837.css" as="style"/><link rel="stylesheet" href="/next-blog/_next/static/css/69a53a8e7e466837.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/next-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/next-blog/_next/static/chunks/webpack-cf185e4b59cdddcf.js" defer=""></script><script src="/next-blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/next-blog/_next/static/chunks/main-1c9e93b8392c1bc9.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/next-blog/_next/static/chunks/899-865d0f25be8776b8.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/post/%5Btitle%5D-406bad804ceffd1d.js" defer=""></script><script src="/next-blog/_next/static/8CuryAa1WcH3Hy5sWK_rn/_buildManifest.js" defer=""></script><script src="/next-blog/_next/static/8CuryAa1WcH3Hy5sWK_rn/_ssgManifest.js" defer=""></script><script src="/next-blog/_next/static/8CuryAa1WcH3Hy5sWK_rn/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/next-blog">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/categories">分类</a></li><li class="ml-4 hover:text-yellow"><a href="/next-blog/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">前端架构&amp;软实力-React.js对比Vue.js</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-04-28 23:09:43</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h1 id="设计思想">设计思想</h1>
<h2 id="vuejs">Vue.js</h2>
<p>渐进式框架，采用自底向上增量开发的模式。</p>
<p>所谓渐进式就是把框架分层。</p>
<p>最核心的部分是视图层渲染，然后往外是组件系统，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-5.png" alt="渐进式"></p>
<p>所谓分层，就是说既可以只用最核心的视图层渲染功能快速开发一些需求，也可以使用一整套全家桶来开发大型应用。Vue.js由足够的灵活性来适应不同的需求，所以开发者可以根据自己的需求选择不同的层级。</p>
<h2 id="reactjs">React.js</h2>
<p>声明式、组件化</p>
<p>React.js使创建交互式UI变得轻而易举。为应用的每一个状态设计简介地试图，当数据改变时React.js可以有效地更新并渲染组件。此外，React.js可以创建拥有各自状态的组件，再由这些组件构成更加复杂的 UI</p>
<h1 id="组件间数据交互">组件间数据交互</h1>
<h2 id="父子组件">父子组件</h2>
<h3 id="vuejs-1">Vue.js</h3>
<p>Vue.js中父组件通过<code>props</code>传递数据给子组件，子组件使用<code>$emit</code>触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据。</p>
<h3 id="reactjs-1">React.js</h3>
<p>React.js中父组件使用<code>props</code>传递数据和回调函数给子组件，子组件通过<code>props</code>传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。</p>
<h2 id="跨级组件">跨级组件</h2>
<h3 id="vuejs-2">Vue.js</h3>
<p>Vue.js中通过<code>provide / inject</code>在祖先组件向所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>
<h3 id="reactjs-2">React.js</h3>
<p>React.js的<code>Context</code> 提供了一个无需为每层组件手动添加 <code>props</code>就能在组件树间进行数据传递的方法。在父组件创建一个<code>Context</code>对象，通过<code>Context.provider</code>的<code>value</code>属性向消费组件传值。</p>
<h1 id="响应式原理">响应式原理</h1>
<h2 id="vuejs-3">Vue.js</h2>
<p>Vue.js采用数据劫持&amp;发布-订阅模式来实现响应式，Vue.js在创建<code>vm</code>的时候，会将数据配置在实例当中，然后通过<code>Object.defineProperty</code>对数据进行操作，为数据动态添加了<code>getter</code>与<code>setter</code>方法，当获取数据的时候会触发对应的<code>getter</code>方法，当设置数据的时候会触发对应的<code>setter</code>方法，从而进一步触发<code>vm</code>的<code>watcher</code>方法，然后数据更改，<code>vm</code>则会进一步触发视图更新操作。</p>
<h2 id="reactjs-3">React.js</h2>
<p>React.js中组件不允许通过<code>this.state</code>这种方式直接更改组件的状态。自身设置的状态，可以通过<code>setState</code>来进行更改。在<code>setState</code>中，传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须向上面方式一样的一个对象函数可以接受<code>prevState</code>和<code>props</code>。React.js在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。</p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactSetData.png" alt="React更新过程"></p>
<h1 id="diff算法">Diff算法</h1>
<h2 id="vuejs-4">Vue.js</h2>
<ol>
<li>同级比较，再比较子节点</li>
<li>先判断一方有子节点而另一方没有子节点的情况</li>
<li>比较双方都有子节点的情况（<a href="https://www.jianguoyun.com/static/stackedit/%5Bhttp://blog.p18c.top/2020/03/04/Vue.js%E7%A0%94%E8%AF%BB-%E8%99%9A%E6%8B%9FDOM/%5D(http://blog.p18c.top/2020/03/04/Vue.js%E7%A0%94%E8%AF%BB-%E8%99%9A%E6%8B%9FDOM/)">核心diff算法</a>）</li>
<li>递归比较子节点</li>
</ol>
<h2 id="reactjs（diff详解）">React.js（<a href="https://www.jianguoyun.com/static/stackedit/%5Bhttps://zhuanlan.zhihu.com/p/20346379%5D(https://zhuanlan.zhihu.com/p/20346379)">Diff详解</a>）</h2>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactDomDiff.png" alt="React.js DOM Diff"></p>
<h1 id="生命周期">生命周期</h1>
<h2 id="vuejs-5">Vue.js</h2>
<ol>
<li>beforeCreate</li>
</ol>
<p><code>new Vue()</code>后触发的第一个钩子，在当前阶段<code>data</code>、<code>methods</code>、<code>computed</code>以及<code>watch</code>上的数据和方法均不能被访问</p>
<ol>
<li>created</li>
</ol>
<p>在实例创建完成之后触发，当前阶段已完成了数据观测，也就是可以使用数据，更改数据，这时更新不会触发<code>updated</code>钩子。可以<strong>做一些初始数据的获取</strong>，在当前阶段<strong>无法访问DOM</strong>（可使用vm.$nextTick）</p>
<ol>
<li>beforeMount</li>
</ol>
<p>发生在挂载之前，在这之前template已导入渲染函数编译，而且当前阶段虚拟DOM已创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发<code>updated</code></p>
<ol>
<li>mounted</li>
</ol>
<p>在挂载之后被触发。在当前阶段，真实的DOM被挂载完毕，数据完成双向绑定，可以访问到DOM，可以使用<code>$ref</code>属性对DOM进行操作</p>
<ol>
<li>beforeUpdate</li>
</ol>
<p>在界面发生更新之前被触发。也就是响应式数据发生改变之前、虚拟DOM重新渲染之前被触发，可以在此阶段对数据进行修改，不会造成重渲染</p>
<ol>
<li>updated</li>
</ol>
<p>早发生更新之前被触发。当前阶段DOM已完成更新。要注意的是避免在此期间更新数据，因为这样可能会造成无限循环的更新</p>
<ol>
<li>beforeDestory</li>
</ol>
<p>在实例销毁之前触发。在当前阶段实例完全可以被使用，可以在此阶段做些善后工作，如清除定时器</p>
<ol>
<li>destoryed</li>
</ol>
<p>在实例销毁之后触发。这时候只剩下DOM，组件已被拆解、数据绑定被卸载、监听被移除、子实例也统统被销毁</p>
<h2 id="reactjs（生命周期详解）">React.js（<a href="https://www.jianguoyun.com/static/stackedit/%5Bhttps://www.jianshu.com/p/b331d0e4b398%5D(https://www.jianshu.com/p/b331d0e4b398)">生命周期详解</a>）</h2>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactLifeCycle.png" alt="React.js生命周期"></p>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactLifeCycle-1.png" alt="React.js生命周期1"></p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"前端架构\u0026软实力-React.js对比Vue.js","tags":["React.js对比Vue.js"],"categories":"前端架构\u0026软实力","description":"# 设计思想\n\n## Vue.js\n\n渐进式框架，采用自底向上增量开发的模式。\n\n所谓渐进式就是把框架分层。\n\n最核心的部分是视图层渲染，然后往外是组件系统，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。\n\n![渐进式](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-5.png)\n\n所谓分层，就是说既可以只用最核心的视图层渲","createDate":"2020-04-28 23:09:43","updateDate":"2021-02-20 17:15:36","body":"\u003ch1 id=\"设计思想\"\u003e设计思想\u003c/h1\u003e\n\u003ch2 id=\"vuejs\"\u003eVue.js\u003c/h2\u003e\n\u003cp\u003e渐进式框架，采用自底向上增量开发的模式。\u003c/p\u003e\n\u003cp\u003e所谓渐进式就是把框架分层。\u003c/p\u003e\n\u003cp\u003e最核心的部分是视图层渲染，然后往外是组件系统，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-5.png\" alt=\"渐进式\"\u003e\u003c/p\u003e\n\u003cp\u003e所谓分层，就是说既可以只用最核心的视图层渲染功能快速开发一些需求，也可以使用一整套全家桶来开发大型应用。Vue.js由足够的灵活性来适应不同的需求，所以开发者可以根据自己的需求选择不同的层级。\u003c/p\u003e\n\u003ch2 id=\"reactjs\"\u003eReact.js\u003c/h2\u003e\n\u003cp\u003e声明式、组件化\u003c/p\u003e\n\u003cp\u003eReact.js使创建交互式UI变得轻而易举。为应用的每一个状态设计简介地试图，当数据改变时React.js可以有效地更新并渲染组件。此外，React.js可以创建拥有各自状态的组件，再由这些组件构成更加复杂的 UI\u003c/p\u003e\n\u003ch1 id=\"组件间数据交互\"\u003e组件间数据交互\u003c/h1\u003e\n\u003ch2 id=\"父子组件\"\u003e父子组件\u003c/h2\u003e\n\u003ch3 id=\"vuejs-1\"\u003eVue.js\u003c/h3\u003e\n\u003cp\u003eVue.js中父组件通过\u003ccode\u003eprops\u003c/code\u003e传递数据给子组件，子组件使用\u003ccode\u003e$emit\u003c/code\u003e触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据。\u003c/p\u003e\n\u003ch3 id=\"reactjs-1\"\u003eReact.js\u003c/h3\u003e\n\u003cp\u003eReact.js中父组件使用\u003ccode\u003eprops\u003c/code\u003e传递数据和回调函数给子组件，子组件通过\u003ccode\u003eprops\u003c/code\u003e传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。\u003c/p\u003e\n\u003ch2 id=\"跨级组件\"\u003e跨级组件\u003c/h2\u003e\n\u003ch3 id=\"vuejs-2\"\u003eVue.js\u003c/h3\u003e\n\u003cp\u003eVue.js中通过\u003ccode\u003eprovide / inject\u003c/code\u003e在祖先组件向所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。\u003c/p\u003e\n\u003ch3 id=\"reactjs-2\"\u003eReact.js\u003c/h3\u003e\n\u003cp\u003eReact.js的\u003ccode\u003eContext\u003c/code\u003e 提供了一个无需为每层组件手动添加 \u003ccode\u003eprops\u003c/code\u003e就能在组件树间进行数据传递的方法。在父组件创建一个\u003ccode\u003eContext\u003c/code\u003e对象，通过\u003ccode\u003eContext.provider\u003c/code\u003e的\u003ccode\u003evalue\u003c/code\u003e属性向消费组件传值。\u003c/p\u003e\n\u003ch1 id=\"响应式原理\"\u003e响应式原理\u003c/h1\u003e\n\u003ch2 id=\"vuejs-3\"\u003eVue.js\u003c/h2\u003e\n\u003cp\u003eVue.js采用数据劫持\u0026amp;发布-订阅模式来实现响应式，Vue.js在创建\u003ccode\u003evm\u003c/code\u003e的时候，会将数据配置在实例当中，然后通过\u003ccode\u003eObject.defineProperty\u003c/code\u003e对数据进行操作，为数据动态添加了\u003ccode\u003egetter\u003c/code\u003e与\u003ccode\u003esetter\u003c/code\u003e方法，当获取数据的时候会触发对应的\u003ccode\u003egetter\u003c/code\u003e方法，当设置数据的时候会触发对应的\u003ccode\u003esetter\u003c/code\u003e方法，从而进一步触发\u003ccode\u003evm\u003c/code\u003e的\u003ccode\u003ewatcher\u003c/code\u003e方法，然后数据更改，\u003ccode\u003evm\u003c/code\u003e则会进一步触发视图更新操作。\u003c/p\u003e\n\u003ch2 id=\"reactjs-3\"\u003eReact.js\u003c/h2\u003e\n\u003cp\u003eReact.js中组件不允许通过\u003ccode\u003ethis.state\u003c/code\u003e这种方式直接更改组件的状态。自身设置的状态，可以通过\u003ccode\u003esetState\u003c/code\u003e来进行更改。在\u003ccode\u003esetState\u003c/code\u003e中，传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须向上面方式一样的一个对象函数可以接受\u003ccode\u003eprevState\u003c/code\u003e和\u003ccode\u003eprops\u003c/code\u003e。React.js在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactSetData.png\" alt=\"React更新过程\"\u003e\u003c/p\u003e\n\u003ch1 id=\"diff算法\"\u003eDiff算法\u003c/h1\u003e\n\u003ch2 id=\"vuejs-4\"\u003eVue.js\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e同级比较，再比较子节点\u003c/li\u003e\n\u003cli\u003e先判断一方有子节点而另一方没有子节点的情况\u003c/li\u003e\n\u003cli\u003e比较双方都有子节点的情况（\u003ca href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttp://blog.p18c.top/2020/03/04/Vue.js%E7%A0%94%E8%AF%BB-%E8%99%9A%E6%8B%9FDOM/%5D(http://blog.p18c.top/2020/03/04/Vue.js%E7%A0%94%E8%AF%BB-%E8%99%9A%E6%8B%9FDOM/)\"\u003e核心diff算法\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003e递归比较子节点\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"reactjs（diff详解）\"\u003eReact.js（\u003ca href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://zhuanlan.zhihu.com/p/20346379%5D(https://zhuanlan.zhihu.com/p/20346379)\"\u003eDiff详解\u003c/a\u003e）\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactDomDiff.png\" alt=\"React.js DOM Diff\"\u003e\u003c/p\u003e\n\u003ch1 id=\"生命周期\"\u003e生命周期\u003c/h1\u003e\n\u003ch2 id=\"vuejs-5\"\u003eVue.js\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003ebeforeCreate\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003enew Vue()\u003c/code\u003e后触发的第一个钩子，在当前阶段\u003ccode\u003edata\u003c/code\u003e、\u003ccode\u003emethods\u003c/code\u003e、\u003ccode\u003ecomputed\u003c/code\u003e以及\u003ccode\u003ewatch\u003c/code\u003e上的数据和方法均不能被访问\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecreated\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在实例创建完成之后触发，当前阶段已完成了数据观测，也就是可以使用数据，更改数据，这时更新不会触发\u003ccode\u003eupdated\u003c/code\u003e钩子。可以\u003cstrong\u003e做一些初始数据的获取\u003c/strong\u003e，在当前阶段\u003cstrong\u003e无法访问DOM\u003c/strong\u003e（可使用vm.$nextTick）\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ebeforeMount\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e发生在挂载之前，在这之前template已导入渲染函数编译，而且当前阶段虚拟DOM已创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发\u003ccode\u003eupdated\u003c/code\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003emounted\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在挂载之后被触发。在当前阶段，真实的DOM被挂载完毕，数据完成双向绑定，可以访问到DOM，可以使用\u003ccode\u003e$ref\u003c/code\u003e属性对DOM进行操作\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ebeforeUpdate\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在界面发生更新之前被触发。也就是响应式数据发生改变之前、虚拟DOM重新渲染之前被触发，可以在此阶段对数据进行修改，不会造成重渲染\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eupdated\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e早发生更新之前被触发。当前阶段DOM已完成更新。要注意的是避免在此期间更新数据，因为这样可能会造成无限循环的更新\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ebeforeDestory\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在实例销毁之前触发。在当前阶段实例完全可以被使用，可以在此阶段做些善后工作，如清除定时器\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003edestoryed\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在实例销毁之后触发。这时候只剩下DOM，组件已被拆解、数据绑定被卸载、监听被移除、子实例也统统被销毁\u003c/p\u003e\n\u003ch2 id=\"reactjs（生命周期详解）\"\u003eReact.js（\u003ca href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://www.jianshu.com/p/b331d0e4b398%5D(https://www.jianshu.com/p/b331d0e4b398)\"\u003e生命周期详解\u003c/a\u003e）\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactLifeCycle.png\" alt=\"React.js生命周期\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactLifeCycle-1.png\" alt=\"React.js生命周期1\"\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"前端架构\u0026软实力-React.js对比Vue.js"},"buildId":"8CuryAa1WcH3Hy5sWK_rn","assetPrefix":"/next-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>