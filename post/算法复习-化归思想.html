<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-算法复习-化归思想</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-3eff910f6206cfe7.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-d89e1712c82a34ac.js" defer=""></script><script src="/_next/static/rfzbvyXf47u3p_eOe2WWT/_buildManifest.js" defer=""></script><script src="/_next/static/rfzbvyXf47u3p_eOe2WWT/_ssgManifest.js" defer=""></script><script src="/_next/static/rfzbvyXf47u3p_eOe2WWT/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">算法复习-化归思想</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2024-06-07 18:27:44</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2024-06-07 20:07:42</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><p>文章灵感来自 leetcode 一篇题解<a href="https://leetcode.cn/problems/isomorphic-strings/solutions/1623468/by-martin-wv-6fet">全网耗时最低解题思路:化归(48ms，100%)</a></p>
<p>简单来说就是将数据格式进行转后，然后进行下一步操作，比如这道题<a href="https://leetcode.cn/problems/isomorphic-strings">205.同构字符串</a></p>
<pre><code>给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

示例 1:

输入：s = &quot;egg&quot;, t = &quot;add&quot;
输出：true
示例 2：

输入：s = &quot;foo&quot;, t = &quot;bar&quot;
输出：false
示例 3：

输入：s = &quot;paper&quot;, t = &quot;title&quot;
输出：true
</code></pre>
<p>经过对题目的分析，判断两个字符串是否是「同构」需要判断 <code>s</code> 和 <code>t</code> 每个位置上的字符是否都一一对应，即 <code>s</code> 的任意一个字符被 <code>t</code> 中唯一的字符对应，同时 <code>t</code> 的任意一个字符被 <code>s</code> 中唯一的字符对应。这也被称为「双射」的关系。传统的做法是在遍历时存储两个映射，然后对比映射关系是否一致:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) {
  <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> !== t.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(s[i])) {
      <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(s[i]) !== t[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (set.<span class="hljs-title function_">has</span>(t[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      map.<span class="hljs-title function_">set</span>(s[i], t[i]);
      set.<span class="hljs-title function_">add</span>(t[i]);
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};
</code></pre>
<p>但这种写法有些许难懂，我们可以用另一种方法来判断两个字符串是否「同构」-即将字符串转换为相同的表示结构再进行对比</p>
<pre><code>egg -&gt; 122
abb -&gt; 122
</code></pre>
<p>这样，我们只需要对比转换后的结果 <code>122</code> 和 <code>122</code> 是否一致就好了</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) {
  <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> !== t.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">if</span> (s === t) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">p</span> = (<span class="hljs-params">s</span>) =&gt; {
    <span class="hljs-keyword">const</span> m = {};
    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur, index</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (!m[cur]) {
        m[cur] = index + <span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${acc}</span><span class="hljs-subst">${m[cur]}</span>`</span>;
    }, <span class="hljs-string">&quot;&quot;</span>);
  };

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">p</span>(s) === <span class="hljs-title function_">p</span>(t);
};
</code></pre>
<p>这种方法还可以在以下题目中使用</p>
<p><a href="https://leetcode.cn/problems/word-pattern">290.单词规律</a></p>
<p>通过将 <code>pattern</code> 和 <code>s</code> 分别转换为同样的格式，对别结果即可</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">parse</span> = (<span class="hljs-params">words</span>) =&gt; {
  <span class="hljs-keyword">const</span> r = {};
  <span class="hljs-keyword">return</span> words.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur, index</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!r[cur]) {
      r[cur] = index + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${acc}</span><span class="hljs-subst">${r[cur]}</span>`</span>;
  }, []);
};

<span class="hljs-keyword">const</span> r1 = <span class="hljs-title function_">parse</span>(pattern.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>));
<span class="hljs-keyword">const</span> r2 = <span class="hljs-title function_">parse</span>(s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">w</span>) =&gt;</span> <span class="hljs-string">`_<span class="hljs-subst">${w}</span>`</span>));

<span class="hljs-keyword">return</span> r1 === r2;
</code></pre>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>2024</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"算法复习-化归思想","tags":["算法","化归"],"categories":"2024复习","description":"文章灵感来自 leetcode 一篇题解[全网耗时最低解题思路:化归(48ms，100%)](https://leetcode.cn/problems/isomorphic-strings/solutions/1623468/by-martin-wv-6fet)\n\n简单来说就是将数据格式进行转后，然后进行下一步操作，比如这道题[205.同构字符串](https://leetcode.cn/pro","createDate":"2024-06-07 18:27:44","updateDate":"2024-06-07 20:07:42","body":"\u003cp\u003e文章灵感来自 leetcode 一篇题解\u003ca href=\"https://leetcode.cn/problems/isomorphic-strings/solutions/1623468/by-martin-wv-6fet\"\u003e全网耗时最低解题思路:化归(48ms，100%)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e简单来说就是将数据格式进行转后，然后进行下一步操作，比如这道题\u003ca href=\"https://leetcode.cn/problems/isomorphic-strings\"\u003e205.同构字符串\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e给定两个字符串 s 和 t ，判断它们是否是同构的。\n\n如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n\n每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n\n示例 1:\n\n输入：s = \u0026quot;egg\u0026quot;, t = \u0026quot;add\u0026quot;\n输出：true\n示例 2：\n\n输入：s = \u0026quot;foo\u0026quot;, t = \u0026quot;bar\u0026quot;\n输出：false\n示例 3：\n\n输入：s = \u0026quot;paper\u0026quot;, t = \u0026quot;title\u0026quot;\n输出：true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e经过对题目的分析，判断两个字符串是否是「同构」需要判断 \u003ccode\u003es\u003c/code\u003e 和 \u003ccode\u003et\u003c/code\u003e 每个位置上的字符是否都一一对应，即 \u003ccode\u003es\u003c/code\u003e 的任意一个字符被 \u003ccode\u003et\u003c/code\u003e 中唯一的字符对应，同时 \u003ccode\u003et\u003c/code\u003e 的任意一个字符被 \u003ccode\u003es\u003c/code\u003e 中唯一的字符对应。这也被称为「双射」的关系。传统的做法是在遍历时存储两个映射，然后对比映射关系是否一致:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isIsomorphic = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003es, t\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (s.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e !== t.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (s.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u0026lt; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e map = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e set = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; s.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (map.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(s[i])) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (map.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(s[i]) !== t[i]) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (set.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(t[i])) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n      map.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(s[i], t[i]);\n      set.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(t[i]);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但这种写法有些许难懂，我们可以用另一种方法来判断两个字符串是否「同构」-即将字符串转换为相同的表示结构再进行对比\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eegg -\u0026gt; 122\nabb -\u0026gt; 122\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样，我们只需要对比转换后的结果 \u003ccode\u003e122\u003c/code\u003e 和 \u003ccode\u003e122\u003c/code\u003e 是否一致就好了\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isIsomorphic = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003es, t\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (s.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e !== t.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (s === t) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ep\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003es\u003c/span\u003e) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e m = {};\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e s.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eacc, cur, index\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!m[cur]) {\n        m[cur] = index + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${acc}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e${m[cur]}\u003c/span\u003e`\u003c/span\u003e;\n    }, \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e);\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ep\u003c/span\u003e(s) === \u003cspan class=\"hljs-title function_\"\u003ep\u003c/span\u003e(t);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方法还可以在以下题目中使用\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.cn/problems/word-pattern\"\u003e290.单词规律\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e通过将 \u003ccode\u003epattern\u003c/code\u003e 和 \u003ccode\u003es\u003c/code\u003e 分别转换为同样的格式，对别结果即可\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ewords\u003c/span\u003e) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e r = {};\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e words.\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eacc, cur, index\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!r[cur]) {\n      r[cur] = index + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${acc}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e${r[cur]}\u003c/span\u003e`\u003c/span\u003e;\n  }, []);\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e r1 = \u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(pattern.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e));\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e r2 = \u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(s.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot; \u0026quot;\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ew\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`_\u003cspan class=\"hljs-subst\"\u003e${w}\u003c/span\u003e`\u003c/span\u003e));\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e r1 === r2;\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"算法复习-化归思想"},"buildId":"rfzbvyXf47u3p_eOe2WWT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>