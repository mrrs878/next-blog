<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-网络相关-tcp</title><meta name="next-head-count" content="3"/><link rel="preload" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" as="style"/><link rel="stylesheet" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/next-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/next-blog/_next/static/chunks/webpack-cf185e4b59cdddcf.js" defer=""></script><script src="/next-blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/next-blog/_next/static/chunks/main-1c9e93b8392c1bc9.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/next-blog/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/post/%5Btitle%5D-406bad804ceffd1d.js" defer=""></script><script src="/next-blog/_next/static/Y_MIfKxNaecXW7Q-n_oaS/_buildManifest.js" defer=""></script><script src="/next-blog/_next/static/Y_MIfKxNaecXW7Q-n_oaS/_ssgManifest.js" defer=""></script><script src="/next-blog/_next/static/Y_MIfKxNaecXW7Q-n_oaS/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/next-blog">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/next-blog/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">网络相关-tcp</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-04-16 21:00:43</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h1 id="tcp的特点">TCP的特点</h1>
<ul>
<li>三次握手</li>
<li>四次挥手</li>
<li>可靠连接</li>
<li>面向字节流</li>
<li>提供拥塞控制</li>
<li>丢包重传</li>
</ul>
<h1 id="tcp如何保证可靠传输">TCP如何保证可靠传输</h1>
<p>tcp在传输的过程中都有一个ack，接收方通过ack告诉发送方收到哪些包了。这样发送方就能知道丢包情况进而重传</p>
<h1 id="tcp的三次握手">TCP的三次握手</h1>
<ol>
<li>client发送SYN到server发起握手</li>
<li>server回复SYN+ACK给client</li>
<li>client回复server一个ACK表示收到了server的SYN+ACK</li>
</ol>
<p>握手的核心目的是告知对方SEQ，对方回复ACK（收到的SEQ+包的大小），这样发送端就知道有没有丢包了。次要目的是告知和协商一些信息</p>
<h1 id="tcp的四次挥手">TCP的四次挥手</h1>
<ol>
<li>client发送FIN包给server</li>
<li>sever回复ACK（对应第一步FIN包的ACK）给client，表示server知道client要断开了</li>
<li>sever发送FIN包给client，表示server也可以断开了</li>
<li>client回复ACK给server，表示既然双方都发送FIN包表示断开，那就真的断开吧</li>
</ol>
<h1 id="为什么要三次握手、四次挥手">为什么要三次握手、四次挥手</h1>
<p>挥手的时候多一次主要是收到第一个FIN包后单独回复了一个ACK包，如果FIN+ACK和并发送那么四次挥手也变成三次了。关于为什么要分开，收到FIN后，知道对方要关闭了，然后OS通知应用层要关闭啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回ACK，准备好了再发FIN。握手没有这个准备过程（服务端在LISTEN状态下）所以可以立即发送SYN+ACK</p>
<h1 id="ack">ACK</h1>
<p><code>ACK = SEQ + LEN(包的大小)</code>，这样发送方可以明确知道对方收到哪些东西</p>
<h1 id="拥塞控制">拥塞控制</h1>
<p>拥塞控制主要作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。拥塞处理包括以下算法：慢开始、拥塞避免、快速重传</p>
<h2 id="慢开始">慢开始</h2>
<p>在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞</p>
<p>慢开始算法步骤具体如下：</p>
<ol>
<li>连接初始设置拥塞窗口（Congestion Window）为1MSS（一个分段的最大数据量）</li>
<li>每过一个RTT（表示发送端发送数据到接收到对端数据所需的往返时间）就将窗口大小x2</li>
<li>指数级增长肯定不能没有限制，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法</li>
</ol>
<h2 id="拥塞避免算法">拥塞避免算法</h2>
<p>拥塞避免算法相比简单点，每过一个RTT，拥塞窗口大小+1，这样能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。在传输过程中可能会遇到定时器超时的情况，这时TCP就会认为网络拥塞了，会马上进行以下步骤：</p>
<ol>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为1MSS</li>
<li>启动拥塞避免算法</li>
</ol>
<h2 id="快速重传">快速重传</h2>
<p>一旦接收端收到的报文出现失序的情况，接收端指会回复最后一个顺序正确的报文序号（没有SACK的情况）。如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。</p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"网络相关-tcp","tags":["网络","TCP"],"categories":"网络","description":"# TCP的特点\n\n- 三次握手\n- 四次挥手\n- 可靠连接\n- 面向字节流\n- 提供拥塞控制\n- 丢包重传\n\n# TCP如何保证可靠传输\n\ntcp在传输的过程中都有一个ack，接收方通过ack告诉发送方收到哪些包了。这样发送方就能知道丢包情况进而重传\n\n# TCP的三次握手\n\n1. client发送SYN到server发起握手\n2. server回复SYN+ACK给client\n3. cli","createDate":"2020-04-16 21:00:43","updateDate":"10/1/2021, 3:34:43 AM","body":"\u003ch1 id=\"tcp的特点\"\u003eTCP的特点\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e三次握手\u003c/li\u003e\n\u003cli\u003e四次挥手\u003c/li\u003e\n\u003cli\u003e可靠连接\u003c/li\u003e\n\u003cli\u003e面向字节流\u003c/li\u003e\n\u003cli\u003e提供拥塞控制\u003c/li\u003e\n\u003cli\u003e丢包重传\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"tcp如何保证可靠传输\"\u003eTCP如何保证可靠传输\u003c/h1\u003e\n\u003cp\u003etcp在传输的过程中都有一个ack，接收方通过ack告诉发送方收到哪些包了。这样发送方就能知道丢包情况进而重传\u003c/p\u003e\n\u003ch1 id=\"tcp的三次握手\"\u003eTCP的三次握手\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eclient发送SYN到server发起握手\u003c/li\u003e\n\u003cli\u003eserver回复SYN+ACK给client\u003c/li\u003e\n\u003cli\u003eclient回复server一个ACK表示收到了server的SYN+ACK\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e握手的核心目的是告知对方SEQ，对方回复ACK（收到的SEQ+包的大小），这样发送端就知道有没有丢包了。次要目的是告知和协商一些信息\u003c/p\u003e\n\u003ch1 id=\"tcp的四次挥手\"\u003eTCP的四次挥手\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eclient发送FIN包给server\u003c/li\u003e\n\u003cli\u003esever回复ACK（对应第一步FIN包的ACK）给client，表示server知道client要断开了\u003c/li\u003e\n\u003cli\u003esever发送FIN包给client，表示server也可以断开了\u003c/li\u003e\n\u003cli\u003eclient回复ACK给server，表示既然双方都发送FIN包表示断开，那就真的断开吧\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"为什么要三次握手、四次挥手\"\u003e为什么要三次握手、四次挥手\u003c/h1\u003e\n\u003cp\u003e挥手的时候多一次主要是收到第一个FIN包后单独回复了一个ACK包，如果FIN+ACK和并发送那么四次挥手也变成三次了。关于为什么要分开，收到FIN后，知道对方要关闭了，然后OS通知应用层要关闭啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回ACK，准备好了再发FIN。握手没有这个准备过程（服务端在LISTEN状态下）所以可以立即发送SYN+ACK\u003c/p\u003e\n\u003ch1 id=\"ack\"\u003eACK\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eACK = SEQ + LEN(包的大小)\u003c/code\u003e，这样发送方可以明确知道对方收到哪些东西\u003c/p\u003e\n\u003ch1 id=\"拥塞控制\"\u003e拥塞控制\u003c/h1\u003e\n\u003cp\u003e拥塞控制主要作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。拥塞处理包括以下算法：慢开始、拥塞避免、快速重传\u003c/p\u003e\n\u003ch2 id=\"慢开始\"\u003e慢开始\u003c/h2\u003e\n\u003cp\u003e在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞\u003c/p\u003e\n\u003cp\u003e慢开始算法步骤具体如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e连接初始设置拥塞窗口（Congestion Window）为1MSS（一个分段的最大数据量）\u003c/li\u003e\n\u003cli\u003e每过一个RTT（表示发送端发送数据到接收到对端数据所需的往返时间）就将窗口大小x2\u003c/li\u003e\n\u003cli\u003e指数级增长肯定不能没有限制，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"拥塞避免算法\"\u003e拥塞避免算法\u003c/h2\u003e\n\u003cp\u003e拥塞避免算法相比简单点，每过一个RTT，拥塞窗口大小+1，这样能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。在传输过程中可能会遇到定时器超时的情况，这时TCP就会认为网络拥塞了，会马上进行以下步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将阈值设为当前拥塞窗口的一半\u003c/li\u003e\n\u003cli\u003e将拥塞窗口设为1MSS\u003c/li\u003e\n\u003cli\u003e启动拥塞避免算法\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"快速重传\"\u003e快速重传\u003c/h2\u003e\n\u003cp\u003e一旦接收端收到的报文出现失序的情况，接收端指会回复最后一个顺序正确的报文序号（没有SACK的情况）。如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"网络相关-tcp"},"buildId":"Y_MIfKxNaecXW7Q-n_oaS","assetPrefix":"/next-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>