<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-JavaScript复习-模块化</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c254d3655a5edcea.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c254d3655a5edcea.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9cd1d19dd7237c4c.js" defer=""></script><script src="/_next/static/chunks/443-78ba638de598a708.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-8e525edef48fb7d5.js" defer=""></script><script src="/_next/static/yzI-MX0bChSNiDL4n6hJE/_buildManifest.js" defer=""></script><script src="/_next/static/yzI-MX0bChSNiDL4n6hJE/_ssgManifest.js" defer=""></script><script src="/_next/static/yzI-MX0bChSNiDL4n6hJE/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/">分类</a></li><li class="ml-4 hover:text-yellow"><a href="/">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">JavaScript复习-模块化</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2021-05-12 04:30:39</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h2 id="模块化解决的问题">模块化解决的问题</h2>
<ul>
<li>外部模块的管理</li>
<li>内部模块的组织</li>
<li>模块源码到目标代码的编译和转换</li>
</ul>
<h2 id="时间线">时间线</h2>
<table>
<thead>
<tr>
<th>生态</th>
<th>诞生时间</th>
</tr>
</thead>
<tbody><tr>
<td>Node.js</td>
<td>2009</td>
</tr>
<tr>
<td>NPM</td>
<td>2010</td>
</tr>
<tr>
<td>requireJS(AMD)</td>
<td>2010</td>
</tr>
<tr>
<td>seaJS(cmd)</td>
<td>2011</td>
</tr>
<tr>
<td>browserify</td>
<td>2011</td>
</tr>
<tr>
<td>webpack</td>
<td>2012</td>
</tr>
<tr>
<td>grunt</td>
<td>2012</td>
</tr>
<tr>
<td>gulp</td>
<td>2013</td>
</tr>
<tr>
<td>react</td>
<td>2013</td>
</tr>
<tr>
<td>vue</td>
<td>2014</td>
</tr>
<tr>
<td>angular</td>
<td>2016</td>
</tr>
<tr>
<td>vite</td>
<td>2020</td>
</tr>
<tr>
<td>snowpack</td>
<td>2020</td>
</tr>
</tbody></table>
<h2 id="外部模块的管理">外部模块的管理</h2>
<h3 id="script标签">script标签</h3>
<p>如果我们要在项目里使用某个外部模块，最简单的方法就是去官网把相关的js文件下载下来放在项目目录，在要使用的html页面里通过script标签引用。这样简单粗暴的方法缺点明显：</p>
<ul>
<li>使用上缺乏便利性</li>
<li>难以跟踪各个外部模块的来源</li>
<li>没有统一的版本管理机制</li>
</ul>
<h3 id="npm">npm</h3>
<p>2010年，npm伴随着Node.js的新版本一起发布。此后，外部模块管理从原始社会进入现代社会。</p>
<ul>
<li>npm是一个远程的JavaScript代码仓库，所有的开发者都可以向这里提交可共享的模块，供其他开发者下载使用</li>
<li>npm还包含一个命令行工具，开发者通过运行<code>npm publish</code>将自己写的模块发布到npm仓库，通过运行<code>npm install xxx</code>可以将别人的模块下载到自己项目根目录下一个叫<code>node_modules</code>的文件夹里</li>
</ul>
<h2 id="内部模块的组织">内部模块的组织</h2>
<h3 id="script标签-1">script标签</h3>
<p>同引入外部模块一样，通过IIFE去组织内部模块并通过<code>script</code>标签引用</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// a.js</span>
<span class="hljs-keyword">var</span> moduleA = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
})(<span class="hljs-variable language_">window</span>);

<span class="hljs-comment">// b.js</span>
<span class="hljs-keyword">var</span> moduleB = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
})(<span class="hljs-variable language_">window</span>);
</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>&quot;/<span class="hljs-attr">path</span>/<span class="hljs-attr">to</span>/<span class="hljs-attr">a.js</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>&quot;/<span class="hljs-attr">path</span>/<span class="hljs-attr">to</span>/<span class="hljs-attr">b.js</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>这种简单粗暴的方式缺点比较明显：</p>
<ul>
<li>随着项目扩大，html文件中会包含大量<code>script</code>标签</li>
<li>模块间的复杂依赖关系仅靠<code>script</code>标签引用顺序来组织</li>
<li>污染全局环境，可能存在命名冲突</li>
</ul>
<h3 id="amdcmdcommonjsesm">AMD&amp;CMD&amp;CommonJS&amp;ESM</h3>
<p>AMD/CMD只是一种设计规范，而不是实现。AMD的主要实现有两个(RequireJS和curl.js)，CMD的主要实现有(sea.js)</p>
<h4 id="amdasynchronous-module-define主要包含两个api：define和require">AMD(Asynchronous Module Define)主要包含两个API：<strong>define</strong>和<strong>require</strong></h4>
<p>define方法用于定义一个模块，接收两个参数：</p>
<ul>
<li>第一个参数是数组表示这个模块所依赖的其他模块</li>
<li>第二个参数是一个回调函数，通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，返回值将作为其他依赖模块的引用</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;Module1&#x27;</span>], <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {
    <span class="hljs-keyword">return</span> {
    }
}); 

<span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;math&#x27;</span>], <span class="hljs-keyword">function</span> (<span class="hljs-params">math</span>) {
　 math.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">15</span>)
});
</code></pre>
<p><code>define</code>能自定义模块而<code>require</code>只能引用其他模块，<code>require</code>的真正作用是执行模块加载</p>
<p>AMD规范去除了纯粹用script便签顺组组织模块带来的问题</p>
<ol>
<li>通过依赖数组的方式声明依赖关系，具体依赖关系交给具体的AMD框架处理</li>
<li>避免生命全局变量带来的环境污染和变量冲突问题</li>
<li>模块异步加载，防止JS加载阻塞页面渲染</li>
</ol>
<h4 id="cmdcommon-module-definition">CMD(Common Module Definition)</h4>
<p>有一个<code>define</code>API,接收一个<code>factory</code>回调函数，有三个参数：</p>
<ul>
<li>require：一个方法标识符，调用它可以动态的获取一个依赖模块的输出</li>
<li>exports：一个对象，用于对其他模块提供输出接口，例如<code>exports.name = xxx</code></li>
<li>module：一个对象，存储了当前模块相关的一些属性和方法，其中<code>module.exports</code>等同于<code>exports</code></li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) {
    <span class="hljs-keyword">var</span> moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;/path/to/ModuleA&#x27;</span>);
    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {}
})
</code></pre>
<h4 id="cmdamd的区别">CMD&amp;AMD的区别</h4>
<p>一方面，在依赖的处理上</p>
<ul>
<li>AMD依赖前置，即通过依赖数组的方式提前声明当前模块的依赖</li>
<li>CMD依赖就近，在需要用到的时候通过调用<code>require</code>方法动态导入</li>
</ul>
<p>另一方面，在本模块的输出上</p>
<ul>
<li>AMD通过返回值的方式对外输出</li>
<li>CMD通过给<code>module.exports</code>赋值的方式对外输出</li>
</ul>
<h3 id="commonjsesm">CommonJS&amp;ESM</h3>
<p><code>CommonJS</code>是Node.js使用的模块化方式</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> ramda = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ramda&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {}
</code></pre>
<p><code>ESM</code>是<code>ES6</code>提出的模块化方案</p>
<pre><code class="hljs language-js">impot { clone } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ramda&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {}
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>CommonJS</th>
<th>ESM</th>
</tr>
</thead>
<tbody><tr>
<td>加载时间</td>
<td>运行时加载</td>
<td>编译时输出接口</td>
</tr>
<tr>
<td>输出方式</td>
<td>值的拷贝</td>
<td>值的引用</td>
</tr>
</tbody></table>
<h4 id="输出方式比对">输出方式比对</h4>
<pre><code class="hljs language-js"><span class="hljs-comment">// CommonJS</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">increaseA</span>(<span class="hljs-params"></span>) {
    a += <span class="hljs-number">1</span>;
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = { a, increaseA };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1</span>
<span class="hljs-title function_">increaseA</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// ESM</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">increaseB</span>(<span class="hljs-params"></span>) {
    b += <span class="hljs-number">1</span>;
}
<span class="hljs-keyword">export</span> { b, increaseB };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 1</span>
<span class="hljs-title function_">increaseB</span>();
conosle.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 2</span>
</code></pre>
<h3 id="webpackbrowserify">webpack/browserify</h3>
<p>AMD/CMD可以看作在线编译模块的方法，也就是等浏览器下载了这些js文件后才进行模块依赖分析，确定加载顺序和执行顺序，带来了一些问题</p>
<ul>
<li>增加代码加载时间，影响用户体验</li>
<li>http请求过多，降低页面性能</li>
</ul>
<p>于是有以下对应方法去解决：</p>
<ul>
<li>提前将模块组织好</li>
<li>进行代码合并，把多个<code>script</code>的代码合并到少数几个文件中减少http请求个数</li>
</ul>
<p>具有代表性的是<code>webpack</code>和<code>browserify</code></p>
<p><img src="http://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack.png" alt="webpack"></p>
<p>打包工具面临的问题&amp;&amp;解决方案</p>
<p><strong>打包后的文件体积过大</strong></p>
<p>代码打包的初衷是减少AMD/CMD等框架造成的加载脚本数量过多的问题，但也带来了打包后单个文件体积过大的问题：如此一来，首屏加载时间缓慢，体验较差</p>
<p>于是webpack引入了代码拆分的功能(Code Splitting)来解决这个问题, 从全部打包后退一步：可以打包成多个包</p>
<ul>
<li>第三方库和业务代码的分离：业务代码更新频率快，而第三方库代码更新频率是比较慢的。分离之后可利用浏览器缓存机制加载第三方库，从而加快页面访问速度</li>
<li>按需加载: 例如我们经常通过前端路由分割不同页面，除了首页外的很多页面(路由)可能访问频率较低，我们可将其从首次加载的资源中去掉，而等到相应的触发时刻再去加载它们。这样就减少了首屏资源的体积，提高了页面加载速度。</li>
</ul>
<h3 id="bundlelesssnowpackvite">bundleless(snowpack/vite)</h3>
<p>利用现代浏览器对ES6普遍支持良好的现状，开发环境下不进行打包。借助浏览器 ESM 的能力，一些代码基本可以做到无需构建直接运行。代表性工具是vite和snowpack</p>
<p>为什么要打包？</p>
<p>对于早期的 web 应用而言，打包模块既能够处理 JS 模块化，又能将多个模块打包合并网络请求。使用这类构建工具打包项目的确是个不错的选择。时至今日基本上主流的浏览器版本都支持 ESM，并且并发网络请求带来的性能问题，在 HTTP/2 普及下不像以前那么凸显的情况下，大家又将目光转向了 ESM。就目前的体验而言，基于原生 ESM 在开发过程中的构建速度似乎远远优于 webpack 之类的打包工具的。</p>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/265632724">前端模块化的十年征程</a></p>
<p><a href="https://juejin.cn/post/6947890290896142350">ESM vs Webpack 面向高性能构建的探索</a></p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><div class="flex items-center justify-center"><span>本网站由 </span><a class="cdn-logo-c" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral"><img class="call-me" src="https://blog.mrrs.top/img/cdn_logo.png" style="width:40px" alt=""/></a><span>提供CDN加速/云存储服务</span></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript复习-模块化","tags":["JavaScript","模块化"],"categories":"2021复习","description":"## 模块化解决的问题\n\n- 外部模块的管理\n- 内部模块的组织\n- 模块源码到目标代码的编译和转换\n\n## 时间线\n\n|  生态  |  诞生时间  |\n| -- | -- |\n|Node.js|2009|\n|NPM|2010|\n|requireJS(AMD)|2010|\n|seaJS(cmd)|2011|\n|browserify|2011|\n|webpack|2012|\n|grunt|20","createDate":"2021-05-12 04:30:39","updateDate":"2021-06-21 23:26:16","body":"\u003ch2 id=\"模块化解决的问题\"\u003e模块化解决的问题\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e外部模块的管理\u003c/li\u003e\n\u003cli\u003e内部模块的组织\u003c/li\u003e\n\u003cli\u003e模块源码到目标代码的编译和转换\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"时间线\"\u003e时间线\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e生态\u003c/th\u003e\n\u003cth\u003e诞生时间\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eNode.js\u003c/td\u003e\n\u003ctd\u003e2009\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eNPM\u003c/td\u003e\n\u003ctd\u003e2010\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003erequireJS(AMD)\u003c/td\u003e\n\u003ctd\u003e2010\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eseaJS(cmd)\u003c/td\u003e\n\u003ctd\u003e2011\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ebrowserify\u003c/td\u003e\n\u003ctd\u003e2011\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewebpack\u003c/td\u003e\n\u003ctd\u003e2012\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003egrunt\u003c/td\u003e\n\u003ctd\u003e2012\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003egulp\u003c/td\u003e\n\u003ctd\u003e2013\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ereact\u003c/td\u003e\n\u003ctd\u003e2013\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003evue\u003c/td\u003e\n\u003ctd\u003e2014\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eangular\u003c/td\u003e\n\u003ctd\u003e2016\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003evite\u003c/td\u003e\n\u003ctd\u003e2020\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esnowpack\u003c/td\u003e\n\u003ctd\u003e2020\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2 id=\"外部模块的管理\"\u003e外部模块的管理\u003c/h2\u003e\n\u003ch3 id=\"script标签\"\u003escript标签\u003c/h3\u003e\n\u003cp\u003e如果我们要在项目里使用某个外部模块，最简单的方法就是去官网把相关的js文件下载下来放在项目目录，在要使用的html页面里通过script标签引用。这样简单粗暴的方法缺点明显：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用上缺乏便利性\u003c/li\u003e\n\u003cli\u003e难以跟踪各个外部模块的来源\u003c/li\u003e\n\u003cli\u003e没有统一的版本管理机制\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"npm\"\u003enpm\u003c/h3\u003e\n\u003cp\u003e2010年，npm伴随着Node.js的新版本一起发布。此后，外部模块管理从原始社会进入现代社会。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enpm是一个远程的JavaScript代码仓库，所有的开发者都可以向这里提交可共享的模块，供其他开发者下载使用\u003c/li\u003e\n\u003cli\u003enpm还包含一个命令行工具，开发者通过运行\u003ccode\u003enpm publish\u003c/code\u003e将自己写的模块发布到npm仓库，通过运行\u003ccode\u003enpm install xxx\u003c/code\u003e可以将别人的模块下载到自己项目根目录下一个叫\u003ccode\u003enode_modules\u003c/code\u003e的文件夹里\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"内部模块的组织\"\u003e内部模块的组织\u003c/h2\u003e\n\u003ch3 id=\"script标签-1\"\u003escript标签\u003c/h3\u003e\n\u003cp\u003e同引入外部模块一样，通过IIFE去组织内部模块并通过\u003ccode\u003escript\u003c/code\u003e标签引用\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// a.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e moduleA = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n})(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// b.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e moduleB = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n})(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e\u0026quot;/\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e/\u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e/\u003cspan class=\"hljs-attr\"\u003ea.js\u003c/span\u003e\u0026quot;\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e\u0026quot;/\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e/\u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e/\u003cspan class=\"hljs-attr\"\u003eb.js\u003c/span\u003e\u0026quot;\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种简单粗暴的方式缺点比较明显：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e随着项目扩大，html文件中会包含大量\u003ccode\u003escript\u003c/code\u003e标签\u003c/li\u003e\n\u003cli\u003e模块间的复杂依赖关系仅靠\u003ccode\u003escript\u003c/code\u003e标签引用顺序来组织\u003c/li\u003e\n\u003cli\u003e污染全局环境，可能存在命名冲突\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"amdcmdcommonjsesm\"\u003eAMD\u0026amp;CMD\u0026amp;CommonJS\u0026amp;ESM\u003c/h3\u003e\n\u003cp\u003eAMD/CMD只是一种设计规范，而不是实现。AMD的主要实现有两个(RequireJS和curl.js)，CMD的主要实现有(sea.js)\u003c/p\u003e\n\u003ch4 id=\"amdasynchronous-module-define主要包含两个api：define和require\"\u003eAMD(Asynchronous Module Define)主要包含两个API：\u003cstrong\u003edefine\u003c/strong\u003e和\u003cstrong\u003erequire\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003edefine方法用于定义一个模块，接收两个参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一个参数是数组表示这个模块所依赖的其他模块\u003c/li\u003e\n\u003cli\u003e第二个参数是一个回调函数，通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，返回值将作为其他依赖模块的引用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003edefine\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Module1\u0026#x27;\u003c/span\u003e], \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    }\n}); \n\n\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\u0026#x27;math\u0026#x27;\u003c/span\u003e], \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003emath\u003c/span\u003e) {\n　 math.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e)\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edefine\u003c/code\u003e能自定义模块而\u003ccode\u003erequire\u003c/code\u003e只能引用其他模块，\u003ccode\u003erequire\u003c/code\u003e的真正作用是执行模块加载\u003c/p\u003e\n\u003cp\u003eAMD规范去除了纯粹用script便签顺组组织模块带来的问题\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过依赖数组的方式声明依赖关系，具体依赖关系交给具体的AMD框架处理\u003c/li\u003e\n\u003cli\u003e避免生命全局变量带来的环境污染和变量冲突问题\u003c/li\u003e\n\u003cli\u003e模块异步加载，防止JS加载阻塞页面渲染\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"cmdcommon-module-definition\"\u003eCMD(Common Module Definition)\u003c/h4\u003e\n\u003cp\u003e有一个\u003ccode\u003edefine\u003c/code\u003eAPI,接收一个\u003ccode\u003efactory\u003c/code\u003e回调函数，有三个参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003erequire：一个方法标识符，调用它可以动态的获取一个依赖模块的输出\u003c/li\u003e\n\u003cli\u003eexports：一个对象，用于对其他模块提供输出接口，例如\u003ccode\u003eexports.name = xxx\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003emodule：一个对象，存储了当前模块相关的一些属性和方法，其中\u003ccode\u003emodule.exports\u003c/code\u003e等同于\u003ccode\u003eexports\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003edefine\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e moduleA = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/path/to/ModuleA\u0026#x27;\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {}\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"cmdamd的区别\"\u003eCMD\u0026amp;AMD的区别\u003c/h4\u003e\n\u003cp\u003e一方面，在依赖的处理上\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAMD依赖前置，即通过依赖数组的方式提前声明当前模块的依赖\u003c/li\u003e\n\u003cli\u003eCMD依赖就近，在需要用到的时候通过调用\u003ccode\u003erequire\u003c/code\u003e方法动态导入\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e另一方面，在本模块的输出上\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAMD通过返回值的方式对外输出\u003c/li\u003e\n\u003cli\u003eCMD通过给\u003ccode\u003emodule.exports\u003c/code\u003e赋值的方式对外输出\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"commonjsesm\"\u003eCommonJS\u0026amp;ESM\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eCommonJS\u003c/code\u003e是Node.js使用的模块化方式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ramda = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;ramda\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eESM\u003c/code\u003e是\u003ccode\u003eES6\u003c/code\u003e提出的模块化方案\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimpot { clone } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;ramda\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eCommonJS\u003c/th\u003e\n\u003cth\u003eESM\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e加载时间\u003c/td\u003e\n\u003ctd\u003e运行时加载\u003c/td\u003e\n\u003ctd\u003e编译时输出接口\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e输出方式\u003c/td\u003e\n\u003ctd\u003e值的拷贝\u003c/td\u003e\n\u003ctd\u003e值的引用\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4 id=\"输出方式比对\"\u003e输出方式比对\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// CommonJS\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincreaseA\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    a += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = { a, increaseA };\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(a); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eincreaseA\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(a); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// ESM\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e b = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincreaseB\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    b += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e { b, increaseB };\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(b); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eincreaseB\u003c/span\u003e();\nconosle.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(b); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"webpackbrowserify\"\u003ewebpack/browserify\u003c/h3\u003e\n\u003cp\u003eAMD/CMD可以看作在线编译模块的方法，也就是等浏览器下载了这些js文件后才进行模块依赖分析，确定加载顺序和执行顺序，带来了一些问题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e增加代码加载时间，影响用户体验\u003c/li\u003e\n\u003cli\u003ehttp请求过多，降低页面性能\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e于是有以下对应方法去解决：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提前将模块组织好\u003c/li\u003e\n\u003cli\u003e进行代码合并，把多个\u003ccode\u003escript\u003c/code\u003e的代码合并到少数几个文件中减少http请求个数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e具有代表性的是\u003ccode\u003ewebpack\u003c/code\u003e和\u003ccode\u003ebrowserify\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack.png\" alt=\"webpack\"\u003e\u003c/p\u003e\n\u003cp\u003e打包工具面临的问题\u0026amp;\u0026amp;解决方案\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e打包后的文件体积过大\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e代码打包的初衷是减少AMD/CMD等框架造成的加载脚本数量过多的问题，但也带来了打包后单个文件体积过大的问题：如此一来，首屏加载时间缓慢，体验较差\u003c/p\u003e\n\u003cp\u003e于是webpack引入了代码拆分的功能(Code Splitting)来解决这个问题, 从全部打包后退一步：可以打包成多个包\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第三方库和业务代码的分离：业务代码更新频率快，而第三方库代码更新频率是比较慢的。分离之后可利用浏览器缓存机制加载第三方库，从而加快页面访问速度\u003c/li\u003e\n\u003cli\u003e按需加载: 例如我们经常通过前端路由分割不同页面，除了首页外的很多页面(路由)可能访问频率较低，我们可将其从首次加载的资源中去掉，而等到相应的触发时刻再去加载它们。这样就减少了首屏资源的体积，提高了页面加载速度。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bundlelesssnowpackvite\"\u003ebundleless(snowpack/vite)\u003c/h3\u003e\n\u003cp\u003e利用现代浏览器对ES6普遍支持良好的现状，开发环境下不进行打包。借助浏览器 ESM 的能力，一些代码基本可以做到无需构建直接运行。代表性工具是vite和snowpack\u003c/p\u003e\n\u003cp\u003e为什么要打包？\u003c/p\u003e\n\u003cp\u003e对于早期的 web 应用而言，打包模块既能够处理 JS 模块化，又能将多个模块打包合并网络请求。使用这类构建工具打包项目的确是个不错的选择。时至今日基本上主流的浏览器版本都支持 ESM，并且并发网络请求带来的性能问题，在 HTTP/2 普及下不像以前那么凸显的情况下，大家又将目光转向了 ESM。就目前的体验而言，基于原生 ESM 在开发过程中的构建速度似乎远远优于 webpack 之类的打包工具的。\u003c/p\u003e\n\u003ch2 id=\"参考\"\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/265632724\"\u003e前端模块化的十年征程\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://juejin.cn/post/6947890290896142350\"\u003eESM vs Webpack 面向高性能构建的探索\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"JavaScript复习-模块化"},"buildId":"yzI-MX0bChSNiDL4n6hJE","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>