<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-React.js学习-使用内置hook</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/cd72816920092dcb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd72816920092dcb.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/CZ6Uu2i9da2HCumDfSdj1/_buildManifest.js" defer=""></script><script src="/_next/static/CZ6Uu2i9da2HCumDfSdj1/_ssgManifest.js" defer=""></script><script src="/_next/static/CZ6Uu2i9da2HCumDfSdj1/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">React.js学习-使用内置hook</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-09-07 10:48:54</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2022-05-11 22:19:50</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write">
      <h1>
        <span class="prefix"></span>
        <span class="content">什么是 hook</span>
        <span class="suffix"></span>
      </h1>
    <p>组件自身能够通过某种机制再触发状态的变更并且引起<strong>re-render</strong>，而这种“机制”就是 Hooks！</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">useEffect</span>
        <span class="suffix"></span>
      </h1>
    <ul>
<li><p>默认情况下，它在第一次渲染之后和每次更新之后都会执行。React 确保了每次运行<code>effect</code>的同时，DOM 都已经更新完毕</p>
</li>
<li><p>每次重新渲染，都会生成新的<code>effect</code>，替换掉之前的。某种意义上讲，<code>effect</code>更像是渲染结果的一部分 —— 每个<code>effect</code> “属于”一次特定的渲染。</p>
</li>
<li><p>每个<code>effect</code>都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。他们都属于<code>effect</code>的一部分</p>
</li>
</ul>

      <h1>
        <span class="prefix"></span>
        <span class="content">自定义 hook 的 state 是否共享</span>
        <span class="suffix"></span>
      </h1>
    <p>在两个组件中使用相同的<code>hook</code>不会共享<code>state</code>，自定义<code>hook</code>是一种重用状态逻辑的机制，所以每次使用自定义<code>hook</code>时其中的所有<code>state</code>和副作用是完全隔离的</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">hook 原理</span>
        <span class="suffix"></span>
      </h1>
    <p>初次渲染的时候，按照 useState，useEffect 等 hook 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中。</p>
<p>更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">state 和 useState 的对应关系</span>
        <span class="suffix"></span>
      </h1>
    <p><code>React</code>靠<code>hook</code>的调用顺序来知道<code>state</code>和<code>useState</code>的对应关系，所以不能在条件/循环中调用<code>hook</code></p>

      <h1>
        <span class="prefix"></span>
        <span class="content">useEffect 的执行时机</span>
        <span class="suffix"></span>
      </h1>
    <p><code>useEffect</code>会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">useCallback 和 useMemo</span>
        <span class="suffix"></span>
      </h1>
    <pre><code class="hljs language-js"><span class="hljs-title function_">useCallback</span>(fn, deps) == <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(), deps);
</code></pre>

      <h1>
        <span class="prefix"></span>
        <span class="content">使用过多 hook 后性能问题</span>
        <span class="suffix"></span>
      </h1>
    <p>hook 不会因为在渲染时创建函数而变慢，在现代浏览器中闭包和类的原始性能只有在极端场景下才会有明显的差别</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">useState 惰性求值</span>
        <span class="suffix"></span>
      </h1>
    <p>如果初始化<code>state</code>需要通过复杂计算获得，那么可以传入一个函数，在函数中计算并返回初始的<code>state</code>，此函数只在初始渲染时被调用</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">calState</span>());
</code></pre>

      <h1>
        <span class="prefix"></span>
        <span class="content">hook 使用必须要遵循的规则</span>
        <span class="suffix"></span>
      </h1>
    <p>在函数值组件主体内（指 React 渲染阶段）改变<code>DOM</code>、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。使用<code>useEffect</code>完成副作用操作赋值给<code>useEffect</code>的函数会在组件渲染到屏幕后执行。</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">useRef</span>
        <span class="suffix"></span>
      </h1>
    <p>通过<code>useRef</code>来拥有一个在<strong>所有帧</strong>中<strong>共享</strong>的变量</p>

      <h1>
        <span class="prefix"></span>
        <span class="content">useReducer</span>
        <span class="suffix"></span>
      </h1>
    <ul>
<li><p>state 逻辑较复杂且包含多个子值</p>
</li>
<li><p>下一个 state 依赖于之前的 state</p>
</li>
</ul>

      <h1>
        <span class="prefix"></span>
        <span class="content">useImperativeHandle</span>
        <span class="suffix"></span>
      </h1>
    <p>简单来讲: useImperativeHandle 赋予函数式组件使用 ref 的特权, 通常和 forwardRef 成对出现,</p>
<p>使用方式:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> { useImperativeHandle, forwardRef, useRef } = <span class="hljs-title class_">React</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Modal</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">open</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;open&quot;</span>);
  };
  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> ({
    open,
  }));

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>modal<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;
});

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> modalRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Modal</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{modalRef}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> modalRef.current.open()}&gt;click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#app&quot;</span>));
root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);
</code></pre>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React.js学习-使用内置hook","tags":["React.js学习","hook"],"categories":"React.js","description":"# 什么是 hook\n\n组件自身能够通过某种机制再触发状态的变更并且引起**re-render**，而这种“机制”就是 Hooks！\n\n# useEffect\n\n- 默认情况下，它在第一次渲染之后和每次更新之后都会执行。React 确保了每次运行`effect`的同时，DOM 都已经更新完毕\n\n- 每次重新渲染，都会生成新的`effect`，替换掉之前的。某种意义上讲，`effect`更像是渲染","createDate":"2020-09-07 10:48:54","updateDate":"2022-05-11 22:19:50","body":"\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e什么是 hook\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e组件自身能够通过某种机制再触发状态的变更并且引起\u003cstrong\u003ere-render\u003c/strong\u003e，而这种“机制”就是 Hooks！\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseEffect\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cul\u003e\n\u003cli\u003e\u003cp\u003e默认情况下，它在第一次渲染之后和每次更新之后都会执行。React 确保了每次运行\u003ccode\u003eeffect\u003c/code\u003e的同时，DOM 都已经更新完毕\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e每次重新渲染，都会生成新的\u003ccode\u003eeffect\u003c/code\u003e，替换掉之前的。某种意义上讲，\u003ccode\u003eeffect\u003c/code\u003e更像是渲染结果的一部分 —— 每个\u003ccode\u003eeffect\u003c/code\u003e “属于”一次特定的渲染。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e每个\u003ccode\u003eeffect\u003c/code\u003e都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。他们都属于\u003ccode\u003eeffect\u003c/code\u003e的一部分\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e自定义 hook 的 state 是否共享\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e在两个组件中使用相同的\u003ccode\u003ehook\u003c/code\u003e不会共享\u003ccode\u003estate\u003c/code\u003e，自定义\u003ccode\u003ehook\u003c/code\u003e是一种重用状态逻辑的机制，所以每次使用自定义\u003ccode\u003ehook\u003c/code\u003e时其中的所有\u003ccode\u003estate\u003c/code\u003e和副作用是完全隔离的\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003ehook 原理\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e初次渲染的时候，按照 useState，useEffect 等 hook 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中。\u003c/p\u003e\n\u003cp\u003e更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003estate 和 useState 的对应关系\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e\u003ccode\u003eReact\u003c/code\u003e靠\u003ccode\u003ehook\u003c/code\u003e的调用顺序来知道\u003ccode\u003estate\u003c/code\u003e和\u003ccode\u003euseState\u003c/code\u003e的对应关系，所以不能在条件/循环中调用\u003ccode\u003ehook\u003c/code\u003e\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseEffect 的执行时机\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e\u003ccode\u003euseEffect\u003c/code\u003e会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseCallback 和 useMemo\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(fn, deps) == \u003cspan class=\"hljs-title function_\"\u003euseMemo\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(), deps);\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e使用过多 hook 后性能问题\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003ehook 不会因为在渲染时创建函数而变慢，在现代浏览器中闭包和类的原始性能只有在极端场景下才会有明显的差别\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseState 惰性求值\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e如果初始化\u003ccode\u003estate\u003c/code\u003e需要通过复杂计算获得，那么可以传入一个函数，在函数中计算并返回初始的\u003ccode\u003estate\u003c/code\u003e，此函数只在初始渲染时被调用\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalState\u003c/span\u003e());\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003ehook 使用必须要遵循的规则\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e在函数值组件主体内（指 React 渲染阶段）改变\u003ccode\u003eDOM\u003c/code\u003e、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。使用\u003ccode\u003euseEffect\u003c/code\u003e完成副作用操作赋值给\u003ccode\u003euseEffect\u003c/code\u003e的函数会在组件渲染到屏幕后执行。\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseRef\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e通过\u003ccode\u003euseRef\u003c/code\u003e来拥有一个在\u003cstrong\u003e所有帧\u003c/strong\u003e中\u003cstrong\u003e共享\u003c/strong\u003e的变量\u003c/p\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseReducer\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cul\u003e\n\u003cli\u003e\u003cp\u003estate 逻辑较复杂且包含多个子值\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e下一个 state 依赖于之前的 state\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseImperativeHandle\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e简单来讲: useImperativeHandle 赋予函数式组件使用 ref 的特权, 通常和 forwardRef 成对出现,\u003c/p\u003e\n\u003cp\u003e使用方式:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { useImperativeHandle, forwardRef, useRef } = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eModal\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003eforwardRef\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprops, ref\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u0026gt; {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;open\u0026quot;\u003c/span\u003e);\n  };\n  \u003cspan class=\"hljs-title function_\"\u003euseImperativeHandle\u003c/span\u003e(ref, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e ({\n    open,\n  }));\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003emodal\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n});\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e modalRef = \u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eModal\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{modalRef}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u0026gt;\u003c/span\u003e modalRef.current.open()}\u0026gt;click me\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateRoot\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;#app\u0026quot;\u003c/span\u003e));\nroot.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"React.js学习-使用内置hook"},"buildId":"CZ6Uu2i9da2HCumDfSdj1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>