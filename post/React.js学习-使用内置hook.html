<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-React.js学习-使用内置hook</title><meta name="next-head-count" content="3"/><link rel="preload" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" as="style"/><link rel="stylesheet" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/next-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/next-blog/_next/static/chunks/webpack-cf185e4b59cdddcf.js" defer=""></script><script src="/next-blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/next-blog/_next/static/chunks/main-1c9e93b8392c1bc9.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/next-blog/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/post/%5Btitle%5D-406bad804ceffd1d.js" defer=""></script><script src="/next-blog/_next/static/ppbuy0Y8ZmHxlPJAAgrU4/_buildManifest.js" defer=""></script><script src="/next-blog/_next/static/ppbuy0Y8ZmHxlPJAAgrU4/_ssgManifest.js" defer=""></script><script src="/next-blog/_next/static/ppbuy0Y8ZmHxlPJAAgrU4/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/next-blog">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/next-blog/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">React.js学习-使用内置hook</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-09-07 10:48:54</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h1 id="什么是-hook">什么是 hook</h1>
<p>组件自身能够通过某种机制再触发状态的变更并且引起<strong>re-render</strong>，而这种“机制”就是Hooks！</p>
<h1 id="useeffect">useEffect</h1>
<ul>
<li><p>默认情况下，它在第一次渲染之后和每次更新之后都会执行。React确保了每次运行<code>effect</code>的同时，DOM都已经更新完毕</p>
</li>
<li><p>每次重新渲染，都会生成新的<code>effect</code>，替换掉之前的。某种意义上讲，<code>effect</code>更像是渲染结果的一部分 —— 每个<code>effect</code> “属于”一次特定的渲染。</p>
</li>
<li><p>每个<code>effect</code>都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。他们都属于<code>effect</code>的一部分</p>
</li>
</ul>
<h1 id="自定义hook的state是否共享">自定义hook的state是否共享</h1>
<p>在两个组件中使用相同的<code>hook</code>不会共享<code>state</code>，自定义<code>hook</code>是一种重用状态逻辑的机制，所以每次使用自定义<code>hook</code>时其中的所有<code>state</code>和副作用是完全隔离的</p>
<h1 id="hook原理">hook原理</h1>
<p>初次渲染的时候，按照 useState，useEffect等hook的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中。</p>
<p>更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。</p>
<h1 id="state和usestate的对应关系">state和useState的对应关系</h1>
<p><code>React</code>靠<code>hook</code>的调用顺序来知道<code>state</code>和<code>useState</code>的对应关系，所以不能在条件/循环中调用<code>hook</code></p>
<h1 id="useeffect的执行时机">useEffect的执行时机</h1>
<p><code>useEffect</code>会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行</p>
<h1 id="usecallback和usememo">useCallback和useMemo</h1>
<pre><code class="hljs language-js"><span class="hljs-title function_">useCallback</span>(fn, deps) == <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(), deps)
</code></pre>
<h1 id="使用过多hook后性能问题">使用过多hook后性能问题</h1>
<p>hook不会因为在渲染时创建函数而变慢，在现代浏览器中闭包和类的原始性能只有在极端场景下才会有明显的差别</p>
<h1 id="usestate惰性求值">useState惰性求值</h1>
<p>如果初始化<code>state</code>需要通过复杂计算获得，那么可以传入一个函数，在函数中计算并返回初始的<code>state</code>，此函数只在初始渲染时被调用</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">calState</span>())
</code></pre>
<h1 id="hook使用必须要遵循的规则">hook使用必须要遵循的规则</h1>
<p>在函数值组件主体内（指React渲染阶段）改变<code>DOM</code>、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的bug并破坏UI的一致性。使用<code>useEffect</code>完成副作用操作赋值给<code>useEffect</code>的函数会在组件渲染到屏幕后执行。</p>
<h1 id="useref">useRef</h1>
<p>通过<code>useRef</code>来拥有一个在<strong>所有帧</strong>中<strong>共享</strong>的变量</p>
<h1 id="usereducer">useReducer</h1>
<ul>
<li><p>state逻辑较复杂且包含多个子值</p>
</li>
<li><p>下一个 state 依赖于之前的 state</p>
</li>
</ul>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React.js学习-使用内置hook","tags":["React.js学习","hook"],"categories":"React.js","description":"# 什么是 hook\n\n组件自身能够通过某种机制再触发状态的变更并且引起**re-render**，而这种“机制”就是Hooks！\n\n# useEffect\n\n- 默认情况下，它在第一次渲染之后和每次更新之后都会执行。React确保了每次运行`effect`的同时，DOM都已经更新完毕\n\n- 每次重新渲染，都会生成新的`effect`，替换掉之前的。某种意义上讲，`effect`更像是渲染结果","createDate":"2020-09-07 10:48:54","updateDate":"2021-01-17 09:59:50","body":"\u003ch1 id=\"什么是-hook\"\u003e什么是 hook\u003c/h1\u003e\n\u003cp\u003e组件自身能够通过某种机制再触发状态的变更并且引起\u003cstrong\u003ere-render\u003c/strong\u003e，而这种“机制”就是Hooks！\u003c/p\u003e\n\u003ch1 id=\"useeffect\"\u003euseEffect\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e默认情况下，它在第一次渲染之后和每次更新之后都会执行。React确保了每次运行\u003ccode\u003eeffect\u003c/code\u003e的同时，DOM都已经更新完毕\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e每次重新渲染，都会生成新的\u003ccode\u003eeffect\u003c/code\u003e，替换掉之前的。某种意义上讲，\u003ccode\u003eeffect\u003c/code\u003e更像是渲染结果的一部分 —— 每个\u003ccode\u003eeffect\u003c/code\u003e “属于”一次特定的渲染。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e每个\u003ccode\u003eeffect\u003c/code\u003e都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。他们都属于\u003ccode\u003eeffect\u003c/code\u003e的一部分\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"自定义hook的state是否共享\"\u003e自定义hook的state是否共享\u003c/h1\u003e\n\u003cp\u003e在两个组件中使用相同的\u003ccode\u003ehook\u003c/code\u003e不会共享\u003ccode\u003estate\u003c/code\u003e，自定义\u003ccode\u003ehook\u003c/code\u003e是一种重用状态逻辑的机制，所以每次使用自定义\u003ccode\u003ehook\u003c/code\u003e时其中的所有\u003ccode\u003estate\u003c/code\u003e和副作用是完全隔离的\u003c/p\u003e\n\u003ch1 id=\"hook原理\"\u003ehook原理\u003c/h1\u003e\n\u003cp\u003e初次渲染的时候，按照 useState，useEffect等hook的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中。\u003c/p\u003e\n\u003cp\u003e更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。\u003c/p\u003e\n\u003ch1 id=\"state和usestate的对应关系\"\u003estate和useState的对应关系\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eReact\u003c/code\u003e靠\u003ccode\u003ehook\u003c/code\u003e的调用顺序来知道\u003ccode\u003estate\u003c/code\u003e和\u003ccode\u003euseState\u003c/code\u003e的对应关系，所以不能在条件/循环中调用\u003ccode\u003ehook\u003c/code\u003e\u003c/p\u003e\n\u003ch1 id=\"useeffect的执行时机\"\u003euseEffect的执行时机\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003euseEffect\u003c/code\u003e会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行\u003c/p\u003e\n\u003ch1 id=\"usecallback和usememo\"\u003euseCallback和useMemo\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(fn, deps) == \u003cspan class=\"hljs-title function_\"\u003euseMemo\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(), deps)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"使用过多hook后性能问题\"\u003e使用过多hook后性能问题\u003c/h1\u003e\n\u003cp\u003ehook不会因为在渲染时创建函数而变慢，在现代浏览器中闭包和类的原始性能只有在极端场景下才会有明显的差别\u003c/p\u003e\n\u003ch1 id=\"usestate惰性求值\"\u003euseState惰性求值\u003c/h1\u003e\n\u003cp\u003e如果初始化\u003ccode\u003estate\u003c/code\u003e需要通过复杂计算获得，那么可以传入一个函数，在函数中计算并返回初始的\u003ccode\u003estate\u003c/code\u003e，此函数只在初始渲染时被调用\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalState\u003c/span\u003e())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"hook使用必须要遵循的规则\"\u003ehook使用必须要遵循的规则\u003c/h1\u003e\n\u003cp\u003e在函数值组件主体内（指React渲染阶段）改变\u003ccode\u003eDOM\u003c/code\u003e、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的bug并破坏UI的一致性。使用\u003ccode\u003euseEffect\u003c/code\u003e完成副作用操作赋值给\u003ccode\u003euseEffect\u003c/code\u003e的函数会在组件渲染到屏幕后执行。\u003c/p\u003e\n\u003ch1 id=\"useref\"\u003euseRef\u003c/h1\u003e\n\u003cp\u003e通过\u003ccode\u003euseRef\u003c/code\u003e来拥有一个在\u003cstrong\u003e所有帧\u003c/strong\u003e中\u003cstrong\u003e共享\u003c/strong\u003e的变量\u003c/p\u003e\n\u003ch1 id=\"usereducer\"\u003euseReducer\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003estate逻辑较复杂且包含多个子值\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e下一个 state 依赖于之前的 state\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"React.js学习-使用内置hook"},"buildId":"ppbuy0Y8ZmHxlPJAAgrU4","assetPrefix":"/next-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>