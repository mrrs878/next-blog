<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-(翻译)创建你自己的React</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/cd72816920092dcb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd72816920092dcb.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/_q5ru5NemgZT2swXpl15Q/_buildManifest.js" defer=""></script><script src="/_next/static/_q5ru5NemgZT2swXpl15Q/_ssgManifest.js" defer=""></script><script src="/_next/static/_q5ru5NemgZT2swXpl15Q/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">(翻译)创建你自己的React</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-11-02 14:25:18</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2020-11-11 15:00:53</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><blockquote>
<p>原文链接:<a href="https://pomb.us/build-your-own-react/">https://pomb.us/build-your-own-react/</a></p>
</blockquote>

      <h1>
        <span class="prefix"></span>
        <span class="content">Build your own React</span>
        <span class="suffix"></span>
      </h1>
    <p>我们将从头开始重写React。 一步步。 遵循真实的React代码中的架构，但没有所有的优化和非必要的功能。</p>
<p>如果您阅读过<a href="https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5">我以前的任何“构建自己的React”文章</a>，不同之处在于该文章基于React 16.8，因此我们现在可以使用<code>hook</code>并删除所有与<code>class</code>相关的代码。</p>
<p>您可以在旧博客文章中找到历史记录，并在<a href="https://github.com/pomber/didact">Didact仓库</a>中找到代码。 还有一个演讲涉及相同的内容。</p>
<p>以下这些都是我们将一一添加到我们的React版本中的内容：</p>
<ul>
<li>第一步: <code>createElement</code> 函数</li>
<li>第二步: <code>render</code> 函数</li>
<li>第三步: Concurrent Mode</li>
<li>第四步: Fibers</li>
<li>第五步: Render and Commit Phases</li>
<li>第六步: Reconciliation</li>
<li>第七步: 函数式组件</li>
<li>第八步: Hooks</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">第零步</span>
        <span class="suffix"></span>
      </h2>
    <p>如果您已经对React，JSX和DOM节点的工作方式有了很好的了解，则可以跳过此步骤。首先让我们回顾一些基本概念，我们将使用只有三行代码的React应用程序：第一个定义一个React节点，下一个从DOM获取一个节点，最后一个将React节点渲染到容器中。然后，我们会删除所有特定于React的代码将其替换为原始JavaScript。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>)
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(element, container)
</code></pre>
<p>在第一行中，我们使用JSX定义了节点。 它不是有效的JavaScript，因此要用原生JS取代它。通过Babel等构建工具，JSX转换为JS。 转换通常很简单：使用对<code>createElement</code>的调用来替换标签内的代码，并将标签<code>type</code>、<code>props</code>、<code>children</code>作为参数传递。<code>React.createElement</code>根据其参数创建一个对象，除了一些验证之外，这就是全部。 因此，我们可以安全地将函数调用替换为其输出。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>

👇

<span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
  <span class="hljs-string">&quot;h1&quot;</span>,
  { <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;foo&quot;</span> },
  <span class="hljs-string">&quot;Hello&quot;</span>
)
</code></pre>
<p>这就是一个节点，一个具有两个属性的对象：<code>type</code>和<code>props</code>（嗯，<a href="https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111">它有更多的属性</a>，但是我们只关心这两个属性）。<code>type</code>是一个字符串，用于指定我们要创建的DOM节点的类型，它是您要创建HTML节点时传递给<code>document.createElement</code>的<code>tagName</code>。 它也可以是一个函数，但我们将其留给步骤VII。<code>props</code>是另一个对象，它具有JSX属性中的所有键和值。 它还有一个特殊的属性：<code>children</code>。在这种情况下，<code>children</code>是字符串，但通常是包含更多节点的数组（这就是为什么节点也是树的原因）。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> element = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;h1&quot;</span>,
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;foo&quot;</span>,
    <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;Hello&quot;</span>,
  },
}
</code></pre>
<p>我们需要替换的另一部分React代码是对<code>ReactDOM.render</code>的调用。<code>render</code>是React更新DOM的地方，现在用我们自己的代码进行操作。</p>
<p>首先，我们使用节点<code>type</code>（在本例中为<code>h1</code>）创建一个<code>node*</code>。然后，我们将所有节点属性分配给该节点。 这里只有一个<code>title</code>。*为避免混淆，我将使用<code>element</code>来指代React节点，并使用<code>node</code>来指代DOM节点。</p>
<p>然后，我们为<code>children</code>创建节点。 我们只有一个字符串作为<code>children</code>，因此我们创建了一个文本节点。使用<code>textNode</code>而不是设置<code>innerText</code>将允许我们以后以相同的方式对待所有节点。另请注意，我们像设置<code>h1</code>标题一样设置<code>nodeValue</code>，就像字符串中带有<code>props: {nodeValue: &quot;hello&quot;}</code>。最后，我们将<code>textNode</code>添加到<code>h1</code>并将<code>h1</code>添加到<code>container</code>。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> element = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;h1&quot;</span>,
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;foo&quot;</span>,
    <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;Hello&quot;</span>,
  },
}

<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>)

<span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(element.<span class="hljs-property">type</span>)
node[<span class="hljs-string">&quot;title&quot;</span>] = element.<span class="hljs-property">props</span>.<span class="hljs-property">title</span>

<span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&quot;&quot;</span>)
text[<span class="hljs-string">&quot;nodeValue&quot;</span>] = element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>

node.<span class="hljs-title function_">appendChild</span>(text)
container.<span class="hljs-title function_">appendChild</span>(node)
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">第一步: createElement 函数</span>
        <span class="suffix"></span>
      </h2>
    <p>现在，让我们切换到另一个App：自己实现的简易React。</p>
<p>首先，从编写<code>createElement</code>开始，将JSX转换为JS。正如在上一步中看到的，<code>element</code>是具有类型和属性的对象。<code>createElement</code>唯一需要做的就是创建该对象。</p>
<p>因为<code>children</code>也可以包含原始数据类型，比如字符串或数字，所以对不是<code>object</code>的<code>child</code>创建特殊节点类型：<code>TEXT_ELEMENT</code>。这样做是因为可以简化代码。对于我们的库，我更喜欢简单而不是高性能代码。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextElement</span>(<span class="hljs-params">text</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;TEXT_ELEMENT&quot;</span>,
    <span class="hljs-attr">props</span>: {
      <span class="hljs-attr">nodeValue</span>: text,
      <span class="hljs-attr">children</span>: [],
    },
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, props, ...children</span>) {
  <span class="hljs-keyword">return</span> {
    type,
    <span class="hljs-attr">props</span>: {
      ...props,
      <span class="hljs-attr">children</span>: children.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> child === <span class="hljs-string">&quot;object&quot;</span>
        ? child
        : <span class="hljs-title function_">createTextElement</span>(child)
      ),
    },
  }
}
</code></pre>
<p>目前Babel仍然使用<code>React.createElement</code>，为了替换它，让我们给自己的库起个名字。我们需要一个听起来像React的名字，但也暗示了它的教学目的，我们叫它<code>Didact</code>。</p>
<p>让我们使用<code>/** @jsx Didact.createElement */</code>来告诉Babel使用我们自己的<code>createElement</code>来转换jsx代码：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/** <span class="hljs-doctag">@jsx</span> Didact.createElement */</span>
<span class="hljs-keyword">const</span> element = (
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>bar<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">b</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
)
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">第二步：redner 函数</span>
        <span class="suffix"></span>
      </h2>
    <p>首先使用element的<code>type</code>创建DOM节点，然后将新element添加到<code>container</code>中。然后对每个<code>child</code>递归调用<code>render</code>：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">element, container</span>) {
  <span class="hljs-keyword">const</span> dom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(element.<span class="hljs-property">type</span>);

  element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-title function_">render</span>(child, dom))

  container.<span class="hljs-title function_">appendChild</span>(dom);
}
</code></pre>
<p>其次，我们还需要处理文本节点，如果element类型为<code>TEXT_ELEMENT</code>，我们将创建文本节点而不是普通节点：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">element, container</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">const</span> dom = element.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;TEXT_ELEMENT&quot;</span>
    ? <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&quot;&quot;</span>)
    : <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElmenet</span>(element.<span class="hljs-property">type</span>);
  <span class="hljs-comment">//...</span>
}
</code></pre>
<p>最后，将<code>props</code>分配给element：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">element, container</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">isProperty</span> = key =&gt; key === <span class="hljs-string">&quot;children&quot;</span>;
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownkeys</span>(element.<span class="hljs-property">props</span>)
    .<span class="hljs-title function_">filter</span>(isProperty)
    .<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> dom[name] = element.<span class="hljs-property">props</span>[name]);
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>这样的话，我们就有了一个可以将JSX呈现到DOM的库：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextElement</span>(<span class="hljs-params">text</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;TEXT_ELEMENT&quot;</span>,
    <span class="hljs-attr">props</span>: {
      <span class="hljs-attr">nodeValue</span>: text,
      <span class="hljs-attr">children</span>: []
    }
  };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, props, ...children</span>) {
  <span class="hljs-keyword">return</span> {
    type,
    <span class="hljs-attr">props</span>: {
      ...props,
      <span class="hljs-attr">children</span>: children.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span>
        <span class="hljs-keyword">typeof</span> child === <span class="hljs-string">&quot;object&quot;</span> ? child : <span class="hljs-title function_">createTextElement</span>(child)
      )
    }
  };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">element, container</span>) {
  <span class="hljs-keyword">const</span> dom =
    element.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;TEXT_ELEMENT&quot;</span>
      ? <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&quot;&quot;</span>)
      : <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(element.<span class="hljs-property">type</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">isProperty</span> = (<span class="hljs-params">key</span>) =&gt; key !== <span class="hljs-string">&quot;children&quot;</span>;
  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(element.<span class="hljs-property">props</span>)
    .<span class="hljs-title function_">filter</span>(isProperty)
    .<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> (dom[name] = element.<span class="hljs-property">props</span>[name]));

  element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-title function_">render</span>(child, dom));

  container.<span class="hljs-title function_">appendChild</span>(dom);
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Didact</span> = {
  createElement,
  render
};

<span class="hljs-comment">/** <span class="hljs-doctag">@jsx</span> Didact.createElement */</span>
<span class="hljs-keyword">const</span> element = (
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello STEP1-STEP2<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#step1&quot;</span>);

<span class="hljs-title class_">Didact</span>.<span class="hljs-title function_">render</span>(element, container);
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">第三步Concurrent Mode</span>
        <span class="suffix"></span>
      </h2>
    <p>在开始添加更多代码之前，我们需要重构。</p>
<p>上面的递归调用存在问题。开始渲染后，直到渲染完完整的element树，我们才会停止。 如果element树很大，则可能会阻塞主线程太长时间。 那么如果浏览器需要执行高优先级的操作（例如处理用户输入或保持动画流畅），则它必须等到渲染完成为止。因此，我们将工作分成几个小部分，在完成每个单元后，如果需要执行其他任何操作，我们将让浏览器中断渲染。</p>
<p>我们使用<code>requestIdleCallback</code>进行循环。 您可以将<code>requestIdleCallback</code>看作<code>setTimeout</code>，但是浏览器将在主线程空闲时运行回调，而不是告诉它何时运行。React不再使用<code>requestIdleCallback</code>，现在它使用scheduler package。 但是对于此用例，它在概念上是相同的。<code>requestIdleCallback</code>还为我们提供了<code>deadline</code>参数。 我们可以使用它来检查浏览器需要再次控制之前有多少时间。</p>
<p>要开始使用循环，我们需要设置第一个工作单元，然后编写一个<code>performUnitOfWork</code>函数，该函数不仅执行工作，还返回下一个工作单元。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">第四步Fiber</span>
        <span class="suffix"></span>
      </h2>
    <p>要组织工作单元，我们需要一个数据结构--Fiber树。我们将为每个元素分配一根Fiber，并且每个Fiber将成为一个工作单元。</p>
<p>假如我们要渲染如下的element树，那么Fiber树就如下所示：</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Didact</span>.<span class="hljs-title function_">render</span>(
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
  container
)
</code></pre>
<p><img src="https://pomb.us/static/a88a3ec01855349c14302f6da28e2b0c/ac667/fiber1.png" alt=""></p>
<p>在render函数中，我们将创建root Fiber并将其设置为<code>nextUnitOfWork</code>。 剩下的工作将在<code>performUnitOfWork</code>函数上进行，我们将为每个Fiber做三件事：</p>
<ol>
<li>将element添加到DOM</li>
<li>为element的子代创建Filber</li>
<li>选择下一个工作单元</li>
</ol>
<p>该数据结构的目标之一是使查找下一个工作单元变得容易。 这就是为什么每个Fiber都链接到其第一个子节点、下一个兄弟节点和父节点。</p>
<ul>
<li>当我们完成对当前Fiber的工作时，如果有child，那么该child对应的Fiber将是下一个工作单元。在我们的示例中，当我们完成div Fiber的工作时，下一个工作单元将是h1 Fiber。</li>
<li>如果当前Fiber没有child，我们将其sibling作为下一个工作单元。例如，p Fiber没有child，因此我们在完成当前之后下一个工作单元将是h1。</li>
<li>如果当前Fiber既没有child也没有sibling，那么我们去“uncle”：父母的兄弟节点。 就像示例中的a和h2 Fiber一样。</li>
<li>如果parent没有sibling，我们会不断检查parent，直到找到有sibling的parent，或者直到找到root。 如果到达root，则意味着我们已经完成了此渲染的所有工作。</li>
</ul>
<p>现在，让我们开始写代码。</p>
<p>首先，更改<code>render</code>函数并创建<code>createDom</code>函数</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">element, container</span>) {
  nextUnitOfWork = {
    <span class="hljs-attr">dom</span>: container,
    <span class="hljs-attr">props</span>: {
      <span class="hljs-attr">children</span>: [element],
    },
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createDom</span>(<span class="hljs-params">fiber</span>) {
  <span class="hljs-keyword">const</span> dom =
    fiber.<span class="hljs-property">type</span> == <span class="hljs-string">&quot;TEXT_ELEMENT&quot;</span>
      ? <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&quot;&quot;</span>)
      : <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(fiber.<span class="hljs-property">type</span>)
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">isProperty</span> = key =&gt; key !== <span class="hljs-string">&quot;children&quot;</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(fiber.<span class="hljs-property">props</span>)
    .<span class="hljs-title function_">filter</span>(isProperty)
    .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
      dom[name] = fiber.<span class="hljs-property">props</span>[name]
    })
  <span class="hljs-keyword">return</span> dom
}
</code></pre>
<p>然后，当浏览器准备就绪时，它将调用我们的<code>workLoop</code>，我们将从<code>root</code>开始执行渲染。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">deadline</span>) {
  <span class="hljs-keyword">let</span> shouldYield = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) {
    nextUnitOfWork = <span class="hljs-title function_">performUnitOfWork</span>(
      nextUnitOfWork
    )
    shouldYield = deadline.<span class="hljs-title function_">timeRemaining</span>() &lt; <span class="hljs-number">1</span>
  }
  <span class="hljs-title function_">requestIdleCallback</span>(workLoop)
}
</code></pre>
<p>首先，我们创建一个新node并将其添加到DOM。我们在<code>fibre.dom</code>属性中跟踪DOM节点。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">fiber</span>) {
  <span class="hljs-keyword">if</span> (!fiber.<span class="hljs-property">dom</span>) {
    fiber.<span class="hljs-property">dom</span> = <span class="hljs-title function_">createDom</span>(fiber)
  }
  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">parent</span>) {
    fiber.<span class="hljs-property">parent</span>.<span class="hljs-property">dom</span>.<span class="hljs-title function_">appendChild</span>(fiber.<span class="hljs-property">dom</span>)
  }
  <span class="hljs-comment">// TODO create new fibers</span>
  <span class="hljs-comment">// TODO return next unit of work</span>
}
</code></pre>
<p>然后对每个<code>child</code>创建Fiber</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> elements = fiber.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>
  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> prevSibling = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">while</span> (index &lt; elements.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> element = elements[index]
    <span class="hljs-keyword">const</span> newFiber = {
      <span class="hljs-attr">type</span>: element.<span class="hljs-property">type</span>,
      <span class="hljs-attr">props</span>: element.<span class="hljs-property">props</span>,
      <span class="hljs-attr">parent</span>: fiber,
      <span class="hljs-attr">dom</span>: <span class="hljs-literal">null</span>,
    }
  }
</code></pre>
<p>然后将其添加到Fiber树中，将其设置为<code>child</code>还是<code>sibing</code>，具体取决于它是否是第一个child。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
      fiber.<span class="hljs-property">child</span> = newFiber
    } <span class="hljs-keyword">else</span> {
      prevSibling.<span class="hljs-property">sibling</span> = newFiber
    }
}
prevSibling = newFiber
index++
</code></pre>
<p>最后，我们按照child ☞ sibling ☞ uncle来选择下一工作单元。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">child</span>) {
  <span class="hljs-keyword">return</span> fiber.<span class="hljs-property">child</span>
}
<span class="hljs-keyword">let</span> nextFiber = fiber
<span class="hljs-keyword">while</span> (nextFiber) {
  <span class="hljs-keyword">if</span> (nextFiber.<span class="hljs-property">sibling</span>) {
    <span class="hljs-keyword">return</span> nextFiber.<span class="hljs-property">sibling</span>
  }
  nextFiber = nextFiber.<span class="hljs-property">parent</span>
}
</code></pre>
<p>完整的代码如下所示：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">fiber</span>) {
  <span class="hljs-keyword">if</span> (!fiber.<span class="hljs-property">dom</span>) {
    fiber.<span class="hljs-property">dom</span> = <span class="hljs-title function_">createDom</span>(fiber)
  }

  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">parent</span>) {
    fiber.<span class="hljs-property">parent</span>.<span class="hljs-property">dom</span>.<span class="hljs-title function_">appendChild</span>(fiber.<span class="hljs-property">dom</span>)
  }

  <span class="hljs-keyword">const</span> elements = fiber.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>
  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> prevSibling = <span class="hljs-literal">null</span>

  <span class="hljs-keyword">while</span> (index &lt; elements.<span class="hljs-property">length</span>) {
    <span class="hljs-keyword">const</span> element = elements[index]

    <span class="hljs-keyword">const</span> newFiber = {
      <span class="hljs-attr">type</span>: element.<span class="hljs-property">type</span>,
      <span class="hljs-attr">props</span>: element.<span class="hljs-property">props</span>,
      <span class="hljs-attr">parent</span>: fiber,
      <span class="hljs-attr">dom</span>: <span class="hljs-literal">null</span>,
    }

    <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
      fiber.<span class="hljs-property">child</span> = newFiber
    } <span class="hljs-keyword">else</span> {
      prevSibling.<span class="hljs-property">sibling</span> = newFiber
    }

    prevSibling = newFiber
    index++
  }

  <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">child</span>) {
    <span class="hljs-keyword">return</span> fiber.<span class="hljs-property">child</span>
  }
  <span class="hljs-keyword">let</span> nextFiber = fiber
  <span class="hljs-keyword">while</span> (nextFiber) {
    <span class="hljs-keyword">if</span> (nextFiber.<span class="hljs-property">sibling</span>) {
      <span class="hljs-keyword">return</span> nextFiber.<span class="hljs-property">sibling</span>
    }
    nextFiber = nextFiber.<span class="hljs-property">parent</span>
  }
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">提交更改</span>
        <span class="suffix"></span>
      </h2>
    <p>我们还有一个问题。每次处理一个元素时，我们都会向DOM添加一个新节点。而且，请记住，浏览器可能会在我们完成整个树的渲染之前中断我们的工作。在这种情况下，用户将看到一个不完整的UI。我们不想这样。</p>
<p>因此，我们需要从<code>performUnitOfWork</code>里删除改变DOM的部分。相反，我们将跟踪Fiber tree。我们称它为<code>wipRoot</code>。一旦我们完成了所有的工作(我们知道它是因为没有下一个工作单元)，我们就将整个Fiber tree提交给DOM。我们在<code>commitRoot</code>函数中完成。在这里，我们递归地将所有节点追加到dom。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">Reconciliation</span>
        <span class="suffix"></span>
      </h2>
    <p>到目前为止，我们只向DOM添加了一些东西，那么更新或删除节点呢? </p>
<p>这就是我们现在要做的，我们需要将<code>render</code>函数接收到的元素与提交给DOM的最后一个Fiber tree进行比较。因此，在完成<code>commit</code>之后，我们需要保存对<strong>最后一个提交到DOM的Fiber tree</strong>的引用。我们称之为<code>currentRoot</code>。我们还在每Fiber中加入了<code>alternate</code>, 此属性是到旧Fiber的链接，即我们在上一个提交阶段提交给DOM的Fiber。</p>
<p>现在让我们从创建新Fiber的<code>performUnitOfWork</code>函数中提取代码到<code>reconcileChildren</code> 。在这里，我们将<code>reconcile</code>旧的fibers和新元素。我们同时遍历旧Fiber tree(<code>wipFiber.alternate</code>)的子元素和我们想要reconciliation的元素数组。如果我们忽略同时遍历数组和链表所需的所有样板文件，那么我们只剩下while中最重要的部分:oldFiber和element。元素是我们想要渲染到DOM的东西，而oldFiber是我们上次渲染的东西。我们需要比较它们，看看是否需要对DOM进行更改。</p>
<p>为了比较它们，我们使用类型:</p>
<ul>
<li>如果旧的Fiber和新元素具有相同的类型，我们可以保留DOM节点，并使用新的道具更新它</li>
<li>如果类型不同，并且有一个新元素，这意味着我们需要创建一个新的DOM节点</li>
<li>如果类型不同，并且有一个旧的光纤，我们需要删除旧的节点</li>
</ul>
<p>这里React也使用key，这样可以更好的<code>reconcile</code>。例如，它检测子元素在元素数组中的位置发生了变化。</p>
<p>当旧Fiber和元素具有相同的类型时，我们创建一个新Fiber，使DOM节点与旧Fiber保持一致，使props与element保持一致。我们还向Fiber 添加了一个新属性:<code>effectTag</code>。我们将在稍后的<code>commit</code>阶段使用此属性。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> sameType =
      oldFiber &amp;&amp;
      element &amp;&amp;
      element.<span class="hljs-property">type</span> == oldFiber.<span class="hljs-property">type</span>
<span class="hljs-keyword">if</span> (sameType) {
  newFiber = {
    <span class="hljs-attr">type</span>: oldFiber.<span class="hljs-property">type</span>,
    <span class="hljs-attr">props</span>: element.<span class="hljs-property">props</span>,
    <span class="hljs-attr">dom</span>: oldFiber.<span class="hljs-property">dom</span>,
    <span class="hljs-attr">parent</span>: wipFiber,
    <span class="hljs-attr">alternate</span>: oldFiber,
    <span class="hljs-attr">effectTag</span>: <span class="hljs-string">&quot;UPDATE&quot;</span>,
  }
}
</code></pre>
<p>对于element需要一个新DOM节点的情况，我们用<code>PLACEMENT</code>标记标记新Fiber。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (element &amp;&amp; !sameType) {
  newFiber = {
    <span class="hljs-attr">type</span>: element.<span class="hljs-property">type</span>,
    <span class="hljs-attr">props</span>: element.<span class="hljs-property">props</span>,
    <span class="hljs-attr">dom</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">parent</span>: wipFiber,
    <span class="hljs-attr">alternate</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">effectTag</span>: <span class="hljs-string">&quot;PLACEMENT&quot;</span>,
  }
}
</code></pre>
<p>对于需要删除节点的情况，我们没有新的Fiber，所以我们在旧Fiber上添加effect标签。但是当我们将Fiber树提交到DOM时，我们从正在进行的根目录执行，它没有旧的Fiber 。所以我们需要一个数组来跟踪要删除的节点。然后，当我们将更改提交到DOM时，我们还使用了来自该数组的Fiber。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (oldFiber &amp;&amp; !sameType) {
  oldFiber.<span class="hljs-property">effectTag</span> = <span class="hljs-string">&quot;DELETION&quot;</span>
  deletions.<span class="hljs-title function_">push</span>(oldFiber)
}
</code></pre>
<p>现在，让我们修改<code>commitWork</code>函数来处理新的<code>effectTags</code>。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitWork</span>(<span class="hljs-params">fiber</span>) {
  <span class="hljs-keyword">if</span> (!fiber) {
    <span class="hljs-keyword">return</span>
  }
  <span class="hljs-keyword">if</span> (
    fiber.<span class="hljs-property">effectTag</span> === <span class="hljs-string">&quot;PLACEMENT&quot;</span> &amp;&amp;
    fiber.<span class="hljs-property">dom</span> != <span class="hljs-literal">null</span>
  ) {
    domParent.<span class="hljs-title function_">appendChild</span>(fiber.<span class="hljs-property">dom</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
      fiber.<span class="hljs-property">effectTag</span> === <span class="hljs-string">&quot;UPDATE&quot;</span> &amp;&amp;
      fiber.<span class="hljs-property">dom</span> != <span class="hljs-literal">null</span>
    ) {
      <span class="hljs-title function_">updateDom</span>(
        fiber.<span class="hljs-property">dom</span>,
        fiber.<span class="hljs-property">alternate</span>.<span class="hljs-property">props</span>,
        fiber.<span class="hljs-property">props</span>
      )
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">effectTag</span> === <span class="hljs-string">&quot;DELETION&quot;</span>) {
      domParent.<span class="hljs-title function_">removeChild</span>(fiber.<span class="hljs-property">dom</span>)
  }
  <span class="hljs-keyword">const</span> domParent = fiber.<span class="hljs-property">parent</span>.<span class="hljs-property">dom</span>
  domParent.<span class="hljs-title function_">appendChild</span>(fiber.<span class="hljs-property">dom</span>)
  <span class="hljs-title function_">commitWork</span>(fiber.<span class="hljs-property">child</span>)
  <span class="hljs-title function_">commitWork</span>(fiber.<span class="hljs-property">sibling</span>)
}
</code></pre>
<ul>
<li><p>如果Fiber有一个<code>PLACEMENT</code>标签，从父Fiber将DOM节点附加到节点。</p>
</li>
<li><p>如果是<code>DELETION</code>，则做相反的操作，删除子元素。</p>
</li>
<li><p>如果是<code>UPDATE</code>，则需要使用更改后的props更新现有DOM节点。我们将在这个<code>updateDom</code>函数中完成这些操作。将旧Fiber中的props与新Fiber中的props进行比较，去掉不存在的prop，设置新的或更换的prop。需要注意的是，如果prop以<code>on</code>前缀开头，我们将以不同的方式处理它：如果event handler发生了更改，我们将其从节点中删除，然后再添加新的handler。</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isEvent</span> = key =&gt; key.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;on&quot;</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isProperty</span> = key =&gt;
      key !== <span class="hljs-string">&quot;children&quot;</span> &amp;&amp; !<span class="hljs-title function_">isEvent</span>(key)
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isNew</span> = (<span class="hljs-params">prev, next</span>) =&gt; <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span>
    prev[key] !== next[key]
<span class="hljs-keyword">const</span> <span class="hljs-title function_">isGone</span> = (<span class="hljs-params">prev, next</span>) =&gt; <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> !(key <span class="hljs-keyword">in</span> next)
  
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDom</span>(<span class="hljs-params">dom, prevProps, nextProps</span>) {
  <span class="hljs-comment">// Remove old properties</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(prevProps)
    .<span class="hljs-title function_">filter</span>(isProperty)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-title function_">isGone</span>(prevProps, nextProps))
    .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
      dom[name] = <span class="hljs-string">&quot;&quot;</span>
  })

  <span class="hljs-comment">// Set new or changed properties</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(nextProps)
    .<span class="hljs-title function_">filter</span>(isProperty)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-title function_">isNew</span>(prevProps, nextProps))
    .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
      dom[name] = nextProps[name]
  })
  
  <span class="hljs-comment">// Add event listeners</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(nextProps)
    .<span class="hljs-title function_">filter</span>(isEvent)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-title function_">isNew</span>(prevProps, nextProps))
    .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> eventType = name
        .<span class="hljs-title function_">toLowerCase</span>()
        .<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>)
      dom.<span class="hljs-title function_">addEventListener</span>(
        eventType,
        nextProps[name]
      )
  })
}
</code></pre>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"(翻译)创建你自己的React","tags":["React.js"],"categories":"React.js","description":"\u003e 原文链接:https://pomb.us/build-your-own-react/\n\n# Build your own React\n\n我们将从头开始重写React。 一步步。 遵循真实的React代码中的架构，但没有所有的优化和非必要的功能。\n\n如果您阅读过[我以前的任何“构建自己的React”文章](https://engineering.hexacta.com/didact-lear","createDate":"2020-11-02 14:25:18","updateDate":"2020-11-11 15:00:53","body":"\u003cblockquote\u003e\n\u003cp\u003e原文链接:\u003ca href=\"https://pomb.us/build-your-own-react/\"\u003ehttps://pomb.us/build-your-own-react/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n      \u003ch1\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eBuild your own React\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h1\u003e\n    \u003cp\u003e我们将从头开始重写React。 一步步。 遵循真实的React代码中的架构，但没有所有的优化和非必要的功能。\u003c/p\u003e\n\u003cp\u003e如果您阅读过\u003ca href=\"https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5\"\u003e我以前的任何“构建自己的React”文章\u003c/a\u003e，不同之处在于该文章基于React 16.8，因此我们现在可以使用\u003ccode\u003ehook\u003c/code\u003e并删除所有与\u003ccode\u003eclass\u003c/code\u003e相关的代码。\u003c/p\u003e\n\u003cp\u003e您可以在旧博客文章中找到历史记录，并在\u003ca href=\"https://github.com/pomber/didact\"\u003eDidact仓库\u003c/a\u003e中找到代码。 还有一个演讲涉及相同的内容。\u003c/p\u003e\n\u003cp\u003e以下这些都是我们将一一添加到我们的React版本中的内容：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一步: \u003ccode\u003ecreateElement\u003c/code\u003e 函数\u003c/li\u003e\n\u003cli\u003e第二步: \u003ccode\u003erender\u003c/code\u003e 函数\u003c/li\u003e\n\u003cli\u003e第三步: Concurrent Mode\u003c/li\u003e\n\u003cli\u003e第四步: Fibers\u003c/li\u003e\n\u003cli\u003e第五步: Render and Commit Phases\u003c/li\u003e\n\u003cli\u003e第六步: Reconciliation\u003c/li\u003e\n\u003cli\u003e第七步: 函数式组件\u003c/li\u003e\n\u003cli\u003e第八步: Hooks\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e第零步\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e如果您已经对React，JSX和DOM节点的工作方式有了很好的了解，则可以跳过此步骤。首先让我们回顾一些基本概念，我们将使用只有三行代码的React应用程序：第一个定义一个React节点，下一个从DOM获取一个节点，最后一个将React节点渲染到容器中。然后，我们会删除所有特定于React的代码将其替换为原始JavaScript。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;foo\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003eHello\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;root\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(element, container)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在第一行中，我们使用JSX定义了节点。 它不是有效的JavaScript，因此要用原生JS取代它。通过Babel等构建工具，JSX转换为JS。 转换通常很简单：使用对\u003ccode\u003ecreateElement\u003c/code\u003e的调用来替换标签内的代码，并将标签\u003ccode\u003etype\u003c/code\u003e、\u003ccode\u003eprops\u003c/code\u003e、\u003ccode\u003echildren\u003c/code\u003e作为参数传递。\u003ccode\u003eReact.createElement\u003c/code\u003e根据其参数创建一个对象，除了一些验证之外，这就是全部。 因此，我们可以安全地将函数调用替换为其输出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;foo\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003eHello\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\n👇\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\n  \u003cspan class=\"hljs-string\"\u003e\u0026quot;h1\u0026quot;\u003c/span\u003e,\n  { \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;foo\u0026quot;\u003c/span\u003e },\n  \u003cspan class=\"hljs-string\"\u003e\u0026quot;Hello\u0026quot;\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这就是一个节点，一个具有两个属性的对象：\u003ccode\u003etype\u003c/code\u003e和\u003ccode\u003eprops\u003c/code\u003e（嗯，\u003ca href=\"https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111\"\u003e它有更多的属性\u003c/a\u003e，但是我们只关心这两个属性）。\u003ccode\u003etype\u003c/code\u003e是一个字符串，用于指定我们要创建的DOM节点的类型，它是您要创建HTML节点时传递给\u003ccode\u003edocument.createElement\u003c/code\u003e的\u003ccode\u003etagName\u003c/code\u003e。 它也可以是一个函数，但我们将其留给步骤VII。\u003ccode\u003eprops\u003c/code\u003e是另一个对象，它具有JSX属性中的所有键和值。 它还有一个特殊的属性：\u003ccode\u003echildren\u003c/code\u003e。在这种情况下，\u003ccode\u003echildren\u003c/code\u003e是字符串，但通常是包含更多节点的数组（这就是为什么节点也是树的原因）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = {\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;h1\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;foo\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Hello\u0026quot;\u003c/span\u003e,\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们需要替换的另一部分React代码是对\u003ccode\u003eReactDOM.render\u003c/code\u003e的调用。\u003ccode\u003erender\u003c/code\u003e是React更新DOM的地方，现在用我们自己的代码进行操作。\u003c/p\u003e\n\u003cp\u003e首先，我们使用节点\u003ccode\u003etype\u003c/code\u003e（在本例中为\u003ccode\u003eh1\u003c/code\u003e）创建一个\u003ccode\u003enode*\u003c/code\u003e。然后，我们将所有节点属性分配给该节点。 这里只有一个\u003ccode\u003etitle\u003c/code\u003e。*为避免混淆，我将使用\u003ccode\u003eelement\u003c/code\u003e来指代React节点，并使用\u003ccode\u003enode\u003c/code\u003e来指代DOM节点。\u003c/p\u003e\n\u003cp\u003e然后，我们为\u003ccode\u003echildren\u003c/code\u003e创建节点。 我们只有一个字符串作为\u003ccode\u003echildren\u003c/code\u003e，因此我们创建了一个文本节点。使用\u003ccode\u003etextNode\u003c/code\u003e而不是设置\u003ccode\u003einnerText\u003c/code\u003e将允许我们以后以相同的方式对待所有节点。另请注意，我们像设置\u003ccode\u003eh1\u003c/code\u003e标题一样设置\u003ccode\u003enodeValue\u003c/code\u003e，就像字符串中带有\u003ccode\u003eprops: {nodeValue: \u0026quot;hello\u0026quot;}\u003c/code\u003e。最后，我们将\u003ccode\u003etextNode\u003c/code\u003e添加到\u003ccode\u003eh1\u003c/code\u003e并将\u003ccode\u003eh1\u003c/code\u003e添加到\u003ccode\u003econtainer\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = {\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;h1\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;foo\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Hello\u0026quot;\u003c/span\u003e,\n  },\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;root\u0026quot;\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e node = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e)\nnode[\u003cspan class=\"hljs-string\"\u003e\u0026quot;title\u0026quot;\u003c/span\u003e] = element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e text = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateTextNode\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e)\ntext[\u003cspan class=\"hljs-string\"\u003e\u0026quot;nodeValue\u0026quot;\u003c/span\u003e] = element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echildren\u003c/span\u003e\n\nnode.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(text)\ncontainer.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(node)\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e第一步: createElement 函数\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e现在，让我们切换到另一个App：自己实现的简易React。\u003c/p\u003e\n\u003cp\u003e首先，从编写\u003ccode\u003ecreateElement\u003c/code\u003e开始，将JSX转换为JS。正如在上一步中看到的，\u003ccode\u003eelement\u003c/code\u003e是具有类型和属性的对象。\u003ccode\u003ecreateElement\u003c/code\u003e唯一需要做的就是创建该对象。\u003c/p\u003e\n\u003cp\u003e因为\u003ccode\u003echildren\u003c/code\u003e也可以包含原始数据类型，比如字符串或数字，所以对不是\u003ccode\u003eobject\u003c/code\u003e的\u003ccode\u003echild\u003c/code\u003e创建特殊节点类型：\u003ccode\u003eTEXT_ELEMENT\u003c/code\u003e。这样做是因为可以简化代码。对于我们的库，我更喜欢简单而不是高性能代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateTextElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etext\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;TEXT_ELEMENT\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003enodeValue\u003c/span\u003e: text,\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [],\n    },\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype, props, ...children\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    type,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      ...props,\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: children.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003echild\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child === \u003cspan class=\"hljs-string\"\u003e\u0026quot;object\u0026quot;\u003c/span\u003e\n        ? child\n        : \u003cspan class=\"hljs-title function_\"\u003ecreateTextElement\u003c/span\u003e(child)\n      ),\n    },\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e目前Babel仍然使用\u003ccode\u003eReact.createElement\u003c/code\u003e，为了替换它，让我们给自己的库起个名字。我们需要一个听起来像React的名字，但也暗示了它的教学目的，我们叫它\u003ccode\u003eDidact\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e让我们使用\u003ccode\u003e/** @jsx Didact.createElement */\u003c/code\u003e来告诉Babel使用我们自己的\u003ccode\u003ecreateElement\u003c/code\u003e来转换jsx代码：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** \u003cspan class=\"hljs-doctag\"\u003e@jsx\u003c/span\u003e Didact.createElement */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = (\n  \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;foo\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003ebar\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eb\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e第二步：redner 函数\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e首先使用element的\u003ccode\u003etype\u003c/code\u003e创建DOM节点，然后将新element添加到\u003ccode\u003econtainer\u003c/code\u003e中。然后对每个\u003ccode\u003echild\u003c/code\u003e递归调用\u003ccode\u003erender\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eelement, container\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dom = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e);\n\n  element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echildren\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003echild\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(child, dom))\n\n  container.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(dom);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其次，我们还需要处理文本节点，如果element类型为\u003ccode\u003eTEXT_ELEMENT\u003c/code\u003e，我们将创建文本节点而不是普通节点：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eelement, container\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dom = element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026quot;TEXT_ELEMENT\u0026quot;\u003c/span\u003e\n    ? \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateTextNode\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e)\n    : \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElmenet\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后，将\u003ccode\u003eprops\u003c/code\u003e分配给element：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eelement, container\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisProperty\u003c/span\u003e = key =\u0026gt; key === \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e;\n  \u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eownkeys\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(isProperty)\n    .\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e) =\u0026gt;\u003c/span\u003e dom[name] = element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e[name]);\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样的话，我们就有了一个可以将JSX呈现到DOM的库：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateTextElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etext\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;TEXT_ELEMENT\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003enodeValue\u003c/span\u003e: text,\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: []\n    }\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype, props, ...children\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    type,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      ...props,\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: children.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003echild\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e child === \u003cspan class=\"hljs-string\"\u003e\u0026quot;object\u0026quot;\u003c/span\u003e ? child : \u003cspan class=\"hljs-title function_\"\u003ecreateTextElement\u003c/span\u003e(child)\n      )\n    }\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eelement, container\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dom =\n    element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026quot;TEXT_ELEMENT\u0026quot;\u003c/span\u003e\n      ? \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateTextNode\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e)\n      : \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisProperty\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ekey\u003c/span\u003e) =\u0026gt; key !== \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e;\n  \u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eownKeys\u003c/span\u003e(element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(isProperty)\n    .\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e) =\u0026gt;\u003c/span\u003e (dom[name] = element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e[name]));\n\n  element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echildren\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003echild\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(child, dom));\n\n  container.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(dom);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDidact\u003c/span\u003e = {\n  createElement,\n  render\n};\n\n\u003cspan class=\"hljs-comment\"\u003e/** \u003cspan class=\"hljs-doctag\"\u003e@jsx\u003c/span\u003e Didact.createElement */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = (\n  \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;foo\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eHello STEP1-STEP2\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;#step1\u0026quot;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-title class_\"\u003eDidact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(element, container);\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e第三步Concurrent Mode\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e在开始添加更多代码之前，我们需要重构。\u003c/p\u003e\n\u003cp\u003e上面的递归调用存在问题。开始渲染后，直到渲染完完整的element树，我们才会停止。 如果element树很大，则可能会阻塞主线程太长时间。 那么如果浏览器需要执行高优先级的操作（例如处理用户输入或保持动画流畅），则它必须等到渲染完成为止。因此，我们将工作分成几个小部分，在完成每个单元后，如果需要执行其他任何操作，我们将让浏览器中断渲染。\u003c/p\u003e\n\u003cp\u003e我们使用\u003ccode\u003erequestIdleCallback\u003c/code\u003e进行循环。 您可以将\u003ccode\u003erequestIdleCallback\u003c/code\u003e看作\u003ccode\u003esetTimeout\u003c/code\u003e，但是浏览器将在主线程空闲时运行回调，而不是告诉它何时运行。React不再使用\u003ccode\u003erequestIdleCallback\u003c/code\u003e，现在它使用scheduler package。 但是对于此用例，它在概念上是相同的。\u003ccode\u003erequestIdleCallback\u003c/code\u003e还为我们提供了\u003ccode\u003edeadline\u003c/code\u003e参数。 我们可以使用它来检查浏览器需要再次控制之前有多少时间。\u003c/p\u003e\n\u003cp\u003e要开始使用循环，我们需要设置第一个工作单元，然后编写一个\u003ccode\u003eperformUnitOfWork\u003c/code\u003e函数，该函数不仅执行工作，还返回下一个工作单元。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e第四步Fiber\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e要组织工作单元，我们需要一个数据结构--Fiber树。我们将为每个元素分配一根Fiber，并且每个Fiber将成为一个工作单元。\u003c/p\u003e\n\u003cp\u003e假如我们要渲染如下的element树，那么Fiber树就如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eDidact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\n  \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e,\n  container\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://pomb.us/static/a88a3ec01855349c14302f6da28e2b0c/ac667/fiber1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e在render函数中，我们将创建root Fiber并将其设置为\u003ccode\u003enextUnitOfWork\u003c/code\u003e。 剩下的工作将在\u003ccode\u003eperformUnitOfWork\u003c/code\u003e函数上进行，我们将为每个Fiber做三件事：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将element添加到DOM\u003c/li\u003e\n\u003cli\u003e为element的子代创建Filber\u003c/li\u003e\n\u003cli\u003e选择下一个工作单元\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e该数据结构的目标之一是使查找下一个工作单元变得容易。 这就是为什么每个Fiber都链接到其第一个子节点、下一个兄弟节点和父节点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当我们完成对当前Fiber的工作时，如果有child，那么该child对应的Fiber将是下一个工作单元。在我们的示例中，当我们完成div Fiber的工作时，下一个工作单元将是h1 Fiber。\u003c/li\u003e\n\u003cli\u003e如果当前Fiber没有child，我们将其sibling作为下一个工作单元。例如，p Fiber没有child，因此我们在完成当前之后下一个工作单元将是h1。\u003c/li\u003e\n\u003cli\u003e如果当前Fiber既没有child也没有sibling，那么我们去“uncle”：父母的兄弟节点。 就像示例中的a和h2 Fiber一样。\u003c/li\u003e\n\u003cli\u003e如果parent没有sibling，我们会不断检查parent，直到找到有sibling的parent，或者直到找到root。 如果到达root，则意味着我们已经完成了此渲染的所有工作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现在，让我们开始写代码。\u003c/p\u003e\n\u003cp\u003e首先，更改\u003ccode\u003erender\u003c/code\u003e函数并创建\u003ccode\u003ecreateDom\u003c/code\u003e函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eelement, container\u003c/span\u003e) {\n  nextUnitOfWork = {\n    \u003cspan class=\"hljs-attr\"\u003edom\u003c/span\u003e: container,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [element],\n    },\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateDom\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efiber\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dom =\n    fiber.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\u0026quot;TEXT_ELEMENT\u0026quot;\u003c/span\u003e\n      ? \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateTextNode\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e)\n      : \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisProperty\u003c/span\u003e = key =\u0026gt; key !== \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(isProperty)\n    .\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      dom[name] = fiber.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e[name]\n    })\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dom\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后，当浏览器准备就绪时，它将调用我们的\u003ccode\u003eworkLoop\u003c/code\u003e，我们将从\u003ccode\u003eroot\u003c/code\u003e开始执行渲染。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eworkLoop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edeadline\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e shouldYield = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextUnitOfWork \u0026amp;\u0026amp; !shouldYield) {\n    nextUnitOfWork = \u003cspan class=\"hljs-title function_\"\u003eperformUnitOfWork\u003c/span\u003e(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.\u003cspan class=\"hljs-title function_\"\u003etimeRemaining\u003c/span\u003e() \u0026lt; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-title function_\"\u003erequestIdleCallback\u003c/span\u003e(workLoop)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先，我们创建一个新node并将其添加到DOM。我们在\u003ccode\u003efibre.dom\u003c/code\u003e属性中跟踪DOM节点。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperformUnitOfWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efiber\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e) {\n    fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreateDom\u003c/span\u003e(fiber)\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fiber.\u003cspan class=\"hljs-property\"\u003eparent\u003c/span\u003e) {\n    fiber.\u003cspan class=\"hljs-property\"\u003eparent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e)\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// TODO create new fibers\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// TODO return next unit of work\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后对每个\u003ccode\u003echild\u003c/code\u003e创建Fiber\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elements = fiber.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echildren\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e index = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e prevSibling = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (index \u0026lt; elements.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = elements[index]\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newFiber = {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: fiber,\n      \u003cspan class=\"hljs-attr\"\u003edom\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后将其添加到Fiber树中，将其设置为\u003ccode\u003echild\u003c/code\u003e还是\u003ccode\u003esibing\u003c/code\u003e，具体取决于它是否是第一个child。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n      fiber.\u003cspan class=\"hljs-property\"\u003echild\u003c/span\u003e = newFiber\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      prevSibling.\u003cspan class=\"hljs-property\"\u003esibling\u003c/span\u003e = newFiber\n    }\n}\nprevSibling = newFiber\nindex++\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后，我们按照child ☞ sibling ☞ uncle来选择下一工作单元。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fiber.\u003cspan class=\"hljs-property\"\u003echild\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fiber.\u003cspan class=\"hljs-property\"\u003echild\u003c/span\u003e\n}\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nextFiber = fiber\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextFiber) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nextFiber.\u003cspan class=\"hljs-property\"\u003esibling\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nextFiber.\u003cspan class=\"hljs-property\"\u003esibling\u003c/span\u003e\n  }\n  nextFiber = nextFiber.\u003cspan class=\"hljs-property\"\u003eparent\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e完整的代码如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperformUnitOfWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efiber\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e) {\n    fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreateDom\u003c/span\u003e(fiber)\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fiber.\u003cspan class=\"hljs-property\"\u003eparent\u003c/span\u003e) {\n    fiber.\u003cspan class=\"hljs-property\"\u003eparent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e)\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e elements = fiber.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echildren\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e index = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e prevSibling = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (index \u0026lt; elements.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = elements[index]\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newFiber = {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: fiber,\n      \u003cspan class=\"hljs-attr\"\u003edom\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n      fiber.\u003cspan class=\"hljs-property\"\u003echild\u003c/span\u003e = newFiber\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      prevSibling.\u003cspan class=\"hljs-property\"\u003esibling\u003c/span\u003e = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fiber.\u003cspan class=\"hljs-property\"\u003echild\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fiber.\u003cspan class=\"hljs-property\"\u003echild\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e nextFiber = fiber\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (nextFiber) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nextFiber.\u003cspan class=\"hljs-property\"\u003esibling\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nextFiber.\u003cspan class=\"hljs-property\"\u003esibling\u003c/span\u003e\n    }\n    nextFiber = nextFiber.\u003cspan class=\"hljs-property\"\u003eparent\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e提交更改\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e我们还有一个问题。每次处理一个元素时，我们都会向DOM添加一个新节点。而且，请记住，浏览器可能会在我们完成整个树的渲染之前中断我们的工作。在这种情况下，用户将看到一个不完整的UI。我们不想这样。\u003c/p\u003e\n\u003cp\u003e因此，我们需要从\u003ccode\u003eperformUnitOfWork\u003c/code\u003e里删除改变DOM的部分。相反，我们将跟踪Fiber tree。我们称它为\u003ccode\u003ewipRoot\u003c/code\u003e。一旦我们完成了所有的工作(我们知道它是因为没有下一个工作单元)，我们就将整个Fiber tree提交给DOM。我们在\u003ccode\u003ecommitRoot\u003c/code\u003e函数中完成。在这里，我们递归地将所有节点追加到dom。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eReconciliation\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e到目前为止，我们只向DOM添加了一些东西，那么更新或删除节点呢? \u003c/p\u003e\n\u003cp\u003e这就是我们现在要做的，我们需要将\u003ccode\u003erender\u003c/code\u003e函数接收到的元素与提交给DOM的最后一个Fiber tree进行比较。因此，在完成\u003ccode\u003ecommit\u003c/code\u003e之后，我们需要保存对\u003cstrong\u003e最后一个提交到DOM的Fiber tree\u003c/strong\u003e的引用。我们称之为\u003ccode\u003ecurrentRoot\u003c/code\u003e。我们还在每Fiber中加入了\u003ccode\u003ealternate\u003c/code\u003e, 此属性是到旧Fiber的链接，即我们在上一个提交阶段提交给DOM的Fiber。\u003c/p\u003e\n\u003cp\u003e现在让我们从创建新Fiber的\u003ccode\u003eperformUnitOfWork\u003c/code\u003e函数中提取代码到\u003ccode\u003ereconcileChildren\u003c/code\u003e 。在这里，我们将\u003ccode\u003ereconcile\u003c/code\u003e旧的fibers和新元素。我们同时遍历旧Fiber tree(\u003ccode\u003ewipFiber.alternate\u003c/code\u003e)的子元素和我们想要reconciliation的元素数组。如果我们忽略同时遍历数组和链表所需的所有样板文件，那么我们只剩下while中最重要的部分:oldFiber和element。元素是我们想要渲染到DOM的东西，而oldFiber是我们上次渲染的东西。我们需要比较它们，看看是否需要对DOM进行更改。\u003c/p\u003e\n\u003cp\u003e为了比较它们，我们使用类型:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果旧的Fiber和新元素具有相同的类型，我们可以保留DOM节点，并使用新的道具更新它\u003c/li\u003e\n\u003cli\u003e如果类型不同，并且有一个新元素，这意味着我们需要创建一个新的DOM节点\u003c/li\u003e\n\u003cli\u003e如果类型不同，并且有一个旧的光纤，我们需要删除旧的节点\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里React也使用key，这样可以更好的\u003ccode\u003ereconcile\u003c/code\u003e。例如，它检测子元素在元素数组中的位置发生了变化。\u003c/p\u003e\n\u003cp\u003e当旧Fiber和元素具有相同的类型时，我们创建一个新Fiber，使DOM节点与旧Fiber保持一致，使props与element保持一致。我们还向Fiber 添加了一个新属性:\u003ccode\u003eeffectTag\u003c/code\u003e。我们将在稍后的\u003ccode\u003ecommit\u003c/code\u003e阶段使用此属性。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sameType =\n      oldFiber \u0026amp;\u0026amp;\n      element \u0026amp;\u0026amp;\n      element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e == oldFiber.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (sameType) {\n  newFiber = {\n    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: oldFiber.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edom\u003c/span\u003e: oldFiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: wipFiber,\n    \u003cspan class=\"hljs-attr\"\u003ealternate\u003c/span\u003e: oldFiber,\n    \u003cspan class=\"hljs-attr\"\u003eeffectTag\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;UPDATE\u0026quot;\u003c/span\u003e,\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于element需要一个新DOM节点的情况，我们用\u003ccode\u003ePLACEMENT\u003c/code\u003e标记标记新Fiber。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element \u0026amp;\u0026amp; !sameType) {\n  newFiber = {\n    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: element.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: element.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edom\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: wipFiber,\n    \u003cspan class=\"hljs-attr\"\u003ealternate\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eeffectTag\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;PLACEMENT\u0026quot;\u003c/span\u003e,\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于需要删除节点的情况，我们没有新的Fiber，所以我们在旧Fiber上添加effect标签。但是当我们将Fiber树提交到DOM时，我们从正在进行的根目录执行，它没有旧的Fiber 。所以我们需要一个数组来跟踪要删除的节点。然后，当我们将更改提交到DOM时，我们还使用了来自该数组的Fiber。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (oldFiber \u0026amp;\u0026amp; !sameType) {\n  oldFiber.\u003cspan class=\"hljs-property\"\u003eeffectTag\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026quot;DELETION\u0026quot;\u003c/span\u003e\n  deletions.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(oldFiber)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在，让我们修改\u003ccode\u003ecommitWork\u003c/code\u003e函数来处理新的\u003ccode\u003eeffectTags\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecommitWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efiber\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!fiber) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n    fiber.\u003cspan class=\"hljs-property\"\u003eeffectTag\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026quot;PLACEMENT\u0026quot;\u003c/span\u003e \u0026amp;\u0026amp;\n    fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ) {\n    domParent.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e)\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n      fiber.\u003cspan class=\"hljs-property\"\u003eeffectTag\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026quot;UPDATE\u0026quot;\u003c/span\u003e \u0026amp;\u0026amp;\n      fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n    ) {\n      \u003cspan class=\"hljs-title function_\"\u003eupdateDom\u003c/span\u003e(\n        fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e,\n        fiber.\u003cspan class=\"hljs-property\"\u003ealternate\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e,\n        fiber.\u003cspan class=\"hljs-property\"\u003eprops\u003c/span\u003e\n      )\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fiber.\u003cspan class=\"hljs-property\"\u003eeffectTag\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026quot;DELETION\u0026quot;\u003c/span\u003e) {\n      domParent.\u003cspan class=\"hljs-title function_\"\u003eremoveChild\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e)\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e domParent = fiber.\u003cspan class=\"hljs-property\"\u003eparent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e\n  domParent.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003edom\u003c/span\u003e)\n  \u003cspan class=\"hljs-title function_\"\u003ecommitWork\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003echild\u003c/span\u003e)\n  \u003cspan class=\"hljs-title function_\"\u003ecommitWork\u003c/span\u003e(fiber.\u003cspan class=\"hljs-property\"\u003esibling\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e如果Fiber有一个\u003ccode\u003ePLACEMENT\u003c/code\u003e标签，从父Fiber将DOM节点附加到节点。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果是\u003ccode\u003eDELETION\u003c/code\u003e，则做相反的操作，删除子元素。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果是\u003ccode\u003eUPDATE\u003c/code\u003e，则需要使用更改后的props更新现有DOM节点。我们将在这个\u003ccode\u003eupdateDom\u003c/code\u003e函数中完成这些操作。将旧Fiber中的props与新Fiber中的props进行比较，去掉不存在的prop，设置新的或更换的prop。需要注意的是，如果prop以\u003ccode\u003eon\u003c/code\u003e前缀开头，我们将以不同的方式处理它：如果event handler发生了更改，我们将其从节点中删除，然后再添加新的handler。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisEvent\u003c/span\u003e = key =\u0026gt; key.\u003cspan class=\"hljs-title function_\"\u003estartsWith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;on\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisProperty\u003c/span\u003e = key =\u0026gt;\n      key !== \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e \u0026amp;\u0026amp; !\u003cspan class=\"hljs-title function_\"\u003eisEvent\u003c/span\u003e(key)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNew\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eprev, next\u003c/span\u003e) =\u0026gt; \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ekey\u003c/span\u003e =\u0026gt;\u003c/span\u003e\n    prev[key] !== next[key]\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisGone\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eprev, next\u003c/span\u003e) =\u0026gt; \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ekey\u003c/span\u003e =\u0026gt;\u003c/span\u003e !(key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e next)\n  \n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateDom\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edom, prevProps, nextProps\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// Remove old properties\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e(prevProps)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(isProperty)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eisGone\u003c/span\u003e(prevProps, nextProps))\n    .\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      dom[name] = \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\n  })\n\n  \u003cspan class=\"hljs-comment\"\u003e// Set new or changed properties\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e(nextProps)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(isProperty)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eisNew\u003c/span\u003e(prevProps, nextProps))\n    .\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      dom[name] = nextProps[name]\n  })\n  \n  \u003cspan class=\"hljs-comment\"\u003e// Add event listeners\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e(nextProps)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(isEvent)\n    .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eisNew\u003c/span\u003e(prevProps, nextProps))\n    .\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e eventType = name\n        .\u003cspan class=\"hljs-title function_\"\u003etoLowerCase\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_\"\u003esubstring\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n      dom.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\n        eventType,\n        nextProps[name]\n      )\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"(翻译)创建你自己的React"},"buildId":"_q5ru5NemgZT2swXpl15Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>