<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-webpack学习-chunk分包</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/SUXcKeHX0J-b1763YW0o6/_buildManifest.js" defer=""></script><script src="/_next/static/SUXcKeHX0J-b1763YW0o6/_ssgManifest.js" defer=""></script><script src="/_next/static/SUXcKeHX0J-b1763YW0o6/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">webpack学习-chunk分包</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2022-05-31 21:41:47</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2022-05-31 21:41:47</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><p>学习 webpack5 中 chunk 分包规则</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">module vs chunk</span>
        <span class="suffix"></span>
      </h2>
    <p>在 webpack 中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGraph 对 Chunk 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 Chunks 。运行完毕之后 webpack 继续将 chunk 一一写入物理文件中，完成编译工作。</p>
<p>综上，Module 主要作用在 webpack 编译过程的前半段，解决原始资源“「如何读」”的问题；而 Chunk 对象则主要作用在编译的后半段，解决编译产物“「如何写」”的问题，两者合作搭建起 webpack 搭建主流程。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">默认分包规则</span>
        <span class="suffix"></span>
      </h2>
    <p>简单总结下:</p>
<ul>
<li><p>同一个 <code>entry</code> 下可触达的模块组织成一个 chunk</p>
</li>
<li><p>异步模块单独划分为一个 chunk</p>
</li>
<li><p><code>entry.runtime</code>单独划分为一个 chunk</p>
</li>
</ul>

      <h3>
        <span class="prefix"></span>
        <span class="content">entry</span>
        <span class="suffix"></span>
      </h3>
    <p><strong>seal 阶段遍历 entry 对象，为每一个 entry 单独生成 chunk，之后再根据模块依赖图将 entry 触达到的所有模块打包进 chunk 中。</strong></p>
<p>对于如下打包配置和文件依赖</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&quot;./src/chunk/index.js&quot;</span>,
    <span class="hljs-attr">main</span>: <span class="hljs-string">&quot;./src/chunk/main.js&quot;</span>,
  },
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,
};
</code></pre>
<p><img src="/img/webpack-chunk-1.png" alt="webpack entry划分chunk-文件依赖"></p>
<p>在示例中， <code>index.js</code>和 <code>main.js</code> 分别静态引入了几个文件</p>
<p>在 <code>npx webpack --json &gt; info.json</code> 打包后的输出结果是这样的</p>
<p><img src="/img/webpack-chunk-0.png" alt="webpack entry划分chunk-打包结果"></p>
<p>可以看到，一共生成了两个 chunk</p>

      <h3>
        <span class="prefix"></span>
        <span class="content">异步模块</span>
        <span class="suffix"></span>
      </h3>
    <p><strong>每次遇到异步模块都会为之创建单独的 Chunk 对象，单独打包异步模块。</strong></p>
<p>还以上述配置和代码为例，只是将 <code>a.js</code> 改为动态引入，即<code>import(&#39;a.js&#39;)</code></p>
<p><img src="/img/webpack-chunk-2.png" alt="webpack 动态import分包"></p>
<p>此时重新执行<code>npx webpack --json &gt; info.json</code> 打包后的输出结果是这样的</p>
<p><img src="/img/webpack-chunk-3.png" alt="webpack 动态import分包"></p>
<p>可以看到新增了一个 chunk</p>

      <h3>
        <span class="prefix"></span>
        <span class="content">entry.runtime</span>
        <span class="suffix"></span>
      </h3>
    <p><strong>Webpack 5 之后还能根据 entry.runtime 配置单独打包运行时代码。</strong></p>
<p>除了 entry、异步模块外，webpack 5 之后还支持基于 runtime 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime。虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 entry.runtime 配置项用于声明如何打包运行时代码。用法上只需在 entry 项中增加字符串形式的 runtime 值，例如：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: {
      <span class="hljs-attr">import</span>: <span class="hljs-string">&quot;./src/chunk/index.js&quot;</span>,
      <span class="hljs-attr">runtime</span>: <span class="hljs-string">&quot;solid-runtime&quot;</span>,
    },
    <span class="hljs-attr">main</span>: {
      <span class="hljs-attr">import</span>: <span class="hljs-string">&quot;./src/chunk/main.js&quot;</span>,
      <span class="hljs-attr">runtime</span>: <span class="hljs-string">&quot;solid-runtime&quot;</span>,
    },
  },
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">devtool</span>: <span class="hljs-literal">false</span>,
};
</code></pre>
<p>此时再次执行 <code>npx webpack --json &gt; info.json</code>，打包结果如下</p>
<p><img src="/img/webpack-chunk-4.png" alt="webpack runtime分包"></p>
<p>可以看到，此时又新增了一个包，而且对比一下输出文件的大小，大部分文件输出到 <code>solid-runtime.js</code> 中， <code>index.js</code> 和 <code>main.js</code> 已经缩短到 30 行左右</p>
<blockquote>
<p>ps: 此时网站中需要单独引入 solid-runtime.js 文件</p>
</blockquote>

      <h2>
        <span class="prefix"></span>
        <span class="content">SplitChunk</span>
        <span class="suffix"></span>
      </h2>
    <p>// TODO</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">参考</span>
        <span class="suffix"></span>
      </h2>
    <p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484029&amp;idx=1&amp;sn=7862737524e799c5eaf1605325171e32&amp;chksm=cf00bf04f8773612682f4650be2f78255912d0ca8ecafff1bd647a8a692ae28098436975908f&amp;scene=178&amp;cur_album_id=1856066636768722949#rd">有点难的知识点： Webpack Chunk 分包规则详解</a></p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"webpack学习-chunk分包","tags":["webpack","chunk"],"categories":"webpack","description":"学习 webpack5 中 chunk 分包规则\n\n## module vs chunk\n\n在 webpack 中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGra","createDate":"2022-05-31 21:41:47","updateDate":"2022-05-31 21:41:47","body":"\u003cp\u003e学习 webpack5 中 chunk 分包规则\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003emodule vs chunk\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e在 webpack 中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGraph 对 Chunk 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 Chunks 。运行完毕之后 webpack 继续将 chunk 一一写入物理文件中，完成编译工作。\u003c/p\u003e\n\u003cp\u003e综上，Module 主要作用在 webpack 编译过程的前半段，解决原始资源“「如何读」”的问题；而 Chunk 对象则主要作用在编译的后半段，解决编译产物“「如何写」”的问题，两者合作搭建起 webpack 搭建主流程。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e默认分包规则\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e简单总结下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e同一个 \u003ccode\u003eentry\u003c/code\u003e 下可触达的模块组织成一个 chunk\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e异步模块单独划分为一个 chunk\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eentry.runtime\u003c/code\u003e单独划分为一个 chunk\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch3\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eentry\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h3\u003e\n    \u003cp\u003e\u003cstrong\u003eseal 阶段遍历 entry 对象，为每一个 entry 单独生成 chunk，之后再根据模块依赖图将 entry 触达到的所有模块打包进 chunk 中。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于如下打包配置和文件依赖\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;development\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eentry\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;./src/chunk/index.js\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003emain\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;./src/chunk/main.js\u0026quot;\u003c/span\u003e,\n  },\n  \u003cspan class=\"hljs-attr\"\u003eoptimization\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eusedExports\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n  \u003cspan class=\"hljs-attr\"\u003edevtool\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/img/webpack-chunk-1.png\" alt=\"webpack entry划分chunk-文件依赖\"\u003e\u003c/p\u003e\n\u003cp\u003e在示例中， \u003ccode\u003eindex.js\u003c/code\u003e和 \u003ccode\u003emain.js\u003c/code\u003e 分别静态引入了几个文件\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003enpx webpack --json \u0026gt; info.json\u003c/code\u003e 打包后的输出结果是这样的\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/webpack-chunk-0.png\" alt=\"webpack entry划分chunk-打包结果\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到，一共生成了两个 chunk\u003c/p\u003e\n\n      \u003ch3\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e异步模块\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h3\u003e\n    \u003cp\u003e\u003cstrong\u003e每次遇到异步模块都会为之创建单独的 Chunk 对象，单独打包异步模块。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e还以上述配置和代码为例，只是将 \u003ccode\u003ea.js\u003c/code\u003e 改为动态引入，即\u003ccode\u003eimport(\u0026#39;a.js\u0026#39;)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/webpack-chunk-2.png\" alt=\"webpack 动态import分包\"\u003e\u003c/p\u003e\n\u003cp\u003e此时重新执行\u003ccode\u003enpx webpack --json \u0026gt; info.json\u003c/code\u003e 打包后的输出结果是这样的\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/webpack-chunk-3.png\" alt=\"webpack 动态import分包\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到新增了一个 chunk\u003c/p\u003e\n\n      \u003ch3\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eentry.runtime\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h3\u003e\n    \u003cp\u003e\u003cstrong\u003eWebpack 5 之后还能根据 entry.runtime 配置单独打包运行时代码。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e除了 entry、异步模块外，webpack 5 之后还支持基于 runtime 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime。虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 entry.runtime 配置项用于声明如何打包运行时代码。用法上只需在 entry 项中增加字符串形式的 runtime 值，例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;development\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eentry\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003eimport\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;./src/chunk/index.js\u0026quot;\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eruntime\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;solid-runtime\u0026quot;\u003c/span\u003e,\n    },\n    \u003cspan class=\"hljs-attr\"\u003emain\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003eimport\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;./src/chunk/main.js\u0026quot;\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eruntime\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;solid-runtime\u0026quot;\u003c/span\u003e,\n    },\n  },\n  \u003cspan class=\"hljs-attr\"\u003eoptimization\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eusedExports\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n  \u003cspan class=\"hljs-attr\"\u003edevtool\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e此时再次执行 \u003ccode\u003enpx webpack --json \u0026gt; info.json\u003c/code\u003e，打包结果如下\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/webpack-chunk-4.png\" alt=\"webpack runtime分包\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到，此时又新增了一个包，而且对比一下输出文件的大小，大部分文件输出到 \u003ccode\u003esolid-runtime.js\u003c/code\u003e 中， \u003ccode\u003eindex.js\u003c/code\u003e 和 \u003ccode\u003emain.js\u003c/code\u003e 已经缩短到 30 行左右\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eps: 此时网站中需要单独引入 solid-runtime.js 文件\u003c/p\u003e\n\u003c/blockquote\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eSplitChunk\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e// TODO\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e参考\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==\u0026amp;mid=2247484029\u0026amp;idx=1\u0026amp;sn=7862737524e799c5eaf1605325171e32\u0026amp;chksm=cf00bf04f8773612682f4650be2f78255912d0ca8ecafff1bd647a8a692ae28098436975908f\u0026amp;scene=178\u0026amp;cur_album_id=1856066636768722949#rd\"\u003e有点难的知识点： Webpack Chunk 分包规则详解\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"webpack学习-chunk分包"},"buildId":"SUXcKeHX0J-b1763YW0o6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>