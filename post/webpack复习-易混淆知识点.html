<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-webpack复习-易混淆知识点</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/d3bd3b56eb8829d9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d3bd3b56eb8829d9.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/nDSJKJkWsKogJoq26OJ5Y/_buildManifest.js" defer=""></script><script src="/_next/static/nDSJKJkWsKogJoq26OJ5Y/_ssgManifest.js" defer=""></script><script src="/_next/static/nDSJKJkWsKogJoq26OJ5Y/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">webpack复习-易混淆知识点</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2021-05-17 12:56:41</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2021-07-15 13:54:55</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><h2 id="modulebundlechunk的区别">module/bundle/chunk的区别</h2>
<p><img src="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack_1.png" alt="module、bundle、chunk"></p>
<ol>
<li>对于一份同逻辑代码，当我们手写下一个一个的文件，它们无论是ESM还是commonJS或AMD，它们都是module</li>
<li>当我们写module源文件传到webpack进行打包时，webpack会根据文件引用关系生成chunk文件，webpack会对这个chunk文件进行一些操作</li>
<li>webpack处理好chunk文件后，最后会输出bundle文件，这个bundle文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行</li>
</ol>
<p>一句话总结：<code>module</code>、<code>chunk</code>、<code>bundle</code>其实就是同一份逻辑代码在不同转换场景下取的三个名字：我们直接写出来的是<code>module</code>，<code>webpack</code>处理时是<code>chunk</code>，最后生成浏览器可以直接运行的<code>bundle</code></p>
<h2 id="filenamechunkfilename">filename/chunkFilename</h2>
<p><code>filename</code>对应于<code>entry</code>里面的输入文件，经过webpack 打包后输出文件的文件名</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
    entry<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/path/to/index.js&quot;</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    output<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        filename<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-punctuation">[</span>name<span class="hljs-punctuation">]</span>.<span class="hljs-punctuation">[</span>hash<span class="hljs-punctuation">:</span><span class="hljs-number">8</span><span class="hljs-punctuation">]</span>.js&#x27;
    <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><code>chunkFilename</code>指未列在<code>entry</code>中却又要被打包出来的<code>chunk</code>文件的名称。一般来说，这个<code>chunk</code>文件指的就是需要<strong>懒加载</strong>的代码</p>
<h2 id="webpackprefetchwebpackpreloadwebpackchunkname">webpackPrefetch/webpackPreload/webpackChunkName</h2>
<pre><code class="hljs language-js"><span class="hljs-title function_">import</span>(<span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">&#x27;./path/to/LoginModal.js&#x27;</span>);
</code></pre>
<p><code>webpackChunkName</code>是为预加载的文件取别名，<code>webpackPrefetch</code>会在浏览器闲置时下载文件，<code>webpackPreload</code>会在父<code>chunk</code>加载时并行下载文件</p>
<h2 id="hashchunkhashcontenthash">hash/chunkhash/contenthash</h2>
<p>hash一般是结合CDN缓存来使用的。如果文件内容改变的话，那么对应文件hash值也会改变，对应的html引用的url地址也会改变，触发cdn服务器从源服务器上拉取对应数据进而更新本地缓存</p>
<p><code>hash</code>是整个项目构建使用的，项目中如果有些变动，hash一定会变，比如说改动了utils.js，index.js里的代码虽然没有改变，但是大家都是用的同一份hash，hash一变，缓存一定会失效，这样子CDN就没有意义了</p>
<p><code>chunkHash</code>就是解决这个问题的，它根据不同的入口文件(<code>entry</code>)进行依赖文件解析、构建对应的chunk，生成对应的hash值。一般用在<code>output</code>配置上</p>
<p><code>contentHash</code>计算与文件内容本身有关。一般用在抽离<code>css</code>文件的插件配置上</p>
<h2 id="sourse-map-中-evalcheapinline">sourse-map 中 eval/cheap/inline</h2>
<p>source-map会生成独立的文件</p>
<p>cheap-source-map不会产生列映射</p>
<p>eval-source-map会以<code>eval</code>函数打包运行模块，不产生独立的map文件，会显示报错的行列信息</p>
<p>inline-source-map映射文件以base64格式编码，加载bundle文件最后，不产生独立的map文件</p>
<h2 id="loder-vs-plugin">loder vs plugin</h2>
<p>loder: 文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</p>
<p>plugin: 在webpack运行的生命周期中会广播许多事件，plugin可以监听这些事件，在合适的时机通过调用webpack提供的api改变输出结果</p>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/To_p4eYJx_dkJr1ApcR4jA">webpack 中最易混淆的 5 个知识点</a></p>
<p><a href="https://webpack.docschina.org">webpack文档</a></p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"webpack复习-易混淆知识点","tags":["webpack"],"categories":"2021复习","description":"## module/bundle/chunk的区别\n\n![module、bundle、chunk](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack_1.png)\n\n1. 对于一份同逻辑代码，当我们手写下一个一个的文件，它们无论是ESM还是commonJS或AMD，它们都是module\n2. 当我们写module源文件传到webpack","createDate":"2021-05-17 12:56:41","updateDate":"2021-07-15 13:54:55","body":"\u003ch2 id=\"modulebundlechunk的区别\"\u003emodule/bundle/chunk的区别\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack_1.png\" alt=\"module、bundle、chunk\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e对于一份同逻辑代码，当我们手写下一个一个的文件，它们无论是ESM还是commonJS或AMD，它们都是module\u003c/li\u003e\n\u003cli\u003e当我们写module源文件传到webpack进行打包时，webpack会根据文件引用关系生成chunk文件，webpack会对这个chunk文件进行一些操作\u003c/li\u003e\n\u003cli\u003ewebpack处理好chunk文件后，最后会输出bundle文件，这个bundle文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e一句话总结：\u003ccode\u003emodule\u003c/code\u003e、\u003ccode\u003echunk\u003c/code\u003e、\u003ccode\u003ebundle\u003c/code\u003e其实就是同一份逻辑代码在不同转换场景下取的三个名字：我们直接写出来的是\u003ccode\u003emodule\u003c/code\u003e，\u003ccode\u003ewebpack\u003c/code\u003e处理时是\u003ccode\u003echunk\u003c/code\u003e，最后生成浏览器可以直接运行的\u003ccode\u003ebundle\u003c/code\u003e\u003c/p\u003e\n\u003ch2 id=\"filenamechunkfilename\"\u003efilename/chunkFilename\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efilename\u003c/code\u003e对应于\u003ccode\u003eentry\u003c/code\u003e里面的输入文件，经过webpack 打包后输出文件的文件名\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n    entry\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\u0026quot;index\u0026quot;\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;/path/to/index.js\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    output\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n        filename\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u0026#x27;\u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003ename\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e.\u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003ehash\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e.js\u0026#x27;\n    \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003echunkFilename\u003c/code\u003e指未列在\u003ccode\u003eentry\u003c/code\u003e中却又要被打包出来的\u003ccode\u003echunk\u003c/code\u003e文件的名称。一般来说，这个\u003ccode\u003echunk\u003c/code\u003e文件指的就是需要\u003cstrong\u003e懒加载\u003c/strong\u003e的代码\u003c/p\u003e\n\u003ch2 id=\"webpackprefetchwebpackpreloadwebpackchunkname\"\u003ewebpackPrefetch/webpackPreload/webpackChunkName\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/* webpackPrefetch: true */\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./path/to/LoginModal.js\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ewebpackChunkName\u003c/code\u003e是为预加载的文件取别名，\u003ccode\u003ewebpackPrefetch\u003c/code\u003e会在浏览器闲置时下载文件，\u003ccode\u003ewebpackPreload\u003c/code\u003e会在父\u003ccode\u003echunk\u003c/code\u003e加载时并行下载文件\u003c/p\u003e\n\u003ch2 id=\"hashchunkhashcontenthash\"\u003ehash/chunkhash/contenthash\u003c/h2\u003e\n\u003cp\u003ehash一般是结合CDN缓存来使用的。如果文件内容改变的话，那么对应文件hash值也会改变，对应的html引用的url地址也会改变，触发cdn服务器从源服务器上拉取对应数据进而更新本地缓存\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehash\u003c/code\u003e是整个项目构建使用的，项目中如果有些变动，hash一定会变，比如说改动了utils.js，index.js里的代码虽然没有改变，但是大家都是用的同一份hash，hash一变，缓存一定会失效，这样子CDN就没有意义了\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003echunkHash\u003c/code\u003e就是解决这个问题的，它根据不同的入口文件(\u003ccode\u003eentry\u003c/code\u003e)进行依赖文件解析、构建对应的chunk，生成对应的hash值。一般用在\u003ccode\u003eoutput\u003c/code\u003e配置上\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econtentHash\u003c/code\u003e计算与文件内容本身有关。一般用在抽离\u003ccode\u003ecss\u003c/code\u003e文件的插件配置上\u003c/p\u003e\n\u003ch2 id=\"sourse-map-中-evalcheapinline\"\u003esourse-map 中 eval/cheap/inline\u003c/h2\u003e\n\u003cp\u003esource-map会生成独立的文件\u003c/p\u003e\n\u003cp\u003echeap-source-map不会产生列映射\u003c/p\u003e\n\u003cp\u003eeval-source-map会以\u003ccode\u003eeval\u003c/code\u003e函数打包运行模块，不产生独立的map文件，会显示报错的行列信息\u003c/p\u003e\n\u003cp\u003einline-source-map映射文件以base64格式编码，加载bundle文件最后，不产生独立的map文件\u003c/p\u003e\n\u003ch2 id=\"loder-vs-plugin\"\u003eloder vs plugin\u003c/h2\u003e\n\u003cp\u003eloder: 文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中\u003c/p\u003e\n\u003cp\u003eplugin: 在webpack运行的生命周期中会广播许多事件，plugin可以监听这些事件，在合适的时机通过调用webpack提供的api改变输出结果\u003c/p\u003e\n\u003ch2 id=\"参考\"\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://mp.weixin.qq.com/s/To_p4eYJx_dkJr1ApcR4jA\"\u003ewebpack 中最易混淆的 5 个知识点\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://webpack.docschina.org\"\u003ewebpack文档\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"webpack复习-易混淆知识点"},"buildId":"nDSJKJkWsKogJoq26OJ5Y","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>