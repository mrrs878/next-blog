<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-React.js学习-useEffect完整指南</title><meta name="next-head-count" content="3"/><link rel="preload" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" as="style"/><link rel="stylesheet" href="/next-blog/_next/static/css/1bf96eec8dc413e7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/next-blog/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/next-blog/_next/static/chunks/webpack-cf185e4b59cdddcf.js" defer=""></script><script src="/next-blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/next-blog/_next/static/chunks/main-1c9e93b8392c1bc9.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/next-blog/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/next-blog/_next/static/chunks/pages/post/%5Btitle%5D-406bad804ceffd1d.js" defer=""></script><script src="/next-blog/_next/static/TVvrPujXTaoFDu5iIhwje/_buildManifest.js" defer=""></script><script src="/next-blog/_next/static/TVvrPujXTaoFDu5iIhwje/_ssgManifest.js" defer=""></script><script src="/next-blog/_next/static/TVvrPujXTaoFDu5iIhwje/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/next-blog">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/next-blog/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/next-blog/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">React.js学习-useEffect完整指南</h1><div class="text-sm space-x-2 text-skin-muted"><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-10-27 15:21:38</span><span><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><blockquote>
<p>原文链接：<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></p>
</blockquote>
<h1 id="每一次渲染都有它自己的">每一次渲染都有它自己的...</h1>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Counter</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
    
    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count+1)}&gt;click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>${ count }<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
        <span class="hljs-comment">// 没做任何特殊事件绑定，只是在渲染时拿取独立的count状态</span>
    )
}
</code></pre>
<ul>
<li>每一次渲染都有它自己的<code>data</code>和<code>props</code></li>
<li>每一次渲染都有它自己的事件处理函数</li>
<li>每一次渲染都有它自己的Effects</li>
<li>每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的<code>props</code>和<code>state</code></li>
<li>当更新状态时，React会重新渲染组件。每一次渲染都能拿到独立的<code>count</code>状态，这个状态值是函数中的一个常量</li>
<li>在单次渲染的范围内，<code>props</code>和<code>state</code>始终保持不变</li>
</ul>
<blockquote>
<p>如果<code>props</code>和<code>state</code>在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的<code>count</code>值。</p>
</blockquote>
<h1 id="组件不要将接收到的参数本地化，或者说使组件完全受控">组件不要将接收到的参数本地化，或者说使组件完全受控</h1>
<p>如果需要对 props 进行加工，可以利用 useMemo 对加工过程进行缓存，仅当依赖变化时才重新执行</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> textColor = <span class="hljs-title function_">useMemo</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">slowlyCalculateTextColor</span>(color),
  [color] <span class="hljs-comment">// ✅ Don’t recalculate until `color` changes</span>
);
</code></pre>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React.js学习-useEffect完整指南","tags":["React.js","Hooks"],"categories":"React.js","description":"\u003e 原文链接：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\n\n# 每一次渲染都有它自己的...\n\n``` jsx\nconst Counter = () =\u003e {\n\tconst [count, setCount] = useState(0)\n    \n    return (\n    \t\u003cbutton onClick=","createDate":"2020-10-27 15:21:38","updateDate":"2020-10-30 18:03:54","body":"\u003cblockquote\u003e\n\u003cp\u003e原文链接：\u003ca href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\"\u003ehttps://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"每一次渲染都有它自己的\"\u003e每一次渲染都有它自己的...\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCounter\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n    \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n        \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u0026gt;\u003c/span\u003e setCount(count+1)}\u0026gt;click me\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n        \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e${ count }\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 没做任何特殊事件绑定，只是在渲染时拿取独立的count状态\u003c/span\u003e\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e每一次渲染都有它自己的\u003ccode\u003edata\u003c/code\u003e和\u003ccode\u003eprops\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e每一次渲染都有它自己的事件处理函数\u003c/li\u003e\n\u003cli\u003e每一次渲染都有它自己的Effects\u003c/li\u003e\n\u003cli\u003e每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的\u003ccode\u003eprops\u003c/code\u003e和\u003ccode\u003estate\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e当更新状态时，React会重新渲染组件。每一次渲染都能拿到独立的\u003ccode\u003ecount\u003c/code\u003e状态，这个状态值是函数中的一个常量\u003c/li\u003e\n\u003cli\u003e在单次渲染的范围内，\u003ccode\u003eprops\u003c/code\u003e和\u003ccode\u003estate\u003c/code\u003e始终保持不变\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果\u003ccode\u003eprops\u003c/code\u003e和\u003ccode\u003estate\u003c/code\u003e在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的\u003ccode\u003ecount\u003c/code\u003e值。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"组件不要将接收到的参数本地化，或者说使组件完全受控\"\u003e组件不要将接收到的参数本地化，或者说使组件完全受控\u003c/h1\u003e\n\u003cp\u003e如果需要对 props 进行加工，可以利用 useMemo 对加工过程进行缓存，仅当依赖变化时才重新执行\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e textColor = \u003cspan class=\"hljs-title function_\"\u003euseMemo\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eslowlyCalculateTextColor\u003c/span\u003e(color),\n  [color] \u003cspan class=\"hljs-comment\"\u003e// ✅ Don’t recalculate until `color` changes\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"React.js学习-useEffect完整指南"},"buildId":"TVvrPujXTaoFDu5iIhwje","assetPrefix":"/next-blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>