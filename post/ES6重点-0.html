<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-ES6重点-0</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/cd72816920092dcb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd72816920092dcb.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/_q5ru5NemgZT2swXpl15Q/_buildManifest.js" defer=""></script><script src="/_next/static/_q5ru5NemgZT2swXpl15Q/_ssgManifest.js" defer=""></script><script src="/_next/static/_q5ru5NemgZT2swXpl15Q/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">ES6重点-0</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2020-02-18 23:43:05</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>10/1/2021, 3:34:43 AM</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write">
      <h2>
        <span class="prefix"></span>
        <span class="content"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a></span>
        <span class="suffix"></span>
      </h2>
    <p><code>Proxy</code>用于<strong>修改某些操作的默认行为</strong>，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。<code>Proxy</code>可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a></span>
        <span class="suffix"></span>
      </h2>
    <p>**WHAT **😳</p>
<p>ES6为了<strong>操作对象</strong>而提供的新的API</p>
<p><strong>WHY</strong>   🤔</p>
<ol>
<li>将<code>Object</code>对象的一些明显是语语言内部的方法（比如<code>Object.defineProperty</code>）放到<code>Reflect</code>对象上，现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></li>
<li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为</li>
<li><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为</li>
</ol>
<p><strong>HOW</strong>  😮</p>
<p><code>Reflect</code>对象一共有13个静态方法</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 适用于函数定义了自己的 apply 方法</span>
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, thisArg, args)
<span class="hljs-comment">// 等同于new target(...args) 这提供了一种不使用 new 来调用构造函数的方法</span>
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(target, args)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, name, receiver)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, name, value, receiver)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, name, desc)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, name)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, name)
<span class="hljs-comment">// 基本等同于Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和</span>
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(target)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">prevenExtensions</span>(target)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(target, name)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(target)

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(target, prototype)
</code></pre>
<p><code>Reflect</code> + <code>Proxy</code>实现观察者模式</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()
<span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">fn</span>) {
  observers.<span class="hljs-title function_">add</span>(fn)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">observable</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) {
      <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)
      observers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> <span class="hljs-title function_">observer</span>())
      <span class="hljs-keyword">return</span> result
    }
  })
}

<span class="hljs-keyword">const</span> person = <span class="hljs-title function_">observable</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;tom&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>
})
<span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${ person.name }</span>, <span class="hljs-subst">${ person.age }</span>`</span>)
}
<span class="hljs-title function_">observe</span>(print)
person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;tom1&quot;</span> 
</code></pre>
<p>📣 在观察者模式中，观察者是知道被观察者的，被观察者一一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过消息代理进行通信。在发布订阅模式中，组件时松散耦合的，正和观察者模式相反。观察者模式大多时候是同步的，比如当事件触发，被观察者就会调用观察者的方法；而发布订阅模式大多时候是异步的（使用消息队列）</p>

      <h2>
        <span class="prefix"></span>
        <span class="content"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a></span>
        <span class="suffix"></span>
      </h2>
    <p><strong>WHAT</strong> 😳</p>
<p><code>ES6</code>引入的一种新的原始数据类型，表示<strong>独一无二</strong>的值。它是<code>JavaScript</code>语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Object</code>、<code>Number</code></p>
<p>📣 不支持 <code>new Symbol()</code></p>
<p><strong>WHY</strong>   🤔</p>
<p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。Symbol值可作为对象属性名</p>
<p><strong>HOW</strong>   😮</p>
<p>Symbol值通过<code>Symbol</code>函数生成</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nameProperty = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>)
<span class="hljs-keyword">let</span> a = {
  [nameProperty]: <span class="hljs-string">&quot;a&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">21</span>
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(a))
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> a) {
  <span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
    <span class="hljs-keyword">const</span> element = a[key];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);
  }
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(a));
</code></pre>
<p>API:</p>
<ul>
<li><p><code>Symbol.description</code></p>
<p>创建<code>Symbol</code>的时候，可以添加一个描述，但读取这个描述需要将<code>Symbol</code>显式转为字符串。<code>Symbol.description</code>可以方便的读取<code>Symbol</code>对应的描述</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nameProp = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>)
nameProp.<span class="hljs-title function_">toString</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nameProp.<span class="hljs-property">description</span>)
</code></pre>
</li>
<li><p><code>Symbol.for</code></p>
<p>重新使用同一个<code>Symbol</code>值。<code>Symbol.for</code>接受一个字符串作为参数，然后<strong>全局搜索</strong>有没有以该参数作为名称的Symbol值，若有，返回之；若没有，创建之</p>
<p><code>Symbol.for(&quot;name&quot;)</code>和<code>Symbol(&quot;name&quot;)</code>的区别：两者都会生成<code>Symbol</code>值；前者会被登记在<strong>全局</strong>环境中供搜索，后者不会</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>) === <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>)
<span class="hljs-comment">// false</span>
<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>) === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>)
<span class="hljs-comment">// true</span>
</code></pre>
</li>
<li><p><code>Symbol.keyFor</code></p>
<p>返回一个已<strong>登记</strong>的<code>Symbol</code>的<code>key</code></p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>)));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>)));
<span class="hljs-comment">// undefined</span>
<span class="hljs-comment">// name</span>
</code></pre>
</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">Set</span>
        <span class="suffix"></span>
      </h2>
    <p><strong>WHAT</strong> 😳</p>
<p>ES6提供的一种数据结构，类似于数组，但成员的值都是唯一的，没有重复的值</p>
<p>Set使用一种类似于<code>===</code>的算法“Same-value-zero equality”来判断值是否相等</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// &quot;5&quot; 和 5 不相等</span>
<span class="hljs-comment">// NaN 和 NaN 相等</span>
<span class="hljs-comment">// 两个空对象不相等</span>
<span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()
set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;5&quot;</span>)
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>)
set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>)
set.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">NaN</span>)
set.<span class="hljs-title function_">add</span>({})
set.<span class="hljs-title function_">add</span>({})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set);
<span class="hljs-comment">// Set { &#x27;5&#x27;, 5, NaN, {}, {} }</span>
</code></pre>
<p><strong>WHY</strong>   🤔</p>
<ul>
<li>可以用作数组去重<code>[...new Set([1, 1, 2, 2, 3])]</code></li>
<li>去除字符串里面的重复字符<code>[...new Set(&#39;aaabbbc&#39;)].join(&quot;&quot;)</code></li>
</ul>
<p><strong>HOW</strong>   😮</p>
<p><code>Set</code>函数可以接受一个数组（或<strong>具有interable接口</strong>的其他数据结构）作为参数，用来初始化</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">Map</span>
        <span class="suffix"></span>
      </h2>
    <p><strong>WHAT</strong> 😳</p>
<p>ES6提供的一种数据结构，类似于对象，也是键-值对的集合，但键的范围不限于字符串，各章类型的值（包括对象）都可以作为键</p>
<p><strong>WHY</strong>   🤔</p>
<p>传统上的Object只能用字符串（[Symbol](## Symbol)）作为键，这给它的使用带来了很大的限制</p>
<p>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性和原作者的属性同名</p>
<p><strong>HOW</strong>   😮</p>
<p>使用 <code>new Map</code> 来创建Map</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-number">2</span>, <span class="hljs-string">&quot;2&quot;</span>]])
map.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;1&quot;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-number">2</span>));
</code></pre>
<p>事实上，不仅仅是数组，任何具有<code>iterator</code>接口、且每个成员都是一个双元素的数组的数据结构都可以作为<code>Map</code>构造函数的参数</p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ES6重点-0","tags":["ES6"],"categories":"JavaScript","description":"## [Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n\n`Proxy`用于**修改某些操作的默认行为**，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。`Proxy`可以理解成在目标对象之前架设一层","createDate":"2020-02-18 23:43:05","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\"\u003eProxy\u003c/a\u003e\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ccode\u003eProxy\u003c/code\u003e用于\u003cstrong\u003e修改某些操作的默认行为\u003c/strong\u003e，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。\u003ccode\u003eProxy\u003c/code\u003e可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\"\u003eReflect\u003c/a\u003e\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e**WHAT **😳\u003c/p\u003e\n\u003cp\u003eES6为了\u003cstrong\u003e操作对象\u003c/strong\u003e而提供的新的API\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWHY\u003c/strong\u003e   🤔\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将\u003ccode\u003eObject\u003c/code\u003e对象的一些明显是语语言内部的方法（比如\u003ccode\u003eObject.defineProperty\u003c/code\u003e）放到\u003ccode\u003eReflect\u003c/code\u003e对象上，现阶段，某些方法同时在\u003ccode\u003eObject\u003c/code\u003e和\u003ccode\u003eReflect\u003c/code\u003e对象上部署，未来的新方法只部署在\u003ccode\u003eReflect\u003c/code\u003e对象上。也就是说，从\u003ccode\u003eReflect\u003c/code\u003e对象上可以拿到语言内部的方法\u003c/li\u003e\n\u003cli\u003e修改某些\u003ccode\u003eObject\u003c/code\u003e方法的返回结果，让其变得更合理。比如\u003ccode\u003eObject.defineProperty(obj, name, desc)\u003c/code\u003e在无法定义属性时，会抛出一个错误，而\u003ccode\u003eReflect.defineProperty(obj, name, desc)\u003c/code\u003e则会返回\u003ccode\u003efalse\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e让\u003ccode\u003eObject\u003c/code\u003e操作都变成函数行为。某些\u003ccode\u003eObject\u003c/code\u003e操作是命令式，比如\u003ccode\u003ename in obj\u003c/code\u003e和\u003ccode\u003edelete obj[name]\u003c/code\u003e，而\u003ccode\u003eReflect.has(obj, name)\u003c/code\u003e和\u003ccode\u003eReflect.deleteProperty(obj, name)\u003c/code\u003e让它们变成了函数行为\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReflect\u003c/code\u003e对象的方法与\u003ccode\u003eProxy\u003c/code\u003e对象的方法一一对应，这就让\u003ccode\u003eProxy\u003c/code\u003e对象可以方便地调用对应的\u003ccode\u003eReflect\u003c/code\u003e方法，完成默认行为\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eHOW\u003c/strong\u003e  😮\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReflect\u003c/code\u003e对象一共有13个静态方法\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 适用于函数定义了自己的 apply 方法\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(target, thisArg, args)\n\u003cspan class=\"hljs-comment\"\u003e// 等同于new target(...args) 这提供了一种不使用 new 来调用构造函数的方法\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econstruct\u003c/span\u003e(target, args)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(target, name, receiver)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(target, name, value, receiver)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edefineProperty\u003c/span\u003e(target, name, desc)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edeleteProperty\u003c/span\u003e(target, name)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(target, name)\n\u003cspan class=\"hljs-comment\"\u003e// 基本等同于Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eownKeys\u003c/span\u003e(target)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisExtensible\u003c/span\u003e(target)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprevenExtensions\u003c/span\u003e(target)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetOwnPropertyDescriptor\u003c/span\u003e(target, name)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPrototypeOf\u003c/span\u003e(target)\n\n\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetPrototypeOf\u003c/span\u003e(target, prototype)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eReflect\u003c/code\u003e + \u003ccode\u003eProxy\u003c/code\u003e实现观察者模式\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e observers = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobserve\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efn\u003c/span\u003e) {\n  observers.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(fn)\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobservable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProxy\u003c/span\u003e(obj, {\n    \u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etarget, key, value, receiver\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(target, key, value, receiver)\n      observers.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobserver\u003c/span\u003e())\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result\n    }\n  })\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e person = \u003cspan class=\"hljs-title function_\"\u003eobservable\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;tom\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${ person.name }\u003c/span\u003e, \u003cspan class=\"hljs-subst\"\u003e${ person.age }\u003c/span\u003e`\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-title function_\"\u003eobserve\u003c/span\u003e(print)\nperson.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026quot;tom1\u0026quot;\u003c/span\u003e \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e📣 在观察者模式中，观察者是知道被观察者的，被观察者一一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过消息代理进行通信。在发布订阅模式中，组件时松散耦合的，正和观察者模式相反。观察者模式大多时候是同步的，比如当事件触发，被观察者就会调用观察者的方法；而发布订阅模式大多时候是异步的（使用消息队列）\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\"\u003eSymbol\u003c/a\u003e\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003cstrong\u003eWHAT\u003c/strong\u003e 😳\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eES6\u003c/code\u003e引入的一种新的原始数据类型，表示\u003cstrong\u003e独一无二\u003c/strong\u003e的值。它是\u003ccode\u003eJavaScript\u003c/code\u003e语言的第七种数据类型，前六种是：\u003ccode\u003eundefined\u003c/code\u003e、\u003ccode\u003enull\u003c/code\u003e、\u003ccode\u003eBoolean\u003c/code\u003e、\u003ccode\u003eString\u003c/code\u003e、\u003ccode\u003eObject\u003c/code\u003e、\u003ccode\u003eNumber\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e📣 不支持 \u003ccode\u003enew Symbol()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWHY\u003c/strong\u003e   🤔\u003c/p\u003e\n\u003cp\u003eES5的对象属性名都是字符串，这容易造成属性名的冲突。Symbol值可作为对象属性名\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHOW\u003c/strong\u003e   😮\u003c/p\u003e\n\u003cp\u003eSymbol值通过\u003ccode\u003eSymbol\u003c/code\u003e函数生成\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nameProperty = \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = {\n  [nameProperty]: \u003cspan class=\"hljs-string\"\u003e\u0026quot;a\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetOwnPropertyNames\u003c/span\u003e(a))\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e a) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (a.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(key)) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = a[key];\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(key);\n  }\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eownKeys\u003c/span\u003e(a));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAPI:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eSymbol.description\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e创建\u003ccode\u003eSymbol\u003c/code\u003e的时候，可以添加一个描述，但读取这个描述需要将\u003ccode\u003eSymbol\u003c/code\u003e显式转为字符串。\u003ccode\u003eSymbol.description\u003c/code\u003e可以方便的读取\u003ccode\u003eSymbol\u003c/code\u003e对应的描述\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nameProp = \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e)\nnameProp.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(nameProp.\u003cspan class=\"hljs-property\"\u003edescription\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eSymbol.for\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e重新使用同一个\u003ccode\u003eSymbol\u003c/code\u003e值。\u003ccode\u003eSymbol.for\u003c/code\u003e接受一个字符串作为参数，然后\u003cstrong\u003e全局搜索\u003c/strong\u003e有没有以该参数作为名称的Symbol值，若有，返回之；若没有，创建之\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSymbol.for(\u0026quot;name\u0026quot;)\u003c/code\u003e和\u003ccode\u003eSymbol(\u0026quot;name\u0026quot;)\u003c/code\u003e的区别：两者都会生成\u003ccode\u003eSymbol\u003c/code\u003e值；前者会被登记在\u003cstrong\u003e全局\u003c/strong\u003e环境中供搜索，后者不会\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e) === \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e) === \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eSymbol.keyFor\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e返回一个已\u003cstrong\u003e登记\u003c/strong\u003e的\u003ccode\u003eSymbol\u003c/code\u003e的\u003ccode\u003ekey\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeyFor\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e)));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeyFor\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;name\u0026quot;\u003c/span\u003e)));\n\u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// name\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eSet\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003cstrong\u003eWHAT\u003c/strong\u003e 😳\u003c/p\u003e\n\u003cp\u003eES6提供的一种数据结构，类似于数组，但成员的值都是唯一的，没有重复的值\u003c/p\u003e\n\u003cp\u003eSet使用一种类似于\u003ccode\u003e===\u003c/code\u003e的算法“Same-value-zero equality”来判断值是否相等\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;5\u0026quot; 和 5 不相等\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// NaN 和 NaN 相等\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 两个空对象不相等\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e set = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e()\nset.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;5\u0026quot;\u003c/span\u003e)\nset.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\nset.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eNaN\u003c/span\u003e)\nset.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eNaN\u003c/span\u003e)\nset.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e({})\nset.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e({})\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(set);\n\u003cspan class=\"hljs-comment\"\u003e// Set { \u0026#x27;5\u0026#x27;, 5, NaN, {}, {} }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWHY\u003c/strong\u003e   🤔\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以用作数组去重\u003ccode\u003e[...new Set([1, 1, 2, 2, 3])]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e去除字符串里面的重复字符\u003ccode\u003e[...new Set(\u0026#39;aaabbbc\u0026#39;)].join(\u0026quot;\u0026quot;)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eHOW\u003c/strong\u003e   😮\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSet\u003c/code\u003e函数可以接受一个数组（或\u003cstrong\u003e具有interable接口\u003c/strong\u003e的其他数据结构）作为参数，用来初始化\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eMap\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003cstrong\u003eWHAT\u003c/strong\u003e 😳\u003c/p\u003e\n\u003cp\u003eES6提供的一种数据结构，类似于对象，也是键-值对的集合，但键的范围不限于字符串，各章类型的值（包括对象）都可以作为键\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWHY\u003c/strong\u003e   🤔\u003c/p\u003e\n\u003cp\u003e传统上的Object只能用字符串（[Symbol](## Symbol)）作为键，这给它的使用带来了很大的限制\u003c/p\u003e\n\u003cp\u003eMap的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性和原作者的属性同名\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHOW\u003c/strong\u003e   😮\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003enew Map\u003c/code\u003e 来创建Map\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e map = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e([[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;2\u0026quot;\u003c/span\u003e]])\nmap.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;1\u0026quot;\u003c/span\u003e)\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(map.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e事实上，不仅仅是数组，任何具有\u003ccode\u003eiterator\u003c/code\u003e接口、且每个成员都是一个双元素的数组的数据结构都可以作为\u003ccode\u003eMap\u003c/code\u003e构造函数的参数\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"ES6重点-0"},"buildId":"_q5ru5NemgZT2swXpl15Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>