<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-React.js学习-一文梳理 React 18 新特性(转载)</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-3eff910f6206cfe7.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-d89e1712c82a34ac.js" defer=""></script><script src="/_next/static/12dVnEXE3Ni1Q4e6nG_vn/_buildManifest.js" defer=""></script><script src="/_next/static/12dVnEXE3Ni1Q4e6nG_vn/_ssgManifest.js" defer=""></script><script src="/_next/static/12dVnEXE3Ni1Q4e6nG_vn/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">React.js学习-一文梳理 React 18 新特性(转载)</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2022-05-16 22:23:31</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2022-05-16 22:38:14</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write"><p>转载自: <a href="https://blog.csdn.net/qq_41257129/article/details/123371328">https://blog.csdn.net/qq_41257129/article/details/123371328</a></p>
<p>React 的迭代过程</p>
<p>React 从 v16 到 v18 主打的特性包括三个变化：</p>
<ul>
<li>v16: Async Mode (异步模式)</li>
<li>v17: Concurrent Mode (并发模式)</li>
<li>v18: Concurrent Render (并发更新)</li>
</ul>
<p>React 中 <code>Fiber</code> 树的更新流程分为两个阶段 <code>render</code> 阶段和 <code>commit</code> 阶段。组件的 <code>render</code> 函数执行时称为 <code>render</code> （本次更新需要做哪些变更），纯 js 计算；而将 <code>render</code> 的结果渲染到页面的过程称为 <code>commit</code> （变更到真实的宿主环境中，在浏览器中就是操作 DOM）。</p>
<p>在 Sync 模式下， <code>render</code> 阶段是一次性执行完成；而在 <code>Concurrent</code> 模式下 <code>render</code> 阶段可以被拆解，每个时间片内执行一部分，直到执行完毕。由于 <code>commit</code> 阶段有 DOM 的更新，不可能让 DOM 更新到一半中断，必须一次性执行完毕。</p>
<ul>
<li>Async Mode: 让 render 变为异步、可中断的。</li>
<li>Concurrent Mode : 让 commit 在用户的感知上是并发的。</li>
<li>Concurrent Render : Concurrent Mode 中包含 breaking change，比如很多库不兼容（mobx 等），所以 v18 提出了 Concurrent Render ，减少了开发者的迁移成本。</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">React 并发新特性</span>
        <span class="suffix"></span>
      </h2>
    <p>并发渲染机制（concurrent rendering）的目的：根据用户的设备性能和网速对渲染过程进行适当的调整， 保证 React 应用在长时间的渲染过程中依旧保持可交互性，避免页面出现卡顿或无响应的情况，从而提升用户体验。</p>
<p>v18 正式引入了的并发渲染机制，并基于此给我们带来了很多新特性。这些新特性都是可选的并发功能，使用了这些新特性的组件并能触发并发渲染，并且与其整个子树都将自动开启 <code>strictMode</code> 。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">新 root API</span>
        <span class="suffix"></span>
      </h2>
    <p>v18 之前 root 节点对用户不透明。</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>
​
<span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>)
<span class="hljs-comment">// v18 之前的方法</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>,root)
v18 中我们可以通过 createRoot <span class="hljs-title class_">Api</span> 手动创建 root 节点。

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>
​
<span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>))
<span class="hljs-comment">// v18 的新方法</span>
root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>,root)
</code></pre>
<p>想要使用 v18 中其他新特性 API， 前提是要使用新的 Root API 来创建根节点。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">Automatic batching 自动批处理优化</span>
        <span class="suffix"></span>
      </h2>
    <p>批处理： React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 <code>setState</code> 事件合并）</p>
<p>在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 <code>promise</code> 链、 <code>setTimeout</code> 等异步代码以及原生事件处理函数。</p>
<pre><code class="hljs language-JSX"><span class="hljs-comment">// v18 之前</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span> () {

  <span class="hljs-title function_">fetchSomething</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {

      <span class="hljs-comment">// React 17 及之前的版本不会批处理以下的 state:</span>
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>) <span class="hljs-comment">// 重新渲染</span>
      <span class="hljs-title function_">setFlag</span>(<span class="hljs-function">(<span class="hljs-params">f</span>) =&gt;</span> !f) <span class="hljs-comment">// 二次重新渲染</span>
    })
}
<span class="hljs-comment">// v18下</span>
<span class="hljs-comment">// 1、promise链中</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span> () {

  <span class="hljs-title function_">fetchSomething</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {

      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>)
      <span class="hljs-title function_">setFlag</span>(<span class="hljs-function">(<span class="hljs-params">f</span>) =&gt;</span> !f) <span class="hljs-comment">// 合并为一次重新渲染</span>
    })
}
<span class="hljs-comment">// 2、setTimeout等异步代码中</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {

  <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>)
  <span class="hljs-title function_">setFlag</span>(<span class="hljs-function">(<span class="hljs-params">f</span>) =&gt;</span> !f) <span class="hljs-comment">// 合并为一次重新渲染</span>
}, <span class="hljs-number">5000</span>)
<span class="hljs-comment">// 3、原生事件中</span>
element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> {

<span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> c + <span class="hljs-number">1</span>)
  <span class="hljs-title function_">setFlag</span>(<span class="hljs-function">(<span class="hljs-params">f</span>) =&gt;</span> !f) <span class="hljs-comment">// 合并为一次重新渲染</span>
})
</code></pre>
<p>如果想退出自动批处理立即更新的话，可以使用 <code>ReactDOM.flushSync()</code> 进行包裹。</p>
<pre><code class="hljs language-JSX"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>
​
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span> () {

  <span class="hljs-comment">// 立即更新</span>
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {

    <span class="hljs-title function_">setCounter</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>)
  })
  <span class="hljs-comment">// 立即更新</span>
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> {

    <span class="hljs-title function_">setFlag</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> !f)
  })
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">startTransition</span>
        <span class="suffix"></span>
      </h2>
    <p>可以用来降低渲染优先级。分别用来包裹计算量大的 <code>function</code> 和 <code>value</code> ，降低优先级，减少重复渲染次数。</p>
<p>举个例子：搜索引擎的关键词联想。一般来说，对于用户在输入框中输入都希望是实时更新的，如果此时联想词比较多同时也要实时更新的话，这就可能会导致用户的输入会卡顿。这样一来用户的体验会变差，这并不是我们想要的结果。</p>
<p>我们将这个场景的状态更新提取出来：一个是用户输入的更新；一个是联想词的更新。这个两个更新紧急程度显然前者大于后者。</p>
<p>以前我们可以使用防抖的操作来过滤不必要的更新，但防抖有一个弊端，当我们长时间的持续输入（时间间隔小于防抖设置的时间），页面就会长时间都不到响应。而 <code>startTransition</code> 可以指定 UI 的渲染优先级，哪些需要实时更新，哪些需要延迟更新。即使用户长时间输入最迟 5s 也会更新一次，官方还提供了 hook 版本的 <code>useTransition</code> ，接受传入一个毫秒的参数用来修改最迟更新时间，返回一个过渡期的 <code>pending</code> 状态和 <code>startTransition</code> 函数。</p>
<pre><code class="hljs language-JSX"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;
​
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {

  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>();
  <span class="hljs-keyword">const</span> [searchQuery, setSearchQuery] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>([]);
  <span class="hljs-keyword">const</span> [loading, startTransition] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useTransition</span>(<span class="hljs-number">2000</span>);
​
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; {

    <span class="hljs-title function_">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
    <span class="hljs-comment">// 延迟更新</span>
    <span class="hljs-title function_">startTransition</span>(<span class="hljs-function">() =&gt;</span> {

      <span class="hljs-title function_">setSearchQuery</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">20000</span>).<span class="hljs-title function_">fill</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>));
    });
  };
​
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">value</span>} <span class="hljs-attr">onChange</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">handleChange</span>} /&gt;</span>
      {
    loading ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      ) : (
        searchQuery.map((item, index) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">index</span>}&gt;</span>{
    item}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>)
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>所有在 <code>startTransition</code> 回调中更新的都会被认为是非紧急处理，如果一旦出现更紧急的处理（比如这里的用户输入）， <code>startTransition</code> 就会中断之前的更新，只会渲染最新一次的状态更新。</p>
<p><code>startTransition</code> 的原理就是利用了 React 底层的优先级调度模型。</p>
<p>更多例子： <a href="https://github.com/reactwg/react-18/discussions/65">真实世界示例：为慢速渲染添加 startTransition</a></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">SSR 下的 Suspense 组件</span>
        <span class="suffix"></span>
      </h2>
    <p><code>Suspense</code> 的作用： 划分页面中需要并发渲染的部分。</p>
<p><code>hydration</code>[水化]：ssr 时服务器输出的是字符串（html），客户端（一般是浏览器）根据这些字符串并结合加载的 JavaScript 来完成 React 的初始化工作这一阶段为水化。</p>
<p>React v18 之前的 SSR， 客户端必须一次性的等待 HTML 数据加载到服务器上并且等待所有 JavaScript 加载完毕之后再开始 <code>hydration</code> ， 等待所有组件 <code>hydration</code> 后，才能进行交互。即整个过程需要完成从获取数据（服务器）→ 渲染到 HTML（服务器）→ 加载代码（客户端）→ 水合物（客户端）这一套流程。这样的 SSR 并不能使我们的完全可交互变快，只是提高了用户的感知静态页面内容的速度。</p>
<p>React v18 在 SSR 下支持了 <code>Suspense</code> ，最大的区别是什么呢？</p>
<ol>
<li><p>服务器不需要等待被 Suspense 包裹组件是否加载到完毕，即可发送 HTML，而代替 suspense 包裹的组件是 fallback 中的内容，一般是一个占位符（spinner），以最小内联<script>标签标记此 HTML 的位置。等待服务器上组件的数据准备好后，React 再将剩余的 HTML 发送到同一个流中。</p>
</li>
<li><p>hydration 的过程是逐步的，不需要等待所有的 js 加载完毕再开始 hydration，避免了页面的卡顿。</p>
</li>
<li><p>React 会提前监听页面上交互事件（如鼠标的点击），对发生交互的区域优先级进行 hydration。</p>
</li>
</ol>
<p><a href="https://github.com/reactwg/react-18/discussions/37">https://github.com/reactwg/react-18/discussions/37</a></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">useSyncExternalStore</span>
        <span class="suffix"></span>
      </h2>
    <p>这个 API 可以防止在 <code>concurrent</code> 模式下，任务中断后第三方 <code>store</code> 被修改，恢复任务时出现 <code>tearing</code> 从而数据不一致问题。用户一般很少使用，大多情况下提供给像 Redux 这样的状态管理库使用，通过 <code>useSyncExternalStore</code> 可以使 React 在 <code>concurrent mode</code> 下，保持自身 <code>state</code> 和来自 Redux 的状态同步。</p>
<pre><code class="hljs language-JSX"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
​
<span class="hljs-comment">// 基础用法，getSnapshot 返回一个缓存的值</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useSyncExternalStore</span>(store.<span class="hljs-property">subscribe</span>, store.<span class="hljs-property">getSnapshot</span>)
​
<span class="hljs-comment">// 根据数据字段，使用内联的 getSnapshot 返回缓存的数据</span>
<span class="hljs-keyword">const</span> selectedField = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useSyncExternalStore</span>(store.<span class="hljs-property">subscribe</span>, <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">getSnapshot</span>().<span class="hljs-property">selectedField</span>)
</code></pre>
<ul>
<li>第一个参数是一个订阅函数，订阅触发时会引起该组件的更新。</li>
<li>第二个函数返回一个 immutable 快照， 返回值是我们想要订阅的数据，只有数据发生变化时才需要重新渲染。</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">useInsertionEffect</span>
        <span class="suffix"></span>
      </h2>
    <p>这个 hook 对现有的专为 React 设计的 css-in-js 库有着很大的作用，可以动态生成新规则与<code>&lt;style&gt;</code>标签一起插入到文档中。</p>
<p>假设现在我们要插入一段 css ，并且将这个操作放在渲染期间去执行。</p>
<pre><code class="hljs language-JSX"><span class="hljs-keyword">function</span> <span class="hljs-title function_">css</span>(<span class="hljs-params">rule</span>) {

  <span class="hljs-keyword">if</span> (!isInserted.<span class="hljs-title function_">has</span>(rule)) {

    isInserted.<span class="hljs-title function_">add</span>(rule)
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">getStyleForRule</span>(rule))
  }
  <span class="hljs-keyword">return</span> rule
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) {

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">css</span>(&#x27;<span class="hljs-attr">...</span>&#x27;)} /&gt;</span></span>
}
</code></pre>
<p>这样会导致每次修改 css 样式时，react 需要在渲染的每一帧中对所有的节点重新计算所有 CSS 规则，这并不是我们想要的结果。</p>
<p>那我们是不是可以在所有 DOM 生成前就插入这些 css 样式，此时我们可能会想到 <code>useLayoutEffect</code> ，但 <code>useLayoutEffect</code> 中可以访问 DOM，如果在这个 hook 中访问了某个 DOM 的布局样式（比如<code>clientWidth</code>），这样会导致我们读取的信息是错误的。</p>
<pre><code class="hljs language-JSX">useLayoutEffect ( <span class="hljs-function">( )  =&gt;</span>  {

  <span class="hljs-keyword">if</span>  ( ref.<span class="hljs-property">current</span>.<span class="hljs-property">clientWidth</span>  &lt;  <span class="hljs-number">100</span> )  {

    setCollapsed ( <span class="hljs-literal">true</span> ) ;
  }
} ) ;
useInsertionEffect 可以帮助我们避免上述问题 ，既可以满足在所有 <span class="hljs-variable constant_">DOM</span> 生成前插入并且不访问 <span class="hljs-variable constant_">DOM</span>。其工作原理大致与 useLayoutEffect 相同，只是此时没法访问 <span class="hljs-variable constant_">DOM</span>节点的引用。我们可以在这个 hook 中插入全局的<span class="hljs-variable constant_">DOM</span>节点，比如如&lt;style&gt; ，或<span class="hljs-variable constant_">SVG</span>&lt;defs&gt; 。

<span class="hljs-keyword">const</span> <span class="hljs-attr">useCSS</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">(<span class="hljs-params">rule</span>) =&gt;</span> {

  <span class="hljs-title function_">useInsertionEffect</span>(<span class="hljs-function">() =&gt;</span> {

    <span class="hljs-keyword">if</span> (!isInserted.<span class="hljs-title function_">has</span>(rule)) {

      isInserted.<span class="hljs-title function_">add</span>(rule)
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">getStyleForRule</span>(rule))
    }
  })
  <span class="hljs-keyword">return</span> rule
}
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Component</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {

  <span class="hljs-keyword">let</span> className = <span class="hljs-title function_">useCSS</span>(rule)
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">className</span>} /&gt;</span></span>
}
</code></pre>
<p><a href="https://github.com/reactwg/react-18/discussions/110">https://github.com/reactwg/react-18/discussions/110</a></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">useId</span>
        <span class="suffix"></span>
      </h2>
    <p>React 一直在向着 SSR 的领域发展，但 SSR 渲染必须保证客户端与服务端生成的 HTML 结构相匹配。我们平时使用的如 <code>Math.random()</code> 在 SSR 面前是没法保证客户端与服务端之间的 <code>id</code> 唯一性。</p>
<p>React 为了解决这个问题，提出来 <code>useOpaqueIdentifier</code> 这个 hook, 不过它在不同环境会产生不同的结果.</p>
<ul>
<li><p>在服务端会生成一个字符串</p>
</li>
<li><p>在客户端会生成一个对象，必须直接传递给 DOM 属性</p>
</li>
</ul>
<p>这样一来，在客户端如果需要生成多个标识，就需要调多次这个 hook，因为它不支持转化为字符串，就无法使用字符串拼接。</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {

  <span class="hljs-keyword">const</span> tabIdOne = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">unstable_useOpaqueIdentifier</span>();
  <span class="hljs-keyword">const</span> panelIdOne = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">unstable_useOpaqueIdentifier</span>();
  <span class="hljs-keyword">const</span> tabIdTwo = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">unstable_useOpaqueIdentifier</span>();
  <span class="hljs-keyword">const</span> panelIdTwo = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">unstable_useOpaqueIdentifier</span>();
​
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Tabs</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;tablist&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Tab</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">tabIdOne</span>} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
            One
          <span class="hljs-tag">&lt;/<span class="hljs-name">Tab</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Tab</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">tabIdTwo</span>} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
            One
          <span class="hljs-tag">&lt;/<span class="hljs-name">Tab</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TabPanel</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">panelIdOne</span>} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
          Content One
        <span class="hljs-tag">&lt;/<span class="hljs-name">TabPanel</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TabPanel</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>
    <span class="hljs-attr">panelIdTwo</span>} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>
          Content Two
        <span class="hljs-tag">&lt;/<span class="hljs-name">TabPanel</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Tabs</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
  );
}
</code></pre>
<p>而 <code>useId</code> 可以生成客户端与服务端之间的唯一 <code>id</code> ，并且返回一个字符串。这样一个组件可以只需调用一次 <code>useId</code> ，并将其结果作为整个组件所需的标识符基础（比如拼接不同的字符串），以便生成唯一 <code>id</code> 。</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> id = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useId</span>();
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Tabs</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;tablist&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Tab</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">id</span>}<span class="hljs-attr">tab1</span>`} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
            One
          <span class="hljs-tag">&lt;/<span class="hljs-name">Tab</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Tab</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">id</span>}<span class="hljs-attr">tab2</span>`} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
            One
          <span class="hljs-tag">&lt;/<span class="hljs-name">Tab</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TabPanel</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">id</span>}<span class="hljs-attr">panel1</span>`} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>
          Content One
        <span class="hljs-tag">&lt;/<span class="hljs-name">TabPanel</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TabPanel</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">id</span>}<span class="hljs-attr">panel2</span>`} <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>
          Content Two
        <span class="hljs-tag">&lt;/<span class="hljs-name">TabPanel</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Tabs</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
  );
};
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">useDefferdValue</span>
        <span class="suffix"></span>
      </h2>
    <p>React 可以通过 <code>useDefferdValue</code> 允许变量延时更新，同时接受一个可选的延迟更新的最大值。React 将尝试尽快更新延迟值，如果在给定的 <code>timeoutMs</code> 期限内未能完成，它将强制更新。</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> defferValue = <span class="hljs-title function_">useDeferredValue</span>(value, {
  <span class="hljs-attr">timeoutMs</span>: <span class="hljs-number">1000</span>,
});
</code></pre>
<p><code>useDefferdValue</code> 能够很好的展现并发渲染时优先级调整的特性，可以用于延迟计算逻辑比较复杂的状态，让其他组件优先渲染，等待这个状态更新完毕之后再渲染。</p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>2024</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React.js学习-一文梳理 React 18 新特性(转载)","tags":["React.js学习","React.js18"],"categories":"React.js","description":"转载自: https://blog.csdn.net/qq_41257129/article/details/123371328\n\nReact 的迭代过程\n\nReact 从 v16 到 v18 主打的特性包括三个变化：\n\n- v16: Async Mode (异步模式)\n- v17: Concurrent Mode (并发模式)\n- v18: Concurrent Render (并发更新)","createDate":"2022-05-16 22:23:31","updateDate":"2022-05-16 22:38:14","body":"\u003cp\u003e转载自: \u003ca href=\"https://blog.csdn.net/qq_41257129/article/details/123371328\"\u003ehttps://blog.csdn.net/qq_41257129/article/details/123371328\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eReact 的迭代过程\u003c/p\u003e\n\u003cp\u003eReact 从 v16 到 v18 主打的特性包括三个变化：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ev16: Async Mode (异步模式)\u003c/li\u003e\n\u003cli\u003ev17: Concurrent Mode (并发模式)\u003c/li\u003e\n\u003cli\u003ev18: Concurrent Render (并发更新)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReact 中 \u003ccode\u003eFiber\u003c/code\u003e 树的更新流程分为两个阶段 \u003ccode\u003erender\u003c/code\u003e 阶段和 \u003ccode\u003ecommit\u003c/code\u003e 阶段。组件的 \u003ccode\u003erender\u003c/code\u003e 函数执行时称为 \u003ccode\u003erender\u003c/code\u003e （本次更新需要做哪些变更），纯 js 计算；而将 \u003ccode\u003erender\u003c/code\u003e 的结果渲染到页面的过程称为 \u003ccode\u003ecommit\u003c/code\u003e （变更到真实的宿主环境中，在浏览器中就是操作 DOM）。\u003c/p\u003e\n\u003cp\u003e在 Sync 模式下， \u003ccode\u003erender\u003c/code\u003e 阶段是一次性执行完成；而在 \u003ccode\u003eConcurrent\u003c/code\u003e 模式下 \u003ccode\u003erender\u003c/code\u003e 阶段可以被拆解，每个时间片内执行一部分，直到执行完毕。由于 \u003ccode\u003ecommit\u003c/code\u003e 阶段有 DOM 的更新，不可能让 DOM 更新到一半中断，必须一次性执行完毕。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAsync Mode: 让 render 变为异步、可中断的。\u003c/li\u003e\n\u003cli\u003eConcurrent Mode : 让 commit 在用户的感知上是并发的。\u003c/li\u003e\n\u003cli\u003eConcurrent Render : Concurrent Mode 中包含 breaking change，比如很多库不兼容（mobx 等），所以 v18 提出了 Concurrent Render ，减少了开发者的迁移成本。\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eReact 并发新特性\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e并发渲染机制（concurrent rendering）的目的：根据用户的设备性能和网速对渲染过程进行适当的调整， 保证 React 应用在长时间的渲染过程中依旧保持可交互性，避免页面出现卡顿或无响应的情况，从而提升用户体验。\u003c/p\u003e\n\u003cp\u003ev18 正式引入了的并发渲染机制，并基于此给我们带来了很多新特性。这些新特性都是可选的并发功能，使用了这些新特性的组件并能触发并发渲染，并且与其整个子树都将自动开启 \u003ccode\u003estrictMode\u003c/code\u003e 。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e新 root API\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003ev18 之前 root 节点对用户不透明。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react-dom\u0026#x27;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./App\u0026#x27;\u003c/span\u003e\n​\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;app\u0026#x27;\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// v18 之前的方法\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e,root)\nv18 中我们可以通过 createRoot \u003cspan class=\"hljs-title class_\"\u003eApi\u003c/span\u003e 手动创建 root 节点。\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react-dom\u0026#x27;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./App\u0026#x27;\u003c/span\u003e\n​\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateRoot\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;app\u0026#x27;\u003c/span\u003e))\n\u003cspan class=\"hljs-comment\"\u003e// v18 的新方法\u003c/span\u003e\nroot.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e,root)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e想要使用 v18 中其他新特性 API， 前提是要使用新的 Root API 来创建根节点。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eAutomatic batching 自动批处理优化\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e批处理： React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 \u003ccode\u003esetState\u003c/code\u003e 事件合并）\u003c/p\u003e\n\u003cp\u003e在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 \u003ccode\u003epromise\u003c/code\u003e 链、 \u003ccode\u003esetTimeout\u003c/code\u003e 等异步代码以及原生事件处理函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-JSX\"\u003e\u003cspan class=\"hljs-comment\"\u003e// v18 之前\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClick\u003c/span\u003e () {\n\n  \u003cspan class=\"hljs-title function_\"\u003efetchSomething\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n      \u003cspan class=\"hljs-comment\"\u003e// React 17 及之前的版本不会批处理以下的 state:\u003c/span\u003e\n      \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ec\u003c/span\u003e) =\u0026gt;\u003c/span\u003e c + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 重新渲染\u003c/span\u003e\n      \u003cspan class=\"hljs-title function_\"\u003esetFlag\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ef\u003c/span\u003e) =\u0026gt;\u003c/span\u003e !f) \u003cspan class=\"hljs-comment\"\u003e// 二次重新渲染\u003c/span\u003e\n    })\n}\n\u003cspan class=\"hljs-comment\"\u003e// v18下\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 1、promise链中\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClick\u003c/span\u003e () {\n\n  \u003cspan class=\"hljs-title function_\"\u003efetchSomething\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n      \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ec\u003c/span\u003e) =\u0026gt;\u003c/span\u003e c + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n      \u003cspan class=\"hljs-title function_\"\u003esetFlag\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ef\u003c/span\u003e) =\u0026gt;\u003c/span\u003e !f) \u003cspan class=\"hljs-comment\"\u003e// 合并为一次重新渲染\u003c/span\u003e\n    })\n}\n\u003cspan class=\"hljs-comment\"\u003e// 2、setTimeout等异步代码中\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ec\u003c/span\u003e) =\u0026gt;\u003c/span\u003e c + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  \u003cspan class=\"hljs-title function_\"\u003esetFlag\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ef\u003c/span\u003e) =\u0026gt;\u003c/span\u003e !f) \u003cspan class=\"hljs-comment\"\u003e// 合并为一次重新渲染\u003c/span\u003e\n}, \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// 3、原生事件中\u003c/span\u003e\nelement.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;click\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n\u003cspan class=\"hljs-title function_\"\u003esetCount\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ec\u003c/span\u003e) =\u0026gt;\u003c/span\u003e c + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  \u003cspan class=\"hljs-title function_\"\u003esetFlag\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ef\u003c/span\u003e) =\u0026gt;\u003c/span\u003e !f) \u003cspan class=\"hljs-comment\"\u003e// 合并为一次重新渲染\u003c/span\u003e\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果想退出自动批处理立即更新的话，可以使用 \u003ccode\u003eReactDOM.flushSync()\u003c/code\u003e 进行包裹。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-JSX\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react-dom\u0026#x27;\u003c/span\u003e\n​\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClick\u003c/span\u003e () {\n\n  \u003cspan class=\"hljs-comment\"\u003e// 立即更新\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eflushSync\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-title function_\"\u003esetCounter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ec\u003c/span\u003e =\u0026gt;\u003c/span\u003e c + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  })\n  \u003cspan class=\"hljs-comment\"\u003e// 立即更新\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eflushSync\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-title function_\"\u003esetFlag\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ef\u003c/span\u003e =\u0026gt;\u003c/span\u003e !f)\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003estartTransition\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e可以用来降低渲染优先级。分别用来包裹计算量大的 \u003ccode\u003efunction\u003c/code\u003e 和 \u003ccode\u003evalue\u003c/code\u003e ，降低优先级，减少重复渲染次数。\u003c/p\u003e\n\u003cp\u003e举个例子：搜索引擎的关键词联想。一般来说，对于用户在输入框中输入都希望是实时更新的，如果此时联想词比较多同时也要实时更新的话，这就可能会导致用户的输入会卡顿。这样一来用户的体验会变差，这并不是我们想要的结果。\u003c/p\u003e\n\u003cp\u003e我们将这个场景的状态更新提取出来：一个是用户输入的更新；一个是联想词的更新。这个两个更新紧急程度显然前者大于后者。\u003c/p\u003e\n\u003cp\u003e以前我们可以使用防抖的操作来过滤不必要的更新，但防抖有一个弊端，当我们长时间的持续输入（时间间隔小于防抖设置的时间），页面就会长时间都不到响应。而 \u003ccode\u003estartTransition\u003c/code\u003e 可以指定 UI 的渲染优先级，哪些需要实时更新，哪些需要延迟更新。即使用户长时间输入最迟 5s 也会更新一次，官方还提供了 hook 版本的 \u003ccode\u003euseTransition\u003c/code\u003e ，接受传入一个毫秒的参数用来修改最迟更新时间，返回一个过渡期的 \u003ccode\u003epending\u003c/code\u003e 状态和 \u003ccode\u003estartTransition\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-JSX\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;react\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;./styles.css\u0026quot;\u003c/span\u003e;\n​\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [value, setValue] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [searchQuery, setSearchQuery] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [loading, startTransition] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseTransition\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n​\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleChange\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt; {\n\n    \u003cspan class=\"hljs-title function_\"\u003esetValue\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 延迟更新\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003estartTransition\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n      \u003cspan class=\"hljs-title function_\"\u003esetSearchQuery\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e20000\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003efill\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e));\n    });\n  };\n​\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;App\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ehandleChange\u003c/span\u003e} /\u0026gt;\u003c/span\u003e\n      {\n    loading ? (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003eloading...\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      ) : (\n        searchQuery.map((item, index) =\u0026gt; \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e}\u0026gt;\u003c/span\u003e{\n    item}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e)\n      )}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所有在 \u003ccode\u003estartTransition\u003c/code\u003e 回调中更新的都会被认为是非紧急处理，如果一旦出现更紧急的处理（比如这里的用户输入）， \u003ccode\u003estartTransition\u003c/code\u003e 就会中断之前的更新，只会渲染最新一次的状态更新。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estartTransition\u003c/code\u003e 的原理就是利用了 React 底层的优先级调度模型。\u003c/p\u003e\n\u003cp\u003e更多例子： \u003ca href=\"https://github.com/reactwg/react-18/discussions/65\"\u003e真实世界示例：为慢速渲染添加 startTransition\u003c/a\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eSSR 下的 Suspense 组件\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ccode\u003eSuspense\u003c/code\u003e 的作用： 划分页面中需要并发渲染的部分。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehydration\u003c/code\u003e[水化]：ssr 时服务器输出的是字符串（html），客户端（一般是浏览器）根据这些字符串并结合加载的 JavaScript 来完成 React 的初始化工作这一阶段为水化。\u003c/p\u003e\n\u003cp\u003eReact v18 之前的 SSR， 客户端必须一次性的等待 HTML 数据加载到服务器上并且等待所有 JavaScript 加载完毕之后再开始 \u003ccode\u003ehydration\u003c/code\u003e ， 等待所有组件 \u003ccode\u003ehydration\u003c/code\u003e 后，才能进行交互。即整个过程需要完成从获取数据（服务器）→ 渲染到 HTML（服务器）→ 加载代码（客户端）→ 水合物（客户端）这一套流程。这样的 SSR 并不能使我们的完全可交互变快，只是提高了用户的感知静态页面内容的速度。\u003c/p\u003e\n\u003cp\u003eReact v18 在 SSR 下支持了 \u003ccode\u003eSuspense\u003c/code\u003e ，最大的区别是什么呢？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e服务器不需要等待被 Suspense 包裹组件是否加载到完毕，即可发送 HTML，而代替 suspense 包裹的组件是 fallback 中的内容，一般是一个占位符（spinner），以最小内联\u003cscript\u003e标签标记此 HTML 的位置。等待服务器上组件的数据准备好后，React 再将剩余的 HTML 发送到同一个流中。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ehydration 的过程是逐步的，不需要等待所有的 js 加载完毕再开始 hydration，避免了页面的卡顿。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eReact 会提前监听页面上交互事件（如鼠标的点击），对发生交互的区域优先级进行 hydration。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/reactwg/react-18/discussions/37\"\u003ehttps://github.com/reactwg/react-18/discussions/37\u003c/a\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseSyncExternalStore\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e这个 API 可以防止在 \u003ccode\u003econcurrent\u003c/code\u003e 模式下，任务中断后第三方 \u003ccode\u003estore\u003c/code\u003e 被修改，恢复任务时出现 \u003ccode\u003etearing\u003c/code\u003e 从而数据不一致问题。用户一般很少使用，大多情况下提供给像 Redux 这样的状态管理库使用，通过 \u003ccode\u003euseSyncExternalStore\u003c/code\u003e 可以使 React 在 \u003ccode\u003econcurrent mode\u003c/code\u003e 下，保持自身 \u003ccode\u003estate\u003c/code\u003e 和来自 Redux 的状态同步。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-JSX\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e\n​\n\u003cspan class=\"hljs-comment\"\u003e// 基础用法，getSnapshot 返回一个缓存的值\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e state = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseSyncExternalStore\u003c/span\u003e(store.\u003cspan class=\"hljs-property\"\u003esubscribe\u003c/span\u003e, store.\u003cspan class=\"hljs-property\"\u003egetSnapshot\u003c/span\u003e)\n​\n\u003cspan class=\"hljs-comment\"\u003e// 根据数据字段，使用内联的 getSnapshot 返回缓存的数据\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e selectedField = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseSyncExternalStore\u003c/span\u003e(store.\u003cspan class=\"hljs-property\"\u003esubscribe\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e store.\u003cspan class=\"hljs-title function_\"\u003egetSnapshot\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eselectedField\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e第一个参数是一个订阅函数，订阅触发时会引起该组件的更新。\u003c/li\u003e\n\u003cli\u003e第二个函数返回一个 immutable 快照， 返回值是我们想要订阅的数据，只有数据发生变化时才需要重新渲染。\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseInsertionEffect\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e这个 hook 对现有的专为 React 设计的 css-in-js 库有着很大的作用，可以动态生成新规则与\u003ccode\u003e\u0026lt;style\u0026gt;\u003c/code\u003e标签一起插入到文档中。\u003c/p\u003e\n\u003cp\u003e假设现在我们要插入一段 css ，并且将这个操作放在渲染期间去执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-JSX\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erule\u003c/span\u003e) {\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isInserted.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(rule)) {\n\n    isInserted.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(rule)\n    \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehead\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egetStyleForRule\u003c/span\u003e(rule))\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rule\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ecss\u003c/span\u003e(\u0026#x27;\u003cspan class=\"hljs-attr\"\u003e...\u003c/span\u003e\u0026#x27;)} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样会导致每次修改 css 样式时，react 需要在渲染的每一帧中对所有的节点重新计算所有 CSS 规则，这并不是我们想要的结果。\u003c/p\u003e\n\u003cp\u003e那我们是不是可以在所有 DOM 生成前就插入这些 css 样式，此时我们可能会想到 \u003ccode\u003euseLayoutEffect\u003c/code\u003e ，但 \u003ccode\u003euseLayoutEffect\u003c/code\u003e 中可以访问 DOM，如果在这个 hook 中访问了某个 DOM 的布局样式（比如\u003ccode\u003eclientWidth\u003c/code\u003e），这样会导致我们读取的信息是错误的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-JSX\"\u003euseLayoutEffect ( \u003cspan class=\"hljs-function\"\u003e( )  =\u0026gt;\u003c/span\u003e  {\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e  ( ref.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eclientWidth\u003c/span\u003e  \u0026lt;  \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e )  {\n\n    setCollapsed ( \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e ) ;\n  }\n} ) ;\nuseInsertionEffect 可以帮助我们避免上述问题 ，既可以满足在所有 \u003cspan class=\"hljs-variable constant_\"\u003eDOM\u003c/span\u003e 生成前插入并且不访问 \u003cspan class=\"hljs-variable constant_\"\u003eDOM\u003c/span\u003e。其工作原理大致与 useLayoutEffect 相同，只是此时没法访问 \u003cspan class=\"hljs-variable constant_\"\u003eDOM\u003c/span\u003e节点的引用。我们可以在这个 hook 中插入全局的\u003cspan class=\"hljs-variable constant_\"\u003eDOM\u003c/span\u003e节点，比如如\u0026lt;style\u0026gt; ，或\u003cspan class=\"hljs-variable constant_\"\u003eSVG\u003c/span\u003e\u0026lt;defs\u0026gt; 。\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euseCSS\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003erule\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title function_\"\u003euseInsertionEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isInserted.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(rule)) {\n\n      isInserted.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(rule)\n      \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehead\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egetStyleForRule\u003c/span\u003e(rule))\n    }\n  })\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rule\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e className = \u003cspan class=\"hljs-title function_\"\u003euseCSS\u003c/span\u003e(rule)\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/reactwg/react-18/discussions/110\"\u003ehttps://github.com/reactwg/react-18/discussions/110\u003c/a\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseId\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003eReact 一直在向着 SSR 的领域发展，但 SSR 渲染必须保证客户端与服务端生成的 HTML 结构相匹配。我们平时使用的如 \u003ccode\u003eMath.random()\u003c/code\u003e 在 SSR 面前是没法保证客户端与服务端之间的 \u003ccode\u003eid\u003c/code\u003e 唯一性。\u003c/p\u003e\n\u003cp\u003eReact 为了解决这个问题，提出来 \u003ccode\u003euseOpaqueIdentifier\u003c/code\u003e 这个 hook, 不过它在不同环境会产生不同的结果.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e在服务端会生成一个字符串\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e在客户端会生成一个对象，必须直接传递给 DOM 属性\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样一来，在客户端如果需要生成多个标识，就需要调多次这个 hook，因为它不支持转化为字符串，就无法使用字符串拼接。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tabIdOne = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunstable_useOpaqueIdentifier\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panelIdOne = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunstable_useOpaqueIdentifier\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tabIdTwo = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunstable_useOpaqueIdentifier\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panelIdTwo = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunstable_useOpaqueIdentifier\u003c/span\u003e();\n​\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eReact.Fragment\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTabs\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edefaultValue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;tablist\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etabIdOne\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n            One\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etabIdTwo\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n            One\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003epanelIdOne\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          Content One\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003epanelIdTwo\u003c/span\u003e} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;two\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          Content Two\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTabs\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eReact.Fragment\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而 \u003ccode\u003euseId\u003c/code\u003e 可以生成客户端与服务端之间的唯一 \u003ccode\u003eid\u003c/code\u003e ，并且返回一个字符串。这样一个组件可以只需调用一次 \u003ccode\u003euseId\u003c/code\u003e ，并将其结果作为整个组件所需的标识符基础（比如拼接不同的字符串），以便生成唯一 \u003ccode\u003eid\u003c/code\u003e 。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e id = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseId\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eReact.Fragment\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTabs\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edefaultValue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;tablist\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`${\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e}\u003cspan class=\"hljs-attr\"\u003etab1\u003c/span\u003e`} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n            One\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`${\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e}\u003cspan class=\"hljs-attr\"\u003etab2\u003c/span\u003e`} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n            One\n          \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTab\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`${\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e}\u003cspan class=\"hljs-attr\"\u003epanel1\u003c/span\u003e`} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;one\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          Content One\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`${\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e}\u003cspan class=\"hljs-attr\"\u003epanel2\u003c/span\u003e`} \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;two\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n          Content Two\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTabPanel\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eTabs\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eReact.Fragment\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003euseDefferdValue\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003eReact 可以通过 \u003ccode\u003euseDefferdValue\u003c/code\u003e 允许变量延时更新，同时接受一个可选的延迟更新的最大值。React 将尝试尽快更新延迟值，如果在给定的 \u003ccode\u003etimeoutMs\u003c/code\u003e 期限内未能完成，它将强制更新。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e defferValue = \u003cspan class=\"hljs-title function_\"\u003euseDeferredValue\u003c/span\u003e(value, {\n  \u003cspan class=\"hljs-attr\"\u003etimeoutMs\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003euseDefferdValue\u003c/code\u003e 能够很好的展现并发渲染时优先级调整的特性，可以用于延迟计算逻辑比较复杂的状态，让其他组件优先渲染，等待这个状态更新完毕之后再渲染。\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"React.js学习-一文梳理 React 18 新特性(转载)"},"buildId":"12dVnEXE3Ni1Q4e6nG_vn","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>