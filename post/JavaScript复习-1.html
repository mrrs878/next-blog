<!DOCTYPE html><html><head><link rel="icon" href="https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg"/><script async="" src="/js/L2Dwidget.min.js"></script><script async="" src="/js/initL2D.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Mr.RS的个人博客-JavaScript复习-1</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/15773988a510c3d3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/15773988a510c3d3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-b927671265afed5e.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-1e7421553b9673ee.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ca6aae25bc99a05f.js" defer=""></script><script src="/_next/static/chunks/899-1cd3a59abdb8ea18.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Btitle%5D-216eae5ddb3b6d26.js" defer=""></script><script src="/_next/static/eYY6QkxJl4SBnCFZCu9oD/_buildManifest.js" defer=""></script><script src="/_next/static/eYY6QkxJl4SBnCFZCu9oD/_ssgManifest.js" defer=""></script><script src="/_next/static/eYY6QkxJl4SBnCFZCu9oD/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><header class="fixed top-0 py-4 left-0 right-0 h-auto px-10 shadow bg-white z-50"><nav><ul class="flex w-auto"><li class="mr-4 hover:text-yellow"><a href="/">首页</a></li><li class="mx-4 hover:text-yellow"><a href="/categories">分类</a></li><li class="mx-4 hover:text-yellow"><a href="/tags">标签</a></li><li class="ml-4 hover:text-yellow"><a href="/timeline">归档</a></li></ul></nav></header><main class="mt-20 mb-4 mx-auto justify-center w-2/3"><div class="mx-auto lg:max-w-5xl md:max-w-3xl"><article class="flex flex-col justify-around pb-16 px-4 mx-auto space-y-10 text-base"><div class="flex flex-col space-y-4"><h1 class="inline pt-10 text-4xl text-skin-primary">JavaScript复习-1</h1><div class="text-sm space-x-2 text-skin-muted grid grid-cols-5"><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>2021-05-11 14:27:01</span><span class="flex align-middle"><svg class="w-5 h-5 inline-block mr-1" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1903" width="20" height="20"><path d="M257.7 752c2 0 4-0.2 6-0.5L431.9 722c2-0.4 3.9-1.3 5.3-2.8l423.9-423.9c3.9-3.9 3.9-10.2 0-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2c-1.9 11.1 1.5 21.9 9.4 29.8 6.6 6.4 14.9 9.9 23.8 9.9z m67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" p-id="1904"></path></svg>2021-06-15 23:15:37</span><span class="flex align-middle"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 inline-block mr-1"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>44</span></div></div><div class="mt-8 flex"><div class="w-full flex-auto custom-markdown-body"><div class="markdown-body" id="write">
      <h2>
        <span class="prefix"></span>
        <span class="content">Proxy和Reflect</span>
        <span class="suffix"></span>
      </h2>
    <p>可以给目标对象定义一个关联的对象，而这个代理对象可以作为抽象的目标对象来使用。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。使用<code>new Proxy(target, handler)</code>来创建</p>
<p><code>handler</code>对象中所有可以捕获的方法都有对应的反射<code>Reflect</code> API方法，这些方法与捕获器拦截的方法具有相同的名称，也具有与被拦截方法相同的行为</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>;
}

<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {
    <span class="hljs-attr">get</span>: <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">get</span>,
})
</code></pre>
<p><code>Proxy.prototype</code>为<code>undefined</code>，因此不能使用<code>instanceof</code>操作符，会抛出<code>TypeError</code></p>
<p><code>Proxy.revocable</code>方法会返回一个<code>revoke</code>方法，用来撤销代理。撤销代理的操作是不可逆、幂等的，撤销后再次访问代理会抛出<code>TypeError</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> revocableProxy = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>
}, {
  <span class="hljs-attr">get</span>: <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">get</span>,
  <span class="hljs-attr">set</span>: <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">set</span>,
});

revocableProxy.<span class="hljs-property">proxy</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// tom</span>
revocableProxy.<span class="hljs-title function_">revoke</span>();
revocableProxy.<span class="hljs-property">proxy</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">//TypeError</span>
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">instanceof原理</span>
        <span class="suffix"></span>
      </h2>
    <p><strong>原型链</strong>。通过检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上，运算符左侧是实例对象，右侧是构造函数</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">instance, object</span>) {
  <span class="hljs-keyword">const</span> proto = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(instance);
  <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (object.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">myInstanceof</span>(proto, object);
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">防抖、节流</span>
        <span class="suffix"></span>
      </h2>
    <p>一种性能优化手段，避免函数过多执行（多用来优化滑动/点击事件回调）</p>
<p>防抖:：在规定的时间内若再次触发则重新及时</p>
<p>节流：在规定的时间内若再次触发(触发间隔大于规定的时间)只会执行一次</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">cb, timeout</span>) {
  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> canceled = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_denounce</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">let</span> res;
    <span class="hljs-built_in">clearTimeout</span>(timer);
    <span class="hljs-keyword">if</span> (canceled) {
      res = cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    } <span class="hljs-keyword">else</span> {
      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        res = cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
      }, timeout);
    }

    <span class="hljs-keyword">return</span> res;
  }

  _denounce.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    canceled = <span class="hljs-literal">true</span>;
  };

  <span class="hljs-keyword">return</span> _denounce;
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">cb, timeout</span>) {
  <span class="hljs-keyword">let</span> lastTime = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> canceled = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">let</span> res;
    <span class="hljs-keyword">if</span> (canceled) {
      res = cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastTime + timeout &lt; now) {
      lastTime = now;
      res = cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    }

    <span class="hljs-keyword">return</span> res;
  }

  _throttle.<span class="hljs-property">cancel</span> = <span class="hljs-function">() =&gt;</span> {
    canceled = <span class="hljs-literal">true</span>;
  };

  <span class="hljs-keyword">return</span> _throttle;
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">函数的name属性</span>
        <span class="suffix"></span>
      </h2>
    <p>es6所有的函数都会暴露出一个<code>name</code>属性，其中包含关于函数的信息。多数形况下这个属性是一个字符串化的变量名，等于该函数的名字。</p>
<p>如果使用<code>Function</code>构造函数创建的，则会标识成<code>anonymous</code></p>
<p>如果函数是一个<code>get</code>、<code>set</code>或使用<code>bind()</code>实例化，那么标识符前会加一个前缀</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">箭头函数的特性</span>
        <span class="suffix"></span>
      </h2>
    <ul>
<li>不能使用<code>arguments</code>、<code>super</code>、<code>new.target</code></li>
<li>不能用作构造函数</li>
<li>没有<code>prototype</code>属性</li>
<li>没有<code>this</code></li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">函数重载</span>
        <span class="suffix"></span>
      </h2>
    <p>JavaScript中没有函数重载。因为ECMAScript函数<strong>没有签名</strong>，函数的参数在内部表现为一个包含零个或多个值的数组。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">new.target</span>
        <span class="suffix"></span>
      </h2>
    <p>ES6新增了检测函数是否使用<code>new</code>关键字调用的<code>new.target</code>属性。如果函数是正常调用的<code>new.target</code>的值是<code>undefined</code>；如果是使用<code>new</code>关键字调用的，则<code>new.target</code>将引用被调用的构造函数</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(errorMessage);
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(successMessage);
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">arguments.callee</span>
        <span class="suffix"></span>
      </h2>
    <p><del><code>arguments</code>对象有一个<code>callee</code>属性，是一个指向<code>arguments</code>对象所在函数的指针。使用<code>arguments.callee</code>可以让函数逻辑与函数名解耦：</del></p>
<p>不推荐使用<code>arguments</code>（VSCode+eslint使用时会报错），因为<strong>访问arguments是个很昂贵的操作，它是个很大的对象</strong>，每次递归调用时都需要重新创建，影响现代浏览器的性能，还会影响闭包。推荐创建临时函数+闭包实现</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">let</span> tmp = num;
  <span class="hljs-keyword">if</span> (tmp &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    res *= tmp;
    tmp -= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (tmp !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();
    <span class="hljs-keyword">return</span> res;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">尾调用优化</span>
        <span class="suffix"></span>
      </h2>
    <p>ES6新增了一项内存管理机制，让JavaScript引擎在满足响应条件时可以重用栈帧。具体来说这项优化非常适合<em>尾调用</em>即<strong>外部函数的返回值是一个内部函数的返回值</strong></p>
<p>尾调用优化的条件：</p>
<ol>
<li>代码在严格模式下运行</li>
<li>外部函数的返回值是对尾调函数的引用</li>
<li>尾调用函数返回后不需要执行额外的操作</li>
<li>尾调用函数没有产生闭包(无法释放外部函数的栈帧)</li>
</ol>
<p>优化<code>factorial</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorialPerform</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">m, n</span>) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> m;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(m * n, n - <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(num, num - <span class="hljs-number">1</span>);
}
</code></pre>
<p>优化<code>fib</code></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> num;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fib</span>(num - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fib</span>(num - <span class="hljs-number">2</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fibPerform</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fibImpl</span>(<span class="hljs-params">m, n, x</span>) {
    <span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibImpl</span>(n, m + n, x - <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibImpl</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, num);
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">JSON.stringify</span>
        <span class="suffix"></span>
      </h2>
    <p><code>JSON.stringify(value[, replacer [, space]])</code>，将一个JavaScript对象或值转换为JSON字符串，如果指定了<code>replacer</code>，则可以选择性地替换值，或将指定的<code>replacer</code>是数组，则可选择性地仅包含数组指定的属性</p>
<p>注意：</p>
<ul>
<li>当在<code>value</code>存在循环引用时会抛出异常<code>TypError(&quot;cyclic object value&quot;)</code></li>
<li>当尝试去转换<code>BigInt</code>类型的值会抛出<code>TypeError(&quot;BigInt value can&#39;t be serialized in JSON&quot;)</code></li>
<li>如果<code>vaule</code>存在<code>toJSON()</code>方法，则返回该函数返回值</li>
<li>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中</li>
<li><code>Boolean</code>、<code>Number</code>、<code>String</code>包装对象会在序列化过程中自动转换为原始值</li>
<li>非数组对象的属性值为<code>undefined</code>、任意的函数、<code>symbol</code>会在序列化中被忽略，数组对象则会转换成<code>null</code></li>
<li><code>Map</code>、<code>Set</code>、<code>WeakMap</code>、<code>WeakSet</code>仅会序列化可枚举属性</li>
<li>函数、<code>undefined</code>被单独转换时会返回<code>undefined</code></li>
<li><code>Date</code>类型会转化为<code>Date.toISOString()</code>返回的值</li>
</ul>
<p><code>replacer</code>为函数时：</p>
<ul>
<li>如果返回一个<code>Number</code>，转换为相应地字符串作为属性值被添加到JSON字符串</li>
<li>如果返回一个<code>String</code>，该字符串作为属性值被添加入JSON字符串</li>
<li>如果返回一个<code>Boolean</code>，<code>true</code>或<code>false</code>作为属性值被添加到JSON字符串</li>
<li>如果返回其他对象，该对象递归地序列化为JSON字符串，对每个属性调用<code>replacer</code>方法。如果该对象是一个函数，则忽略</li>
<li>如果返回<code>undefined</code>则忽略</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">jsonp</span>
        <span class="suffix"></span>
      </h2>
    <pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">jsonpCallback</span> = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(data);
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script);
    }
    script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">${url}</span><span class="hljs-subst">${url.includes(<span class="hljs-string">&#x27;?&#x27;</span>) ? <span class="hljs-string">&#x27;&amp;&#x27;</span> : <span class="hljs-string">&#x27;?&#x27;</span>}</span>cb=jsonpCallback`</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);
  })
}
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">取消网络请求</span>
        <span class="suffix"></span>
      </h2>
    <p>根据所使用的API的不同，有不同的解决方案：</p>
<ul>
<li><code>XMLHttpRequest</code>
  使用<code>XMLHttpRequest.abort()</code><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-literal">true</span>);
xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);
xhr.<span class="hljs-title function_">abort</span>();
</code></pre>
</li>
<li><code>fetch</code>
  使用<code>AbortController</code><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
<span class="hljs-keyword">const</span> signal = controller.<span class="hljs-property">signal</span>;
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;url&#x27;</span>, { signal });
controller.<span class="hljs-title function_">abort</span>();
</code></pre>
</li>
<li><code>axios</code>
  使用<code>CancelToken</code><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> source = axiox.<span class="hljs-property">CancelToken</span>.<span class="hljs-title function_">source</span>();
<span class="hljs-keyword">const</span> cancelToken = source.<span class="hljs-property">token</span>;

axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;url&#x27;</span>, { cancelToken });
source.<span class="hljs-title function_">cancel</span>();
</code></pre>
</li>
</ul>

      <h2>
        <span class="prefix"></span>
        <span class="content">findIndex和indexOf</span>
        <span class="suffix"></span>
      </h2>
    <p><code>findIndex</code>根据所给函数进行匹配，<code>indexOf</code>使用<code>===</code>进行匹配</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> students = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">32</span> }]

students.<span class="hljs-title function_">indexOf</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> }) <span class="hljs-comment">// -1</span>
students.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;tom&#x27;</span> &amp;&amp; item.<span class="hljs-property">age</span> === <span class="hljs-number">23</span>) <span class="hljs-comment">// 0</span>
</code></pre>

      <h2>
        <span class="prefix"></span>
        <span class="content">TDZ(暂时性死区)</span>
        <span class="suffix"></span>
      </h2>
    <p>在JavaScript中，当控制流进入到它们出现的范围内，所有绑定都会被实例化。传统的<code>var</code>和<code>function</code>声明允许在实际声明之前访问那些绑定，并且值（<code>value</code>）为<code>undefined</code>。这种遗留行为被称为<strong>变量提升（hosting）</strong>。<code>let</code>和<code>const</code>声明也会被实例化，但<strong>运行到实际声明之前禁止访问</strong>。这称为<strong>暂时性死区(TDZ)</strong></p>

      <h2>
        <span class="prefix"></span>
        <span class="content">WeakMap</span>
        <span class="suffix"></span>
      </h2>
    <p>在JavaScript中，map API可以通过使用其四个API方法共用两个数组（一个存放key，一个存放value）来实现。给这种map设置value时会同时将key和value添加到这两个数组的尾部。从而使得key和value的索引在两个数组中相对应。当从该map取值的时候，需要遍历所有的key，然后再使用索引从存储value的数组中检索出相应的value</p>
<p>但这样的实现会有两个很大的缺点，首先赋值和搜索操作都是O(n)的时间复杂度。另一个缺点是可能导致内存泄漏，因为数组会一直引用着每个key和value。这种引用使得垃圾回收算法不能回收处理它们，即使没有其他引用存在了</p>
<p>相比之下，原生的WeakMap持有的是每个键对象的<strong>弱引用</strong>，这意味着没有其他引用存在时垃圾回收能正确进行。原生的WeakMap的结构是特殊且<strong>有效</strong>的，其用于映射的key只有在其没有被回收时才是有效的</p>
<p>正由于这样的弱引用，WeakMap的key是<strong>不可枚举</strong>的（没有办法给出所有的key，key取决于垃圾回收器的状态，是不可预知的）。如果key是可枚举的，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。</p>

      <h2>
        <span class="prefix"></span>
        <span class="content">参考</span>
        <span class="suffix"></span>
      </h2>
    <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">mdn-JSON.stringify()</a></p>
<p><a href="https://github.com/shfshanyue/Daily-Question/issues/502">如何取消请求的发送</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">mdn-WeakMap</a></p>
</div></div></div></article></div></main><footer class="flex flex-col items-center justify-center leading-8 text-sm w-full py-2 border-t text-skin-muted"><p>Designed &amp; developed by<a class="ml-1 text-yellow" target="_blank" href="https://github.com/mrrs878" rel="noreferrer">Mr.RS</a></p><p>©<!-- --> <!-- -->2022</p></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript复习-1","tags":["JavaScript"],"categories":"2021复习","description":"## Proxy和Reflect\n\n可以给目标对象定义一个关联的对象，而这个代理对象可以作为抽象的目标对象来使用。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。使用`new Proxy(target, handler)`来创建\n\n`handler`对象中所有可以捕获的方法都有对应的反射`Reflect` API方法，这些方法与捕获器拦截的方法具有相同的名称，也具有与被拦截方","createDate":"2021-05-11 14:27:01","updateDate":"2021-06-15 23:15:37","body":"\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eProxy和Reflect\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e可以给目标对象定义一个关联的对象，而这个代理对象可以作为抽象的目标对象来使用。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。使用\u003ccode\u003enew Proxy(target, handler)\u003c/code\u003e来创建\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehandler\u003c/code\u003e对象中所有可以捕获的方法都有对应的反射\u003ccode\u003eReflect\u003c/code\u003e API方法，这些方法与捕获器拦截的方法具有相同的名称，也具有与被拦截方法相同的行为\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = {\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;tom\u0026#x27;\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proxy = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProxy\u003c/span\u003e(target, {\n    \u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eget\u003c/span\u003e,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eProxy.prototype\u003c/code\u003e为\u003ccode\u003eundefined\u003c/code\u003e，因此不能使用\u003ccode\u003einstanceof\u003c/code\u003e操作符，会抛出\u003ccode\u003eTypeError\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eProxy.revocable\u003c/code\u003e方法会返回一个\u003ccode\u003erevoke\u003c/code\u003e方法，用来撤销代理。撤销代理的操作是不可逆、幂等的，撤销后再次访问代理会抛出\u003ccode\u003eTypeError\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e revocableProxy = \u003cspan class=\"hljs-title class_\"\u003eProxy\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erevocable\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;tom\u0026#x27;\u003c/span\u003e\n}, {\n  \u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eget\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eset\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eset\u003c/span\u003e,\n});\n\nrevocableProxy.\u003cspan class=\"hljs-property\"\u003eproxy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// tom\u003c/span\u003e\nrevocableProxy.\u003cspan class=\"hljs-title function_\"\u003erevoke\u003c/span\u003e();\nrevocableProxy.\u003cspan class=\"hljs-property\"\u003eproxy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e//TypeError\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003einstanceof原理\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003cstrong\u003e原型链\u003c/strong\u003e。通过检测构造函数的\u003ccode\u003eprototype\u003c/code\u003e属性是否出现在某个实例对象的原型链上，运算符左侧是实例对象，右侧是构造函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emyInstanceof\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einstance, object\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proto = \u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPrototypeOf\u003c/span\u003e(instance);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (proto === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (object.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e === proto) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emyInstanceof\u003c/span\u003e(proto, object);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e防抖、节流\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e一种性能优化手段，避免函数过多执行（多用来优化滑动/点击事件回调）\u003c/p\u003e\n\u003cp\u003e防抖:：在规定的时间内若再次触发则重新及时\u003c/p\u003e\n\u003cp\u003e节流：在规定的时间内若再次触发(触发间隔大于规定的时间)只会执行一次\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edebounce\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecb, timeout\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e timer = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e canceled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_denounce\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e res;\n    \u003cspan class=\"hljs-built_in\"\u003eclearTimeout\u003c/span\u003e(timer);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (canceled) {\n      res = cb.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      timer = \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n        res = cb.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n      }, timeout);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n  }\n\n  _denounce.\u003cspan class=\"hljs-property\"\u003ecancel\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    canceled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _denounce;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecb, timeout\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lastTime = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e canceled = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_throttle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e now = \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e res;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (canceled) {\n      res = cb.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (lastTime + timeout \u0026lt; now) {\n      lastTime = now;\n      res = cb.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n  }\n\n  _throttle.\u003cspan class=\"hljs-property\"\u003ecancel\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n    canceled = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _throttle;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e函数的name属性\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003ees6所有的函数都会暴露出一个\u003ccode\u003ename\u003c/code\u003e属性，其中包含关于函数的信息。多数形况下这个属性是一个字符串化的变量名，等于该函数的名字。\u003c/p\u003e\n\u003cp\u003e如果使用\u003ccode\u003eFunction\u003c/code\u003e构造函数创建的，则会标识成\u003ccode\u003eanonymous\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e如果函数是一个\u003ccode\u003eget\u003c/code\u003e、\u003ccode\u003eset\u003c/code\u003e或使用\u003ccode\u003ebind()\u003c/code\u003e实例化，那么标识符前会加一个前缀\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e箭头函数的特性\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cul\u003e\n\u003cli\u003e不能使用\u003ccode\u003earguments\u003c/code\u003e、\u003ccode\u003esuper\u003c/code\u003e、\u003ccode\u003enew.target\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e不能用作构造函数\u003c/li\u003e\n\u003cli\u003e没有\u003ccode\u003eprototype\u003c/code\u003e属性\u003c/li\u003e\n\u003cli\u003e没有\u003ccode\u003ethis\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e函数重载\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003eJavaScript中没有函数重载。因为ECMAScript函数\u003cstrong\u003e没有签名\u003c/strong\u003e，函数的参数在内部表现为一个包含零个或多个值的数组。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003enew.target\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003eES6新增了检测函数是否使用\u003ccode\u003enew\u003c/code\u003e关键字调用的\u003ccode\u003enew.target\u003c/code\u003e属性。如果函数是正常调用的\u003ccode\u003enew.target\u003c/code\u003e的值是\u003ccode\u003eundefined\u003c/code\u003e；如果是使用\u003ccode\u003enew\u003c/code\u003e关键字调用的，则\u003ccode\u003enew.target\u003c/code\u003e将引用被调用的构造函数\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(errorMessage);\n  }\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(successMessage);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003earguments.callee\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003cdel\u003e\u003ccode\u003earguments\u003c/code\u003e对象有一个\u003ccode\u003ecallee\u003c/code\u003e属性，是一个指向\u003ccode\u003earguments\u003c/code\u003e对象所在函数的指针。使用\u003ccode\u003earguments.callee\u003c/code\u003e可以让函数逻辑与函数名解耦：\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e不推荐使用\u003ccode\u003earguments\u003c/code\u003e（VSCode+eslint使用时会报错），因为\u003cstrong\u003e访问arguments是个很昂贵的操作，它是个很大的对象\u003c/strong\u003e，每次递归调用时都需要重新创建，影响现代浏览器的性能，还会影响闭包。推荐创建临时函数+闭包实现\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efactorial\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e tmp = num;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (tmp \u0026lt; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e res = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    res *= tmp;\n    tmp -= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (tmp !== \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e尾调用优化\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003eES6新增了一项内存管理机制，让JavaScript引擎在满足响应条件时可以重用栈帧。具体来说这项优化非常适合\u003cem\u003e尾调用\u003c/em\u003e即\u003cstrong\u003e外部函数的返回值是一个内部函数的返回值\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e尾调用优化的条件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e代码在严格模式下运行\u003c/li\u003e\n\u003cli\u003e外部函数的返回值是对尾调函数的引用\u003c/li\u003e\n\u003cli\u003e尾调用函数返回后不需要执行额外的操作\u003c/li\u003e\n\u003cli\u003e尾调用函数没有产生闭包(无法释放外部函数的栈帧)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e优化\u003ccode\u003efactorial\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efactorialPerform\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003em, n\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (n === \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e m;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(m * n, n - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(num, num - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e优化\u003ccode\u003efib\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efib\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (num \u0026lt; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efib\u003c/span\u003e(num - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) + \u003cspan class=\"hljs-title function_\"\u003efib\u003c/span\u003e(num - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efibPerform\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efibImpl\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003em, n, x\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (x === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e m;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efibImpl\u003c/span\u003e(n, m + n, x - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efibImpl\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, num);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eJSON.stringify\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ccode\u003eJSON.stringify(value[, replacer [, space]])\u003c/code\u003e，将一个JavaScript对象或值转换为JSON字符串，如果指定了\u003ccode\u003ereplacer\u003c/code\u003e，则可以选择性地替换值，或将指定的\u003ccode\u003ereplacer\u003c/code\u003e是数组，则可选择性地仅包含数组指定的属性\u003c/p\u003e\n\u003cp\u003e注意：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当在\u003ccode\u003evalue\u003c/code\u003e存在循环引用时会抛出异常\u003ccode\u003eTypError(\u0026quot;cyclic object value\u0026quot;)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e当尝试去转换\u003ccode\u003eBigInt\u003c/code\u003e类型的值会抛出\u003ccode\u003eTypeError(\u0026quot;BigInt value can\u0026#39;t be serialized in JSON\u0026quot;)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e如果\u003ccode\u003evaule\u003c/code\u003e存在\u003ccode\u003etoJSON()\u003c/code\u003e方法，则返回该函数返回值\u003c/li\u003e\n\u003cli\u003e非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBoolean\u003c/code\u003e、\u003ccode\u003eNumber\u003c/code\u003e、\u003ccode\u003eString\u003c/code\u003e包装对象会在序列化过程中自动转换为原始值\u003c/li\u003e\n\u003cli\u003e非数组对象的属性值为\u003ccode\u003eundefined\u003c/code\u003e、任意的函数、\u003ccode\u003esymbol\u003c/code\u003e会在序列化中被忽略，数组对象则会转换成\u003ccode\u003enull\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap\u003c/code\u003e、\u003ccode\u003eSet\u003c/code\u003e、\u003ccode\u003eWeakMap\u003c/code\u003e、\u003ccode\u003eWeakSet\u003c/code\u003e仅会序列化可枚举属性\u003c/li\u003e\n\u003cli\u003e函数、\u003ccode\u003eundefined\u003c/code\u003e被单独转换时会返回\u003ccode\u003eundefined\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDate\u003c/code\u003e类型会转化为\u003ccode\u003eDate.toISOString()\u003c/code\u003e返回的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ereplacer\u003c/code\u003e为函数时：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果返回一个\u003ccode\u003eNumber\u003c/code\u003e，转换为相应地字符串作为属性值被添加到JSON字符串\u003c/li\u003e\n\u003cli\u003e如果返回一个\u003ccode\u003eString\u003c/code\u003e，该字符串作为属性值被添加入JSON字符串\u003c/li\u003e\n\u003cli\u003e如果返回一个\u003ccode\u003eBoolean\u003c/code\u003e，\u003ccode\u003etrue\u003c/code\u003e或\u003ccode\u003efalse\u003c/code\u003e作为属性值被添加到JSON字符串\u003c/li\u003e\n\u003cli\u003e如果返回其他对象，该对象递归地序列化为JSON字符串，对每个属性调用\u003ccode\u003ereplacer\u003c/code\u003e方法。如果该对象是一个函数，则忽略\u003c/li\u003e\n\u003cli\u003e如果返回\u003ccode\u003eundefined\u003c/code\u003e则忽略\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003ejsonp\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ejsonp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e script = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;script\u0026#x27;\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ejsonpCallback\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(data);\n      \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eremoveChild\u003c/span\u003e(script);\n    }\n    script.\u003cspan class=\"hljs-property\"\u003esrc\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${url}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e${url.includes(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;?\u0026#x27;\u003c/span\u003e) ? \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026amp;\u0026#x27;\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\u0026#x27;?\u0026#x27;\u003c/span\u003e}\u003c/span\u003ecb=jsonpCallback`\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(script);\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e取消网络请求\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e根据所使用的API的不同，有不同的解决方案：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eXMLHttpRequest\u003c/code\u003e\n  使用\u003ccode\u003eXMLHttpRequest.abort()\u003c/code\u003e\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e();\nxhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;url\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\nxhr.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\nxhr.\u003cspan class=\"hljs-title function_\"\u003eabort\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efetch\u003c/code\u003e\n  使用\u003ccode\u003eAbortController\u003c/code\u003e\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e controller = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAbortController\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e signal = controller.\u003cspan class=\"hljs-property\"\u003esignal\u003c/span\u003e;\n\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;url\u0026#x27;\u003c/span\u003e, { signal });\ncontroller.\u003cspan class=\"hljs-title function_\"\u003eabort\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaxios\u003c/code\u003e\n  使用\u003ccode\u003eCancelToken\u003c/code\u003e\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = axiox.\u003cspan class=\"hljs-property\"\u003eCancelToken\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esource\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cancelToken = source.\u003cspan class=\"hljs-property\"\u003etoken\u003c/span\u003e;\n\naxios.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;url\u0026#x27;\u003c/span\u003e, { cancelToken });\nsource.\u003cspan class=\"hljs-title function_\"\u003ecancel\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003efindIndex和indexOf\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ccode\u003efindIndex\u003c/code\u003e根据所给函数进行匹配，\u003ccode\u003eindexOf\u003c/code\u003e使用\u003ccode\u003e===\u003c/code\u003e进行匹配\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e students = [{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;tom\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;jerry\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e }]\n\nstudents.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;tom\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e }) \u003cspan class=\"hljs-comment\"\u003e// -1\u003c/span\u003e\nstudents.\u003cspan class=\"hljs-title function_\"\u003efindIndex\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e) =\u0026gt;\u003c/span\u003e item.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;tom\u0026#x27;\u003c/span\u003e \u0026amp;\u0026amp; item.\u003cspan class=\"hljs-property\"\u003eage\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eTDZ(暂时性死区)\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e在JavaScript中，当控制流进入到它们出现的范围内，所有绑定都会被实例化。传统的\u003ccode\u003evar\u003c/code\u003e和\u003ccode\u003efunction\u003c/code\u003e声明允许在实际声明之前访问那些绑定，并且值（\u003ccode\u003evalue\u003c/code\u003e）为\u003ccode\u003eundefined\u003c/code\u003e。这种遗留行为被称为\u003cstrong\u003e变量提升（hosting）\u003c/strong\u003e。\u003ccode\u003elet\u003c/code\u003e和\u003ccode\u003econst\u003c/code\u003e声明也会被实例化，但\u003cstrong\u003e运行到实际声明之前禁止访问\u003c/strong\u003e。这称为\u003cstrong\u003e暂时性死区(TDZ)\u003c/strong\u003e\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003eWeakMap\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e在JavaScript中，map API可以通过使用其四个API方法共用两个数组（一个存放key，一个存放value）来实现。给这种map设置value时会同时将key和value添加到这两个数组的尾部。从而使得key和value的索引在两个数组中相对应。当从该map取值的时候，需要遍历所有的key，然后再使用索引从存储value的数组中检索出相应的value\u003c/p\u003e\n\u003cp\u003e但这样的实现会有两个很大的缺点，首先赋值和搜索操作都是O(n)的时间复杂度。另一个缺点是可能导致内存泄漏，因为数组会一直引用着每个key和value。这种引用使得垃圾回收算法不能回收处理它们，即使没有其他引用存在了\u003c/p\u003e\n\u003cp\u003e相比之下，原生的WeakMap持有的是每个键对象的\u003cstrong\u003e弱引用\u003c/strong\u003e，这意味着没有其他引用存在时垃圾回收能正确进行。原生的WeakMap的结构是特殊且\u003cstrong\u003e有效\u003c/strong\u003e的，其用于映射的key只有在其没有被回收时才是有效的\u003c/p\u003e\n\u003cp\u003e正由于这样的弱引用，WeakMap的key是\u003cstrong\u003e不可枚举\u003c/strong\u003e的（没有办法给出所有的key，key取决于垃圾回收器的状态，是不可预知的）。如果key是可枚举的，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。\u003c/p\u003e\n\n      \u003ch2\u003e\n        \u003cspan class=\"prefix\"\u003e\u003c/span\u003e\n        \u003cspan class=\"content\"\u003e参考\u003c/span\u003e\n        \u003cspan class=\"suffix\"\u003e\u003c/span\u003e\n      \u003c/h2\u003e\n    \u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"\u003emdn-JSON.stringify()\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/shfshanyue/Daily-Question/issues/502\"\u003e如何取消请求的发送\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\"\u003emdn-WeakMap\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/post/[title]","query":{"title":"JavaScript复习-1"},"buildId":"eYY6QkxJl4SBnCFZCu9oD","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>