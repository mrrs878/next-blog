{"pageProps":{"post":{"title":"Vue.js学习-基础","tags":["Vue.js"],"categories":"Vue.js","description":"# 生命周期钩子函数\n\n- beforeCreate\n\n  获取不到props/data\n\n- created\n\n  可以获取到props/data，组件未挂载\n\n- beforeMount\n\n  开始创建VDOM\n\n- mounted\n\n  将VDOM渲染为真实DOM并渲染数据，组件中如果有子组件的话会递归挂载子组件，只有当所有子组件全部挂载完毕才会执行跟组件的挂载钩子\n\n- beforeU","createDate":"2020-04-18 21:04:39","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生命周期钩子函数</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>beforeCreate</p>\n<p>获取不到props/data</p>\n</li>\n<li><p>created</p>\n<p>可以获取到props/data，组件未挂载</p>\n</li>\n<li><p>beforeMount</p>\n<p>开始创建VDOM</p>\n</li>\n<li><p>mounted</p>\n<p>将VDOM渲染为真实DOM并渲染数据，组件中如果有子组件的话会递归挂载子组件，只有当所有子组件全部挂载完毕才会执行跟组件的挂载钩子</p>\n</li>\n<li><p>beforeUpdate/updated</p>\n<p>分别在数据更新前/更新时调用。不能在updated里做更新，会造成死循环</p>\n</li>\n<li><p>beforeDestory</p>\n<p>适合移移除事件、定时器等</p>\n</li>\n<li><p>destoryed</p>\n<p>所有子组件都销毁完毕后会执行根组件的destoryed</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组件通信</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p><code>props/$emit</code>\n通过props将数据自伤而下传递；通过$emit/v-on来向上传递消息</p>\n</li>\n<li><p>eventbus\n通过eventbus进行消息的发布订阅</p>\n</li>\n<li><p>vuex\n全局数据管理库，可通过vuex管理全局的数据流</p>\n</li>\n<li><pre><code>$attrs/$listeners\n</code></pre>\n<p>可以进行跨级的组件通信</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 父组件</span>\n&lt;template&gt;\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;home&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">m-input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;姓名&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">m-input</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">MInput</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/components/MInput.vue&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;home&quot;</span>,\n    <span class=\"hljs-title function_\">data</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;zhangsan&quot;</span>\n        };\n    },\n    <span class=\"hljs-attr\">components</span>: {\n        <span class=\"hljs-title class_\">MInput</span>\n    }\n};\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n<span class=\"hljs-comment\">// 子组件</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">&quot;$attrs&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">&quot;$attrs&quot;</span> @<span class=\"hljs-attr\">input</span>=<span class=\"hljs-string\">&quot;$emit(&#x27;input&#x27;,$event.target.value)&quot;</span> <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">&quot;value&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">props</span>: {\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-title class_\">String</span>,\n        <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">&quot;&quot;</span>\n    }\n};\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n</li>\n<li><p>proveded/inject\n允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并且在其上下游关系成立的时间内始终有效</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">mixin和mixins的区别</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>mixin用于全局混入，会影响到每个组件实例（vuex、vue-router等插件实现核心机制）</li>\n<li>mixins常用来扩展组件</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">computed和watch的区别</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>computed是计算属性，依赖其他属性计算值，并且computed的值有缓存，只有当计算值发生变化才返回内容</li>\n<li>watch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作</li>\n</ul>\n<p>一般来说需要依赖别的属性来动态获得值得时候可以使用computed，对于监听到值的变化需要做一些<strong>复杂业务逻辑</strong>的情况可以使用watch</p>\n<p><a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttp://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/%5D(http://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/)\">实现原理</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">computed如何知道依赖</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>Vue.js实例初始化过程中，将所有计算属性包装为lazy watcher</li>\n<li>首次访问计算属性时，watcher为dirty，此时开始计算watcher的值</li>\n<li>计算开始之前，此watcher将被设置为依赖目标，开始收集依赖</li>\n<li>计算watcher值的过程中，被访问到属性的getter中会检查是否存在依赖目标，若存在依赖目标就会创建依赖关系</li>\n<li>watcher的值计算完成后，新的依赖被设置，旧的依赖会被删除，依赖收集完成</li>\n<li>当依赖属性更新时，会通知自身的依赖目标，watcher被设置为dirty</li>\n<li>再次访问该计算属性，重复计算及依赖收集步骤（3-6）</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">keep-alive有什么作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>如果需要在组件切换的时候<strong>保存一些组件的状态防止多次渲染</strong>，就可以使用<code>keep-alive</code>组件包裹需要保存的组件。对于<code>keep-alive</code>组件来说，它有两个独有的声明周期钩子函数，分别为<code>activated</code>、和<code>deactivated</code>。用<code>keep-alive</code>包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行<code>deactivated</code>钩子函数，命中缓存渲染后会执行<code>activated</code>钩子函数。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">v-show和v-if的区别</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><code>v-show</code>只是在<code>display:none</code>和<code>display:block</code>之间切换，无论初始条件是什么DOM都会被创建，后面只需切换CSS。所以总的来说<code>v-show</code>在初始渲染时有着更高的开销，但切换开销很小，适合频繁切换的场景。</li>\n<li><code>v-if</code>的话关于到Vue底层的编译。当初始属性为<code>false</code>时，组件就不会被渲染，直到条件为<code>true</code>。并且切换条件时会触发销毁/挂载组件及回流。所以总的来说在<strong>创建时开销较小，切换时开销大，适合不经常切换的场景</strong>，并且基于<code>v-if</code>这种惰性渲染机制，可以在必要的时候才去渲染组件，<strong>减少整个页面的初始渲染开销</strong></li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">data为什么使用函数</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><strong>组件复用时所有组件实例都会共享data</strong>，如果data是对象的话，就会造成一个组件修改data后影响其他组件，所以有必要将data写成函数，每次用到就调用一次函数获得新的数据</p>\n<p>当使用<code>new Vue()</code>的方式时，无论我们将data设置为对象函数函数都是可以的，因为<code>new Vue()</code>的方式是生成一个根组件，该组件不会被复用也就不会存在共享data的情况了</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js响应式原理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>对于Object，基于发布订阅模式，使用<code>Object.defineProperty</code>，在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖。当一个vue组件实例创建的时候，vue会遍历<code>data</code>选项的属性，用<code>Object.defineProperty</code>将它们转换为<code>getter/setter</code>并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的<code>watcher</code>实例，它会在组件渲染的过程中把属性记录为依赖，只有当依赖项的<code>setter</code>被调用时，会通知<code>watcher</code>重新计算从而使它管理的组件得以更新</p>\n<p>对于Array，基于函数劫持，改写数组原型方法，并遍历数组，对于是对象的项使用👆的方法进行观测</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js的特点</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>简洁</li>\n<li>数据驱动，自动计算属性和追踪依赖的模板表达式</li>\n<li>组件化，高科服用、解耦的组件来构建页面</li>\n<li>快速，精确有效批量DOM更新</li>\n<li>模板友好</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>$nextTick</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>Vue.js实现响应式并不是在数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。nextTick是在下次dom更新循环结束之后执行延迟回调，在修改数据之后使用<em>n<strong>e</strong>x<strong>t</strong>T<strong>i</strong>c**k</em>是在下次<em>d<strong>o</strong>m</em>更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的dom</p>\n<p>渲染节流</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>v-for</code>中<code>key</code>的作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>当vue更新通过v-for渲染的元素时，它默认使用<strong>就地复用</strong>的策略，如果数据项的顺序被改变，vue将不是移动dom元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定的索引下显示已经被渲染过的每个元素。为了给vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序所有元素，需要给vue提供一个唯一key属性</p>\n<p>key <strong>主要用在vue的虚拟dom算法</strong>，在新旧node对比时辨识vnodes。如果不使用key，vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法，使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>$router</code>和<code>$route</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><code>$router</code>是路由信息对象，包括<code>path、params、hash、query、fullPath、matched、name</code>等路由信息参数</li>\n<li><code>$route</code>是路由实例，包括了路由跳转方法、钩子函数等</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>@click.native</code>中<code>native</code>的作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>对于普通标签，<code>@click</code>会监听点击事件，而对于写在组件上的<code>@click</code>，如果不加<code>native</code>，则代表坚挺的是组件的点击事件，而不是组件内的点击事件，因此，在组件内写的<code>click handler</code>不会被执行</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>v-model</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>v-model</code>常用于表单元素上进行数据的双向绑定，比如``。除了原生的元素，它还能在自定义组件中使用</p>\n<pre><code>v-model`是一个语法糖，可以拆解为`props: value`和`events:input`。就是说组件必须提供一个名为`value`的`prop`以及名为`input`的自定义事件，满足这两个条件就能在自定义组件上使用`v-model\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">作用域插槽</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>一种带有数据的插槽</p>\n<p>普通插槽 = 父组件设置的样式 + 父组件通过props传递的数据</p>\n<p>作用域插槽 = 父组件设置的样式 + <strong>自身的数据</strong>（该数据父组件也可以访问得到）</p>\n"}},"__N_SSG":true}