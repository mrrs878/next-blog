{"pageProps":{"post":{"title":"(翻译)创建你自己的React","tags":["React.js"],"categories":"React.js","description":"> 原文链接:https://pomb.us/build-your-own-react/\n\n# Build your own React\n\n我们将从头开始重写React。 一步步。 遵循真实的React代码中的架构，但没有所有的优化和非必要的功能。\n\n如果您阅读过[我以前的任何“构建自己的React”文章](https://engineering.hexacta.com/didact-lear","createDate":"2020-11-02 14:25:18","updateDate":"2020-11-11 15:00:53","body":"<blockquote>\n<p>原文链接:<a href=\"https://pomb.us/build-your-own-react/\">https://pomb.us/build-your-own-react/</a></p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Build your own React</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>我们将从头开始重写React。 一步步。 遵循真实的React代码中的架构，但没有所有的优化和非必要的功能。</p>\n<p>如果您阅读过<a href=\"https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5\">我以前的任何“构建自己的React”文章</a>，不同之处在于该文章基于React 16.8，因此我们现在可以使用<code>hook</code>并删除所有与<code>class</code>相关的代码。</p>\n<p>您可以在旧博客文章中找到历史记录，并在<a href=\"https://github.com/pomber/didact\">Didact仓库</a>中找到代码。 还有一个演讲涉及相同的内容。</p>\n<p>以下这些都是我们将一一添加到我们的React版本中的内容：</p>\n<ul>\n<li>第一步: <code>createElement</code> 函数</li>\n<li>第二步: <code>render</code> 函数</li>\n<li>第三步: Concurrent Mode</li>\n<li>第四步: Fibers</li>\n<li>第五步: Render and Commit Phases</li>\n<li>第六步: Reconciliation</li>\n<li>第七步: 函数式组件</li>\n<li>第八步: Hooks</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第零步</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果您已经对React，JSX和DOM节点的工作方式有了很好的了解，则可以跳过此步骤。首先让我们回顾一些基本概念，我们将使用只有三行代码的React应用程序：第一个定义一个React节点，下一个从DOM获取一个节点，最后一个将React节点渲染到容器中。然后，我们会删除所有特定于React的代码将其替换为原始JavaScript。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>)\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(element, container)\n</code></pre>\n<p>在第一行中，我们使用JSX定义了节点。 它不是有效的JavaScript，因此要用原生JS取代它。通过Babel等构建工具，JSX转换为JS。 转换通常很简单：使用对<code>createElement</code>的调用来替换标签内的代码，并将标签<code>type</code>、<code>props</code>、<code>children</code>作为参数传递。<code>React.createElement</code>根据其参数创建一个对象，除了一些验证之外，这就是全部。 因此，我们可以安全地将函数调用替换为其输出。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n\n👇\n\n<span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createElement</span>(\n  <span class=\"hljs-string\">&quot;h1&quot;</span>,\n  { <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;foo&quot;</span> },\n  <span class=\"hljs-string\">&quot;Hello&quot;</span>\n)\n</code></pre>\n<p>这就是一个节点，一个具有两个属性的对象：<code>type</code>和<code>props</code>（嗯，<a href=\"https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111\">它有更多的属性</a>，但是我们只关心这两个属性）。<code>type</code>是一个字符串，用于指定我们要创建的DOM节点的类型，它是您要创建HTML节点时传递给<code>document.createElement</code>的<code>tagName</code>。 它也可以是一个函数，但我们将其留给步骤VII。<code>props</code>是另一个对象，它具有JSX属性中的所有键和值。 它还有一个特殊的属性：<code>children</code>。在这种情况下，<code>children</code>是字符串，但通常是包含更多节点的数组（这就是为什么节点也是树的原因）。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;h1&quot;</span>,\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;foo&quot;</span>,\n    <span class=\"hljs-attr\">children</span>: <span class=\"hljs-string\">&quot;Hello&quot;</span>,\n  },\n}\n</code></pre>\n<p>我们需要替换的另一部分React代码是对<code>ReactDOM.render</code>的调用。<code>render</code>是React更新DOM的地方，现在用我们自己的代码进行操作。</p>\n<p>首先，我们使用节点<code>type</code>（在本例中为<code>h1</code>）创建一个<code>node*</code>。然后，我们将所有节点属性分配给该节点。 这里只有一个<code>title</code>。*为避免混淆，我将使用<code>element</code>来指代React节点，并使用<code>node</code>来指代DOM节点。</p>\n<p>然后，我们为<code>children</code>创建节点。 我们只有一个字符串作为<code>children</code>，因此我们创建了一个文本节点。使用<code>textNode</code>而不是设置<code>innerText</code>将允许我们以后以相同的方式对待所有节点。另请注意，我们像设置<code>h1</code>标题一样设置<code>nodeValue</code>，就像字符串中带有<code>props: {nodeValue: &quot;hello&quot;}</code>。最后，我们将<code>textNode</code>添加到<code>h1</code>并将<code>h1</code>添加到<code>container</code>。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;h1&quot;</span>,\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;foo&quot;</span>,\n    <span class=\"hljs-attr\">children</span>: <span class=\"hljs-string\">&quot;Hello&quot;</span>,\n  },\n}\n\n<span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>)\n\n<span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(element.<span class=\"hljs-property\">type</span>)\nnode[<span class=\"hljs-string\">&quot;title&quot;</span>] = element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">title</span>\n\n<span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\ntext[<span class=\"hljs-string\">&quot;nodeValue&quot;</span>] = element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>\n\nnode.<span class=\"hljs-title function_\">appendChild</span>(text)\ncontainer.<span class=\"hljs-title function_\">appendChild</span>(node)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第一步: createElement 函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>现在，让我们切换到另一个App：自己实现的简易React。</p>\n<p>首先，从编写<code>createElement</code>开始，将JSX转换为JS。正如在上一步中看到的，<code>element</code>是具有类型和属性的对象。<code>createElement</code>唯一需要做的就是创建该对象。</p>\n<p>因为<code>children</code>也可以包含原始数据类型，比如字符串或数字，所以对不是<code>object</code>的<code>child</code>创建特殊节点类型：<code>TEXT_ELEMENT</code>。这样做是因为可以简化代码。对于我们的库，我更喜欢简单而不是高性能代码。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createTextElement</span>(<span class=\"hljs-params\">text</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>,\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">nodeValue</span>: text,\n      <span class=\"hljs-attr\">children</span>: [],\n    },\n  }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-params\">type, props, ...children</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    type,\n    <span class=\"hljs-attr\">props</span>: {\n      ...props,\n      <span class=\"hljs-attr\">children</span>: children.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-keyword\">typeof</span> child === <span class=\"hljs-string\">&quot;object&quot;</span>\n        ? child\n        : <span class=\"hljs-title function_\">createTextElement</span>(child)\n      ),\n    },\n  }\n}\n</code></pre>\n<p>目前Babel仍然使用<code>React.createElement</code>，为了替换它，让我们给自己的库起个名字。我们需要一个听起来像React的名字，但也暗示了它的教学目的，我们叫它<code>Didact</code>。</p>\n<p>让我们使用<code>/** @jsx Didact.createElement */</code>来告诉Babel使用我们自己的<code>createElement</code>来转换jsx代码：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@jsx</span> Didact.createElement */</span>\n<span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span>bar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第二步：redner 函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>首先使用element的<code>type</code>创建DOM节点，然后将新element添加到<code>container</code>中。然后对每个<code>child</code>递归调用<code>render</code>：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-keyword\">const</span> dom = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(element.<span class=\"hljs-property\">type</span>);\n\n  element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-title function_\">render</span>(child, dom))\n\n  container.<span class=\"hljs-title function_\">appendChild</span>(dom);\n}\n</code></pre>\n<p>其次，我们还需要处理文本节点，如果element类型为<code>TEXT_ELEMENT</code>，我们将创建文本节点而不是普通节点：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> dom = element.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>\n    ? <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n    : <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElmenet</span>(element.<span class=\"hljs-property\">type</span>);\n  <span class=\"hljs-comment\">//...</span>\n}\n</code></pre>\n<p>最后，将<code>props</code>分配给element：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = key =&gt; key === <span class=\"hljs-string\">&quot;children&quot;</span>;\n  <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownkeys</span>(element.<span class=\"hljs-property\">props</span>)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> dom[name] = element.<span class=\"hljs-property\">props</span>[name]);\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>这样的话，我们就有了一个可以将JSX呈现到DOM的库：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createTextElement</span>(<span class=\"hljs-params\">text</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>,\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">nodeValue</span>: text,\n      <span class=\"hljs-attr\">children</span>: []\n    }\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-params\">type, props, ...children</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    type,\n    <span class=\"hljs-attr\">props</span>: {\n      ...props,\n      <span class=\"hljs-attr\">children</span>: children.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span>\n        <span class=\"hljs-keyword\">typeof</span> child === <span class=\"hljs-string\">&quot;object&quot;</span> ? child : <span class=\"hljs-title function_\">createTextElement</span>(child)\n      )\n    }\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-keyword\">const</span> dom =\n    element.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>\n      ? <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n      : <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(element.<span class=\"hljs-property\">type</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = (<span class=\"hljs-params\">key</span>) =&gt; key !== <span class=\"hljs-string\">&quot;children&quot;</span>;\n  <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(element.<span class=\"hljs-property\">props</span>)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> (dom[name] = element.<span class=\"hljs-property\">props</span>[name]));\n\n  element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-title function_\">render</span>(child, dom));\n\n  container.<span class=\"hljs-title function_\">appendChild</span>(dom);\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Didact</span> = {\n  createElement,\n  render\n};\n\n<span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@jsx</span> Didact.createElement */</span>\n<span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello STEP1-STEP2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n);\n\n<span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#step1&quot;</span>);\n\n<span class=\"hljs-title class_\">Didact</span>.<span class=\"hljs-title function_\">render</span>(element, container);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第三步Concurrent Mode</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在开始添加更多代码之前，我们需要重构。</p>\n<p>上面的递归调用存在问题。开始渲染后，直到渲染完完整的element树，我们才会停止。 如果element树很大，则可能会阻塞主线程太长时间。 那么如果浏览器需要执行高优先级的操作（例如处理用户输入或保持动画流畅），则它必须等到渲染完成为止。因此，我们将工作分成几个小部分，在完成每个单元后，如果需要执行其他任何操作，我们将让浏览器中断渲染。</p>\n<p>我们使用<code>requestIdleCallback</code>进行循环。 您可以将<code>requestIdleCallback</code>看作<code>setTimeout</code>，但是浏览器将在主线程空闲时运行回调，而不是告诉它何时运行。React不再使用<code>requestIdleCallback</code>，现在它使用scheduler package。 但是对于此用例，它在概念上是相同的。<code>requestIdleCallback</code>还为我们提供了<code>deadline</code>参数。 我们可以使用它来检查浏览器需要再次控制之前有多少时间。</p>\n<p>要开始使用循环，我们需要设置第一个工作单元，然后编写一个<code>performUnitOfWork</code>函数，该函数不仅执行工作，还返回下一个工作单元。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第四步Fiber</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>要组织工作单元，我们需要一个数据结构--Fiber树。我们将为每个元素分配一根Fiber，并且每个Fiber将成为一个工作单元。</p>\n<p>假如我们要渲染如下的element树，那么Fiber树就如下所示：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Didact</span>.<span class=\"hljs-title function_\">render</span>(\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>,\n  container\n)\n</code></pre>\n<p><img src=\"https://pomb.us/static/a88a3ec01855349c14302f6da28e2b0c/ac667/fiber1.png\" alt=\"\"></p>\n<p>在render函数中，我们将创建root Fiber并将其设置为<code>nextUnitOfWork</code>。 剩下的工作将在<code>performUnitOfWork</code>函数上进行，我们将为每个Fiber做三件事：</p>\n<ol>\n<li>将element添加到DOM</li>\n<li>为element的子代创建Filber</li>\n<li>选择下一个工作单元</li>\n</ol>\n<p>该数据结构的目标之一是使查找下一个工作单元变得容易。 这就是为什么每个Fiber都链接到其第一个子节点、下一个兄弟节点和父节点。</p>\n<ul>\n<li>当我们完成对当前Fiber的工作时，如果有child，那么该child对应的Fiber将是下一个工作单元。在我们的示例中，当我们完成div Fiber的工作时，下一个工作单元将是h1 Fiber。</li>\n<li>如果当前Fiber没有child，我们将其sibling作为下一个工作单元。例如，p Fiber没有child，因此我们在完成当前之后下一个工作单元将是h1。</li>\n<li>如果当前Fiber既没有child也没有sibling，那么我们去“uncle”：父母的兄弟节点。 就像示例中的a和h2 Fiber一样。</li>\n<li>如果parent没有sibling，我们会不断检查parent，直到找到有sibling的parent，或者直到找到root。 如果到达root，则意味着我们已经完成了此渲染的所有工作。</li>\n</ul>\n<p>现在，让我们开始写代码。</p>\n<p>首先，更改<code>render</code>函数并创建<code>createDom</code>函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  nextUnitOfWork = {\n    <span class=\"hljs-attr\">dom</span>: container,\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">children</span>: [element],\n    },\n  }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDom</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">const</span> dom =\n    fiber.<span class=\"hljs-property\">type</span> == <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>\n      ? <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n      : <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(fiber.<span class=\"hljs-property\">type</span>)\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = key =&gt; key !== <span class=\"hljs-string\">&quot;children&quot;</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(fiber.<span class=\"hljs-property\">props</span>)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      dom[name] = fiber.<span class=\"hljs-property\">props</span>[name]\n    })\n  <span class=\"hljs-keyword\">return</span> dom\n}\n</code></pre>\n<p>然后，当浏览器准备就绪时，它将调用我们的<code>workLoop</code>，我们将从<code>root</code>开始执行渲染。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">workLoop</span>(<span class=\"hljs-params\">deadline</span>) {\n  <span class=\"hljs-keyword\">let</span> shouldYield = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) {\n    nextUnitOfWork = <span class=\"hljs-title function_\">performUnitOfWork</span>(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.<span class=\"hljs-title function_\">timeRemaining</span>() &lt; <span class=\"hljs-number\">1</span>\n  }\n  <span class=\"hljs-title function_\">requestIdleCallback</span>(workLoop)\n}\n</code></pre>\n<p>首先，我们创建一个新node并将其添加到DOM。我们在<code>fibre.dom</code>属性中跟踪DOM节点。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">if</span> (!fiber.<span class=\"hljs-property\">dom</span>) {\n    fiber.<span class=\"hljs-property\">dom</span> = <span class=\"hljs-title function_\">createDom</span>(fiber)\n  }\n  <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">parent</span>) {\n    fiber.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">dom</span>.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  }\n  <span class=\"hljs-comment\">// TODO create new fibers</span>\n  <span class=\"hljs-comment\">// TODO return next unit of work</span>\n}\n</code></pre>\n<p>然后对每个<code>child</code>创建Fiber</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> elements = fiber.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>\n  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">while</span> (index &lt; elements.<span class=\"hljs-property\">length</span>) {\n    <span class=\"hljs-keyword\">const</span> element = elements[index]\n    <span class=\"hljs-keyword\">const</span> newFiber = {\n      <span class=\"hljs-attr\">type</span>: element.<span class=\"hljs-property\">type</span>,\n      <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n      <span class=\"hljs-attr\">parent</span>: fiber,\n      <span class=\"hljs-attr\">dom</span>: <span class=\"hljs-literal\">null</span>,\n    }\n  }\n</code></pre>\n<p>然后将其添加到Fiber树中，将其设置为<code>child</code>还是<code>sibing</code>，具体取决于它是否是第一个child。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) {\n      fiber.<span class=\"hljs-property\">child</span> = newFiber\n    } <span class=\"hljs-keyword\">else</span> {\n      prevSibling.<span class=\"hljs-property\">sibling</span> = newFiber\n    }\n}\nprevSibling = newFiber\nindex++\n</code></pre>\n<p>最后，我们按照child ☞ sibling ☞ uncle来选择下一工作单元。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">child</span>) {\n  <span class=\"hljs-keyword\">return</span> fiber.<span class=\"hljs-property\">child</span>\n}\n<span class=\"hljs-keyword\">let</span> nextFiber = fiber\n<span class=\"hljs-keyword\">while</span> (nextFiber) {\n  <span class=\"hljs-keyword\">if</span> (nextFiber.<span class=\"hljs-property\">sibling</span>) {\n    <span class=\"hljs-keyword\">return</span> nextFiber.<span class=\"hljs-property\">sibling</span>\n  }\n  nextFiber = nextFiber.<span class=\"hljs-property\">parent</span>\n}\n</code></pre>\n<p>完整的代码如下所示：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">if</span> (!fiber.<span class=\"hljs-property\">dom</span>) {\n    fiber.<span class=\"hljs-property\">dom</span> = <span class=\"hljs-title function_\">createDom</span>(fiber)\n  }\n\n  <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">parent</span>) {\n    fiber.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">dom</span>.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  }\n\n  <span class=\"hljs-keyword\">const</span> elements = fiber.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>\n  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span>\n\n  <span class=\"hljs-keyword\">while</span> (index &lt; elements.<span class=\"hljs-property\">length</span>) {\n    <span class=\"hljs-keyword\">const</span> element = elements[index]\n\n    <span class=\"hljs-keyword\">const</span> newFiber = {\n      <span class=\"hljs-attr\">type</span>: element.<span class=\"hljs-property\">type</span>,\n      <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n      <span class=\"hljs-attr\">parent</span>: fiber,\n      <span class=\"hljs-attr\">dom</span>: <span class=\"hljs-literal\">null</span>,\n    }\n\n    <span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) {\n      fiber.<span class=\"hljs-property\">child</span> = newFiber\n    } <span class=\"hljs-keyword\">else</span> {\n      prevSibling.<span class=\"hljs-property\">sibling</span> = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">child</span>) {\n    <span class=\"hljs-keyword\">return</span> fiber.<span class=\"hljs-property\">child</span>\n  }\n  <span class=\"hljs-keyword\">let</span> nextFiber = fiber\n  <span class=\"hljs-keyword\">while</span> (nextFiber) {\n    <span class=\"hljs-keyword\">if</span> (nextFiber.<span class=\"hljs-property\">sibling</span>) {\n      <span class=\"hljs-keyword\">return</span> nextFiber.<span class=\"hljs-property\">sibling</span>\n    }\n    nextFiber = nextFiber.<span class=\"hljs-property\">parent</span>\n  }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">提交更改</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>我们还有一个问题。每次处理一个元素时，我们都会向DOM添加一个新节点。而且，请记住，浏览器可能会在我们完成整个树的渲染之前中断我们的工作。在这种情况下，用户将看到一个不完整的UI。我们不想这样。</p>\n<p>因此，我们需要从<code>performUnitOfWork</code>里删除改变DOM的部分。相反，我们将跟踪Fiber tree。我们称它为<code>wipRoot</code>。一旦我们完成了所有的工作(我们知道它是因为没有下一个工作单元)，我们就将整个Fiber tree提交给DOM。我们在<code>commitRoot</code>函数中完成。在这里，我们递归地将所有节点追加到dom。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Reconciliation</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>到目前为止，我们只向DOM添加了一些东西，那么更新或删除节点呢? </p>\n<p>这就是我们现在要做的，我们需要将<code>render</code>函数接收到的元素与提交给DOM的最后一个Fiber tree进行比较。因此，在完成<code>commit</code>之后，我们需要保存对<strong>最后一个提交到DOM的Fiber tree</strong>的引用。我们称之为<code>currentRoot</code>。我们还在每Fiber中加入了<code>alternate</code>, 此属性是到旧Fiber的链接，即我们在上一个提交阶段提交给DOM的Fiber。</p>\n<p>现在让我们从创建新Fiber的<code>performUnitOfWork</code>函数中提取代码到<code>reconcileChildren</code> 。在这里，我们将<code>reconcile</code>旧的fibers和新元素。我们同时遍历旧Fiber tree(<code>wipFiber.alternate</code>)的子元素和我们想要reconciliation的元素数组。如果我们忽略同时遍历数组和链表所需的所有样板文件，那么我们只剩下while中最重要的部分:oldFiber和element。元素是我们想要渲染到DOM的东西，而oldFiber是我们上次渲染的东西。我们需要比较它们，看看是否需要对DOM进行更改。</p>\n<p>为了比较它们，我们使用类型:</p>\n<ul>\n<li>如果旧的Fiber和新元素具有相同的类型，我们可以保留DOM节点，并使用新的道具更新它</li>\n<li>如果类型不同，并且有一个新元素，这意味着我们需要创建一个新的DOM节点</li>\n<li>如果类型不同，并且有一个旧的光纤，我们需要删除旧的节点</li>\n</ul>\n<p>这里React也使用key，这样可以更好的<code>reconcile</code>。例如，它检测子元素在元素数组中的位置发生了变化。</p>\n<p>当旧Fiber和元素具有相同的类型时，我们创建一个新Fiber，使DOM节点与旧Fiber保持一致，使props与element保持一致。我们还向Fiber 添加了一个新属性:<code>effectTag</code>。我们将在稍后的<code>commit</code>阶段使用此属性。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> sameType =\n      oldFiber &amp;&amp;\n      element &amp;&amp;\n      element.<span class=\"hljs-property\">type</span> == oldFiber.<span class=\"hljs-property\">type</span>\n<span class=\"hljs-keyword\">if</span> (sameType) {\n  newFiber = {\n    <span class=\"hljs-attr\">type</span>: oldFiber.<span class=\"hljs-property\">type</span>,\n    <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n    <span class=\"hljs-attr\">dom</span>: oldFiber.<span class=\"hljs-property\">dom</span>,\n    <span class=\"hljs-attr\">parent</span>: wipFiber,\n    <span class=\"hljs-attr\">alternate</span>: oldFiber,\n    <span class=\"hljs-attr\">effectTag</span>: <span class=\"hljs-string\">&quot;UPDATE&quot;</span>,\n  }\n}\n</code></pre>\n<p>对于element需要一个新DOM节点的情况，我们用<code>PLACEMENT</code>标记标记新Fiber。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (element &amp;&amp; !sameType) {\n  newFiber = {\n    <span class=\"hljs-attr\">type</span>: element.<span class=\"hljs-property\">type</span>,\n    <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n    <span class=\"hljs-attr\">dom</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">parent</span>: wipFiber,\n    <span class=\"hljs-attr\">alternate</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">effectTag</span>: <span class=\"hljs-string\">&quot;PLACEMENT&quot;</span>,\n  }\n}\n</code></pre>\n<p>对于需要删除节点的情况，我们没有新的Fiber，所以我们在旧Fiber上添加effect标签。但是当我们将Fiber树提交到DOM时，我们从正在进行的根目录执行，它没有旧的Fiber 。所以我们需要一个数组来跟踪要删除的节点。然后，当我们将更改提交到DOM时，我们还使用了来自该数组的Fiber。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (oldFiber &amp;&amp; !sameType) {\n  oldFiber.<span class=\"hljs-property\">effectTag</span> = <span class=\"hljs-string\">&quot;DELETION&quot;</span>\n  deletions.<span class=\"hljs-title function_\">push</span>(oldFiber)\n}\n</code></pre>\n<p>现在，让我们修改<code>commitWork</code>函数来处理新的<code>effectTags</code>。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">commitWork</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">if</span> (!fiber) {\n    <span class=\"hljs-keyword\">return</span>\n  }\n  <span class=\"hljs-keyword\">if</span> (\n    fiber.<span class=\"hljs-property\">effectTag</span> === <span class=\"hljs-string\">&quot;PLACEMENT&quot;</span> &amp;&amp;\n    fiber.<span class=\"hljs-property\">dom</span> != <span class=\"hljs-literal\">null</span>\n  ) {\n    domParent.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (\n      fiber.<span class=\"hljs-property\">effectTag</span> === <span class=\"hljs-string\">&quot;UPDATE&quot;</span> &amp;&amp;\n      fiber.<span class=\"hljs-property\">dom</span> != <span class=\"hljs-literal\">null</span>\n    ) {\n      <span class=\"hljs-title function_\">updateDom</span>(\n        fiber.<span class=\"hljs-property\">dom</span>,\n        fiber.<span class=\"hljs-property\">alternate</span>.<span class=\"hljs-property\">props</span>,\n        fiber.<span class=\"hljs-property\">props</span>\n      )\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">effectTag</span> === <span class=\"hljs-string\">&quot;DELETION&quot;</span>) {\n      domParent.<span class=\"hljs-title function_\">removeChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  }\n  <span class=\"hljs-keyword\">const</span> domParent = fiber.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">dom</span>\n  domParent.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  <span class=\"hljs-title function_\">commitWork</span>(fiber.<span class=\"hljs-property\">child</span>)\n  <span class=\"hljs-title function_\">commitWork</span>(fiber.<span class=\"hljs-property\">sibling</span>)\n}\n</code></pre>\n<ul>\n<li><p>如果Fiber有一个<code>PLACEMENT</code>标签，从父Fiber将DOM节点附加到节点。</p>\n</li>\n<li><p>如果是<code>DELETION</code>，则做相反的操作，删除子元素。</p>\n</li>\n<li><p>如果是<code>UPDATE</code>，则需要使用更改后的props更新现有DOM节点。我们将在这个<code>updateDom</code>函数中完成这些操作。将旧Fiber中的props与新Fiber中的props进行比较，去掉不存在的prop，设置新的或更换的prop。需要注意的是，如果prop以<code>on</code>前缀开头，我们将以不同的方式处理它：如果event handler发生了更改，我们将其从节点中删除，然后再添加新的handler。</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isEvent</span> = key =&gt; key.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&quot;on&quot;</span>)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = key =&gt;\n      key !== <span class=\"hljs-string\">&quot;children&quot;</span> &amp;&amp; !<span class=\"hljs-title function_\">isEvent</span>(key)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isNew</span> = (<span class=\"hljs-params\">prev, next</span>) =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span>\n    prev[key] !== next[key]\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isGone</span> = (<span class=\"hljs-params\">prev, next</span>) =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> !(key <span class=\"hljs-keyword\">in</span> next)\n  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateDom</span>(<span class=\"hljs-params\">dom, prevProps, nextProps</span>) {\n  <span class=\"hljs-comment\">// Remove old properties</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(prevProps)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title function_\">isGone</span>(prevProps, nextProps))\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      dom[name] = <span class=\"hljs-string\">&quot;&quot;</span>\n  })\n\n  <span class=\"hljs-comment\">// Set new or changed properties</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(nextProps)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title function_\">isNew</span>(prevProps, nextProps))\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      dom[name] = nextProps[name]\n  })\n  \n  <span class=\"hljs-comment\">// Add event listeners</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(nextProps)\n    .<span class=\"hljs-title function_\">filter</span>(isEvent)\n    .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title function_\">isNew</span>(prevProps, nextProps))\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> eventType = name\n        .<span class=\"hljs-title function_\">toLowerCase</span>()\n        .<span class=\"hljs-title function_\">substring</span>(<span class=\"hljs-number\">2</span>)\n      dom.<span class=\"hljs-title function_\">addEventListener</span>(\n        eventType,\n        nextProps[name]\n      )\n  })\n}\n</code></pre>\n"}},"__N_SSG":true}