{"pageProps":{"post":{"title":"函数式编程-纯函数","tags":["函数式编程","纯函数"],"categories":"函数式编程","description":"# 纯函数的基本概念\n\n纯函数是这样一种函数，相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。\n\n可能会导致不纯的情况：\n\n- 修改调用/传入的参数\n\n  ```javascript\n  let array = [1, 2, 3, 4, 5];\n\n  // 纯的\n  array.slice(0, 3); //[1, 2, 3]\n  array.slice(0, 3); //[1,","createDate":"2019-10-15 13:43:45","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">纯函数的基本概念</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>纯函数是这样一种函数，相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>\n<p>可能会导致不纯的情况：</p>\n<ul>\n<li><p>修改调用/传入的参数</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n\n<span class=\"hljs-comment\">// 纯的</span>\narray.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[1, 2, 3]</span>\narray.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[1, 2, 3]</span>\n\n<span class=\"hljs-comment\">// 不纯的 --&gt; 会修改array</span>\narray.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[1, 2, 3]</span>\narray.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[4, 5]</span>\n</code></pre>\n</li>\n<li><p>依赖外部环境</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// 纯的</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkAge</span>(<span class=\"hljs-params\">minmun, age</span>) {\n  <span class=\"hljs-keyword\">return</span> age &gt; minmun;\n}\n\n<span class=\"hljs-comment\">// 不纯的 --&gt; 引入了外部的环境，从而增加了认知负荷(cognitive load)</span>\n<span class=\"hljs-keyword\">let</span> minmum = <span class=\"hljs-number\">21</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkAge</span>(<span class=\"hljs-params\">age</span>) {\n  <span class=\"hljs-keyword\">return</span> age &gt; minmun;\n}\n</code></pre>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">副作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p>\n<p>副作用可能包括：</p>\n<ul>\n<li>更改文件系统</li>\n<li>往数据库插入记录</li>\n<li>发送一个 http 请求</li>\n<li>修改传入的数据</li>\n<li>打印/log</li>\n<li>获取用户输入</li>\n<li>DOM 查询</li>\n<li>访问系统状态</li>\n<li>......</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">追求纯的理由</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>可缓存性(cacheable)</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">memoize</span>(<span class=\"hljs-params\">f</span>) {\n  <span class=\"hljs-keyword\">let</span> cache = {};\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> arg_str = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(<span class=\"hljs-variable language_\">arguments</span>);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(cache[arg_str]);\n    cache[arg_str] = cache[arg_str] || f.<span class=\"hljs-title function_\">apply</span>(f, <span class=\"hljs-variable language_\">arguments</span>);\n    <span class=\"hljs-keyword\">return</span> cache[arg_str];\n  };\n}\n\n<span class=\"hljs-keyword\">const</span> squareNumber = <span class=\"hljs-title function_\">memoize</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * x);\n\n<span class=\"hljs-title function_\">squareNumber</span>(<span class=\"hljs-number\">3</span>);\n<span class=\"hljs-title function_\">squareNumber</span>(<span class=\"hljs-number\">3</span>);\n</code></pre>\n</li>\n<li><p>可移植性/自文档化(portable/self-documenting)</p>\n</li>\n<li><p>可测试性(testable)</p>\n</li>\n<li><p>合理性(reasonable)</p>\n<p>使用纯函数的最大好处是<a href=\"https://en.wikipedia.org/wiki/Referential_transparency\">引用透明性(referential transparency)</a>。</p>\n<p>如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么就认为这段代码是引用透明的。由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。对于引用透明的代码，可以使用&quot;等式推导&quot;(equational reasoning)的技术来分析代码，所谓&quot;等式推导&quot;就是&quot;一对一&quot;替换，有点像在不考虑程序行执行的怪异行为(quirks of programmatic evaluation)的情况下手动执行相关代码。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Immutable</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;immutable&quot;</span>);\n\n<span class=\"hljs-comment\">// decrementHP是纯函数！！！因为player的来源是immutable.Map，set方法不会使map改变，而是返回一个新的map对象</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">decrementHP</span>(<span class=\"hljs-params\">player</span>) {\n  <span class=\"hljs-keyword\">return</span> player.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&quot;hp&quot;</span>, player.<span class=\"hljs-property\">hp</span> - <span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isSameTeam</span>(<span class=\"hljs-params\">player1, player2</span>) {\n  <span class=\"hljs-keyword\">return</span> player1.<span class=\"hljs-property\">team</span> === player2.<span class=\"hljs-property\">team</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">punch</span>(<span class=\"hljs-params\">player, target</span>) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isSameTeam</span>(player, target)) {\n    <span class=\"hljs-keyword\">return</span> target;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">decrementHP</span>(target);\n  }\n}\n\n<span class=\"hljs-keyword\">let</span> jobe = <span class=\"hljs-title class_\">Immutable</span>.<span class=\"hljs-title class_\">Map</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Jobe&quot;</span>, <span class=\"hljs-attr\">hp</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-attr\">team</span>: <span class=\"hljs-string\">&quot;red&quot;</span> });\n<span class=\"hljs-keyword\">let</span> michael = <span class=\"hljs-title class_\">Immutable</span>.<span class=\"hljs-title class_\">Map</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Michael&quot;</span>, <span class=\"hljs-attr\">hp</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-attr\">team</span>: <span class=\"hljs-string\">&quot;green&quot;</span> });\n\n<span class=\"hljs-title function_\">punch</span>(jobe, michael);\n<span class=\"hljs-comment\">//=&gt; Immutable.Map({name:&quot;Michael&quot;, hp:19, team: &quot;green&quot;})</span>\n</code></pre>\n<p><a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide/issues/244\">关于 decrementHP 是不是纯函数的讨论</a></p>\n</li>\n<li><p>并行代码</p>\n<p>可以并行运行任意纯函数，因为纯函数根本不需要访问共享内存，而且根据其定义，纯函数也不会因副作用而进入<a href=\"https://en.wikipedia.org/wiki/Race_condition\">竞态(race condition)</a></p>\n</li>\n</ul>\n"}},"__N_SSG":true}