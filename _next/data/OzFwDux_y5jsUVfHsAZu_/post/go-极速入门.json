{"pageProps":{"post":{"title":"go-极速入门","tags":["go"],"categories":"go","description":"# 依赖包管理工具\n\n- dep\n  未完待续...\n- go vendor\n  未完待续...\n- glide\n  未完待续...\n- **go modules**\n  \n  伴随Go 1.11出现，**官方推荐**\n\n# go mod 命令\n- `go mod tidy`\n  \n  拉取缺少的模块，移除不用的模块\n- `go mod vandor`\n  \n  将依赖复制到vendor下\n-","createDate":"2020-01-14 13:43:45","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">依赖包管理工具</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>dep\n未完待续...</p>\n</li>\n<li><p>go vendor\n未完待续...</p>\n</li>\n<li><p>glide\n未完待续...</p>\n</li>\n<li><p><strong>go modules</strong></p>\n<p>伴随Go 1.11出现，<strong>官方推荐</strong></p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">go mod 命令</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p><code>go mod tidy</code></p>\n<p>拉取缺少的模块，移除不用的模块</p>\n</li>\n<li><p><code>go mod vandor</code></p>\n<p>将依赖复制到vendor下</p>\n</li>\n<li><p><code>go mod download</code></p>\n<p>下载依赖包</p>\n</li>\n<li><p><code>go mod verify</code></p>\n<p>检测依赖</p>\n</li>\n<li><p><code>go mod graph</code></p>\n<p>打印模块依赖图</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片就像数组的引用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片拥有 <em>长度</em> 和 <em>容量</em></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>切片的长度就是它所包含的元素个数。</li>\n<li>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</li>\n<li>切片 s 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片可以用内建函数 <code>make</code> 来创建，这也是创建动态数组的方式。<code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\">a := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">5</span>)  <span class=\"hljs-comment\">// len(a)=5</span>\n\n<span class=\"hljs-comment\">// 要指定它的容量，需向 make 传入第三个参数：</span>\nb := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// len(b)=0, cap(b)=5</span>\nb = b[:<span class=\"hljs-built_in\">cap</span>(b)] <span class=\"hljs-comment\">// len(b)=5, cap(b)=5</span>\nb = b[<span class=\"hljs-number\">1</span>:]      <span class=\"hljs-comment\">// len(b)=4, cap(b)=4</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">向切片追加元素</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。append 的结果是一个包含原切片所有元素加上新添加元素的切片。当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个(<strong>cap值翻倍</strong>)更大的数组。返回的切片会指向这个新分配的数组。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> s []<span class=\"hljs-type\">int</span>\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=0 cap=0 []</span>\n\n    <span class=\"hljs-comment\">// cap不够用——&gt;cap翻倍——&gt;cap=2</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">0</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=1 cap=2 [0]</span>\n\n    <span class=\"hljs-comment\">// cap够用——&gt;保持不变——&gt;cap=2</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">1</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=2 cap=2 [0 1]</span>\n\n    <span class=\"hljs-comment\">// cap不够用——&gt;cap翻倍——&gt;cap=8</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=5 cap=8 [0 1 2 3 4]</span>\n\n    <span class=\"hljs-comment\">// cap够用——&gt;cap保持不变——&gt;cap=8</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=8 cap=8 [0 1 2 3 4 5 6 7]</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printSlice</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">int</span>)</span></span> {\n    fmt.Printf(<span class=\"hljs-string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"hljs-built_in\">len</span>(s), <span class=\"hljs-built_in\">cap</span>(s), s)\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>map</code>-无序的 <code>key-value</code> 数据结构</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>map集合中的 <code>key/value</code> 可以是任意类型，但所有<code>key</code>必须同属于一种数据类型，所有的<code>value</code>必须同属于一种数据类型。<code>key</code> 和 <code>value</code> 的数据类型可以不相同</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>for</code>循环</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-go\">person := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span> { <span class=\"hljs-string\">&quot;tom&quot;</span>, <span class=\"hljs-string\">&quot;john&quot;</span>, <span class=\"hljs-string\">&quot;jerry&quot;</span> }\n\n<span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> person {\n  fmt.Printf(<span class=\"hljs-string\">&quot;person[%d]: %s\\n&quot;</span>, k, v)\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>go</code>关键字</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>在go关键字后面加一个函数，就可以创建一个线程，函数可以为已经写好的函数，也可以是匿名函数</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  fmt.Printf(<span class=\"hljs-string\">&quot;main start&quot;</span>)\n  <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n    fmt.Println(<span class=\"hljs-string\">&quot;goroutine&quot;</span>)\n  }()\n  time.sleep(<span class=\"hljs-number\">1</span> * time.Second)\n  fmt.Printf(<span class=\"hljs-string\">&quot;main end&quot;</span>)\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>chan</code>-类似于队列，遵循先进先出的规则</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">声明<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// 声明不带缓冲的通道</span>\nch1 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>)\n\n<span class=\"hljs-comment\">// 声明带10个缓冲的通道</span>\nch2 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">10</span>)\n\n<span class=\"hljs-comment\">// 声明只读通道</span>\nch3 := <span class=\"hljs-built_in\">make</span>(&lt;-<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>)\n\n<span class=\"hljs-comment\">// 声明只写通道</span>\nch4 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span>&lt;- <span class=\"hljs-type\">string</span>)\n</code></pre>\n<p>不带缓冲的通道，进何处都会阻塞\n带缓冲的通道，进一次长度+1，出一次长度-1，如果长度等于缓冲区长度时，再进就会阻塞</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">写入<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\">ch1 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">10</span>)\nch1 &lt;- <span class=\"hljs-string\">&quot;a&quot;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">读取<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\">val, ok := &lt;- ch1\nval := &lt;- ch1\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">关闭<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\"><span class=\"hljs-built_in\">close</span>(<span class=\"hljs-keyword\">chan</span>)\n</code></pre>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">productor</span><span class=\"hljs-params\">(ch <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>)</span></span> {\n  fmt.Println(<span class=\"hljs-string\">&quot;producer start&quot;</span>)\n  ch &lt;- <span class=\"hljs-string\">&quot;a&quot;</span>\n  ch &lt;- <span class=\"hljs-string\">&quot;b&quot;</span>\n  ch &lt;- <span class=\"hljs-string\">&quot;c&quot;</span>\n  ch &lt;- <span class=\"hljs-string\">&quot;d&quot;</span>\n  fmt.Println(<span class=\"hljs-string\">&quot;producer end&quot;</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  fmt.Println(<span class=\"hljs-string\">&quot;main start&quot;</span>)\n  ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">3</span>)\n  <span class=\"hljs-keyword\">go</span> producer(ch)\n\n  time.Sleep(<span class=\"hljs-number\">1</span> * time.Second)\n  fmt.Println(<span class=\"hljs-string\">&quot;main end&quot;</span>)\n}\n\n<span class=\"hljs-comment\">// main start</span>\n<span class=\"hljs-comment\">// producer start  发生阻塞</span>\n<span class=\"hljs-comment\">// main end</span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>defer</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>主要应用场景有异常处理、记录日志、清理数据、释放资源 等等。</p>\n<ul>\n<li><code>defer</code>在声明时不会立刻去执行，而是在函数 <code>return</code> 后去执行的。</li>\n<li><code>defer</code>函数定义的顺序与实际执行的顺序是相反的，也就是最先声明的最后才执行</li>\n</ul>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;a&quot;</span>)\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;b&quot;</span>)\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;c&quot;</span>)\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;d&quot;</span>)\n\n  fmt.Println(<span class=\"hljs-string\">&quot;main&quot;</span>)\n}\n\n<span class=\"hljs-comment\">// main</span>\n<span class=\"hljs-comment\">// d</span>\n<span class=\"hljs-comment\">// c</span>\n<span class=\"hljs-comment\">// b</span>\n<span class=\"hljs-comment\">// a</span>\n</code></pre>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">calc</span><span class=\"hljs-params\">(index <span class=\"hljs-type\">string</span>, a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n    ret := a + b\n    fmt.Println(index, a, b, ret)\n    <span class=\"hljs-keyword\">return</span> ret\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    x := <span class=\"hljs-number\">1</span>\n    y := <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-keyword\">defer</span> calc(<span class=\"hljs-string\">&quot;A&quot;</span>, x, calc(<span class=\"hljs-string\">&quot;B&quot;</span>, x, y))\n    x = <span class=\"hljs-number\">3</span>\n    <span class=\"hljs-keyword\">defer</span> calc(<span class=\"hljs-string\">&quot;C&quot;</span>, x, calc(<span class=\"hljs-string\">&quot;D&quot;</span>, x, y))\n    y = <span class=\"hljs-number\">4</span>\n}\n\n<span class=\"hljs-comment\">// B 1 2 3</span>\n<span class=\"hljs-comment\">// D 3 2 5</span>\n<span class=\"hljs-comment\">// C 3 5 8</span>\n<span class=\"hljs-comment\">// A 1 3 4</span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>interface</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基本</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>一种<strong>抽象</strong>类型</li>\n</ul>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n\n<span class=\"hljs-keyword\">type</span> Sayer <span class=\"hljs-keyword\">interface</span> {\n    say()\n}\n\n<span class=\"hljs-keyword\">type</span> Cat <span class=\"hljs-keyword\">struct</span> {\n    Sayer\n}\n\n<span class=\"hljs-keyword\">type</span> Dog <span class=\"hljs-keyword\">struct</span> {\n    Sayer\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(cat *Cat)</span></span> say() {\n    fmt.Println(<span class=\"hljs-string\">&quot;miao miao miao~&quot;</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(dog *Dog)</span></span> say() {\n    fmt.Println(<span class=\"hljs-string\">&quot;wang wang wang~&quot;</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> dog Dog\n    dog.say()\n    <span class=\"hljs-keyword\">var</span> cat Cat\n    cat.say()\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">空接口的应用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>空接口作为函数的参数</li>\n<li>空接口作为<code>map</code>的值</li>\n<li>类型断言<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">var</span> x <span class=\"hljs-keyword\">interface</span>{}\n  x = <span class=\"hljs-string\">&quot;hello world&quot;</span>\n  v, ok := x.(<span class=\"hljs-type\">string</span>)\n  <span class=\"hljs-keyword\">if</span> ok {\n      fmt.Println(v)\n  } <span class=\"hljs-keyword\">else</span> {\n      fmt.Println(<span class=\"hljs-string\">&quot;类型断言失败&quot;</span>)\n  }\n}\n</code></pre>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">单元测试</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的<code>Go</code>代码过程是类似的。</p>\n<p><code>go test</code>命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>\n<p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th align=\"left\">格式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>测试函数</td>\n<td align=\"left\">函数名前缀为<code>Test</code></td>\n<td>测试程序的一些逻辑行为是否正确</td>\n</tr>\n<tr>\n<td>基准函数</td>\n<td align=\"left\">函数名前缀为<code>Benchmark</code></td>\n<td>测试函数的性能</td>\n</tr>\n<tr>\n<td>示例函数</td>\n<td align=\"left\">函数名前缀为<code>Example</code></td>\n<td>为文档提供示例文档</td>\n</tr>\n</tbody></table>\n<p>测试函数实例</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestName</span><span class=\"hljs-params\">(t *testing.T)</span></span>{\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n"}},"__N_SSG":true}