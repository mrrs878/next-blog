{"pageProps":{"posts":[{"title":"React.js学习-StreamingSSR","tags":["React.js","StreamingSSR","SSR"],"categories":"React.js","description":"流式服务端渲染\n\n首先，让我们看一下 React18 之前是怎么实现 SSR 的\n\n## HTTP分块传输\n\n不过在此之前，我们可能需要先了解一下**HTTP分块传输**\n\n> 分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP 由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只","createDate":"2023-02-07 20:41:44","updateDate":"2023-02-17 19:57:42","body":"<p>流式服务端渲染</p>\n<p>首先，让我们看一下 React18 之前是怎么实现 SSR 的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP分块传输</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>不过在此之前，我们可能需要先了解一下<strong>HTTP分块传输</strong></p>\n<blockquote>\n<p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP 由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在 HTTP 协议 1.1 版本（HTTP/1.1）中提供。</p>\n</blockquote>\n<p>当 HTTP 的响应头设置 <code>Transfer-Encoding: chunked</code> 时，服务器端就可以将 Response 分段返回</p>\n<p>如下示例</p>\n<pre><code class=\"hljs language-js\">app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-keyword\">async</span> (req, res) =&gt; {\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>);\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Transfer-Encoding&quot;</span>, <span class=\"hljs-string\">&quot;chunked&quot;</span>);\n\n  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;&lt;html&gt;&lt;body&gt;&lt;div&gt;First segment&lt;/div&gt;&quot;</span>);\n  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;&lt;div&gt;Second segment&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);\n\n  res.<span class=\"hljs-title function_\">end</span>();\n});\n</code></pre>\n<p>完整版 demo<a href=\"https://github.com/mrrs878/snippets/tree/main/demos/node-streaming\">看这里</a></p>\n<p>在使用 telnet 测试时，可以清楚地看到响应报文中的 <code>chunked</code> 数据格式: 先是一行 16 进制数据（表示接下来数据的长度），然后是数据；然后再是 16 进制长度和数据，如此重复，最后是 0 长度分块结束</p>\n<p><img src=\"/img/streaming-ssr-4.png\" alt=\"renderString timing\"></p>\n<p>这样，针对于页面渲染，<strong>浏览器就可以先渲染部分，而后持续接收服务端返回的数据来继续渲染</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">renderToString &amp; renderToNodeStream</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>这是 React18 之前提供的用于 SSR 的 API ，两个方法都可用于在服务端渲染组件，两者的区别在于 <code>renderToString</code> 会将一个组件渲染为 HTML 字符串， 而 <code>renderToNodeStream</code> 会将一个组件渲染称为一个 Node.js 可读流，可通过 <code>res.write</code> 将数据传递给客户端</p>\n<p>这是一个典型的SSR应用架构。在用户访问页面时，先在服务端使用一些 React 提供的 API 将将组件渲染为 html 发送给客户端，这样客户端能够在 javascript 执行完毕前展示基本的 html 内容，减少白屏等待时间。然后在 javascript 加载完毕后对现有的 html 元素进行事件绑定（注水），注水完毕后才是一个正常的 React 应用</p>\n<p>虽然可以实现 SSR ，但存在一些弊端： </p>\n<ol>\n<li><p><strong>存在大量的阻塞性行为：服务端需要等待组件全部渲染完毕后才能发送给客户端；客户端需要等待所有组件的 javascript 加载完毕后才能进行注水操作（渲染逻辑复杂时，页面首次渲染到可交互之间可能存在较长的不可交互时间）</strong></p>\n</li>\n<li><p><strong>不支持懒加载/代码分割</strong></p>\n</li>\n</ol>\n<p>好消息是 React18 中的 <a href=\"https://github.com/facebook/react/pull/14144\">Fizz</a> 架构带来了两个新的特性可以完美解决这些问题，即<strong>Streaming HTML（流式渲染）</strong>和<strong>Selective Hydration（选择性注水）</strong></p>\n<p>接下来让我们看看 React18 是如何解决这些问题的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">流式渲染（Streaming HTML）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">renderToPipeableStream</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>虽然 <code>renderToNodeStream</code> 相对于 <code>renderToString</code> 有一定的性能提升，但还存在一个问题<strong>需要等服务端将整个页面渲染完毕后才会开始传输数据</strong>，复杂情况下，如果某个组件内有耗时的操作，这样就会阻塞 HTML 的生成。对此，React18 提供了一个新的 API <code>renderToPipeableStream</code> ，相较于 <code>renderToNodeStream</code> 该方法可以分段传输 HTML 到浏览器，这样浏览器就可以更快地启动 HTML 的渲染，提高性能</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">选择性注水 （Selective Hydration）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ref</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81\">分块传输编码</a></p>\n</li>\n<li><p><a href=\"https://zh-hans.reactjs.org/docs/react-dom-server.html#rendertonodestream\">rendertonodestream</a></p>\n</li>\n<li><p><a href=\"https://juejin.cn/post/7064759195710521381\">浅析 React 18 Streaming SSR（流式服务端渲染）</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2ODQ1OTExOA==&amp;mid=2247501565&amp;idx=1&amp;sn=b9488bb90455e33eb94ec379c46ce42b&amp;chksm=cea971fcf9def8ea0f176bb06ab65ab4bcf20bfc605f8d728ca382a9de8e72cdfd7c1d1b0930&amp;token=805012839&amp;lang=zh_CN#rd\">React Streaming SSR 原理解析</a></p>\n</li>\n</ul>\n"},{"title":"ETag","tags":["ETag"],"categories":"网络","description":"![编译](/img/etag.png)\n\n## 什么是ETag\n\nhttp响应头，服务端根据返回的资源生成，有两种语法—强/弱\n\n有两种用途: 缓存、乐观并发控制\n\n## 缓存\n\n可用来实现协商缓存，大致流程如下\n\n![协商缓存](/img/etag-1.png)\n\n1. 浏览器首次访问时，服务端基于返回的数据，根据「合适的算法」计算出一个hash串 ，并在响应头中携带进 `ETag` 头部","createDate":"2022-11-09 21:13:46","updateDate":"2022-11-09 21:36:41","body":"<p><img src=\"/img/etag.png\" alt=\"编译\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是ETag</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>http响应头，服务端根据返回的资源生成，有两种语法—强/弱</p>\n<p>有两种用途: 缓存、乐观并发控制</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">缓存</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>可用来实现协商缓存，大致流程如下</p>\n<p><img src=\"/img/etag-1.png\" alt=\"协商缓存\"></p>\n<ol>\n<li><p>浏览器首次访问时，服务端基于返回的数据，根据「合适的算法」计算出一个hash串 ，并在响应头中携带进 <code>ETag</code> 头部</p>\n</li>\n<li><p>浏览器「根据情况」适当缓存响应数据</p>\n</li>\n<li><p>浏览器再次访问时，请求头中携带 <code>If-None-Match</code> ，服务端会判断该值是否是最新的，如果是，服务器则返回304状态码，浏览器直接使用本次已缓存的数据；否则返回200和最新的 <code>ETag</code></p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">实现乐观并发控制</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。乐观并发控制多数用于数据竞争(data race)不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。    -- wiki</p>\n</blockquote>\n<p>简单来讲就是对产生冲突的情况持一种「乐观」的态度，乐观并发控制将重点放在事务提交<strong>冲突检查</strong>上，而不是直接锁住数据不让访问</p>\n<p>实现原理: 提交时带上 <code>If-Match</code> 头部，值为获取资源接口响应头中的<code>ETag</code> ，服务端判断如果该值是否为最新的，如果不匹配，则意味着数据已经被修改，抛出 <code>412</code> 前提条件失败错误</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Q&amp;A</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在实际使用过程中，有以下收获/踩过以下坑</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">强/弱两种语法到底意味着什么</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>现在还是不知道 🤷‍♂️</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ETag如何计算/生成</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>并未规定算法，各web服务器实现方式不一，以下为 Node.js 的实现 <a href=\"https://github.com/jshttp/etag#readme\">etag</a></p>\n<ul>\n<li>资源文件</li>\n</ul>\n<p><img src=\"/img/etag-3.png\" alt=\"stattag\"></p>\n<p>使用文件长度+mtime</p>\n<ul>\n<li>string/Buffer</li>\n</ul>\n<p><img src=\"/img/etag-2.png\" alt=\"stattag\"></p>\n<p>内容长度+内容hash</p>\n<p>ps: mtime(modified time, 指文件内容改变的时间戳)</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ETag改变，是否意味着资源一定发生变动</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>不。当编辑文件却未更改文件内容时，或者 touch file，mtime 也会改变，此时 etag 会发生改变，但是文件内容没有更改</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ETag代表的协商缓存在POST请求中能使用吗</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>不可以。尽管rfc规定在设置合适的响应头(<code>content-location</code>)后或合适的操作(先POST后GET，此时GET会使用缓存的POST数据)，浏览器可以缓存POST请求，但实验证明浏览器并没有实现该特性；并且，对于相同的url，POST请求会使GET请求的缓存失效</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag\">ETag</a></p>\n<p><a href=\"https://zh.m.wikipedia.org/zh-hans/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\">乐观并发控制</a></p>\n<p><a href=\"https://stackoverflow.com/a/59569451/12241567\">Is it possible to cache POST methods in HTTP?</a></p>\n"},{"title":"编译原理-绪论","tags":["编译原理"],"categories":"编译原理","description":"![编译](/img/compiler-0.png)\n\n## 什么是编译\n\n编译：将高级语言翻译成汇编语言或机器语言的过程\n\n高级语言：源语言；汇编语言/机器语言：目标语言\n\n- 机器语言（Machine Language）：可以被计算机直接理解。与人类表达习惯相去甚远，难记忆、难编写、难阅读、易写错\n\n- 汇编语言（Assembly Language）：引入助记符。依赖于特定机器，非计算机专业","createDate":"2022-09-14 21:13:46","updateDate":"2022-09-14 21:13:46","body":"<p><img src=\"/img/compiler-0.png\" alt=\"编译\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是编译</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>编译：将高级语言翻译成汇编语言或机器语言的过程</p>\n<p>高级语言：源语言；汇编语言/机器语言：目标语言</p>\n<ul>\n<li><p>机器语言（Machine Language）：可以被计算机直接理解。与人类表达习惯相去甚远，难记忆、难编写、难阅读、易写错</p>\n</li>\n<li><p>汇编语言（Assembly Language）：引入助记符。依赖于特定机器，非计算机专业人员使用受限制，编写效率依然低效</p>\n</li>\n<li><p>高级语言（High Level Language）：类似于数学定义或自然语言的简洁形式。接近人类表达习惯，不依赖于特定机器，编写效率高</p>\n</li>\n</ul>\n<p>ps: 编译型语言和解释型语言-编译型语言在编译过程中生成目标平台的指令，解释型语言在运行过程中才生成目标平台的指令。虚拟机的任务是在运行过程中将中间代码翻译成目标平台的指令。（详细信息可查看参考1）</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">编译器的结构</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>可大致分为两部分：<strong>前端</strong>，<strong>后端</strong></p>\n<p><img src=\"/img/compiler-1.png\" alt=\"编译\"></p>\n<p>前端（front end）：与源语言相关，又可分为：词法分析、语法分析、语义分析、中间代码生成几个<strong>阶段(phase)</strong></p>\n<p>后端（back end）：与目标语言相关，又可分为：目标代码生成、机器语言优化几个<strong>阶段(phase)</strong></p>\n<p>其中每个阶段都会读取上一阶段的输出，并产出独特的数据结构</p>\n<p>阶段：编译器的逻辑组成，在实际实现过程中，多个阶段可能会被组合在一起（比如语义分析的结果通常会直接表示为中间代码的形式）</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://www.zhihu.com/question/21486706/answer/18642540\">程序的编译与解释有什么区别？</a></p>\n"},{"title":"设计模式-模板方法模式","tags":["设计模式","模板方法模式"],"categories":"设计模式","description":"# WHAT\n\n模板方法是一种只需要使用继承就可以实现的较为简单的模式。\n\n模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常**在抽象父类中封装了子类的算法框架**，包括实现一些公共方法及**封装子类中所有方法的执行顺序**。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。\n\n符合 OCP 原则\n\n# WHY\n\n模板方法模式是一种典型的通","createDate":"2019-10-19 14:32:49","updateDate":"2022-09-05 21:27:09","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>模板方法是一种只需要使用继承就可以实现的较为简单的模式。</p>\n<p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常<strong>在抽象父类中封装了子类的算法框架</strong>，包括实现一些公共方法及<strong>封装子类中所有方法的执行顺序</strong>。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>\n<p>符合 OCP 原则</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语 言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把 这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这 部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>分离共同点</p>\n</li>\n<li><p>写父类(子类的共同点)，<strong>保证子类一定会实现(使用抛异常、抽象类/抽象方法、构造函数等来约束)</strong></p>\n</li>\n<li><p>写子类，继承父类，实现父类的方法</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">传统继承实现</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// 抛异常约束版</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Beverage</span> {\n  <span class=\"hljs-title function_\">boilWater</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;把水煮沸&quot;</span>);\n  }\n  <span class=\"hljs-title function_\">brew</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;子类应该实现brew方法&quot;</span>);\n  }\n  <span class=\"hljs-title function_\">pourInCup</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;子类应该实现pourInCup方法&quot;</span>);\n  }\n  <span class=\"hljs-title function_\">addCondiments</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;子类应该实现addCondiments方法&quot;</span>);\n  }\n  <span class=\"hljs-comment\">/**\n   * 封装了饮料的算法框架\n   */</span>\n  <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">boilWater</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">brew</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">pourInCup</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">addCondiments</span>();\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Coffee</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Beverage</span> {\n  <span class=\"hljs-title function_\">brew</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;用沸水冲泡咖啡&quot;</span>);\n  }\n  <span class=\"hljs-title function_\">pourInCup</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;把咖啡倒进杯子&quot;</span>);\n  }\n  <span class=\"hljs-title function_\">addCondiments</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;加糖和牛奶&quot;</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">let</span> coffee = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Coffee</span>();\ncoffee.<span class=\"hljs-title function_\">init</span>();\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">高阶函数实现</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>javascript 中，函数是一等公民，可以直接将函数传递进 init 中</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">beverage</span> = (<span class=\"hljs-params\">param</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">boilWater</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;把水煮沸&quot;</span>);\n  }\n\n  <span class=\"hljs-keyword\">const</span> brew = param.<span class=\"hljs-property\">brew</span> || (<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;应该传入brew方法&quot;</span>);\n  })\n\n  <span class=\"hljs-keyword\">const</span> pourInCup = param.<span class=\"hljs-property\">pourInCup</span> || (<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;应该传入pourInCup方法&quot;</span>);\n  })\n\n  <span class=\"hljs-keyword\">const</span> addCondiments = param.<span class=\"hljs-property\">addCondiments</span> || (<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;应该传入addCondiments方法&quot;</span>);\n  })\n\n  <span class=\"hljs-comment\">/**\n   * 封装了饮料的算法框架\n   */</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">init</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-title function_\">boilWater</span>();\n    <span class=\"hljs-title function_\">brew</span>();\n    <span class=\"hljs-title function_\">pourInCup</span>();\n    <span class=\"hljs-title function_\">addCondiments</span>();\n  }\n\n  <span class=\"hljs-keyword\">return</span> {\n    init\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> coffee = <span class=\"hljs-title function_\">beverage</span>({\n  <span class=\"hljs-attr\">brew</span>: <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;用沸水冲泡咖啡&#x27;</span>);\n  },\n  <span class=\"hljs-attr\">pourInCup</span>: <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;把咖啡倒进杯子&#x27;</span>);\n  },\n  <span class=\"hljs-attr\">addCondiments</span>: <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;加糖和牛奶&#x27;</span>);\n  },\n})\n\ncoffee.<span class=\"hljs-title function_\">init</span>();\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">变化</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>兼容多种算法？有些子类的需要一些特殊的算法</p>\n<p>钩子方法(hook)可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自 行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向</p>\n"},{"title":"设计模式-状态模式","tags":["设计模式","状态模式"],"categories":"设计模式","description":"学习一下「状态模式」\n\n## 从一个场景切入\n\n💡 需求：按下按钮，根据当前的状态，电灯会切换到新的状态 off->on/on->off\n\n针对于这个小的需求，第一时间可能会写下这段代码\n\n```ts\nenum State {\n  on,\n  off,\n}\n\nclass Light {\n  state: State;\n\n  constructor() {\n    this.state = St","createDate":"2022-08-27 15:11:28","updateDate":"2022-08-30 20:35:40","body":"<p>学习一下「状态模式」</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">从一个场景切入</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>💡 需求：按下按钮，根据当前的状态，电灯会切换到新的状态 off-&gt;on/on-&gt;off</p>\n<p>针对于这个小的需求，第一时间可能会写下这段代码</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-built_in\">enum</span> <span class=\"hljs-title class_\">State</span> {\n  on,\n  off,\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Light</span> {\n  <span class=\"hljs-attr\">state</span>: <span class=\"hljs-title class_\">State</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">off</span>;\n  }\n\n  <span class=\"hljs-title function_\">press</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">on</span>) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">off</span>;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">off</span>) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">on</span>;\n    }\n  }\n}\n</code></pre>\n<p>测试一下</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> light = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Light</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(light.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">off</span>);\n\nlight.<span class=\"hljs-title function_\">press</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(light.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">on</span>);\n\nlight.<span class=\"hljs-title function_\">press</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(light.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">off</span>);\n</code></pre>\n<p>看起来实现了功能，但其实是存在一些隐患（缺陷）的：一段时间后，需求变了，电灯增加了一种状态--强光：在关闭的情况下，第一次打开是正常光，再按一下会切换到强光，再按一下才是关闭。针对于这个变动，我们上面的代码稍作改动也能处理：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-title function_\">press</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">off</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">on</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">on</span>) {\n    <span class=\"hljs-comment\">// 打开的情况下再次按下会切换到强光</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">superLight</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> === <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">superLight</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = <span class=\"hljs-title class_\">State</span>.<span class=\"hljs-property\">off</span>;\n  }\n}\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>但这仅仅是增加了一种状态，那如果以后再添加一种弱光，强强光。。。那都要去修改 <code>press</code> 方法，一来该函数将会变得极其臃肿；再者，该设计也违反了开闭原则：每次新增或修改 light 的状态，都需要修改 <code>press</code> 方法，这使得该函数非常不稳定，难以维护</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用状态模式改进 💡 程序</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部</strong></p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">State</span> {\n  <span class=\"hljs-attr\">light</span>: <span class=\"hljs-title class_\">Light</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">light: Light</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">light</span> = light;\n  }\n\n  <span class=\"hljs-title function_\">press</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;press方法必须被重写&quot;</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OffLightState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span> {\n  <span class=\"hljs-attr\">light</span>: <span class=\"hljs-title class_\">Light</span>;\n\n  <span class=\"hljs-title function_\">press</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;on&quot;</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">light</span>.<span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">light</span>.<span class=\"hljs-property\">onLightState</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OnLightState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span> {\n  <span class=\"hljs-attr\">light</span>: <span class=\"hljs-title class_\">Light</span>;\n\n  <span class=\"hljs-title function_\">press</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;superLight&quot;</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">light</span>.<span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">light</span>.<span class=\"hljs-property\">superLightState</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SuperLightState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span> {\n  <span class=\"hljs-attr\">light</span>: <span class=\"hljs-title class_\">Light</span>;\n\n  <span class=\"hljs-title function_\">press</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;off&quot;</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">light</span>.<span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">light</span>.<span class=\"hljs-property\">offLightState</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Light</span> {\n  <span class=\"hljs-attr\">state</span>: <span class=\"hljs-title class_\">State</span>;\n\n  <span class=\"hljs-attr\">offLightState</span>: <span class=\"hljs-title class_\">OffLightState</span>;\n\n  <span class=\"hljs-attr\">superLightState</span>: <span class=\"hljs-title class_\">SuperLightState</span>;\n\n  <span class=\"hljs-attr\">onLightState</span>: <span class=\"hljs-title class_\">OnLightState</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onLightState</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OnLightState</span>(<span class=\"hljs-variable language_\">this</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">offLightState</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OffLightState</span>(<span class=\"hljs-variable language_\">this</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">superLightState</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SuperLightState</span>(<span class=\"hljs-variable language_\">this</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">offLightState</span>;\n  }\n\n  <span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-params\">state: State</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = state;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> light = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Light</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(light.<span class=\"hljs-property\">state</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">OffLightState</span>);\n\nlight.<span class=\"hljs-property\">state</span>.<span class=\"hljs-title function_\">press</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(light.<span class=\"hljs-property\">state</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">OnLightState</span>);\n\nlight.<span class=\"hljs-property\">state</span>.<span class=\"hljs-title function_\">press</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(light.<span class=\"hljs-property\">state</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">SuperLightState</span>);\n\nlight.<span class=\"hljs-property\">state</span>.<span class=\"hljs-title function_\">press</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(light.<span class=\"hljs-property\">state</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">OffLightState</span>);\n</code></pre>\n<p>在这里，我们创建了几个不同的 <code>State</code> ，这个状态都有一个 <code>press</code> 方法，代表开关被按下时执行的动作：切换下一个状态</p>\n<p>使用状态模式后，<strong>代码量明显增加</strong>，但这样的好处非常明显：<strong>它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类中，便于管理；此外，由于状态之间的切换都被分布在状态类内部，因此我们无需编写过多的 <code>if-else</code> 来控制状态之间的转换</strong></p>\n<p>当我们需要为 light 新增一种状态时，只需要增加一个新的 <code>State</code> 然后改变相关联的状态之前的切换规则即可</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用状态机重构</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>借助于 <code>xstate</code> 重构 💡 需求</p>\n<ol>\n<li>创建状态机</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createMachine } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;xstate&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> lightMachine = <span class=\"hljs-title function_\">createMachine</span>({\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;light&quot;</span>,\n  <span class=\"hljs-attr\">initial</span>: <span class=\"hljs-string\">&quot;off&quot;</span>,\n  <span class=\"hljs-attr\">states</span>: {\n    <span class=\"hljs-attr\">off</span>: {\n      <span class=\"hljs-attr\">on</span>: {\n        <span class=\"hljs-attr\">press</span>: <span class=\"hljs-string\">&quot;weak&quot;</span>,\n      },\n    },\n    <span class=\"hljs-attr\">weak</span>: {\n      <span class=\"hljs-attr\">on</span>: {\n        <span class=\"hljs-attr\">press</span>: <span class=\"hljs-string\">&quot;normal&quot;</span>,\n      },\n    },\n    <span class=\"hljs-attr\">normal</span>: {\n      <span class=\"hljs-attr\">on</span>: {\n        <span class=\"hljs-attr\">press</span>: <span class=\"hljs-string\">&quot;super&quot;</span>,\n      },\n    },\n    <span class=\"hljs-attr\">super</span>: {\n      <span class=\"hljs-attr\">on</span>: {\n        <span class=\"hljs-attr\">press</span>: <span class=\"hljs-string\">&quot;off&quot;</span>,\n      },\n    },\n  },\n});\n\n<span class=\"hljs-keyword\">export</span> { lightMachine };\n</code></pre>\n<ol start=\"2\">\n<li>使用</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { interpret } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;xstate&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { lightMachine } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./light.machine&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> lightService = <span class=\"hljs-title function_\">interpret</span>(lightMachine).<span class=\"hljs-title function_\">onTransition</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;lightService.state: &quot;</span>, lightService.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">value</span>);\n});\n\nlightService.<span class=\"hljs-title function_\">start</span>();\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(lightService.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">value</span> === <span class=\"hljs-string\">&quot;off&quot;</span>);\n\nlightService.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&quot;press&quot;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(lightService.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">value</span> === <span class=\"hljs-string\">&quot;weak&quot;</span>);\n\nlightService.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&quot;press&quot;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(lightService.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">value</span> === <span class=\"hljs-string\">&quot;normal&quot;</span>);\n\nlightService.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&quot;press&quot;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(lightService.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">value</span> === <span class=\"hljs-string\">&quot;super&quot;</span>);\n\nlightService.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&quot;press&quot;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">assert</span>(lightService.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">value</span> === <span class=\"hljs-string\">&quot;off&quot;</span>);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>状态模式定义了状态与行为之间的关系，较为细致的区分了事物内部的状态，并且将跟此种状态相关的行为都封装在这个状态内部（比如切换到新的状态），避免了 Context 无限膨胀，方便增加新的状态和转换。但由于每个状态都需要一个类，较为繁琐，并且由于逻辑分散在各个状态类中，无形中增加了对整体的状态机逻辑的理解难度</p>\n"},{"title":"前端架构&软实力-babel","tags":["babel","访问者模式","有限状态机"],"categories":"前端架构&软实力","description":"探究 Babel 内部的一些实现机制\n\n## tokenizer/parse-有限状态机\n\n// TODO\n\n## traverse-访问者模式\n\nVisitor（访问者模式）属于行为型模式\n\n意图：**表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。**\n\n访问者，顾名思义，就是对象访问的一种设计模式，我们可以在不改变要访问对象的前提下","createDate":"2022-08-22 20:11:45","updateDate":"2022-08-24 20:33:45","body":"<p>探究 Babel 内部的一些实现机制</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">tokenizer/parse-有限状态机</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>// TODO</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">traverse-访问者模式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Visitor（访问者模式）属于行为型模式</p>\n<p>意图：<strong>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</strong></p>\n<p>访问者，顾名思义，就是对象访问的一种设计模式，我们可以在不改变要访问对象的前提下，对访问对象的操作做拓展：<strong>它将对象的操作权移交给了 Visitor。</strong></p>\n<p>Babel 在 traverse 阶段用到了访问者模式，该阶段 Babel 的主要工作包括：</p>\n<ol>\n<li><p>对 ast 进行深度优先遍历</p>\n</li>\n<li><p>对节点进行添加、更新和移除等操作</p>\n</li>\n</ol>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Phone</span> {\n  <span class=\"hljs-title function_\">accept</span>(<span class=\"hljs-attr\">visitor</span>: <span class=\"hljs-title class_\">Visitor</span>): <span class=\"hljs-title class_\">PhoneInfo</span>;\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">PhoneInfo</span> {\n  <span class=\"hljs-attr\">os</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">chip</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-title class_\">GPUType</span>?: <span class=\"hljs-built_in\">string</span>;\n  port?: <span class=\"hljs-built_in\">string</span>;\n  screen?: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Visitor</span> {\n  <span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-attr\">phone</span>: <span class=\"hljs-title class_\">Mate40</span>): <span class=\"hljs-title class_\">PhoneInfo</span>;\n  <span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-attr\">phone</span>: <span class=\"hljs-title class_\">IPhone13</span>): <span class=\"hljs-title class_\">PhoneInfo</span>;\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mate40</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Phone</span> {\n  <span class=\"hljs-title function_\">accept</span>(<span class=\"hljs-attr\">visitor</span>: <span class=\"hljs-title class_\">Visitor</span>): <span class=\"hljs-title class_\">PhoneInfo</span> {\n    <span class=\"hljs-keyword\">return</span> visitor.<span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-variable language_\">this</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IPhone13</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Phone</span> {\n  <span class=\"hljs-title function_\">accept</span>(<span class=\"hljs-attr\">visitor</span>: <span class=\"hljs-title class_\">Visitor</span>): <span class=\"hljs-title class_\">PhoneInfo</span> {\n    <span class=\"hljs-keyword\">return</span> visitor.<span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-variable language_\">this</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PhoneVisitor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Visitor</span> {\n  <span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-attr\">phone</span>: <span class=\"hljs-title class_\">Mate40</span>): <span class=\"hljs-title class_\">PhoneInfo</span>;\n  <span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-attr\">phone</span>: <span class=\"hljs-title class_\">IPhone13</span>): <span class=\"hljs-title class_\">PhoneInfo</span>;\n  <span class=\"hljs-title function_\">visit</span>(<span class=\"hljs-attr\">phone</span>: unknown): <span class=\"hljs-title class_\">PhoneInfo</span> {\n    <span class=\"hljs-keyword\">if</span> (phone <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Mate40</span>) {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">os</span>: <span class=\"hljs-string\">&#x27;HarmonyOS&#x27;</span>,\n        <span class=\"hljs-attr\">chip</span>: <span class=\"hljs-string\">&#x27;Kirin 9000&#x27;</span>,\n        <span class=\"hljs-title class_\">GPUType</span>: <span class=\"hljs-string\">&#x27;Mali-G78&#x27;</span>,\n        <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;type-c&#x27;</span>,\n      };\n    }\n    <span class=\"hljs-keyword\">if</span> (phone <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">IPhone13</span>) {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">os</span>: <span class=\"hljs-string\">&#x27;ios&#x27;</span>,\n        <span class=\"hljs-attr\">chip</span>: <span class=\"hljs-string\">&#x27;A15仿生芯片&#x27;</span>,\n        <span class=\"hljs-attr\">screen</span>: <span class=\"hljs-string\">&#x27;电容屏&#x27;</span>,\n      };\n    }\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;不识别的phone&#x27;</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> mate40 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Mate40</span>();\n<span class=\"hljs-keyword\">const</span> visitor = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PhoneVisitor</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mate40.<span class=\"hljs-title function_\">accept</span>(visitor));\n\n<span class=\"hljs-keyword\">export</span> {};\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://www.codetd.com/article/13756799\">由 Babel 理解前端编译原理</a></p>\n"},{"title":"前端架构&软实力-pnpm","tags":["pnpm","npm"],"categories":"前端架构&软实力","description":"[pnpm](https://pnpm.io) 全称是 “Performant NPM”，即高性能的 npm。它结合软硬链接与新的依赖组织方式，大大提升了包管理的效率，也同时解决了 “幽灵依赖” 的问题，让包管理更加规范，降低潜在风险发生的可能性\n\n## 安装&使用\n\n```bash\nnpm i pnpm -g\n```\n\n## npm的历史遗留\n\nnpm2(Node.js 0.11.14~4.9","createDate":"2022-08-15 19:11:45","updateDate":"2022-08-17 20:33:45","body":"<p><a href=\"https://pnpm.io\">pnpm</a> 全称是 “Performant NPM”，即高性能的 npm。它结合软硬链接与新的依赖组织方式，大大提升了包管理的效率，也同时解决了 “幽灵依赖” 的问题，让包管理更加规范，降低潜在风险发生的可能性</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装&amp;使用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-bash\">npm i pnpm -g\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">npm的历史遗留</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>npm2(Node.js 0.11.14~4.9.1) 是通过<strong>嵌套</strong>的方式管理 <code>node_modules</code> 的</p>\n<p><img src=\"/img/npm2-node-modules-structure.png\" alt=\"npm2-node-modules-structure\"></p>\n<p>这样的处理方式层级结构非常明显，可以清楚的知道当前安装的包，但是这样也存在不小的问题：</p>\n<ol>\n<li><p>会有依赖下载多次的问题，无法复用</p>\n</li>\n<li><p>目录层级太深，路径过长，有些操作系统会报错（在 windows 系统中文件路径不能超过 280 个字符）</p>\n</li>\n</ol>\n<p><img src=\"/img/heaviest-objects-in-the-universe.png\" alt=\"heaviest-objects-in-the-universe\"></p>\n<p>npm3+(Node.js 5.0.0+) 是通过<strong>铺平的扁平化</strong>的方式来管理 <code>node_modules</code></p>\n<p><img src=\"/img/npm3-node-modules-structure.png\" alt=\"npm3-node-modules-structure\"></p>\n<p>安装时会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。该方式解决了 npm2 的部分问题，但也引入了其他的问题</p>\n<ol>\n<li><p><strong>幽灵依赖</strong></p>\n</li>\n<li><p>同名的包只会提升一个版本的，其余的版本依然会复制多次，而且该特性严重依赖包的<strong>安装顺序</strong></p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm 的优势</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单描述一下 pnpm 的优势：</p>\n<ul>\n<li><p>快。安装速度快。安装过的依赖会被精准缓存并拿来复用，基于内容寻址存储（CAS），包版本升级带来的变化都只 diff，绝不浪费一点空间</p>\n</li>\n<li><p>狠。废除幽灵依赖</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">寻址方式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>pnpm 的 <code>node_modules</code> 结构</p>\n<p><img src=\"/img/pnpm-node-modules-structure.jpeg\" alt=\"pnpm-node-modules-structure\"></p>\n<ul>\n<li><p>所有的 package 都安装在全局目录 <code>~/.pnpm/v3/files</code> 下，同一版本的包只存储一份内容，甚至不同版本的包也仅存储 diff 内容</p>\n</li>\n<li><p>每个项目的 <code>node_modules</code> 下有 <code>.pnpm</code> 目录以平级结构管理每个版本的包的源码内容，以<strong>硬连接</strong>方式指向 pnpm-store 中的文件地址</p>\n</li>\n<li><p>每个项目的 <code>node_modules</code> 下安装的包结构为树状，以<strong>软链接</strong>的方式将内容指向 <code>node_modules/.pnpm</code> 中的包（类似于 npm2）</p>\n</li>\n</ul>\n<p>针对于使用 <code>pnpm</code> 管理的包，寻址一般会经历以下步骤：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// index.js</span>\n<span class=\"hljs-keyword\">import</span> { something } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;bar&quot;</span>;\n</code></pre>\n<p>以 <code>bar</code> 这个包为例，寻址时的路径大概是这样的：</p>\n<p><code>node_modules/bar</code> -&gt;(软链) <code>node_modules/.pnpm/bar@1.0.0/node_modules/bar</code> -&gt;(硬链) <code>~/.pnpm-store/v3/files/00/xxx</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">幽灵依赖</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>有些项目中未安装的包（未在 <code>package.json</code> 中声明），但仍然可以在项目里使用</p>\n<p>产生的原因：在安装的时候， npm/yarn 会通过铺平的扁平化的方式来管理 <code>node_modules</code> ，因此项目文件中是可以寻址到这个包的</p>\n<p>因为 pnpm 特殊的寻址设计，使得第一层可以仅包含 <code>package.json</code> 定义的包，使 <code>node_modules</code> 不可能寻址到未定义在 <code>package.json</code> 中的包，自然就解决了幽灵依赖的问题</p>\n<p><img src=\"/img/eslint-no-extraneous-dependencies.png\" alt=\"eslint-no-extraneous-dependencies\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">硬链接/软链接</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>硬链接通过 <code>ls originFilePath sourceFilePath</code> 创建，这样创建出来的两个文件都指向同一个文件存储地址，因此无论修改哪个文件，都相当于直接修改了原始地址的内容，导致两个文件内容同时变化。进一步说，通过硬链接创建的文件都是等效的，通过 <code>ls li ./</code> 查看文件属性时，可看到该文件有几个硬链接引用</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 创建源文件</span>\n<span class=\"hljs-built_in\">touch</span> t.txt\n\n<span class=\"hljs-comment\"># 编辑源文件（输入rererererere）</span>\nvim t.txt\n\n<span class=\"hljs-comment\"># 创建硬链接</span>\n<span class=\"hljs-built_in\">ln</span> t.txt t_h.txt\n\n<span class=\"hljs-comment\"># 查看源/目文件内容</span>\n<span class=\"hljs-built_in\">cat</span> t.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-built_in\">cat</span> <span class=\"hljs-built_in\">cat</span> t_h.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-comment\"># 查看源/目文件信息</span>\n<span class=\"hljs-built_in\">ls</span> -li ./t_h.txt ./t.txt\n\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t.txt</span>\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t_h.txt</span>\n\n<span class=\"hljs-comment\"># 2 则表示该文件有几个硬链接引用</span>\n</code></pre>\n<p>软链接通过 <code>ls -s originFilePath sourceFilePath</code> 创建，可以认为是指向文件地址指针的指针，相当于常见的<em>快捷方式</em></p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 创建软链接</span>\n<span class=\"hljs-built_in\">ln</span> -s t.txt t_s.txt\n\n<span class=\"hljs-comment\"># 查看文件内容</span>\n<span class=\"hljs-built_in\">cat</span> t_s.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-comment\"># 查看文件信息</span>\n<span class=\"hljs-built_in\">ls</span> -li ./t_s.txt ./t.txt\n\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t.txt</span>\n<span class=\"hljs-comment\"># 25881568 lrwxr-xr-x  1 echo  staff   5  8 15 19:46 ./t_s.txt -&gt; t.txt</span>\n</code></pre>\n<p>源文件被删除后，软链接会失效，但硬链接不会，软链接可以对文件夹生效。软链接本身只占很小的存储空间，硬链接 0 占用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm-store</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>全局安装目录，存储所有的包（该目录可通过 <code>pnpm store path</code> 查看）</p>\n<p>这个硬链接目标文件并不是普通的 NPM 包源码，而是一个哈希文件，这种文件组织方式叫做 content-addressable（基于内容的寻址）。简单来说，基于内容的寻址比基于文件名寻址的好处是，即便包版本升级了，也仅需存储改动 Diff，而不需要存储新版本的完整文件内容，在版本管理上进一步节约了存储空间。</p>\n<p>pnpm-store 的组织方式大概是这样的：</p>\n<pre><code>~/.pnpm-store\n- v3\n  - files\n    - 00\n      - e4e13870602ad2922bfc7..\n      - e99f6ffa679b846dfcbb1..\n      ..\n    - 01\n      ..\n    - ..\n      ..\n    - ff\n      ..\n</code></pre>\n<p>之所以能采用这种存储方式，是因为 NPM 包一经发布内容就不会再改变，因此适合内容寻址这种内容固定的场景，同时内容寻址也忽略了包的结构关系，当一个新包下载下来解压后，遇到相同文件 Hash 值时就可以抛弃，仅存储 Hash 值不存在的文件，这样就自然实现了开头说的，pnpm 对于同一个包不同的版本也仅存储其增量改动的能力。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>不同于npm/yarn，pnpm 采用了一种全新的包管理方式，不再是复制了，而是都从全局 store <strong>硬连接</strong>到 <code>node_modules/.pnpm</code> ，然后之间通过<strong>软链接</strong>来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/253.%E7%B2%BE%E8%AF%BB%E3%80%8Apnpm%E3%80%8B.md\">253.精读《pnpm》.md</a></p>\n<p><a href=\"https://rushjs.io/pages/advanced/phantom_deps/\">Phantom dependencies</a></p>\n<p><a href=\"https://nodejs.org/zh-cn/download/releases/\">Node.js version</a></p>\n<p><a href=\"https://www.infoq.cn/article/qj3z2ygrzdgicqauaffn\">npm 依赖管理中被忽略的那些细节</a></p>\n<p><a href=\"https://blog.pusher.com/what-you-need-know-npm-5/#:~:text=%24%20npm%20install%20npm%20added%20125%2C%20removed%2032%2C,network%20if%20something%20is%20missing%20from%20the%20cache.\">Here’s what you need to know about npm 5</a></p>\n"},{"title":"typescript学习-高级概念","tags":["分发","逆变","协变"],"categories":"typescript","description":"一些 typescript 中的概念\n\n## 分发\n\n先上 demo\n\n```ts\ntype GetSomeType<T extends string | number> = T extends string ? \"a\" : \"b\";\n\nlet one: GetSomeType<string>;\n// 'a'\n\nlet two: GetSomeType<number>;\n// 'b'\n\nlet","createDate":"2022-07-29 20:01:35","updateDate":"2022-08-01 20:54:30","body":"<p>一些 typescript 中的概念</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">分发</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>先上 demo</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">GetSomeType</span>&lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>&gt; = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> ? <span class=\"hljs-string\">&quot;a&quot;</span> : <span class=\"hljs-string\">&quot;b&quot;</span>;\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">one</span>: <span class=\"hljs-title class_\">GetSomeType</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;;\n<span class=\"hljs-comment\">// &#x27;a&#x27;</span>\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">two</span>: <span class=\"hljs-title class_\">GetSomeType</span>&lt;<span class=\"hljs-built_in\">number</span>&gt;;\n<span class=\"hljs-comment\">// &#x27;b&#x27;</span>\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">three</span>: <span class=\"hljs-title class_\">GetSomeType</span>&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>&gt;;\n<span class=\"hljs-comment\">// ?</span>\n</code></pre>\n<p>对于 <code>three</code> 的类型，感觉会是什么呢？ <code>a</code> or <code>b</code> or <code>&#39;a&#39; | &#39;b&#39;</code> ？</p>\n<p><img src=\"/img/typescript-high-concept-0.png\" alt=\"类型分发\"></p>\n<p>答案是 <code>&#39;a&#39; | &#39;b&#39;</code> !</p>\n<p>有点意思， <code>three</code>的类型竟然被推导成为了 <code>&#39;a&#39; | &#39;b&#39;</code> 组成的联合类型</p>\n<p><strong>其实这就是所谓分发在捣鬼</strong></p>\n<p>抛开晦涩的概念来解读分发，结合上边的 Demo 来说所谓的<strong>分发简单来说就是分别使用 string 和 number 这两个类型进入 GetSomeType 中进行判断，最终返回两次类型结果组成的联合类型</strong></p>\n<p>那么，什么情况下会产生分发呢？满足分发需要一定的条件</p>\n<ol>\n<li><p>毫无疑问分发一定是需要产生在 extends 产生的类型条件判断中，并且是前置类型</p>\n</li>\n<li><p>分发一定是要满足联合类型，只有联合类型才会产生分发</p>\n</li>\n<li><p>分发一定要满足所谓的裸类型中才会产生效果（像 <code>Array&lt;string&gt;</code> 就不属于裸类型）</p>\n</li>\n</ol>\n<p>分发的作用/应用：实现一些工具类型，比如内置的 <code>Exclude</code> 和 <code>Extract</code> 等</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">TypeA</span> = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">boolean</span> | symbol;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">MyExclude</span>&lt;T, U&gt; = T <span class=\"hljs-keyword\">extends</span> U ? <span class=\"hljs-built_in\">never</span> : T;\n</code></pre>\n<p><img src=\"/img/typescript-high-concept-1.png\" alt=\"分发的应用-Exclude\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">逆变</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>首先，思考一下如下场景</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">let</span> a!: { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> };\n<span class=\"hljs-keyword\">let</span> b!: { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> };\n\nb = a;\n\na = b;\n</code></pre>\n<p>对于 <code>a = b</code> 这一赋值 ts 是会报错的</p>\n<p><img src=\"/img/typescript-high-concept-2.png\" alt=\"类型安全性\"></p>\n<p>我们都清楚 TS 属于静态类型检测，所谓类型的赋值是要保证安全性的。</p>\n<p><strong>通俗来说也就是多的可以赋值给少的</strong>，上述代码因为 a 的类型定义中完全包括 b 的类型定义，所以 a 类型完全是可以赋值给 b 类型，这被称为类型兼容性。</p>\n<p>但对于函数而言，刚好相反</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> A = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> };\n<span class=\"hljs-keyword\">type</span> B = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> };\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fn1</span> = (<span class=\"hljs-params\">a: A</span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-property\">name</span>);\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fn2</span> = (<span class=\"hljs-params\">b: B</span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b.<span class=\"hljs-property\">name</span>);\n\nfn1 = fn2;\n\n<span class=\"hljs-comment\">// 报错</span>\nfn2 = fn1;\n</code></pre>\n<p>对于 <code>fn2 = fn1</code> 是会报错的，如下</p>\n<p><img src=\"/img/typescript-high-concept-3.png\" alt=\"逆变\"></p>\n<p>逆变，描述的是函数之间互相赋值，<strong>参数</strong>之间的类型兼容性，参数少的可以赋值给参数多的，反之则不可</p>\n<p>原因可以简单的理解为：函数之间的赋值复制的是指针，但函数调用时该函数的签名（js中并没有函数签名，只是为了方便解释）并没有跟随一起复制过去。</p>\n<p>因此，拿上面的例子来讲：假设 <code>fn2 = fn1</code> 可以正常执行，在此操作后，执行 <code>fn2(b: B)</code> 实际上执行的是 <code>fn1</code> ，但入参是 <code>B</code> 类型，此时 <code>fn1</code> 内部可能会调用 <code>A</code> 中存在但 <code>B</code> 中不存在的一些属性，可能会报错。为了保证安全性，因此不允许这种赋值</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">协变</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>协变，描述的是函数之间互相赋值，<strong>返回值</strong>之间的类型兼容性，参数多的可以赋值给参数少的，反之则不可</p>\n<p>例如</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> A = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> };\n<span class=\"hljs-keyword\">type</span> B = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> };\n\n<span class=\"hljs-keyword\">let</span> fn1!: <span class=\"hljs-function\">() =&gt;</span> A;\n<span class=\"hljs-keyword\">let</span> fn2!: <span class=\"hljs-function\">() =&gt;</span> B;\n\n<span class=\"hljs-comment\">// 报错</span>\nfn1 = fn2;\n\nfn2 = fn1;\n</code></pre>\n<p><img src=\"/img/typescript-high-concept-4.png\" alt=\"协变\"></p>\n<p>其实这种现象也很好理解：就像普通变量赋值一样，为保证类型安全性，阻止了该行为</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://juejin.cn/post/7089809919251054628\">如何进阶 TypeScript 功底？一文带你理解 TS 中各种高级语法</a></p>\n"},{"title":"「转」微内核架构应用研究","tags":["微内核"],"categories":"软件架构","description":"转载自: https://yunsong0922.github.io/2018/12/09/微内核架构应用研究/\n\n**微内核架构（Microkernel Architecture）也叫 Plugin Architecture，是一种基于插件的架构方式，通过编写精简的微内核来支撑以 plugin 的方式来添加更多丰富的功能**。微内核架构在我们常用的应用和框架里面非常常见，比如工具有 Intel","createDate":"2022-07-28 21:23:31","updateDate":"2022-07-29 19:38:14","body":"<p>转载自: <a href=\"https://yunsong0922.github.io/2018/12/09/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6/\">https://yunsong0922.github.io/2018/12/09/微内核架构应用研究/</a></p>\n<p><strong>微内核架构（Microkernel Architecture）也叫 Plugin Architecture，是一种基于插件的架构方式，通过编写精简的微内核来支撑以 plugin 的方式来添加更多丰富的功能</strong>。微内核架构在我们常用的应用和框架里面非常常见，比如工具有 IntelliJ、Chrome、Sublime、Photoshop 等， 前端框架有 jQuery、Babel、Webpack 等，基本比较流行的应用和框架都采用了微内核架构，虽然具体技术实现不同，但从思想上，它们都利用了插件机制带来的扩展性和灵活性。</p>\n<p>微内核架构具体来说是什么样子的架构？为何具有如此大的威力？有哪些框架在使用它和架构以及如何使用的？下面的内容会进行具体的介绍。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">1、什么是微内核架构？</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>微内核架构包含两个核心概念：内核系统和插件模块</strong>。应用的逻辑被切分到内核系统和插件模块中，以提供很好的扩展性、灵活性和逻辑隔离性。<strong>内核系统是将系统所要完成的业务逻辑进行高度的抽象，在高度抽象概念的基础上以实现通用业务逻辑。插件模块是独立的组件，包含特定的处理逻辑和自定义代码，旨在增强或扩展微核心以产生额外的业务功能</strong>。通常，插件模块应独立于其他插件模块，当然也可以设计需要其他插件的插件。无论哪种方式，将插件之间的通信保持在最低限度以避免依赖性问题非常重要。</p>\n<p>内核系统在运行时候需要知道可用的插件，并获取它们的引用。比较常见的方式是微内核实现一种类<strong>注册表</strong>的机制，插件会注册到注册表中，从而微内核在适当的时机完成对插件的调用。微内核和插件之间的具体通信协议在架构模式层面并没做具体限制，可以是在同一个进程内，也可以是分布式的，可以通过 Socket 通信，也可以通过 HTTP 通信。关键的是<strong>插件可以扩展微内核，并且各个插件之间的功能各自独立</strong>。</p>\n<p><img src=\"/img/microkernel-architecture-0.png\" alt=\"微内核架构示意图\"></p>\n<p>下面让我们看看现有的框架是如何实现微内核架构的。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">2、 微内核架构的前端应用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">2.1、 jQuery 的微内核架构实现</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>jQuery 是前端流行的综合性框架，为前端的发展做出了不朽的贡献，在 MV* 框架流行之前，jQuery 扛起了整个前端大旗。为什么 jQuery 能如此流行呢？其中一个重要的原因是 jQuery 的简单和非常容易扩展。jQuery 的插件规则非常简单，几乎没有具体的规则，这是它能在整个社区中实现的难以置信的多样性的原因之一。</p>\n<p>我们可以简单地<strong>通过向 jQuery 的 jQuery.fn 对象添加一个新的函数属性来编写一个插件</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 方法 1</span>\n(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">$</span>){\n  $.fn.<span class=\"hljs-property\">myPlugin</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-comment\">//our plugin logic</span>\n  };\n})(jQuery);\n\n<span class=\"hljs-comment\">// 方法 2</span>\njQuery.<span class=\"hljs-title function_\">extend</span>({\n  <span class=\"hljs-attr\">myPlugin</span>: <span class=\"hljs-title function_\">funtion</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">//our plugin logic</span>\n  }\n})\n</code></pre>\n<p>这里我们通过两种方法，生成了 myPlugin myPlugin 中可以做任何我们想做的事情。</p>\n<p>具体插件使用方法如下</p>\n<pre><code class=\"hljs language-js\">$(<span class=\"hljs-string\">&quot;#elem&quot;</span>).<span class=\"hljs-title function_\">myPlugin</span>({\n  <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;value&quot;</span>,\n});\n</code></pre>\n<p>这么简单的插件机制，jQuery 是如何实现的呢？jQuery 采用了原型设计模式</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// jQuery 入口函数</span>\n<span class=\"hljs-keyword\">var</span> jQuery = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">selector, context</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> jQuery.<span class=\"hljs-title function_\">init</span>(selector, context);\n};\n\n<span class=\"hljs-comment\">// jQuery 核心原型定义，也是 jQuery plugin 的扩展接口</span>\njQuery.<span class=\"hljs-property\">fn</span> = jQuery.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = {\n  <span class=\"hljs-attr\">hello</span>: <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);\n  },\n  <span class=\"hljs-comment\">//... 其他定义</span>\n};\n\n<span class=\"hljs-comment\">// 另一种扩展 plugin 的便捷方法，接收一个对象</span>\njQuery.<span class=\"hljs-property\">extend</span> = jQuery.<span class=\"hljs-property\">fn</span>.<span class=\"hljs-property\">extend</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">targetObj</span>) {\n  <span class=\"hljs-comment\">// 克隆 targetObj</span>\n};\n\n<span class=\"hljs-comment\">// jQuery 真正的实例化构造函数</span>\n<span class=\"hljs-keyword\">var</span> init = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">selector, context</span>) {\n  <span class=\"hljs-comment\">// init dom elements</span>\n};\ninit.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = jQuery.<span class=\"hljs-property\">fn</span>;\njQuery.<span class=\"hljs-property\">init</span> = init;\n$ = jQuery;\n</code></pre>\n<p>我们所有的扩展其实赋值给了 jQuery.prototype，这样在生成真正的 jQuery 对象的时候，相应的扩展就都可以使用了。jQuery 中自带的大量函数都是基于这种方式实现的。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">2.2、 Webpack 的微内核架构实现</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Webpack 是前端领域熟知的打包框架，可以将各种资源打包到 js 文件中，统一进行管理。Webpack 之所以能灵活的加载各种类型的资源，并将这些资源以灵活的形式进行打包，得益于 Webpack 优雅的微内核架构设计。</p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">概念和架构设计</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>Webpack 的整体概念设计包括 Compiler、Loader 和 Plugin，</p>\n<ul>\n<li><p>Compiler - 从业务上来讲， Webpack 本质上就是一个编译器，Compiler 实现了核心的微内核架构，将 Loader 和 Plugin 合理的组织在一起</p>\n</li>\n<li><p>Loader - 顾名思义是不同类型的资源加载器，比如 css-loader，babel-loader</p>\n</li>\n<li><p>Plugin - Compiler 在整个编译过程中，以 Hook 的形式暴露出了一系列回调，以供开发者编写 Plugin 来接收 Hook 并处理</p>\n</li>\n</ul>\n<p>三者的关系如下图</p>\n<p><img src=\"/img/microkernel-architecture-1.png\" alt=\"webpack微内核架构中compiler、plugin、loader之间的关系\"></p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Loader 设计</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>Loader 和 Compiler 之间的关系非常灵活。Compiler 根据文件后缀筛选出相应的 Loader 来加载文件，比如用 css-loader 来加载 css 文件，用 babel-loader 来加载 jsx 文件。</p>\n<p>Loader 接收 Compiler 传递过来的字符串形式的文件，经过编译和转换成为 javascript 之后将结果返还给 webpack 的 Compiler。Compiler 会从返回的结果中解析需要继续加载的 module，继续逐级加载，直至加载完成整个 module 依赖图。这个记载过程中可能会遇到各种各样的资源类型，会分别找到相应的 Loader 来加载。</p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Tapable Plugin Framework</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>在讲 Webpack 的 Plugin 实现之前，需要提一下 webpack 中衍生出来的 <a href=\"https://github.com/webpack/tapable\">Tapable Plugin Framework</a>。<strong>Tapable 是 webpack 插件架构的核心，极大简化了 webpack 的整体架构</strong>。虽然它在为 webpack 服务，但庆幸的是 Tapable 的优雅抽象使得我们能用它来编写其他微内核架构。</p>\n<p>这里简单介绍一下 Tapable 的核心概念，更多细节可以参考 <a href=\"https://github.com/webpack/tapable\">Tapable Github</a></p>\n<p><strong>Tapable 中核心概念包括 Hook 和 Tap 。 Hook 是 Compiler 编译过程中主动释放出的接口，Tap 可以为理解 HookHandler</strong>。这看起来很像是 Event 和 EventHandler 的关系，但细细思考和看代码之后，其实差距还挺大的。</p>\n<p>在整个执行过程中，Tap 执行后会返回结果，并且这个返回结果会在后续的编译处理中使用，不论 Tap 是同步执行还是异步执行。而 Event 和 EventHandler 的关系，EventHandler 更像是 Event 发生后的一种副作用，不论是语义和编程模型都和 Hook 与 Tap 不同。</p>\n<p>Tapable 提供了多种类型的 Hook，以方便进行数据处理和收集。按照执行类型可以分为：<code>Sync</code>、<code>AsyncSeries</code>、<code>AsyncParallel</code>。按照返回结果可以分为: Basic、Waterfall、Bail、Loop。这使得 Compiler 的编程模型得到了极大简化。更多细节这里就不赘述了，如果想要了解更多请移步 <a href=\"https://github.com/webpack/tapable\">Tapable Github</a> 和 <a href=\"https://www.npmjs.com/package/@types/tapable\">Tapable Type Definition</a></p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Plugin 设计</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>在讲完了 Loader 和 Tapable 之后，Plugin 的逻辑也就更好理解了，Compiler 使用 Loader 加载完成 javascript 之后，会在 Compiler 中调用各种 Hook 来完成核心的打包编译逻辑，而这些核心的打包和处理逻辑全都是 Plugin 实现了 Hook 回调来完成的。下面举一个例子：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">SyncHook</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;tapable&quot;</span>);\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Car</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">hooks</span> = {\n      <span class=\"hljs-attr\">accelerate</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SyncHook</span>([<span class=\"hljs-string\">&quot;newSpeed&quot;</span>]),\n      <span class=\"hljs-attr\">brake</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SyncHook</span>(),\n    };\n  }\n\n  <span class=\"hljs-title function_\">setSpeed</span>(<span class=\"hljs-params\">newSpeed</span>) {\n    <span class=\"hljs-comment\">// 实现真正的加速</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">hooks</span>.<span class=\"hljs-property\">accelerate</span>.<span class=\"hljs-title function_\">call</span>(newSpeed);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> myCar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>();\n\n<span class=\"hljs-comment\">// Use the tap method to add a plugin</span>\nmyCar.<span class=\"hljs-property\">hooks</span>.<span class=\"hljs-property\">accelerate</span>.<span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-string\">&quot;LoggerPlugin&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">newSpeed</span>) =&gt;</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Accelerating to <span class=\"hljs-subst\">${newSpeed}</span>`</span>)\n);\n\nmyCar.<span class=\"hljs-title function_\">setSpeed</span>(<span class=\"hljs-number\">13</span>);\n\n<span class=\"hljs-comment\">// 打印出 Accelerating to 13</span>\n</code></pre>\n<p>这里 Car 这个实体使用 SyncHook 暴露了 accelerate Hook，当汽车真正开始加速之后，调用加速 Hook，相应的 Tap 也会被执行。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">2.3、 Babel 的微内核架构实现</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Babel 是现代前端领域必备的 JavaScript 编译器，特别是用 ES6 来编写前端，它是一个源码到源码的编译器，通常也叫做 “转换编译器（transpiler)”。面对快速变化而异构的前端环境，Babel 也使用了 Plugin 微内核架构来扩展自身的编译生命周期。</p>\n<p>Babel 的生命周期主要抽象为 3 个核心阶段：</p>\n<ul>\n<li>解析（parse）- 进行词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）以生成 <a href=\"https://astexplorer.net/\">AST(抽象语法树)</a></li>\n<li>转换 (transform) - 对 AST 进行相应的转换操作，此处实现了丰富的 Plugin 机制</li>\n<li>生成 (generate) - 根据 AST 生成目标代码</li>\n</ul>\n<blockquote>\n<p>AST 是编译器的核心数据结构，所有的源代码在经历解析阶段之后转换为 AST，转换阶段的核心代码都在操作 AST。更多 AST 细节移步 <a href=\"https://astexplorer.net/\">AST Explorer</a> 和 <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST Wiki</a></p>\n</blockquote>\n<p>目前看来，Babel 由于解析阶段的复杂性，解析阶段暂时没有微内核架构支撑，但转换阶段实现了清晰微内核架构，可以方便的编写 plugin 来支撑语法转换，生成阶段比较简单，直接根据转换阶段生成的 AST 输出即可，不需要微内核架构。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解析阶段</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>解析阶段将源代码解析为 AST(抽象语法树), Babel 暂时并没有对普通开发者暴露 plugin 开发接口，而是使用继承的方式来进行扩展，实现不同语言的解析器。所以如果想要支持新的语法，此阶段需要直接往 Babel 中提交相应的 PR，但相应的转换阶段代码可以用 plugin 的方式进行开发。</p>\n<p>这里列举了 Babel 中常用的 Parser 类型</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 通用解析器</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parser</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatementParser</span> {}\n\n<span class=\"hljs-comment\">// Typescript 解析器</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TypescriptParser</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Parser</span> {}\n\n<span class=\"hljs-comment\">// Flow 解析器</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FlowParser</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Parser</span> {}\n\n<span class=\"hljs-comment\">// Jsx 解析器</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JsxParser</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Parser</span> {}\n\n<span class=\"hljs-comment\">// Es 解析器</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EsTreeParser</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Parser</span> {}\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">转换阶段</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>在解析阶段结束后，会生成 AST，转换阶段主要就是对 ASTNode 进行操作。所有的转换代码都可以用 plugin 的方式实现相应的 Visitor 来提供。Visitor 是操作 ASTNode 的实体定义。解析阶段所有的 Visitor 会尝试遍历所有感兴趣的 ASTNode。举个简单的例子：</p>\n<p>这里是一个非常简单的 Babel 插件，用于处理 === 的表达式。\n假设要将语句 <code>foo === bar</code> ，解析为 <code>yun === song</code> 。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// example plugin</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">babel</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">visitor</span>: {\n      <span class=\"hljs-title class_\">BinaryExpression</span>(path) {\n        <span class=\"hljs-keyword\">if</span> (path.<span class=\"hljs-property\">node</span>.<span class=\"hljs-property\">operator</span> !== <span class=\"hljs-string\">&quot;===&quot;</span>) {\n          <span class=\"hljs-keyword\">return</span>;\n        }\n\n        path.<span class=\"hljs-property\">node</span>.<span class=\"hljs-property\">left</span> = babel.<span class=\"hljs-property\">types</span>.<span class=\"hljs-title function_\">identifier</span>(<span class=\"hljs-string\">&quot;yun&quot;</span>);\n        path.<span class=\"hljs-property\">node</span>.<span class=\"hljs-property\">right</span> = babel.<span class=\"hljs-property\">types</span>.<span class=\"hljs-title function_\">identifier</span>(<span class=\"hljs-string\">&quot;song&quot;</span>);\n      },\n    },\n  };\n}\n</code></pre>\n<p>此函数在运行后，会返回 plugin 对象。plugin 对象中的变量 Visitor 包含核心 transform 逻辑，通过提供要处理的表达式类型，比如这里是 BinaryExpression，即可以处理相应的语句。这里判断如果 BinaryExpression 是一个 === 操作，就将变量的左右进行替换。</p>\n<p>Visitor 主要是在操作 AST，比如上述 <code>foo === bar</code> 对应的语法分析树为：</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;BinaryExpression&quot;</span>,\n  <span class=\"hljs-attr\">operator</span>: <span class=\"hljs-string\">&quot;===&quot;</span>,\n  <span class=\"hljs-attr\">left</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;foo&quot;</span>\n  },\n  <span class=\"hljs-attr\">right</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;bar&quot;</span>\n  }\n}\n</code></pre>\n<p>上述 Visitor 就是在将 left 和 right 换掉。</p>\n<p>这里附上 Visitor 的接口定义，</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Scope 是作用域，Binding 是变量和作用域的关系</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Scope</span> {}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Binding</span> {}\n\n<span class=\"hljs-comment\">// plugin 编写核心接口</span>\n<span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">Visitor</span>&lt;S = <span class=\"hljs-title class_\">Node</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">VisitNodeObject</span>&lt;<span class=\"hljs-title class_\">Node</span>&gt; {\n    <span class=\"hljs-title class_\">ArrayExpression</span>?: <span class=\"hljs-title class_\">VisitNode</span>&lt;S, t.<span class=\"hljs-property\">ArrayExpression</span>&gt;;\n    <span class=\"hljs-title class_\">AssignmentExpression</span>?: <span class=\"hljs-title class_\">VisitNode</span>&lt;S, t.<span class=\"hljs-property\">AssignmentExpression</span>&gt;;\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">VisitNode</span>&lt;T, P&gt; = <span class=\"hljs-title class_\">VisitNodeFunction</span>&lt;T, P&gt; | <span class=\"hljs-title class_\">VisitNodeObject</span>&lt;T&gt;;\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">VisitNodeFunction</span>&lt;T, P&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">this</span>: T, path: NodePath&lt;P&gt;, state: any</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>;\n<span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">VisitNodeObject</span>&lt;T&gt; {\n    enter?(<span class=\"hljs-attr\">path</span>: <span class=\"hljs-title class_\">NodePath</span>&lt;T&gt;, <span class=\"hljs-attr\">state</span>: any): <span class=\"hljs-keyword\">void</span>;\n    exit?(<span class=\"hljs-attr\">path</span>: <span class=\"hljs-title class_\">NodePath</span>&lt;T&gt;, <span class=\"hljs-attr\">state</span>: any): <span class=\"hljs-keyword\">void</span>;\n}\n\n<span class=\"hljs-comment\">// 代表一个 Node，但比 Node 拥有更丰富的信息，方便快速处理</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NodePath</span>&lt;T = <span class=\"hljs-title class_\">Node</span>&gt; {}\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生成阶段</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>暂无微内核架构</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">3、微内核架构的服务端应用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>TODO</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">4、总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>从以上的分析，我们可以看到。微内核架构作为一种常用的架构模式，无论是在前端和后端，都能极大的简化架构设计，并提供优越的扩展性和灵活性。对我们个人的设计和开发提供了很好的思路。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考资料</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://addyosmani.com/resources/essentialjsdesignpatterns/book/\">Learning Javascript Design Patterns</a>\n<a href=\"https://github.com/jquery/jquery\">jQuery 源代码</a>\n<a href=\"https://webpack.js.org/api/\">Webpack API</a>\n<a href=\"https://github.com/webpack/tapable\">Tapable Plugin Framework</a>\n<a href=\"https://www.npmjs.com/package/@types/tapable\">Tapable Type Definition</a>\n<a href=\"https://astexplorer.net/\">AST Explorer</a>\n<a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-introduction\">Babel 插件手册</a>\n<a href=\"https://github.com/babel/babel/tree/master/packages/babel-parser\">@babel/parser</a>\n<a href=\"https://www.npmjs.com/package/@types/babel-traverse\">@types/babel-traverse</a></p>\n"},{"title":"webpack学习-ModuleFederation","tags":["webpack","ModuleFederation"],"categories":"webpack","description":"学习webpack@5.73.0的 ModuleFederation\n\n## WHAT\n\nwebpack 提供的一种跨项目模块共享机制\n\n先通过一个 🌰 了解一下\n\n![webpack ModuleFederation](/img/webpack-mf-0.png)\n\n如图所示，分别创建了两个项目 `host` 和 `remote`\n\n- `remote` 中创建了两个组件 `Button`","createDate":"2022-06-11 18:51:42","updateDate":"2022-06-12 22:51:42","body":"<p>学习<a href=\"mailto:&#x77;&#101;&#98;&#112;&#97;&#x63;&#107;&#64;&#x35;&#46;&#x37;&#x33;&#x2e;&#x30;\">&#x77;&#101;&#98;&#112;&#97;&#x63;&#107;&#64;&#x35;&#46;&#x37;&#x33;&#x2e;&#x30;</a>的 ModuleFederation</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>webpack 提供的一种跨项目模块共享机制</p>\n<p>先通过一个 🌰 了解一下</p>\n<p><img src=\"/img/webpack-mf-0.png\" alt=\"webpack ModuleFederation\"></p>\n<p>如图所示，分别创建了两个项目 <code>host</code> 和 <code>remote</code></p>\n<ul>\n<li><code>remote</code> 中创建了两个组件 <code>Button</code> 和 <code>Header</code></li>\n<li><code>host</code> 中的 <code>bootstrap.jsx</code> 引用了两个组件 (注意，这两个组件在 <code>host</code> 项目中并未定义)</li>\n</ul>\n<p>分别在两个项目下执行 <code>npx webpack serve</code> ，然后访问 <code>host</code> 的开发地址 <code>http://localhost:8080/</code> 效果如图所示，接着尝试修改 <code>remote</code> 中的 <code>components/Header.jsx</code> 发现页面中也相应发生变化</p>\n<p>🤔</p>\n<p>也就是说，我们在 <code>host</code> 中引用了 <code>remote</code> 中的组件？😱</p>\n<p>对的，这就是 webpack5 提供的新特性 ModuleFederation ，中文直译模块联邦</p>\n<p>联邦模块有两个主要概念： <code>host</code> （消费其他 <code>remote</code> ）和 <code>remote</code> （被 <code>host</code> 消费）。 每个项目可以是 <code>host</code> 也可以是 <code>remote</code> ，也可以两个都是。可以通过 webpack 配置来区分，可以参考上述的例子</p>\n<ul>\n<li><p>作为 <code>host</code> 需要配置 <code>remotes</code> 列表</p>\n</li>\n<li><p>作为 <code>remote</code> 需要配置项目名（ <code>name</code> ），打包后的文件名（ <code>filename</code> ），提供的模块（ <code>exposes</code> ）</p>\n</li>\n</ul>\n<p>而且想要开启这一特性，只需要少许的配置即可</p>\n<p>在需要共享的项目中，即上述的 <code>remote</code> 中，添加这个 webpack 配置</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">ModuleFederationPlugin</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack&quot;</span>).<span class=\"hljs-property\">container</span>;\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ModuleFederationPlugin</span>({\n      <span class=\"hljs-comment\">// 当前应用的名字，全局唯一ID，通过 name/{expose} 的方式使用</span>\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;remote&quot;</span>,\n      <span class=\"hljs-comment\">// *可选，打包方式，与 name 保持一致即可</span>\n      <span class=\"hljs-attr\">library</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;var&quot;</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;remote&quot;</span> },\n      <span class=\"hljs-comment\">// 共享组件/模块打包后所在的文件，使用者直接导入这个文件即可</span>\n      <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;remoteEntry.js&quot;</span>,\n      <span class=\"hljs-attr\">exposes</span>: {\n        <span class=\"hljs-comment\">// 这里便是我们要共享的模块/组件，引用方式为 import(name/{expose})，比如 import(&#x27;remote/Button&#x27;)</span>\n        <span class=\"hljs-string\">&quot;./Button&quot;</span>: <span class=\"hljs-string\">&quot;./src/components/Button.jsx&quot;</span>,\n        <span class=\"hljs-string\">&quot;./Header&quot;</span>: <span class=\"hljs-string\">&quot;./src/components/Header.jsx&quot;</span>,\n      },\n      <span class=\"hljs-comment\">// 在这里指定需要共享的package</span>\n      <span class=\"hljs-attr\">shared</span>: {\n        <span class=\"hljs-attr\">react</span>: { <span class=\"hljs-attr\">singleton</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">requiredVersion</span>: <span class=\"hljs-string\">&quot;^18.1.0&quot;</span> },\n        <span class=\"hljs-string\">&quot;react-dom&quot;</span>: { <span class=\"hljs-attr\">singleton</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">requiredVersion</span>: <span class=\"hljs-string\">&quot;^18.1.0&quot;</span> },\n      },\n    }),\n  ],\n};\n</code></pre>\n<p>同时，在需要引用这些组件的项目中，即上述的<code>host</code>项目，webpack 配置文件中新增这些配置</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">ModuleFederationPlugin</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack&quot;</span>).<span class=\"hljs-property\">container</span>;\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ModuleFederationPlugin</span>({\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;host&quot;</span>,\n      <span class=\"hljs-comment\">// 表示当前应用是一个 Host，可以引用 remote 中 expose 的模块</span>\n      <span class=\"hljs-attr\">remotes</span>: {\n        <span class=\"hljs-attr\">remote</span>: <span class=\"hljs-string\">&quot;remote@http://localhost:8081/remoteEntry.js&quot;</span>,\n      },\n      <span class=\"hljs-comment\">// 在这里指定需要共享的package</span>\n      <span class=\"hljs-comment\">// 在使用 Module Federation 时，Host、Remote 必须配置一致的 shared 这样才会生效</span>\n      <span class=\"hljs-attr\">shared</span>: {\n        <span class=\"hljs-attr\">react</span>: { <span class=\"hljs-attr\">singleton</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">requiredVersion</span>: <span class=\"hljs-string\">&quot;^18.1.0&quot;</span> },\n        <span class=\"hljs-string\">&quot;react-dom&quot;</span>: { <span class=\"hljs-attr\">singleton</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">requiredVersion</span>: <span class=\"hljs-string\">&quot;^18.1.0&quot;</span> },\n      },\n    }),\n  ],\n};\n</code></pre>\n<p>在这里，我们也可以简单得分析一下 host 应用加载的 js 文件</p>\n<p><img src=\"/img/webpack-mf-1.png\" alt=\"webpack ModuleFederation配置shared的构建文件\"></p>\n<p>如图所示，在本示例中 host 加载了三个 remote 的文件<code>remoteEntry.js</code>和<code>src_components_Header_jsx.js</code>与<code>src_components_Button_jsx.js</code>，其中后两者是加载的组件代码，<code>remoteEntry.js</code>是入口文件，可以发现并没有加载 react 相关的源码，这是因为我们配置了<code>shared</code>，这样 remote 就可以和 host 共用一套 react（在这里，react 是被打包进<code>main.js</code>中）。如果没有配置<code>shared</code>选项，那么会单独加载一份 react 代码</p>\n<p><img src=\"/img/webpack-mf-2.png\" alt=\"webpack ModuleFederation未配置shared的构建文件\"></p>\n<p>可以看到，这时会单独加载一份react源码</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在构建工具层面上对模块共享、模块加载做一些扩展、优化</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>修改了 <code>webpack_require</code> 的部分实现，在 <code>require</code> 的时候从远程加载资源，缓存到全局对象 <code>window[&quot;webpackChunk&quot;+appName]</code> 中，然后合并到 <code>webpack_modules</code> 中</p>\n<p>webpack 每次打包都会将资源全部包裹在一个立即执行函数里面，这样虽然避免了全局环境的污染，但也使得外部不能访问内部模块。 在这个立即执行函数里面，webpack 使用 <code>webpack_modules</code> 对象保存所有的模块代码，然后用内部定义的 <code>webpack_require</code> 方法从 <code>webpack_modules</code> 中加载模块。并且在异步加载和文件拆分两种情况下向全局暴露一个 <code>webpackChunk</code> 数组用于沟通多个 webpack 资源，这个数组通过被 webpack 重写 <code>push</code> 方法，会在其他资源向 <code>webpackChunk</code> 数组中新增内容时同步添加到 <code>webpack_modules</code> 中从而实现模块整合</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://www.zoo.team/article/webpack-modular\">模块联邦浅析</a></p>\n<p><a href=\"https://webpack.docschina.org/concepts/module-federation/#Uncaught-Error-Shared-module-is-not-available-for-eager-consumption\">webpack 中文文档</a></p>\n<p><a href=\"https://github.com/module-federation/module-federation-examples/tree/master/basic-host-remote\">module-federation-examples/basic-host-remote</a></p>\n"},{"title":"webpack学习-构建流程","tags":["webpack","构建流程"],"categories":"webpack","description":"学习 webpack5 的构建流程\n\n## 构建的核心流程\n\n分为三步\n\n1. 初始化\n\n2. 构建\n\n3. 输出文件\n\n### 初始化\n\n从配置文件、 shell 命令行中读取参数，与默认配置结合得出最终的配置，而后根据该配置创建出 compiler 对象并根据配置中的 entry 找出所有的入口文件，调用 compilation.addEntry 将入口文件转换为 dependence 对象","createDate":"2022-06-08 22:53:56","updateDate":"2022-06-09 22:41:47","body":"<p>学习 webpack5 的构建流程</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">构建的核心流程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>分为三步</p>\n<ol>\n<li><p>初始化</p>\n</li>\n<li><p>构建</p>\n</li>\n<li><p>输出文件</p>\n</li>\n</ol>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">初始化</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>从配置文件、 shell 命令行中读取参数，与默认配置结合得出最终的配置，而后根据该配置创建出 compiler 对象并根据配置中的 entry 找出所有的入口文件，调用 compilation.addEntry 将入口文件转换为 dependence 对象，同时初始化编译环境（包括注入插件、注册各种模块等）</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">构建</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>根据初始化阶段创建的 dependence 创建 module 对象，调用合适的 loader 将 module 转为标准的 js 内容，接着调用 js 解释器将内容转为 ast 对象，从中找出该模块依赖的模块，创建 dependence，而后递归此过程，直到所有入口依赖的文件都经过了本步骤的处理</p>\n<p>在经过递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的<strong>依赖关系图</strong></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">输出文件</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>主要完成 module 到 chunk 的转化</p>\n<p>根据入口和模块之间的依赖关系，组装成一个个包含多个 module 的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，最后根据配置好的输出路径和文件名将文件内容写入到文件系统中</p>\n<p>chunk 分包规则：</p>\n<ul>\n<li><p>同一个 <code>entry</code> 下可触达的模块组织成一个 chunk</p>\n</li>\n<li><p>异步模块单独划分为一个 chunk</p>\n</li>\n<li><p><code>entry.runtime</code>单独划分为一个 chunk</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">资源形态流转</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如图</p>\n<p><img src=\"/img/webpack-core-0.png\" alt=\"webpack 资源形态流转\"></p>\n<p>从 entry 文件开始，将其转为 dependence ，而后雕工对应的工厂函数创建 module 对象，之后读取 module 对应的文件内容，将其解析为 ast ，如果该文件有其他依赖，则重复此步骤。至此，所有的文件均为转化为 module</p>\n<p>接着，遍历 module 集合，按照内置的分包规则将不同的 module 整合到一个 chunk 中；遍历 chunk 集合，将其转为 assets 集合</p>\n<p>最后，将 assets 写入文件系统</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">loader 与 plugin</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>plugin 从代码上看是一个带有 apply 函数的 class 。 webpack 会在特定的时机触发钩子，并会附带上足够的上下文信息，插件定义的钩子回调中，可以与这些上下文背后的数据结构、接口交互产生 side effect，进而影响到编译状态和后续流程</p>\n<p>loader 从代码上看是一个函数，接收特定的参数（源代码等），经过转换后返回一个js解释器可以解析的内容</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw\">[万字总结] 一文吃透 Webpack 核心原理</a></p>\n"},{"title":"webpack学习-chunk分包","tags":["webpack","chunk"],"categories":"webpack","description":"学习 webpack5 中 chunk 分包规则\n\n## module vs chunk\n\n在 webpack 中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGra","createDate":"2022-05-31 21:41:47","updateDate":"2022-05-31 21:41:47","body":"<p>学习 webpack5 中 chunk 分包规则</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">module vs chunk</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在 webpack 中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGraph 对 Chunk 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 Chunks 。运行完毕之后 webpack 继续将 chunk 一一写入物理文件中，完成编译工作。</p>\n<p>综上，Module 主要作用在 webpack 编译过程的前半段，解决原始资源“「如何读」”的问题；而 Chunk 对象则主要作用在编译的后半段，解决编译产物“「如何写」”的问题，两者合作搭建起 webpack 搭建主流程。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">默认分包规则</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单总结下:</p>\n<ul>\n<li><p>同一个 <code>entry</code> 下可触达的模块组织成一个 chunk</p>\n</li>\n<li><p>异步模块单独划分为一个 chunk</p>\n</li>\n<li><p><code>entry.runtime</code>单独划分为一个 chunk</p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">entry</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>seal 阶段遍历 entry 对象，为每一个 entry 单独生成 chunk，之后再根据模块依赖图将 entry 触达到的所有模块打包进 chunk 中。</strong></p>\n<p>对于如下打包配置和文件依赖</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;development&quot;</span>,\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&quot;./src/chunk/index.js&quot;</span>,\n    <span class=\"hljs-attr\">main</span>: <span class=\"hljs-string\">&quot;./src/chunk/main.js&quot;</span>,\n  },\n  <span class=\"hljs-attr\">optimization</span>: {\n    <span class=\"hljs-attr\">usedExports</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-literal\">false</span>,\n};\n</code></pre>\n<p><img src=\"/img/webpack-chunk-1.png\" alt=\"webpack entry划分chunk-文件依赖\"></p>\n<p>在示例中， <code>index.js</code>和 <code>main.js</code> 分别静态引入了几个文件</p>\n<p>在 <code>npx webpack --json &gt; info.json</code> 打包后的输出结果是这样的</p>\n<p><img src=\"/img/webpack-chunk-0.png\" alt=\"webpack entry划分chunk-打包结果\"></p>\n<p>可以看到，一共生成了两个 chunk</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">异步模块</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>每次遇到异步模块都会为之创建单独的 Chunk 对象，单独打包异步模块。</strong></p>\n<p>还以上述配置和代码为例，只是将 <code>a.js</code> 改为动态引入，即<code>import(&#39;a.js&#39;)</code></p>\n<p><img src=\"/img/webpack-chunk-2.png\" alt=\"webpack 动态import分包\"></p>\n<p>此时重新执行<code>npx webpack --json &gt; info.json</code> 打包后的输出结果是这样的</p>\n<p><img src=\"/img/webpack-chunk-3.png\" alt=\"webpack 动态import分包\"></p>\n<p>可以看到新增了一个 chunk</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">entry.runtime</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>Webpack 5 之后还能根据 entry.runtime 配置单独打包运行时代码。</strong></p>\n<p>除了 entry、异步模块外，webpack 5 之后还支持基于 runtime 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime。虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 entry.runtime 配置项用于声明如何打包运行时代码。用法上只需在 entry 项中增加字符串形式的 runtime 值，例如：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;development&quot;</span>,\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">index</span>: {\n      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&quot;./src/chunk/index.js&quot;</span>,\n      <span class=\"hljs-attr\">runtime</span>: <span class=\"hljs-string\">&quot;solid-runtime&quot;</span>,\n    },\n    <span class=\"hljs-attr\">main</span>: {\n      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&quot;./src/chunk/main.js&quot;</span>,\n      <span class=\"hljs-attr\">runtime</span>: <span class=\"hljs-string\">&quot;solid-runtime&quot;</span>,\n    },\n  },\n  <span class=\"hljs-attr\">optimization</span>: {\n    <span class=\"hljs-attr\">usedExports</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-literal\">false</span>,\n};\n</code></pre>\n<p>此时再次执行 <code>npx webpack --json &gt; info.json</code>，打包结果如下</p>\n<p><img src=\"/img/webpack-chunk-4.png\" alt=\"webpack runtime分包\"></p>\n<p>可以看到，此时又新增了一个包，而且对比一下输出文件的大小，大部分文件输出到 <code>solid-runtime.js</code> 中， <code>index.js</code> 和 <code>main.js</code> 已经缩短到 30 行左右</p>\n<blockquote>\n<p>ps: 此时网站中需要单独引入 solid-runtime.js 文件</p>\n</blockquote>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">SplitChunk</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>// TODO</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484029&amp;idx=1&amp;sn=7862737524e799c5eaf1605325171e32&amp;chksm=cf00bf04f8773612682f4650be2f78255912d0ca8ecafff1bd647a8a692ae28098436975908f&amp;scene=178&amp;cur_album_id=1856066636768722949#rd\">有点难的知识点： Webpack Chunk 分包规则详解</a></p>\n"},{"title":"webpack学习-tree shaking","tags":["webpack","Tree-Shaking"],"categories":"webpack","description":"学习 webpack5 中 tree shaking 原理\n\n## WHAT\n\n一种优化技术\n\n使用方式：\n\n1. 使用 ESM 编写代码\n\n2. 启用标记功能。配置 webpack 的 `optimization.useExports = true`\n\n3. 启用清除功能。有多种配置方式\n\n- 配置 `mode = production`\n- 配置 `optimization.minimize","createDate":"2022-05-30 11:27:17","updateDate":"2022-05-30 21:38:52","body":"<p>学习 webpack5 中 tree shaking 原理</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一种优化技术</p>\n<p>使用方式：</p>\n<ol>\n<li><p>使用 ESM 编写代码</p>\n</li>\n<li><p>启用标记功能。配置 webpack 的 <code>optimization.useExports = true</code></p>\n</li>\n<li><p>启用清除功能。有多种配置方式</p>\n</li>\n</ol>\n<ul>\n<li>配置 <code>mode = production</code></li>\n<li>配置 <code>optimization.minimize = true</code></li>\n<li>提供 <code>optimization.minimizer</code></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>减少打包文件体积，提升网站性能</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>基于 ESM，静态分析哪些模块没有被用到，借助于一些 DCI 工具，删除没用到的代码</p>\n<p>过程分为两步</p>\n<ol>\n<li><p>基于两个插件，标记没有用到的模块（代码）导出，并删除没用到的导出</p>\n</li>\n<li><p>删除</p>\n</li>\n</ol>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">标记</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>其中标记过程又可分为三步，标记的效果就是<strong>删除没有被其它模块使用的导出语句</strong>，但并<strong>没有删除源码</strong></p>\n<ol>\n<li>make 阶段</li>\n</ol>\n<p>使用 <code>FlagDependencyExportsPlugin</code> 收集模块导出变量并记录到 <code>module.ExportInfo</code> 变量中</p>\n<ol start=\"2\">\n<li>seal 阶段</li>\n</ol>\n<p>使用 <code>FlagDependencyUsagePlugin</code> 遍历 <code>module.ExportInfo</code> ，修改 <code>module.exportInfo._usedInRuntime</code> 记录使用到的变量</p>\n<ol start=\"3\">\n<li>生成阶段</li>\n</ol>\n<p>若变量没有被其它模块使用则删除对应的导出语句，并打上标记</p>\n<p><img src=\"/img/webpack-tree-shaking-0.png\" alt=\"webpack tree-shaking\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">删除</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>将由 Terser、UglifyJS 等 DCE 工具“摇”掉这部分无效代码，构成完整的 Tree Shaking 操作</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>综上所述，Webpack 中 Tree Shaking 的实现分为如下步骤：</p>\n<ol>\n<li><p>在 <code>FlagDependencyExportsPlugin</code> 插件中根据模块的 <code>dependencies</code> 列表收集模块导出值，并记录到 ModuleGraph 体系的 <code>exportsInfo</code> 中</p>\n</li>\n<li><p>在 <code>FlagDependencyUsagePlugin</code> 插件中收集模块的导出值的使用情况，并记录到 <code>exportInfo._usedInRuntime</code> 集合中</p>\n</li>\n<li><p>在 <code>HarmonyExportXXXDependency.Template.apply</code> 方法中根据导出值的使用情况生成不同的导出语句\n使用 DCE 工具删除 Dead Code，实现完整的树摇效果</p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484579&amp;idx=1&amp;sn=f687adfc6a7ea155c0fdf504defb65b5&amp;chksm=cf00b9daf87730cc2bf7934f6fd40c50ad28ef4e418922740aedacc998f2fa62388d4c81649c&amp;scene=178&amp;cur_album_id=1856066636953272321#rd\">Webpack 原理系列九：Tree-Shaking 实现原理</a></p>\n"},{"title":"webpack学习-HMR","tags":["webpack","HMR"],"categories":"webpack","description":"## WHAT\n\nHMR: (hot module replacement)热模块替换/模块热替换，见名思意，即无需刷新在内存环境中即可替换掉过旧模块。与 Live Reload 相对应\n\n> PS: Live Reload，当代码进行更新后，在浏览器自动刷新以获取最新前端代码\n\n`*.css`: 可以使用 HMR 功能，因为`style-loader`内部实现了\n\n`*.js`: 默认不能使用","createDate":"2022-02-09 20:41:29","updateDate":"2022-05-25 09:38:52","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>HMR: (hot module replacement)热模块替换/模块热替换，见名思意，即无需刷新在内存环境中即可替换掉过旧模块。与 Live Reload 相对应</p>\n<blockquote>\n<p>PS: Live Reload，当代码进行更新后，在浏览器自动刷新以获取最新前端代码</p>\n</blockquote>\n<p><code>*.css</code>: 可以使用 HMR 功能，因为<code>style-loader</code>内部实现了</p>\n<p><code>*.js</code>: 默认不能使用 HMR 功能 --&gt; 需要修改 js 代码，添加支持 HMR 功能的代码</p>\n<p>注意: HMR 功能对<code>js</code>的处理，只能处理非入口<code>js</code>文件的其他文件</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// js文件开启HMR</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">hot</span>) {\n  <span class=\"hljs-comment\">// 需要检测的文件</span>\n  <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">hot</span>.<span class=\"hljs-title function_\">accept</span>(<span class=\"hljs-string\">&quot;path/to/HMRFile.js&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">/*\n     * HMRFile文件关键逻辑\n     */</span>\n  });\n\n  <span class=\"hljs-comment\">// 或者简单得传个空函数</span>\n  <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">hot</span>.<span class=\"hljs-title function_\">accept</span>(<span class=\"hljs-function\">() =&gt;</span> {});\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一个模块发生变化，只会重新打包这一个模块(而不是打包所有模块)极大提升构建速度</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">关于 chunk 和 module</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>chunk 就是若干 module 打成的包，一个 chunk 应该包括多个 module，一般来说最终会形成一个 file。而 js 以外的资源，webpack 会通过各种 loader 转化成一个 module，这个模块会被打包到某个 chunk 中，并不会形成一个单独的 chunk。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">关于 HMR 和 webpack-dev-server, webpack-hot-middleware, webpack-dev-middleware 之间的关系</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><code>webpack-dev-server</code> 实现了封装好的的 HMR，除了配置文件和命令行参数外，较难定制开发</p>\n<p><code>webpack-hot-middleware</code> / <code>webpack-dev-middleware</code> 可搭配服务端框架实现个性化的 HMR 服务</p>\n<p>两者的区别在于</p>\n<ol>\n<li><p><code>webpack-dev-server</code> 使用 websocket 来作为客户端/服务端之间的通信方式，后者使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource\">EventSource</a></p>\n</li>\n<li><p>通信过程中使用的事件名不同。前者使用 <code>hash</code> 和 <code>ok</code> ，后者使用 <code>build</code> 和 <code>sync</code></p>\n</li>\n</ol>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HMR原理</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>webpack-dev-server hmr流程图</p>\n<p><img src=\"/img/webpack-hmr-0.jpeg\" alt=\"webpack-dev-server hmr流程图\"></p>\n<p>在<code>webpack的</code>运行时使用<code>__webpack__modules__</code>维护所有的模块</p>\n<p>而热模块替换的原理，即通过<code>chunk</code>的方式加载最新的<code>modules</code>，找到<code>__webpack__modules__</code>中对应的模块逐一替换，并删除其上下缓存。</p>\n<p>其精简数据结构用以下代码表示:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack 运行时代码</span>\n<span class=\"hljs-keyword\">const</span> __webpack_modules = [\n  <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">module</span>, <span class=\"hljs-built_in\">exports</span>, __webpack_require__</span>) =&gt;</span> {\n    <span class=\"hljs-title function_\">__webpack_require__</span>(<span class=\"hljs-number\">0</span>);\n  },\n  <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;这是一号模块&quot;</span>);\n  },\n];\n\n<span class=\"hljs-comment\">// HMR Chunk 代码</span>\n<span class=\"hljs-comment\">// JSONP 异步加载的所需要更新的 modules，并在 __webpack_modules__ 中进行替换</span>\nself[<span class=\"hljs-string\">&quot;webpackHotUpdate&quot;</span>](<span class=\"hljs-number\">0</span>, {\n  <span class=\"hljs-number\">1</span>: <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;这是最新的一号模块&quot;</span>);\n  },\n});\n</code></pre>\n<p>其下为更具体更完整的流程，每一步都涉及众多，有兴趣的可阅读<code>webpack-dev-server</code>及开发环境<code>webpack</code>运行时的源码。</p>\n<ol>\n<li><p><code>webpack-dev-server</code>将打包输出<code>bundle</code>使用内存型文件系统控制，而非真实的文件系统。此时使用的是<a href=\"https://github.com/webpack/memory-fs\">memory-fs</a>模拟 node.js fs API</p>\n</li>\n<li><p>每当文件发生变更时，<code>webpack</code>将会重新编译，<code>webpack-dev-server</code>将会监控到此时文件变更事件，并找到其对应的<code>module</code>。此时使用的是<a href=\"https://github.com/paulmillr/chokidar\">chokidar</a>监控文件变更</p>\n</li>\n<li><p><code>webpack-dev-server</code>将会把变更模块通知到浏览器端，此时使用<code>websocket</code>与浏览器进行交流。此时使用的是<a href=\"https://github.com/websockets/ws\">ws</a></p>\n</li>\n<li><p>浏览器根据<code>websocket</code>接收到<code>hash</code>，并通过<code>hash</code>以<a href=\"https://en.wikipedia.org/wiki/JSONP\">JSONP</a>的方式请求更新模块的<code>chunk</code></p>\n</li>\n<li><p>浏览器加载<code>chunk</code>，并使用新的模块对旧模块进行热替换，并删除其缓存</p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">各大框架中的 HMR</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>react, <a href=\"https://github.com/facebook/react/blob/main/packages/react-refresh/README.md\">react-refresh</a></p>\n</li>\n<li><p>vue, <a href=\"https://www.npmjs.com/package/vue-loader\">vue-loader</a></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://github.com/shfshanyue/Daily-Question/issues/79\">【Q078】webpack 中什么是 HMR，原理是什么 #79</a></p>\n"},{"title":"webpack学习-HMR原理","tags":["webpack","HMR","webpack-dev-server"],"categories":"webpack","description":"研究一下`webpack-dev-server`的 HMR 原理\n\n基于 webpack5 单页应用构建流程分析\n\n## 如何使用\n\n在配置文件中添加\n\n```js\nmodule.exports = {\n  devServer: {\n    hot: true,\n  },\n};\n```\n\n后，即可启用`webpack-dev-server`的 HMR 功能，只是启用，还需要在业务代码中告诉`we","createDate":"2022-05-24 17:56:32","updateDate":"2022-05-20 19:38:52","body":"<p>研究一下<code>webpack-dev-server</code>的 HMR 原理</p>\n<p>基于 webpack5 单页应用构建流程分析</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何使用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在配置文件中添加</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">devServer</span>: {\n    <span class=\"hljs-attr\">hot</span>: <span class=\"hljs-literal\">true</span>,\n  },\n};\n</code></pre>\n<p>后，即可启用<code>webpack-dev-server</code>的 HMR 功能，只是启用，还需要在业务代码中告诉<code>webpack-dev-server</code>如何更新代码</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">hot</span>) {\n  <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">hot</span>.<span class=\"hljs-title function_\">accept</span>([<span class=\"hljs-string\">&quot;./content.js&quot;</span>], <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">render</span>();\n  });\n}\n</code></pre>\n<p>这样，在<code>content.js</code>发生改变后，会执行回调函数，即重新<code>render</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">流程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>核心流程总结如下</p>\n<p>包括<code>webpack-dev-server</code>和<code>webpack.HotModuleReplacementPlugin</code></p>\n<ol>\n<li><p><code>webpack-dev-server</code>会启动静态文件服务器，用于返回打包后的资源，该服务器使用<a href=\"https://github.com/webpack/memory-fs\">memory-fs</a>模拟原生文件系统</p>\n</li>\n<li><p><code>webpack-dev-server</code>会修改<code>entry</code>，将<code>webpack.HotModuleReplacementPlugin</code>的一些运行时代码注入到 chunk 中，并开启<code>webpack</code>的<code>watch</code>模式</p>\n</li>\n<li><p>客户端请求文件后，会和<code>webpack-dev-server</code>建立一个<code>ws</code>服务</p>\n</li>\n<li><p>文件发生变动后，<code>webpack-dev-server</code>会重新打包文件，生成两个额外文件：<code>chunkId.hash.hot-update.json</code>和<code>chunkId.hash.hot-update.js</code>，同时会通过<code>ws</code>向客户端发送消息，告知客户端有最新的代码</p>\n</li>\n<li><p>客户端收到消息后先请求<code>chunkId.hash.hot-update.json</code>，然后通过返回值去请求<code>chunkId.hash.hot-update.js</code></p>\n</li>\n<li><p>增量更新客户端代码并重新执行<code>module.hot.accept</code>传递进来的回调函数</p>\n</li>\n</ol>\n<p>其中<code>webpack-dev-server</code>和<code>webpack.HotModuleReplacementPlugin</code>分别完成的工作包括</p>\n<p><code>webpack-dev-server</code>:</p>\n<ul>\n<li><p>启动一个<code>express</code>服务器，返回打包后的文件</p>\n</li>\n<li><p>修改<code>compiler.outputFileSystem</code>为<code>memory-fs</code></p>\n</li>\n<li><p>建立一个<code>ws</code>服务</p>\n</li>\n<li><p>修改<code>entry</code>文件，将一些代码添加到 chunk 中（和服务端建立<code>ws</code>，处理各种消息等）</p>\n</li>\n</ul>\n<p><code>webpack.HotModuleReplacementPlugin</code>:</p>\n<ul>\n<li><p>代码变动后生成<code>chunkId.hash.hot-update.json</code>和<code>chunkId.hash.hot-update.js</code></p>\n</li>\n<li><p>请求新模块，热更代码等</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>将分为以下几个模块分析</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">建立 HMR 服务</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>创建一个 websocket 服务：在代码变动并编译完成后，向客户端发送两个消息<code>{ type: &quot;hash&quot;, data: &quot;xxx&quot; }</code>和<code>{ type: &quot;ok&quot; }</code></p>\n<p><img src=\"/img/webpack-hmr-1.png\" alt=\"hmr websocket消息\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">更新 compiler</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><code>webpack-dev-server</code>会更新配置文件中的<code>entry</code>，将<code>webpack-dev-server/lib/client.js</code>打包进 chunk 中</p>\n<p><code>webpack-dev-server/lib/client.js</code>会在客户端执行，并和 HMR Server 建立连接，接收消息</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注入运行时</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><code>webpack.HotModuleReplacementPlugin</code>会注入一些运行时代码</p>\n<p><img src=\"/img/webpack-hmr-2.png\" alt=\"hmr 运行时\"></p>\n<p>此时，构建产物中即包含了所有运行 HMR 所需的客户端运行时与接口。这些 HMR 运行时会在浏览器执行一套基于 WebSocket 消息的时序框架，如图：</p>\n<p><img src=\"/img/webpack-hmr-3.png\" alt=\"hmr 运行时\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">增量构建</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>除注入客户端代码外，<code>webpack.HotModuleReplacementPlugin</code>还会在代码发生变动后生成两个文件<code>chunkId.hash.hot-update.json</code>和<code>chunkId.hash.hot-update.js</code>，稍后<code>webpack-dev-server</code>会向客户端发送<code>hash</code>和<code>ok</code>消息</p>\n<p><img src=\"/img/webpack-hmr-1.png\" alt=\"hmr 运行时\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">应用更新</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>客户端在接收到<code>webpack-dev-server</code>中<code>ws</code>服务发送的<code>hash</code>和<code>ok</code>消息后，会根据最新的<code>hash</code>获取<code>chunkId.hash.hot-update.json</code>文件，然后根据文件中提及到的<code>chunk</code>，再去请求<code>chunkId.hash-hot.update.js</code></p>\n<p><img src=\"/img/webpack-hmr-4.png\" alt=\"hmr 运行时\"></p>\n<p><em>注意，在 Webpack 4 及之前，热更新文件以模块为单位，即所有发生变化的模块都会生成对应的热更新文件； Webpack 5 之后热更新文件以 chunk 为单位，如上例中，main chunk 下任意文件的变化都只会生成 main.[hash].hot-update.js 更新文件。</em></p>\n<p><code>chunkId.hash-hot.update.js</code>拿到后会将代码更新到<code>__webpack_require__.c</code>中，并且执行<code>module.hot.accept</code>回调</p>\n<p>至此，热更新完毕</p>\n"},{"title":"React.js学习-useContext性能优化","tags":["React.js","useContext"],"categories":"React.js","description":"`useContext`在 React 中主要作为`useState`的替代品，用于在复杂组件间传递数据，但需要稍加注意一些组件重复渲染问题\n\n先说结论：由于`Context`的限制，每当`Context`中的数据发生变化时，通过`useContext`使用该`Context`的组件及其子组件都会触发重渲。对此，可通过拆分`Context`，减少`Context`的作用域，减少重渲的范围\n\n下面","createDate":"2022-05-19 21:41:41","updateDate":"2022-05-19 23:07:41","body":"<p><code>useContext</code>在 React 中主要作为<code>useState</code>的替代品，用于在复杂组件间传递数据，但需要稍加注意一些组件重复渲染问题</p>\n<p>先说结论：由于<code>Context</code>的限制，每当<code>Context</code>中的数据发生变化时，通过<code>useContext</code>使用该<code>Context</code>的组件及其子组件都会触发重渲。对此，可通过拆分<code>Context</code>，减少<code>Context</code>的作用域，减少重渲的范围</p>\n<p>下面会以一个简单的计数器作为示例</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一个简单的 🌰</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在这里，我们创建了一个<code>CounterContext</code>，全局共享了<code>state</code>和一些<code>action</code>，页面中<code>Header</code>组件和<code>Counter</code>组件中都使用了<code>CounterContext</code>来取值，而且<code>Header</code>和<code>Counter</code>分别有一个<code>Headerer</code>和<code>Counterer</code>子组件</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>\n      <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.jsdelivr.net/npm/react@18.1.0/umd/react.development.js&quot;</span>\n      <span class=\"hljs-attr\">crossorigin</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>\n      <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.jsdelivr.net/npm/react-dom@18.1.0/umd/react-dom.development.js&quot;</span>\n      <span class=\"hljs-attr\">crossorigin</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/babel&quot;</span>&gt;</span><span class=\"language-javascript\">\n      <span class=\"hljs-keyword\">const</span> {\n        useContext,\n        useReducer,\n        createContext,\n        useCallback,\n        useState,\n        memo,\n        useMemo,\n      } = <span class=\"hljs-title class_\">React</span>;\n\n      <span class=\"hljs-keyword\">const</span> initialState = {\n        <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>,\n      };\n\n      <span class=\"hljs-keyword\">const</span> initialDispatch = {};\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">StateContext</span> = <span class=\"hljs-title function_\">createContext</span>(initialState);\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Store</span> = (<span class=\"hljs-params\">{ children }</span>) =&gt; {\n        <span class=\"hljs-keyword\">const</span> [state, setState] = <span class=\"hljs-title function_\">useState</span>({ <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> });\n\n        <span class=\"hljs-keyword\">const</span> increment = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> {\n          <span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">state</span>) =&gt;</span> ({\n            ...state,\n            <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">count</span> + <span class=\"hljs-number\">1</span>,\n          }));\n        }, []);\n\n        <span class=\"hljs-keyword\">const</span> decrement = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> {\n          <span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">state</span>) =&gt;</span> ({\n            ...state,\n            <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">count</span> - <span class=\"hljs-number\">1</span>,\n          }));\n        }, []);\n\n        <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title function_\">useMemo</span>(\n          <span class=\"hljs-function\">() =&gt;</span> ({ state, decrement, increment }),\n          [state, increment, decrement]\n        );\n\n        <span class=\"hljs-keyword\">return</span> (\n          <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StateContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">state</span>, <span class=\"hljs-attr\">increment</span>, <span class=\"hljs-attr\">decrement</span> }}&gt;</span>\n            {children}\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StateContext.Provider</span>&gt;</span></span>\n        );\n      };\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Header</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n        <span class=\"hljs-keyword\">const</span> { state } = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">StateContext</span>);\n\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rerender Header&quot;</span>);\n\n        <span class=\"hljs-keyword\">return</span> (\n          <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{state.count}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Headerer</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n        );\n      };\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Counter</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n        <span class=\"hljs-keyword\">const</span> { increment, decrement } = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">StateContext</span>);\n\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rerender Counter&quot;</span>);\n\n        <span class=\"hljs-keyword\">return</span> (\n          <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;counter&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{increment}</span>&gt;</span>+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{decrement}</span>&gt;</span>-<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Counterer</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n        );\n      };\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Headerer</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rerender Headerer&quot;</span>);\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Headerer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n      };\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MHeaderer</span> = <span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-title class_\">Headerer</span>);\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Counterer</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rerender Counterer&quot;</span>);\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Counterer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n      };\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Store</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Counter</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Store</span>&gt;</span></span>\n      );\n\n      <span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#app&quot;</span>));\n      root.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>组件结构是这样的</p>\n<p><img src=\"/img/use-context-o-0.png\" alt=\"组件结构\"></p>\n<p>代码跑起来后页面显示正常，操作后数据也正常更新，但当我们打开控制台后，会发现打印的数据有点不正常</p>\n<p>刷新页面，初次渲染时打印数据是正常的</p>\n<pre><code class=\"hljs language-sh\">rerender Header\nrerender Headerer\nrerender Counter\nrerender Counterer\n</code></pre>\n<p>点击 ➕ 或 ➖ 后</p>\n<pre><code class=\"hljs language-sh\">rerender Header\nrerender Headerer\nrerender Counter\nrerender Counterer\n<span class=\"hljs-comment\"># &lt;------点击按钮-------&gt;</span>\nrerender Header\nrerender Headerer\nrerender Counter\nrerender Counterer\n</code></pre>\n<p>发现<code>Header</code>和<code>Counter</code>及其子组件都触发更新了，好家伙，直呼好家伙</p>\n<p>针对这个简单的 demo，我的<code>Counter</code>只是想用来渲染可更新数据的两个按钮，没必要重渲吧。我的<code>Headerer</code>和<code>Counterer</code>也只是想展示两个 UI，为啥也更新了</p>\n<p>原因开头已经表述过了，但具体的解决方（代）案（码）是什么呢</p>\n<blockquote>\n<p>talk is cheap, show me the code</p>\n</blockquote>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">未使用到 Context 的</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对于像<code>Headerer</code>和<code>Counterer</code>这种没有直接使用到<code>Context</code>的，可通过寻常的解法：<code>memo</code>搞定</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MHeaderer</span> = <span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-title class_\">Headerer</span>);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Header</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MHeaderer</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<p>这样当再次重渲时就会跳过<code>Headerer</code>和<code>Counterer</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用到 Context 的</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>针对于像<code>Counter</code>这种直接使用到<code>Context</code>的，<code>memo</code>已经搞不定了，不过由于<code>state</code>和<code>setState</code>并不强制绑定，我们可通过将其拆分到两个<code>Context</code>来避免不必要的重渲，即：</p>\n<p>分别创建两个<code>Context</code>，来将<code>state</code>和<code>setState</code>共享到全局</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">StateContext</span> = <span class=\"hljs-title function_\">createContext</span>(initialState);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DispatchContext</span> = <span class=\"hljs-title function_\">createContext</span>(initialDispatch);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Store</span> = (<span class=\"hljs-params\">{ children }</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> dispatch = <span class=\"hljs-title function_\">useMemo</span>(\n    <span class=\"hljs-function\">() =&gt;</span> ({ decrement, increment }),\n    [increment, decrement]\n  );\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StateContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{state}</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DispatchContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{dispatch}</span>&gt;</span>\n        {children}\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">DispatchContext.Provider</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StateContext.Provider</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<p>在这里，<code>DispatchContext</code>的<code>value</code>必须使用<code>useMemo</code>缓存一下：<code>value</code>是一个对象，触发<code>state</code>更新后<code>Store</code>组件会重渲，如果不缓存，<code>value</code>也会改变，导致使用到<code>DispatchContext</code>的组件也会重渲，拆分了个寂寞。。。因此拆分后一定要记得打印一下日志，看有没有效果</p>\n<p>此时的组件结构是这样的</p>\n<p><img src=\"/img/use-context-o-1.png\" alt=\"优化后的useContext\"></p>\n<p>经过此番优化后，日志打印正常了</p>\n<pre><code class=\"hljs language-sh\">rerender Header\nrerender Headerer\nrerender Counter\nrerender Counterer\n<span class=\"hljs-comment\"># &lt;------点击按钮-------&gt;</span>\nrerender Header\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li><p>对于未直接使用到<code>Context</code>的，可通过<code>memo</code>等手段优化，避免不必要的重渲</p>\n</li>\n<li><p>对于直接使用到<code>Context</code>的，可通过拆分<code>Context</code>优化</p>\n</li>\n</ol>\n"},{"title":"React.js学习-一文梳理 React 18 新特性(转载)","tags":["React.js学习","React.js18"],"categories":"React.js","description":"转载自: https://blog.csdn.net/qq_41257129/article/details/123371328\n\nReact 的迭代过程\n\nReact 从 v16 到 v18 主打的特性包括三个变化：\n\n- v16: Async Mode (异步模式)\n- v17: Concurrent Mode (并发模式)\n- v18: Concurrent Render (并发更新)","createDate":"2022-05-16 22:23:31","updateDate":"2022-05-16 22:38:14","body":"<p>转载自: <a href=\"https://blog.csdn.net/qq_41257129/article/details/123371328\">https://blog.csdn.net/qq_41257129/article/details/123371328</a></p>\n<p>React 的迭代过程</p>\n<p>React 从 v16 到 v18 主打的特性包括三个变化：</p>\n<ul>\n<li>v16: Async Mode (异步模式)</li>\n<li>v17: Concurrent Mode (并发模式)</li>\n<li>v18: Concurrent Render (并发更新)</li>\n</ul>\n<p>React 中 <code>Fiber</code> 树的更新流程分为两个阶段 <code>render</code> 阶段和 <code>commit</code> 阶段。组件的 <code>render</code> 函数执行时称为 <code>render</code> （本次更新需要做哪些变更），纯 js 计算；而将 <code>render</code> 的结果渲染到页面的过程称为 <code>commit</code> （变更到真实的宿主环境中，在浏览器中就是操作 DOM）。</p>\n<p>在 Sync 模式下， <code>render</code> 阶段是一次性执行完成；而在 <code>Concurrent</code> 模式下 <code>render</code> 阶段可以被拆解，每个时间片内执行一部分，直到执行完毕。由于 <code>commit</code> 阶段有 DOM 的更新，不可能让 DOM 更新到一半中断，必须一次性执行完毕。</p>\n<ul>\n<li>Async Mode: 让 render 变为异步、可中断的。</li>\n<li>Concurrent Mode : 让 commit 在用户的感知上是并发的。</li>\n<li>Concurrent Render : Concurrent Mode 中包含 breaking change，比如很多库不兼容（mobx 等），所以 v18 提出了 Concurrent Render ，减少了开发者的迁移成本。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React 并发新特性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>并发渲染机制（concurrent rendering）的目的：根据用户的设备性能和网速对渲染过程进行适当的调整， 保证 React 应用在长时间的渲染过程中依旧保持可交互性，避免页面出现卡顿或无响应的情况，从而提升用户体验。</p>\n<p>v18 正式引入了的并发渲染机制，并基于此给我们带来了很多新特性。这些新特性都是可选的并发功能，使用了这些新特性的组件并能触发并发渲染，并且与其整个子树都将自动开启 <code>strictMode</code> 。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">新 root API</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>v18 之前 root 节点对用户不透明。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./App&#x27;</span>\n​\n<span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;app&#x27;</span>)\n<span class=\"hljs-comment\">// v18 之前的方法</span>\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span>/&gt;</span></span>,root)\nv18 中我们可以通过 createRoot <span class=\"hljs-title class_\">Api</span> 手动创建 root 节点。\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./App&#x27;</span>\n​\n<span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;app&#x27;</span>))\n<span class=\"hljs-comment\">// v18 的新方法</span>\nroot.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span>/&gt;</span></span>,root)\n</code></pre>\n<p>想要使用 v18 中其他新特性 API， 前提是要使用新的 Root API 来创建根节点。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Automatic batching 自动批处理优化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>批处理： React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 <code>setState</code> 事件合并）</p>\n<p>在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 <code>promise</code> 链、 <code>setTimeout</code> 等异步代码以及原生事件处理函数。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-comment\">// v18 之前</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span> () {\n\n  <span class=\"hljs-title function_\">fetchSomething</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n      <span class=\"hljs-comment\">// React 17 及之前的版本不会批处理以下的 state:</span>\n      <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 重新渲染</span>\n      <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 二次重新渲染</span>\n    })\n}\n<span class=\"hljs-comment\">// v18下</span>\n<span class=\"hljs-comment\">// 1、promise链中</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span> () {\n\n  <span class=\"hljs-title function_\">fetchSomething</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n      <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n      <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 合并为一次重新渲染</span>\n    })\n}\n<span class=\"hljs-comment\">// 2、setTimeout等异步代码中</span>\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n  <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 合并为一次重新渲染</span>\n}, <span class=\"hljs-number\">5000</span>)\n<span class=\"hljs-comment\">// 3、原生事件中</span>\nelement.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n\n<span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 合并为一次重新渲染</span>\n})\n</code></pre>\n<p>如果想退出自动批处理立即更新的话，可以使用 <code>ReactDOM.flushSync()</code> 进行包裹。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>\n​\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span> () {\n\n  <span class=\"hljs-comment\">// 立即更新</span>\n  <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">flushSync</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n    <span class=\"hljs-title function_\">setCounter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n  })\n  <span class=\"hljs-comment\">// 立即更新</span>\n  <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">flushSync</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n    <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">f</span> =&gt;</span> !f)\n  })\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">startTransition</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>可以用来降低渲染优先级。分别用来包裹计算量大的 <code>function</code> 和 <code>value</code> ，降低优先级，减少重复渲染次数。</p>\n<p>举个例子：搜索引擎的关键词联想。一般来说，对于用户在输入框中输入都希望是实时更新的，如果此时联想词比较多同时也要实时更新的话，这就可能会导致用户的输入会卡顿。这样一来用户的体验会变差，这并不是我们想要的结果。</p>\n<p>我们将这个场景的状态更新提取出来：一个是用户输入的更新；一个是联想词的更新。这个两个更新紧急程度显然前者大于后者。</p>\n<p>以前我们可以使用防抖的操作来过滤不必要的更新，但防抖有一个弊端，当我们长时间的持续输入（时间间隔小于防抖设置的时间），页面就会长时间都不到响应。而 <code>startTransition</code> 可以指定 UI 的渲染优先级，哪些需要实时更新，哪些需要延迟更新。即使用户长时间输入最迟 5s 也会更新一次，官方还提供了 hook 版本的 <code>useTransition</code> ，接受传入一个毫秒的参数用来修改最迟更新时间，返回一个过渡期的 <code>pending</code> 状态和 <code>startTransition</code> 函数。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./styles.css&quot;</span>;\n​\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n\n  <span class=\"hljs-keyword\">const</span> [value, setValue] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>();\n  <span class=\"hljs-keyword\">const</span> [searchQuery, setSearchQuery] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>([]);\n  <span class=\"hljs-keyword\">const</span> [loading, startTransition] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useTransition</span>(<span class=\"hljs-number\">2000</span>);\n​\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleChange</span> = (<span class=\"hljs-params\">e</span>) =&gt; {\n\n    <span class=\"hljs-title function_\">setValue</span>(e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>);\n    <span class=\"hljs-comment\">// 延迟更新</span>\n    <span class=\"hljs-title function_\">startTransition</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n      <span class=\"hljs-title function_\">setSearchQuery</span>(<span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">20000</span>).<span class=\"hljs-title function_\">fill</span>(e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>));\n    });\n  };\n​\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">value</span>} <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">handleChange</span>} /&gt;</span>\n      {\n    loading ? (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      ) : (\n        searchQuery.map((item, index) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">index</span>}&gt;</span>{\n    item}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>)\n      )}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p>所有在 <code>startTransition</code> 回调中更新的都会被认为是非紧急处理，如果一旦出现更紧急的处理（比如这里的用户输入）， <code>startTransition</code> 就会中断之前的更新，只会渲染最新一次的状态更新。</p>\n<p><code>startTransition</code> 的原理就是利用了 React 底层的优先级调度模型。</p>\n<p>更多例子： <a href=\"https://github.com/reactwg/react-18/discussions/65\">真实世界示例：为慢速渲染添加 startTransition</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">SSR 下的 Suspense 组件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>Suspense</code> 的作用： 划分页面中需要并发渲染的部分。</p>\n<p><code>hydration</code>[水化]：ssr 时服务器输出的是字符串（html），客户端（一般是浏览器）根据这些字符串并结合加载的 JavaScript 来完成 React 的初始化工作这一阶段为水化。</p>\n<p>React v18 之前的 SSR， 客户端必须一次性的等待 HTML 数据加载到服务器上并且等待所有 JavaScript 加载完毕之后再开始 <code>hydration</code> ， 等待所有组件 <code>hydration</code> 后，才能进行交互。即整个过程需要完成从获取数据（服务器）→ 渲染到 HTML（服务器）→ 加载代码（客户端）→ 水合物（客户端）这一套流程。这样的 SSR 并不能使我们的完全可交互变快，只是提高了用户的感知静态页面内容的速度。</p>\n<p>React v18 在 SSR 下支持了 <code>Suspense</code> ，最大的区别是什么呢？</p>\n<ol>\n<li><p>服务器不需要等待被 Suspense 包裹组件是否加载到完毕，即可发送 HTML，而代替 suspense 包裹的组件是 fallback 中的内容，一般是一个占位符（spinner），以最小内联<script>标签标记此 HTML 的位置。等待服务器上组件的数据准备好后，React 再将剩余的 HTML 发送到同一个流中。</p>\n</li>\n<li><p>hydration 的过程是逐步的，不需要等待所有的 js 加载完毕再开始 hydration，避免了页面的卡顿。</p>\n</li>\n<li><p>React 会提前监听页面上交互事件（如鼠标的点击），对发生交互的区域优先级进行 hydration。</p>\n</li>\n</ol>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/37\">https://github.com/reactwg/react-18/discussions/37</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useSyncExternalStore</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>这个 API 可以防止在 <code>concurrent</code> 模式下，任务中断后第三方 <code>store</code> 被修改，恢复任务时出现 <code>tearing</code> 从而数据不一致问题。用户一般很少使用，大多情况下提供给像 Redux 这样的状态管理库使用，通过 <code>useSyncExternalStore</code> 可以使 React 在 <code>concurrent mode</code> 下，保持自身 <code>state</code> 和来自 Redux 的状态同步。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>\n​\n<span class=\"hljs-comment\">// 基础用法，getSnapshot 返回一个缓存的值</span>\n<span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useSyncExternalStore</span>(store.<span class=\"hljs-property\">subscribe</span>, store.<span class=\"hljs-property\">getSnapshot</span>)\n​\n<span class=\"hljs-comment\">// 根据数据字段，使用内联的 getSnapshot 返回缓存的数据</span>\n<span class=\"hljs-keyword\">const</span> selectedField = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useSyncExternalStore</span>(store.<span class=\"hljs-property\">subscribe</span>, <span class=\"hljs-function\">() =&gt;</span> store.<span class=\"hljs-title function_\">getSnapshot</span>().<span class=\"hljs-property\">selectedField</span>)\n</code></pre>\n<ul>\n<li>第一个参数是一个订阅函数，订阅触发时会引起该组件的更新。</li>\n<li>第二个函数返回一个 immutable 快照， 返回值是我们想要订阅的数据，只有数据发生变化时才需要重新渲染。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useInsertionEffect</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>这个 hook 对现有的专为 React 设计的 css-in-js 库有着很大的作用，可以动态生成新规则与<code>&lt;style&gt;</code>标签一起插入到文档中。</p>\n<p>假设现在我们要插入一段 css ，并且将这个操作放在渲染期间去执行。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">css</span>(<span class=\"hljs-params\">rule</span>) {\n\n  <span class=\"hljs-keyword\">if</span> (!isInserted.<span class=\"hljs-title function_\">has</span>(rule)) {\n\n    isInserted.<span class=\"hljs-title function_\">add</span>(rule)\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">head</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-title function_\">getStyleForRule</span>(rule))\n  }\n  <span class=\"hljs-keyword\">return</span> rule\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Component</span>(<span class=\"hljs-params\"></span>) {\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">css</span>(&#x27;<span class=\"hljs-attr\">...</span>&#x27;)} /&gt;</span></span>\n}\n</code></pre>\n<p>这样会导致每次修改 css 样式时，react 需要在渲染的每一帧中对所有的节点重新计算所有 CSS 规则，这并不是我们想要的结果。</p>\n<p>那我们是不是可以在所有 DOM 生成前就插入这些 css 样式，此时我们可能会想到 <code>useLayoutEffect</code> ，但 <code>useLayoutEffect</code> 中可以访问 DOM，如果在这个 hook 中访问了某个 DOM 的布局样式（比如<code>clientWidth</code>），这样会导致我们读取的信息是错误的。</p>\n<pre><code class=\"hljs language-JSX\">useLayoutEffect ( <span class=\"hljs-function\">( )  =&gt;</span>  {\n\n  <span class=\"hljs-keyword\">if</span>  ( ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">clientWidth</span>  &lt;  <span class=\"hljs-number\">100</span> )  {\n\n    setCollapsed ( <span class=\"hljs-literal\">true</span> ) ;\n  }\n} ) ;\nuseInsertionEffect 可以帮助我们避免上述问题 ，既可以满足在所有 <span class=\"hljs-variable constant_\">DOM</span> 生成前插入并且不访问 <span class=\"hljs-variable constant_\">DOM</span>。其工作原理大致与 useLayoutEffect 相同，只是此时没法访问 <span class=\"hljs-variable constant_\">DOM</span>节点的引用。我们可以在这个 hook 中插入全局的<span class=\"hljs-variable constant_\">DOM</span>节点，比如如&lt;style&gt; ，或<span class=\"hljs-variable constant_\">SVG</span>&lt;defs&gt; 。\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">useCSS</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">rule</span>) =&gt;</span> {\n\n  <span class=\"hljs-title function_\">useInsertionEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n    <span class=\"hljs-keyword\">if</span> (!isInserted.<span class=\"hljs-title function_\">has</span>(rule)) {\n\n      isInserted.<span class=\"hljs-title function_\">add</span>(rule)\n      <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">head</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-title function_\">getStyleForRule</span>(rule))\n    }\n  })\n  <span class=\"hljs-keyword\">return</span> rule\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Component</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> {\n\n  <span class=\"hljs-keyword\">let</span> className = <span class=\"hljs-title function_\">useCSS</span>(rule)\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">className</span>} /&gt;</span></span>\n}\n</code></pre>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/110\">https://github.com/reactwg/react-18/discussions/110</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useId</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>React 一直在向着 SSR 的领域发展，但 SSR 渲染必须保证客户端与服务端生成的 HTML 结构相匹配。我们平时使用的如 <code>Math.random()</code> 在 SSR 面前是没法保证客户端与服务端之间的 <code>id</code> 唯一性。</p>\n<p>React 为了解决这个问题，提出来 <code>useOpaqueIdentifier</code> 这个 hook, 不过它在不同环境会产生不同的结果.</p>\n<ul>\n<li><p>在服务端会生成一个字符串</p>\n</li>\n<li><p>在客户端会生成一个对象，必须直接传递给 DOM 属性</p>\n</li>\n</ul>\n<p>这样一来，在客户端如果需要生成多个标识，就需要调多次这个 hook，因为它不支持转化为字符串，就无法使用字符串拼接。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">App</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> {\n\n  <span class=\"hljs-keyword\">const</span> tabIdOne = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n  <span class=\"hljs-keyword\">const</span> panelIdOne = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n  <span class=\"hljs-keyword\">const</span> tabIdTwo = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n  <span class=\"hljs-keyword\">const</span> panelIdTwo = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n​\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.Fragment</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabs</span> <span class=\"hljs-attr\">defaultValue</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;tablist&quot;</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">tabIdOne</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">tabIdTwo</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">panelIdOne</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n          Content One\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">panelIdTwo</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;two&quot;</span>&gt;</span>\n          Content Two\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tabs</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.Fragment</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p>而 <code>useId</code> 可以生成客户端与服务端之间的唯一 <code>id</code> ，并且返回一个字符串。这样一个组件可以只需调用一次 <code>useId</code> ，并将其结果作为整个组件所需的标识符基础（比如拼接不同的字符串），以便生成唯一 <code>id</code> 。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">App</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useId</span>();\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.Fragment</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabs</span> <span class=\"hljs-attr\">defaultValue</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;tablist&quot;</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">tab1</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">tab2</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">panel1</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n          Content One\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">panel2</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;two&quot;</span>&gt;</span>\n          Content Two\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tabs</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.Fragment</span>&gt;</span></span>\n  );\n};\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useDefferdValue</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>React 可以通过 <code>useDefferdValue</code> 允许变量延时更新，同时接受一个可选的延迟更新的最大值。React 将尝试尽快更新延迟值，如果在给定的 <code>timeoutMs</code> 期限内未能完成，它将强制更新。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> defferValue = <span class=\"hljs-title function_\">useDeferredValue</span>(value, {\n  <span class=\"hljs-attr\">timeoutMs</span>: <span class=\"hljs-number\">1000</span>,\n});\n</code></pre>\n<p><code>useDefferdValue</code> 能够很好的展现并发渲染时优先级调整的特性，可以用于延迟计算逻辑比较复杂的状态，让其他组件优先渲染，等待这个状态更新完毕之后再渲染。</p>\n"},{"title":"React.js学习-useEffect vs useLayoutEffect","tags":["React.js学习","useEffect","useLayoutEffect"],"categories":"React.js","description":"大部分情况下不需要明确区分 `useEffect` 和 `useLayoutEffect`\n\n（至少我还没遇到过 😂，不过有必要了解一下，没准哪天就遇到了）\n\n两者唯一的区别在于执行时机的不同\n\n## useEffect\n\n一般看来，对于 `useEffect` ，为了防止浏览器渲染卡顿，其回调函数会在浏览器 `paint` 之后执行，这看起来很正常，下面是一个正常的组件渲染流程：\n\n1. 做","createDate":"2022-05-10 21:49:31","updateDate":"2022-05-16 22:23:14","body":"<p>大部分情况下不需要明确区分 <code>useEffect</code> 和 <code>useLayoutEffect</code></p>\n<p>（至少我还没遇到过 😂，不过有必要了解一下，没准哪天就遇到了）</p>\n<p>两者唯一的区别在于执行时机的不同</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useEffect</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一般看来，对于 <code>useEffect</code> ，为了防止浏览器渲染卡顿，其回调函数会在浏览器 <code>paint</code> 之后执行，这看起来很正常，下面是一个正常的组件渲染流程：</p>\n<ol>\n<li><p>做一些准备工作（渲染 <code>VDOM</code> 、调度 <code>effects</code> 等）</p>\n</li>\n<li><p>React 将控制权交由浏览器以 <code>paint</code></p>\n</li>\n<li><p>执行 <code>useEffect</code> 回调</p>\n</li>\n</ol>\n<p>确实，大部分情况下是这样，只不过凡事都有例外，且看官网的描述:</p>\n<blockquote>\n<p>虽然 <code>useEffect</code> 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。在开始新的更新前，React 总会先清除上一轮渲染的 <code>effect</code> 。</p>\n</blockquote>\n<p>官网的介绍<strong>会保证在任何新的渲染前执行</strong>，并没有说一定会在浏览器 <code>paint</code> 之后执行，因此是不是有一些场景 <code>effect</code> 会在 <code>paint</code> 之前执行？🤔</p>\n<p>如果在 <code>useEffect</code> 的回调触发之前，React 组件又进行了一次状态更新，React 会先将之前的 Passive Effect 都处理掉。例如在 <code>useLayoutEffect</code> 中更新状态，在这种情况下，<code>useEffect</code>的回调 会在 paint 之前执行</p>\n<p><img src=\"https://blog.thoughtspile.tech/images/forced-le-flush-chart-5dc51705d5854315a6fa5e0be1464f7d.png\" alt=\"useLayoutEffect-useEffect\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useLayoutEffect</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>和 <code>useEffect</code> 的唯一区别在于<strong>执行时机不同</strong>， <code>useLayoutEffect</code> 一定会保证回调函数会在 paint 之前执行，下面是一个正常的组件渲染流程：</p>\n<ol>\n<li><p>做一些准备工作（渲染 <code>VDOM</code> 、调度 <code>effects</code> 等）</p>\n</li>\n<li><p>执行 <code>useLayoutEffect</code> 回调</p>\n</li>\n<li><p>React 将控制权交由浏览器以 <code>paint</code></p>\n</li>\n<li><p>执行 <code>useEffect</code> 回调</p>\n</li>\n</ol>\n<p>这个区别的体现场景在于使用 useEffect 更新数据时，界面会闪烁一下</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">const</span> { useState, useEffect, useLayoutEffect } = <span class=\"hljs-title class_\">React</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [value, setValue] = <span class=\"hljs-title function_\">useState</span>(-<span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (i &lt;= <span class=\"hljs-number\">900000000</span>) {\n      i++;\n    }\n    <span class=\"hljs-keyword\">if</span> (value === <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-keyword\">const</span> tmp = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * <span class=\"hljs-number\">100</span>;\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;setValue&quot;</span>, tmp);\n      <span class=\"hljs-title function_\">setValue</span>(<span class=\"hljs-function\">() =&gt;</span> tmp);\n    }\n  }, [value]);\n\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;render&quot;</span>, value, <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>());\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setValue(0)}&gt;{value}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n};\n</code></pre>\n<p>可以看到有一个明显的闪烁</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/useEffect-%20blink.gif\" alt=\"useEffect-blink\"></p>\n<p>改用 <code>useLayoutEffect</code> 后就不会出现这种情况了</p>\n"},{"title":"微前端-技术调研","tags":["微前端"],"categories":"微前端","description":"微前端是近两年比较火热的话题，从国外的 single-spa 到阿里的 qiankun，从京东的 micro-app 到欢聚时代的 emp ，各家大厂使尽浑身解数推出自家的微前端框架，那么微前端到底是什么呢\n\n## 什么是微前端\n\n网上看到一句话对其总结的鞭辟入里\n\n> “微前端是一种架构风格，其中众多独立交付的前端应用组合成一个大型整体。”\n\n微前端的概念最早在 2016 年底被[提出](ht","createDate":"2022-04-28 22:12:20","updateDate":"2022-05-12 22:57:34","body":"<p>微前端是近两年比较火热的话题，从国外的 single-spa 到阿里的 qiankun，从京东的 micro-app 到欢聚时代的 emp ，各家大厂使尽浑身解数推出自家的微前端框架，那么微前端到底是什么呢</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是微前端</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>网上看到一句话对其总结的鞭辟入里</p>\n<blockquote>\n<p>“微前端是一种架构风格，其中众多独立交付的前端应用组合成一个大型整体。”</p>\n</blockquote>\n<p>微前端的概念最早在 2016 年底被<a href=\"https://www.thoughtworks.com/radar/techniques/micro-frontends\">提出</a>，<strong>微前端不是单纯的前端框架或者工具，而是一套架构体系</strong>，它将微服务的概念扩展到前端世界。在该技术架构下，新的/改造好之后的前端应用可由多个子应用构成，这些子应用间独立开发、独立部署、独立运行时、技术栈无关</p>\n<p>微前端有如下特性：</p>\n<ol>\n<li><p>技术栈无关</p>\n</li>\n<li><p>独立开发/部署</p>\n</li>\n<li><p>增量升级</p>\n</li>\n</ol>\n<p>既然微前端这么好，为什么直到 16 年才被提出来呢</p>\n<p>其实早在上古时代，<code>iframe</code>就可称为微前端，为什么这么说呢，因为<code>iframe</code>可以做到完美隔离 javascript/css ，并且可适用 url 快速接入。那既然这么简单，为啥没有流行起来呢（在微前端领域）？因为<code>iframe</code>缺点同样明显：隔离过于简单粗暴，导致应用间数据交互困难；整个应用全量加载，性能较差；弹窗类业务无法正常施展。。。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么要做微前端</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>微前端既可将多个应用/项目整合到一起，又可减小各应用间的耦合性，提高项目的可扩展性</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">实现微前端有哪些方案</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>从集成方式出发可以大致分为构建时集成、运行时集成</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">构建时集成</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>最常见的是将子应用独立开发为一个单独的可发布的 Javascript 包，在主应用中引用并加载。但是，这种方法意味着我们必须重新编译并发布每个微前端，才能发布对产品任何单个部分的更改</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">运行时集成</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>和构建时集成相反，在运行时动态加载各应用</p>\n<p>最简单的事通过 nginx 来分发</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span> <span class=\"hljs-attr\">dir</span>=<span class=\"hljs-string\">&quot;ltr&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Feed me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Feed me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--# include file=&quot;$PAGE.html&quot; --&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<pre><code class=\"hljs language-sh\">server {\n    listen 8080;\n    server_name localhost;\n\n    root /usr/share/nginx/html;\n    index index.html;\n    ssi on;\n\n    <span class=\"hljs-comment\"># Redirect / to /browse</span>\n    rewrite ^/$ http://localhost:8080/browse redirect;\n\n    <span class=\"hljs-comment\"># Decide which HTML fragment to insert based on the URL</span>\n    location /browse {\n      <span class=\"hljs-built_in\">set</span> <span class=\"hljs-variable\">$PAGE</span> <span class=\"hljs-string\">&#x27;browse&#x27;</span>;\n    }\n    location /order {\n      <span class=\"hljs-built_in\">set</span> <span class=\"hljs-variable\">$PAGE</span> <span class=\"hljs-string\">&#x27;order&#x27;</span>;\n    }\n    location /profile {\n      <span class=\"hljs-built_in\">set</span> <span class=\"hljs-variable\">$PAGE</span> <span class=\"hljs-string\">&#x27;profile&#x27;</span>\n    }\n\n    <span class=\"hljs-comment\"># All locations should render through index.html</span>\n    error_page 404 /index.html;\n}\n</code></pre>\n<p>这种方式也可勉强称为<em>微前端</em>，因为我们将每个业务都拆分到一个独立的应用中，可以交由独立的团队维护。除了这种服务端集成，在客户端也可以通过一定的手段拆分-集成</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Feed me!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Welcome to Feed me!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- These scripts don&#x27;t render anything immediately --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- Instead they attach entry-point functions to `window` --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://browse.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://order.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://profile.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;micro-frontend-root&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\">\n      <span class=\"hljs-comment\">// These global functions are attached to window by the above scripts</span>\n      <span class=\"hljs-keyword\">const</span> microFrontendsByRoute = {\n        <span class=\"hljs-string\">&quot;/&quot;</span>: <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">renderBrowseRestaurants</span>,\n        <span class=\"hljs-string\">&quot;/order-food&quot;</span>: <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">renderOrderFood</span>,\n        <span class=\"hljs-string\">&quot;/user-profile&quot;</span>: <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">renderUserProfile</span>,\n      };\n      <span class=\"hljs-keyword\">const</span> renderFunction = microFrontendsByRoute[<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">location</span>.<span class=\"hljs-property\">pathname</span>];\n\n      <span class=\"hljs-comment\">// Having determined the entry-point function, we now call it,</span>\n      <span class=\"hljs-comment\">// giving it the ID of the element where it should render itself</span>\n      <span class=\"hljs-title function_\">renderFunction</span>(<span class=\"hljs-string\">&quot;micro-frontend-root&quot;</span>);\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>在这里，我们将每个应用打包成一个 javascript 文件，在匹配到 URL 后执行对应的代码，渲染页面。</p>\n<p>除了使用 javascript ，还可使用开篇提到的 iframe 集成，但 iframe 缺点过于明显就不讨论。此外，还可使用 web components 来实现，其也属于 javascript 因此不另列</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Feed me!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Welcome to Feed me!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- These scripts don&#x27;t render anything immediately --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- Instead they each define a custom element type --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://browse.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://order.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://profile.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;micro-frontend-root&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\">\n      <span class=\"hljs-comment\">// These element types are defined by the above scripts</span>\n      <span class=\"hljs-keyword\">const</span> webComponentsByRoute = {\n        <span class=\"hljs-string\">&quot;/&quot;</span>: <span class=\"hljs-string\">&quot;micro-frontend-browse-restaurants&quot;</span>,\n        <span class=\"hljs-string\">&quot;/order-food&quot;</span>: <span class=\"hljs-string\">&quot;micro-frontend-order-food&quot;</span>,\n        <span class=\"hljs-string\">&quot;/user-profile&quot;</span>: <span class=\"hljs-string\">&quot;micro-frontend-user-profile&quot;</span>,\n      };\n      <span class=\"hljs-keyword\">const</span> webComponentType = webComponentsByRoute[<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">location</span>.<span class=\"hljs-property\">pathname</span>];\n\n      <span class=\"hljs-comment\">// Having determined the right web component custom element type,</span>\n      <span class=\"hljs-comment\">// we now create an instance of it and attach it to the document</span>\n      <span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;micro-frontend-root&quot;</span>);\n      <span class=\"hljs-keyword\">const</span> webComponent = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(webComponentType);\n      root.<span class=\"hljs-title function_\">appendChild</span>(webComponent);\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>除了这两种分类，还可从拆分粒度来分类</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基于路由分发</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>上面介绍的基本都是一个页面一个应用，那么还有没有粒度更细一点的：想在一个页面加载多个应用？🤔</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">前端微服务化</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>每个前端应用都是独立的、自主运行的，最后通过模块化的方式组合出完整的前端应用</p>\n<p>比如借助上面的 Web Components 实现</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Feed me!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Welcome to Feed me!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- These scripts don&#x27;t render anything immediately --&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- Instead they each define a custom element type --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://browse.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://order.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://profile.example.com/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;micro-frontend-root&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">micro-frontend-browse-restaurants</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">micro-frontend-order-food</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">micro-frontend-user-profile</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>在这里，我们加载的 js 资源可以是任何借助框架构建后生成的 web component 组件文件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>微前端是一种架构风格，其中众多独立交付的前端应用组合成一个大型整体。</p>\n<p>微前端技术方案可分为运行时集成/构建时集成，或者按照拆分粒度划分为路由分发式和微服务化</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://www.icode9.com/content-4-946879.html\">详解微前端</a></p>\n"},{"title":"React.js学习-使用内置hook","tags":["React.js学习","hook"],"categories":"React.js","description":"# 什么是 hook\n\n组件自身能够通过某种机制再触发状态的变更并且引起**re-render**，而这种“机制”就是 Hooks！\n\n# useEffect\n\n- 默认情况下，它在第一次渲染之后和每次更新之后都会执行。React 确保了每次运行`effect`的同时，DOM 都已经更新完毕\n\n- 每次重新渲染，都会生成新的`effect`，替换掉之前的。某种意义上讲，`effect`更像是渲染","createDate":"2020-09-07 10:48:54","updateDate":"2022-05-11 22:19:50","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是 hook</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>组件自身能够通过某种机制再触发状态的变更并且引起<strong>re-render</strong>，而这种“机制”就是 Hooks！</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useEffect</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>默认情况下，它在第一次渲染之后和每次更新之后都会执行。React 确保了每次运行<code>effect</code>的同时，DOM 都已经更新完毕</p>\n</li>\n<li><p>每次重新渲染，都会生成新的<code>effect</code>，替换掉之前的。某种意义上讲，<code>effect</code>更像是渲染结果的一部分 —— 每个<code>effect</code> “属于”一次特定的渲染。</p>\n</li>\n<li><p>每个<code>effect</code>都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。他们都属于<code>effect</code>的一部分</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">自定义 hook 的 state 是否共享</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>在两个组件中使用相同的<code>hook</code>不会共享<code>state</code>，自定义<code>hook</code>是一种重用状态逻辑的机制，所以每次使用自定义<code>hook</code>时其中的所有<code>state</code>和副作用是完全隔离的</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">hook 原理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>初次渲染的时候，按照 useState，useEffect 等 hook 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中。</p>\n<p>更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">state 和 useState 的对应关系</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>React</code>靠<code>hook</code>的调用顺序来知道<code>state</code>和<code>useState</code>的对应关系，所以不能在条件/循环中调用<code>hook</code></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useEffect 的执行时机</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>useEffect</code>会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useCallback 和 useMemo</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">useCallback</span>(fn, deps) == <span class=\"hljs-title function_\">useMemo</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">fn</span>(), deps);\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用过多 hook 后性能问题</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>hook 不会因为在渲染时创建函数而变慢，在现代浏览器中闭包和类的原始性能只有在极端场景下才会有明显的差别</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useState 惰性求值</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>如果初始化<code>state</code>需要通过复杂计算获得，那么可以传入一个函数，在函数中计算并返回初始的<code>state</code>，此函数只在初始渲染时被调用</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">calState</span>());\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">hook 使用必须要遵循的规则</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>在函数值组件主体内（指 React 渲染阶段）改变<code>DOM</code>、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。使用<code>useEffect</code>完成副作用操作赋值给<code>useEffect</code>的函数会在组件渲染到屏幕后执行。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useRef</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>通过<code>useRef</code>来拥有一个在<strong>所有帧</strong>中<strong>共享</strong>的变量</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useReducer</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>state 逻辑较复杂且包含多个子值</p>\n</li>\n<li><p>下一个 state 依赖于之前的 state</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useImperativeHandle</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>简单来讲: useImperativeHandle 赋予函数式组件使用 ref 的特权, 通常和 forwardRef 成对出现,</p>\n<p>使用方式:</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> { useImperativeHandle, forwardRef, useRef } = <span class=\"hljs-title class_\">React</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Modal</span> = <span class=\"hljs-title function_\">forwardRef</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">props, ref</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">open</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;open&quot;</span>);\n  };\n  <span class=\"hljs-title function_\">useImperativeHandle</span>(ref, <span class=\"hljs-function\">() =&gt;</span> ({\n    open,\n  }));\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>modal<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n});\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> modalRef = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Modal</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{modalRef}</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> modalRef.current.open()}&gt;click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#app&quot;</span>));\nroot.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n</code></pre>\n"},{"title":"JavaScript-异步并发","tags":["异步","并发","队列","Promise.all"],"categories":"JavaScript","description":"来源于一道面试题\n\n_请实现如下的函数：可以批量请求数据，所有的 URL 地址在 urls 参数中，同时可以通过 max 参数控制请求的并发度，当所有请求结束后，需要执行 callback 回调函数。发送请求的函数直接使用 fetch 即可_\n\n划出重点：请求数据、控制请求的并发度\n\n## Promise.all\n\n第一眼想到 `Promise.all` 实现，于是开写，但写着写着发现不对劲，这","createDate":"2022-05-08 21:58:54","updateDate":"2022-05-08 22:39:51","body":"<p>来源于一道面试题</p>\n<p><em>请实现如下的函数：可以批量请求数据，所有的 URL 地址在 urls 参数中，同时可以通过 max 参数控制请求的并发度，当所有请求结束后，需要执行 callback 回调函数。发送请求的函数直接使用 fetch 即可</em></p>\n<p>划出重点：请求数据、控制请求的并发度</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise.all</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>第一眼想到 <code>Promise.all</code> 实现，于是开写，但写着写着发现不对劲，这样貌似不算并发，或者说没有达到要求的并发度控制: <code>Promise.all</code>只能在当前所有<code>promises</code>请求完毕后才能开启下一次请求，这样并不能吃满 <code>max</code> 并发度，需要变换策略</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">闭包 + 循环 + 递归</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>可以使用闭包+循环+递归来解决：循环控制并发度，递归来发送所有请求</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">request</span> = (<span class=\"hljs-params\">...args</span>) =&gt; <span class=\"hljs-title function_\">fetch</span>(...args).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> res.<span class=\"hljs-title function_\">json</span>());\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">minIn2</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; (a &gt; b ? b : a);\n\n<span class=\"hljs-keyword\">const</span> macAddresses = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">10</span>)\n  .<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n  .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, index</span>) =&gt;</span> <span class=\"hljs-string\">`http://localhost:8080/<span class=\"hljs-subst\">${index}</span>`</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sendRequest</span>(<span class=\"hljs-params\">urls, max, callback</span>) {\n  <span class=\"hljs-keyword\">const</span> res = [];\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doRequest</span>(<span class=\"hljs-params\">url</span>) {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">const</span> r = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">request</span>(url);\n      res.<span class=\"hljs-title function_\">push</span>(r);\n    } <span class=\"hljs-keyword\">catch</span> (e) {\n      res.<span class=\"hljs-title function_\">push</span>(e);\n    } <span class=\"hljs-keyword\">finally</span> {\n      <span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">length</span> === urls.<span class=\"hljs-property\">length</span>) {\n        <span class=\"hljs-title function_\">callback</span>(res);\n      }\n      <span class=\"hljs-keyword\">if</span> (i === urls.<span class=\"hljs-property\">length</span>) {\n        <span class=\"hljs-keyword\">return</span>;\n      }\n      <span class=\"hljs-title function_\">doRequest</span>(urls[i++]);\n    }\n  }\n\n  <span class=\"hljs-keyword\">for</span> (; i &lt; <span class=\"hljs-title function_\">minIn2</span>(max, urls.<span class=\"hljs-property\">length</span>); i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-title function_\">doRequest</span>(urls[i]);\n  }\n}\n\n<span class=\"hljs-title function_\">sendRequest</span>(macAddresses, <span class=\"hljs-number\">3</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);\n});\n</code></pre>\n<p>这里面有个关键的变量<code>i</code>，该变量维护了当前完成到哪个请求</p>\n<p>这个回答在面试时应该可以应付第一波攻势，但如果对方进一步发问，如果我的 urls 不是预先制定好的，我可以通过调用多次 <code>sendRequest</code> 来发送请求，那这应该怎么实现呢</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">队列</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>针对于进一步发问，这时候就没有那么简单了，因为我们同时还要维护所有urls，这样的话我们可以引入队列来解决，即：相较于上面的<code>i</code>，这里使用一个队列来维护当前完成到哪个请求</p>\n<ol>\n<li><p>使用一个<code>queue</code>来保存所有的请求</p>\n</li>\n<li><p>入队后立即出队</p>\n</li>\n<li><p>在出队过程中先判断有没有达到最大并发度，如果有直接退出出队逻辑，若没有，则执行当前节点，完毕后继续出队即重复当前逻辑</p>\n</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">{ concurrency = <span class=\"hljs-number\">1</span>, onCompleted } = {}</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queue</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingPromises</span> = [];\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">concurrency</span> = concurrency;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onCompleted</span> = onCompleted;\n  }\n\n  <span class=\"hljs-title function_\">enqueue</span>(<span class=\"hljs-params\">promise</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queue</span>.<span class=\"hljs-title function_\">push</span>({\n        promise,\n        resolve,\n        reject,\n      });\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">dequeue</span>();\n    });\n  }\n\n  <span class=\"hljs-title function_\">dequeue</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingPromises</span>.<span class=\"hljs-property\">length</span> === <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">concurrency</span>) {\n      <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-keyword\">const</span> item = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queue</span>.<span class=\"hljs-title function_\">shift</span>();\n    <span class=\"hljs-keyword\">if</span> (!item) {\n      <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingPromises</span>.<span class=\"hljs-title function_\">push</span>(item.<span class=\"hljs-property\">promise</span>);\n      item\n        .<span class=\"hljs-title function_\">promise</span>()\n        .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingPromises</span>.<span class=\"hljs-title function_\">shift</span>();\n          item.<span class=\"hljs-title function_\">resolve</span>(value);\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">dequeue</span>();\n        })\n        .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingPromises</span>.<span class=\"hljs-title function_\">shift</span>();\n          item.<span class=\"hljs-title function_\">reject</span>(e);\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">dequeue</span>();\n        });\n    } <span class=\"hljs-keyword\">catch</span> (e) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingPromises</span>.<span class=\"hljs-title function_\">shift</span>();\n      item.<span class=\"hljs-title function_\">reject</span>(e);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">dequeue</span>();\n    }\n  }\n}\n</code></pre>\n<p>该队列每个节点为一个返回 Promise 的函数，因此使用时需要注意一下</p>\n<p>使用的话可以这样：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">request</span> = (<span class=\"hljs-params\">...args</span>) =&gt; <span class=\"hljs-title function_\">fetch</span>(...args).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> res.<span class=\"hljs-title function_\">json</span>());\n\n<span class=\"hljs-keyword\">const</span> macAddresses = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">10</span>)\n  .<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n  .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, index</span>) =&gt;</span> <span class=\"hljs-string\">`http://localhost:8080/<span class=\"hljs-subst\">${index}</span>`</span>);\n\n<span class=\"hljs-keyword\">const</span> queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Queue</span>({\n  <span class=\"hljs-attr\">concurrency</span>: <span class=\"hljs-number\">3</span>,\n  <span class=\"hljs-attr\">onCompleted</span>: <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;completed&quot;</span>);\n  },\n});\n\nmacAddresses.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">address</span>) =&gt;</span> {\n  queue.<span class=\"hljs-title function_\">enqueue</span>(<span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">request</span>(address);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(address, res);\n  });\n});\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">p-queue</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>上面实现的 Queue 还不够完善，npm 上有个非常完善的库<a href=\"https://www.npmjs.com/package/p-queue\">p-queue</a></p>\n"},{"title":"Web Component-Lit-2","tags":["微前端","WebComponent","Lit"],"categories":"微前端","description":"在昨天，我们使用 Lit 重构了`Reply`组件\n\n功能是完成了，不过最后总结的时候有些许吐槽，事后想起来貌似是自己使用姿势不对 🤔 ，因此今天基于 typescript + webpack + Lit 来重新开发，果然体验一下就上去了：\n\n1. typescript。有了 typescript 的加持，少写了不少模版代码\n\n2. VS Code 插件。我们在上一篇处理中吐槽没有语法提示，今","createDate":"2022-04-27 22:25:56","updateDate":"2022-05-07 22:54:37","body":"<p>在昨天，我们使用 Lit 重构了<code>Reply</code>组件</p>\n<p>功能是完成了，不过最后总结的时候有些许吐槽，事后想起来貌似是自己使用姿势不对 🤔 ，因此今天基于 typescript + webpack + Lit 来重新开发，果然体验一下就上去了：</p>\n<ol>\n<li><p>typescript。有了 typescript 的加持，少写了不少模版代码</p>\n</li>\n<li><p>VS Code 插件。我们在上一篇处理中吐槽没有语法提示，今天发现 VS Code 有一个插件可以做到该功能，嗯，体验又高了一级</p>\n</li>\n</ol>\n<p>接下来就开始介绍我的探索之旅</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">配置开发环境</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>主要是安装 package + 配置 webpack + 安装插件</p>\n<ol>\n<li>安装必要的 package</li>\n</ol>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;dependencies&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;lit&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^2.2.2&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;typescript&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^4.6.3&quot;</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;html-webpack-plugin&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^5.5.0&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;ts-loader&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^9.2.9&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;webpack&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^5.72.0&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;webpack-cli&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^4.9.2&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;webpack-dev-server&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^4.8.1&quot;</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<ol start=\"2\">\n<li>配置 webpack</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HtmlWebpackPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;html-webpack-plugin&quot;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;development&quot;</span>,\n  <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&quot;./src/index.ts&quot;</span>,\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.ts$/</span>,\n        <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-string\">&quot;ts-loader&quot;</span>],\n      },\n    ],\n  },\n  <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">&quot;source-map&quot;</span>,\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HtmlWebpackPlugin</span>()],\n};\n</code></pre>\n<ol start=\"3\">\n<li>添加启动命令</li>\n</ol>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;dev:lit&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;webpack serve&quot;</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<ol start=\"4\">\n<li>安装 VS Code 插件</li>\n</ol>\n<p>VS Code 插件栏中搜索<strong>lit-plugin</strong>，然后安装即可，安装好之后<code>html</code>和<code>css</code>里的代码就有高亮和语法提示了（没有的话重新打开文件试试，再不行就重启大法好），而且点击组件还可以跳转了</p>\n<p>至此，开发环境配置完毕</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用 typescript 重构代码</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>俗话说得好，磨刀不误砍柴工，先规划好要做什么</p>\n<ol>\n<li><p>重构 Reply 组件</p>\n</li>\n<li><p>使用 typescript 开发</p>\n</li>\n<li><p>使用 webpack 📦</p>\n</li>\n</ol>\n<p>那么既然用到 webpack 了，那么我们就按照通常的项目来设计了</p>\n<pre><code class=\"hljs language-sh\">.\n├── package.json\n├── src\n│   ├── components\n│   │   ├── Comment.ts <span class=\"hljs-comment\"># 评论组件</span>\n│   │   └── Reply.ts   <span class=\"hljs-comment\"># 回复组件</span>\n│   └── index.ts       <span class=\"hljs-comment\"># 入口文件，同时会创建一个App组件</span>\n├── tsconfig.json\n├── webpack.config.js\n└── yarn.lock\n</code></pre>\n<p>在这里，我们分别将不同的组件抽离到不同的文件中，这样逻辑更清晰，维护起来也更方便</p>\n<p>好了，接下来开始编码</p>\n<p>（代码和之前的差不多，我直接敲重点）</p>\n<p>从 js 迁移到 ts 开始很方便快捷的，主要修改的逻辑包含下面几项</p>\n<ol>\n<li><p>去除之前的<code>window.customElements.define(&#39;m-comment&#39;, Comment);</code>，在<code>class</code>最上面添加注解<code>@customElement(&quot;m-comment&quot;)</code></p>\n</li>\n<li><p>属性声明也可以使用注解了</p>\n</li>\n</ol>\n<pre><code class=\"hljs language-ts\">  <span class=\"hljs-meta\">@property</span>({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span> })\n  avatar = <span class=\"hljs-string\">&#x27;&#x27;</span>\n</code></pre>\n<ol start=\"3\">\n<li>组件中的<code>this.shadowRoot.querySelector(&#39;#input&#39;)</code>需要修改一下</li>\n</ol>\n<p>我们可以使用<code>!</code>来强制声明<code>this.shadowRoot</code>是一定存在的，或者添加一个<code>if</code>判断</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-title function_\">onSubmit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">comment</span>: <span class=\"hljs-title class_\">HTMLInputElement</span>|<span class=\"hljs-literal\">null</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>!.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#input&#x27;</span>);\n    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">dispatchEvent</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CustomEvent</span>(<span class=\"hljs-string\">&#x27;submit-comment&#x27;</span>, {\n      <span class=\"hljs-attr\">detail</span>: comment!.<span class=\"hljs-property\">value</span>,\n    }));\n    comment!.<span class=\"hljs-property\">value</span> = <span class=\"hljs-string\">&quot;&quot;</span>;\n  }\n</code></pre>\n<ol start=\"4\">\n<li>完成</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/611ad4cbcda94373a63fb5b2b22bd715~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"lit-ts-js\"></p>\n<p>可以看到，有了 typescript 的加持，代码明显清爽许多，而且开发体验也更好了</p>\n<p>完整代码在<a href=\"https://github.com/mrrs878/web-components\">这里</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>typescript 牛逼，开发插件的大佬牛逼</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://lit.dev/docs/\">Lit</a></p>\n"},{"title":"Web Component-Lit","tags":["微前端","WebComponent","Lit"],"categories":"微前端","description":"在前几篇中，我们基于原生的 Web Components 开发了一个`Reply`组件，大概长这样\n\n![web component reply](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa68a485f5242f5b5e1eb75dfc801c1~tplv-k3u1fbpfcp-zoom-1.image)\n\n功能是完成了，不过这些","createDate":"2022-04-26 20:49:40","updateDate":"2022-04-26 22:54:37","body":"<p>在前几篇中，我们基于原生的 Web Components 开发了一个<code>Reply</code>组件，大概长这样</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa68a485f5242f5b5e1eb75dfc801c1~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"web component reply\"></p>\n<p>功能是完成了，不过这些都是裸用 Web Components，有不少缺陷：</p>\n<ol>\n<li><p>性能问题。由于我们没有任何 dom diff 的操作，接收到数据后直接渲染一个节点及其子节点，过于简单粗暴</p>\n</li>\n<li><p>数据传输问题。我们在上一篇处理数据中提到使用<code>property</code>来处理父子组件交互问题，但这样就没法给子组件传递初始属性</p>\n</li>\n<li><p>效率。可以看到，仅仅是一个简单的<code>Reply</code>组件，就写了很多琐碎的 dom 操作，如果组件复杂一点，代码量肯定会激增</p>\n</li>\n<li><p>and so on</p>\n</li>\n</ol>\n<p>好在现在有一个库，可以帮助我们解决这些基础问题，使得我们可以专注于处理业务需求</p>\n<p><a href=\"https://lit.dev/\">Lit</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Lit 是什么</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>Lit is a simple library for building fast, lightweight web components.</p>\n</blockquote>\n<p>奥，用来创建 Web Components 的一个库</p>\n<p>官网上非常醒目地表达出其特点：Simple、Fast、Web Components，而且还对这三个特点做了说明</p>\n<p>Simple：基于原生 Web Components，添加了一些响应式、声明式模版语法和其它一些特性</p>\n<p>Fast：构建后体积非常小，5KB，而且没有虚拟DOM\\增量更新</p>\n<p>Web Components：基于原生 Web Components，可以和各种框架、平台无缝衔接</p>\n<p>看起来还是挺有意思的，可以试用一下</p>\n<p>这是官网给出的示例</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> { html, css, <span class=\"hljs-title class_\">LitElement</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;lit&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { customElement, property } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;lit/decorators.js&quot;</span>;\n\n@<span class=\"hljs-title function_\">customElement</span>(<span class=\"hljs-string\">&quot;simple-greeting&quot;</span>)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleGreeting</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">LitElement</span> {\n  <span class=\"hljs-keyword\">static</span> styles = css`<span class=\"language-css\">\n    <span class=\"hljs-selector-tag\">p</span> {\n      <span class=\"hljs-attribute\">color</span>: blue;\n    }\n  `</span>;\n\n  @<span class=\"hljs-title function_\">property</span>()\n  name = <span class=\"hljs-string\">&quot;Somebody&quot;</span>;\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> html`<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello, </span><span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.name}</span><span class=\"language-xml\">!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>`</span>;\n  }\n}\n\n&lt;simple-greeting name=<span class=\"hljs-string\">&quot;World&quot;</span>&gt;&lt;/simple-greeting&gt;;\n</code></pre>\n<p>开起来还是挺简单的，那么就先试用一下，使用 Lit 来重构 Reply 组件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用 Lit 重构 Reply 组件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>配置开发环境的过程就略过了，直接进入编码环节</p>\n<p>先将目光移到上述的示例，该示例创建了一个<code>simple-greeting</code>组件</p>\n<p>首先，使用<code>customElement</code>注解，定义了一个组件<code>simple-greeting</code>，这个对标<code>customElements.define</code></p>\n<p>接着，使用<code>css</code>函数创建样式，这个对标<code>template&gt;style</code></p>\n<p>然后，使用<code>property</code>声明了一个属性，这个对标原生的<code>setAttribute/getAttribute</code></p>\n<p>最后，使用<code>html</code>函数创建了一个 dom 模版</p>\n<p>按照上面的步骤，可以很简单地修改我们的代码</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">LitElement</span>,\n  css,\n  html,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;https://cdn.jsdelivr.net/gh/lit/dist@2.2.2/all/lit-all.min.js&quot;</span>;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Reply</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">LitElement</span> {\n  <span class=\"hljs-keyword\">static</span> styles = css`<span class=\"language-css\">`</span>;\n\n  <span class=\"hljs-keyword\">static</span> properties = {\n    <span class=\"hljs-attr\">placeholder</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span> },\n  };\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">super</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">avatar</span> = <span class=\"hljs-string\">&quot;https://joeschmoe.io/api/v1/random&quot;</span>;\n  }\n\n  <span class=\"hljs-title function_\">onSubmit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> comment = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#input&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">dispatchEvent</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CustomEvent</span>(<span class=\"hljs-string\">&quot;submit-comment&quot;</span>));\n  }\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> html`<span class=\"language-xml\">\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;reply-c&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;comments-c&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;commentsContainer&quot;</span>&gt;</span>\n          </span><span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.comments.map(\n            (comment) =&gt;\n              html`<span class=\"language-xml\">\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">m-comment</span>\n                  <span class=\"hljs-attr\">.avatar</span>=<span class=\"hljs-string\">&quot;</span></span></span><span class=\"hljs-subst\">${comment.avatar}</span><span class=\"language-xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">&quot;</span>\n                  <span class=\"hljs-attr\">.nickName</span>=<span class=\"hljs-string\">&quot;</span></span></span><span class=\"hljs-subst\">${comment.nickName}</span><span class=\"language-xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">&quot;</span>\n                  <span class=\"hljs-attr\">.comment</span>=<span class=\"hljs-string\">&quot;</span></span></span><span class=\"hljs-subst\">${comment.comment}</span><span class=\"language-xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">&quot;</span>\n                /&gt;</span>\n              `</span>\n          )}</span><span class=\"language-xml\">\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    `</span>;\n  }\n}\n</code></pre>\n<p>可以看到，我们代码里已经没有监听<code>comments</code>的逻辑，Lit 会帮我们做监听，变化时自动重渲</p>\n<p>总体改造起来还是挺顺利的，有点 React + Vue 组合起来的感觉，只是在<code>App</code>里向<code>Reply</code>组件传递<code>comments</code>属性时耗费点时间，由于没看清官网的文档，一直使用的是<code>&lt;m-reply comments=${comments} /&gt;</code>来传递，导致<code>Reply</code>组件一直接受不到值，最后翻看官网的示例，发现传递复杂类型的值时需要在前面加一个<code>.</code>（有点坑，整个改造时间有将近一半时间卡在这里 😭）</p>\n<p>开发体验一般，欠缺一些没有语法提示和高亮</p>\n<p>完整代码在<a href=\"https://github.com/mrrs878/web-components/blob/main/reply-lit.html\">这里</a>（在这里，为了更进一步体现组件化的思想，我们创建了三个组件<code>App</code>、<code>Reply</code>、<code>Comment</code>。<code>App</code>是根组件，用来创建页面，并将之前的<code>Reply</code>组件拆分为<code>Reply</code> + <code>Comment</code>）</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用起来有利有弊，性能较裸写肯定有提升，但开发体验还待提高，值得尝试一下</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://lit.dev/docs/\">Lit</a></p>\n"},{"title":"Web Component-处理数据","tags":["微前端","WebComponent","Attribute","Property"],"categories":"微前端","description":"在前一篇中，我们开发了一个`Reply`组件，大概长这样\n\n![web component reply](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa68a485f5242f5b5e1eb75dfc801c1~tplv-k3u1fbpfcp-zoom-1.image)\n\n功能是完成了，不过今天浏览看到一篇文章[Handling dat","createDate":"2022-04-24 22:00:47","updateDate":"2022-04-23 22:54:37","body":"<p>在前一篇中，我们开发了一个<code>Reply</code>组件，大概长这样</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa68a485f5242f5b5e1eb75dfc801c1~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"web component reply\"></p>\n<p>功能是完成了，不过今天浏览看到一篇文章<a href=\"https://itnext.io/handling-data-with-web-components-9e7e4a452e6e\">Handling data with Web Components</a>，大概是介绍了 Web Component 中数据交互的几种方式，有不少收获，特此总结记录一下</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">attribute VS property</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>首先是<code>attribute</code>和<code>property</code>，我们之前的代码中使用的是<code>attribute</code>来将<code>comments</code>传递到组件中，组件拿到后开始渲染数据。这种方案有一个弊端：<code>attribute</code>只接收字符串类型的数据，由于<code>comments</code>是一个数组类型，因此我们在传递之前需要使用<code>JSON.stringify</code>一下以及使用数据时需要<code>JSON.parse</code>一下，使用起来有一些不够方便</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 更新comments时需要处理成字符串</span>\nreply.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&quot;comments&quot;</span>, <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(comments));\n\n<span class=\"hljs-comment\">// 使用时需要解析成数组</span>\n<span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&quot;comments&quot;</span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">renderComments</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(newValue));\n}\n</code></pre>\n<p>那么有没有一种更好的方式来取代这种方式呢？有的，可以使用<code>property</code>来传递数据</p>\n<p><code>property</code>和<code>attribute</code>中文翻译过来意思很接近，但实际上是有不小的区别</p>\n<p>考虑下面这一行代码</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;Age:&quot;</span> /&gt;</span>\n</code></pre>\n<p><code>type</code>和<code>value</code>就是<code>input</code>标签的<em>attribute</em></p>\n<p>当浏览器编译完 HTML 代码，会生成与之对应的一个个 DOM 节点，每个 DOM 节点是一个对象，此时它又拥有很多<em>property</em>，例如<code>height</code>、<code>alt</code>、<code>checked</code>等</p>\n<p>对于一个 DOM 节点对象来讲，<code>property</code>就是这个对象上的属性；<code>attribute</code>是该对象对应的 HTML 标签元素上的属性</p>\n<p><code>property</code>和<code>attribute</code>大致上一一对应，但也有些特例，比如上述<code>input</code>标签的<code>value</code>。DOM 节点对象上的<code>value</code>会在输入之后发生变化，假如用户输入的是<code>John</code>，那么此时<code>Input.value</code>的返回值是<code>John</code>，而<code>Input.getAttribute(&#39;value&#39;)</code>的返回值则是<code>Name:</code>。此外还有其他的一些特例，感兴趣的可以去这里<a href=\"https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html/6004028#6004028\">What is the difference between properties and attributes in HTML</a>看看原文</p>\n<p>既然<code>property</code>是对象上的一个属性，那个肯定也可以给它赋一个对象类型的值！接下来就使用<code>property</code>来重构<code>Reply</code>组件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用 property 重构组件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>其实修改起来非常方便，代码改动还是比较少的</p>\n<p>首先是最下面给组件更新值的代码需要变动：不再使用<code>setAttribute</code>，而是直接设置<code>comments</code>属性</p>\n<pre><code class=\"hljs language-js\">reply.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&quot;comments&quot;</span>, <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(comments));\n\n<span class=\"hljs-comment\">// 修改为 ⬇️</span>\n\nreply.<span class=\"hljs-property\">comments</span> = comments;\n</code></pre>\n<p>其次，我们需要一对<code>getter</code>和<code>setter</code>来监听数据变化从而渲染新的值</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Reply</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 在这里，我们使用_comments来保存comments数据</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_comments</span> = [];\n  }\n  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">comments</span>() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_comments</span>;\n  }\n\n  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">comments</span>(<span class=\"hljs-params\">newValue</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_comments</span> = newValue;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">renderComments</span>(newValue);\n  }\n}\n</code></pre>\n<p>同时，删除监听<code>comments</code>属性相关的代码，因为我们这个已经通过<code>setter</code>实现数据监听了</p>\n<p>到这里，我们已经完成重构，实现组件的原本功能了</p>\n<p>不过我们要更新一步！</p>\n<p>既然我们都能传递数组进去了，那么在大胆点，可不可以传递一个函数呢？</p>\n<p>当然可以！！！</p>\n<p>我们可以直接在<code>reply</code>上挂载一个<code>onSubmitComment</code>函数，在<code>Reply</code>内部按钮点击时调用该回调，并将数据传递出来</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 直接在组件实例上挂载一个回调函数</span>\nreply.<span class=\"hljs-property\">onSubmitComment</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n  comments.<span class=\"hljs-title function_\">push</span>({\n    <span class=\"hljs-attr\">comment</span>: e,\n    nickName,\n    avatar,\n  });\n  reply.<span class=\"hljs-property\">comments</span> = comments;\n};\n\n<span class=\"hljs-comment\">// 组件内部，点击按钮时调用该函数</span>\nsubmitBtn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onSubmitComment</span>?.(commentInput.<span class=\"hljs-property\">value</span>);\n  commentInput.<span class=\"hljs-property\">value</span> = <span class=\"hljs-string\">&quot;&quot;</span>;\n});\n</code></pre>\n<p>芜湖～ 🎉</p>\n<p>完整代码<a href=\"https://github.com/mrrs878/web-components/blob/main/reply-property.html\">在这里</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>attribute</code>只能传递字符串数据，<code>property</code>由于是 DOM 对象上的属性，因此可以传递诸如对象、函数等复杂类型的数据。</p>\n<p>据此，我们可以使用<code>property</code>来将数据直接设置到组件实例上，组件内部新增一对<code>getter</code>和<code>setter</code>来接收数据，而且我们还可以直接在组件实例上挂载一个回调函数，在组件内部可以直接调用该回调。</p>\n<p>此外在处理类似于<code>disable</code>这种类型的<code>attribute</code>时也可以使用<code>property</code>+<code>getter</code>和<code>setter</code>来实现布尔类型属性的设置</p>\n<p>总之，<code>attribute</code>和<code>property</code>搭配使用将极大提高开发效率</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html/6004028#6004028\">What is the difference between properties and attributes in HTML</a></p>\n<p><a href=\"https://itnext.io/handling-data-with-web-components-9e7e4a452e6e\"># Handling data with Web Components</a></p>\n"},{"title":"Web Component-开发组件","tags":["微前端","WebComponent"],"categories":"微前端","description":"经过前两天的学习，已经基本入门 Web Component ，那么就开始实战，开发第一个组件\n\n不过在此之前，还要介绍另一个特性\n\n## slot\n\n> slot 由其 name 属性标识，并且允许您在模板中定义占位符，当在标记中使用该元素时，该占位符可以填充所需的任何 HTML 标记片段。--MDN\n\n比如我们的`template`是这样的：在需要的地方放置一个指定`name`属性的`slot","createDate":"2022-04-22 09:51:39","updateDate":"2022-04-23 20:40:37","body":"<p>经过前两天的学习，已经基本入门 Web Component ，那么就开始实战，开发第一个组件</p>\n<p>不过在此之前，还要介绍另一个特性</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">slot</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>slot 由其 name 属性标识，并且允许您在模板中定义占位符，当在标记中使用该元素时，该占位符可以填充所需的任何 HTML 标记片段。--MDN</p>\n</blockquote>\n<p>比如我们的<code>template</code>是这样的：在需要的地方放置一个指定<code>name</code>属性的<code>slot</code></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeaderTemplate&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;my-text&quot;</span>&gt;</span>My default text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n</code></pre>\n<p>在使用的时候，可以这样玩：给元素设置一个<code>slot</code>属性，值为<code>template</code>里<code>slot</code>的<code>name</code></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">m-header</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeader&quot;</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;hello&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">&quot;my-text&quot;</span>&gt;</span>Let&#x27;s have some different text!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">m-header</span>&gt;</span>\n</code></pre>\n<p>这样<code>span</code>会替换<code>template</code>里的<code>slot</code>。使用起来还是挺简单的</p>\n<p>特性介绍完毕，接下来进行今天的主题：组件开发实战</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Reply 组件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>本次来复制 Ant Design 的 <code>Card</code> 组件</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reply.png\" alt=\"reply\"></p>\n<p>先观察组件</p>\n<ol>\n<li><p>默认情况下有一个头像、输入框、提交按钮</p>\n</li>\n<li><p>在输入值点击提交按钮后，输入框上方会出现每一条的评论，包括评论人头像、昵称、评论的内容</p>\n</li>\n</ol>\n<p>针对上述功能，简单的实现思路（肯定有更好、更优雅的 😬）：</p>\n<ol>\n<li><p><code>m-reply</code>为受控组件，只负责提交、渲染数据，因此需要一个<code>comments</code>属性，指代待渲染的评论</p>\n</li>\n<li><p>在输入框输入数据后，点击提交，组件会向父组件发送一个消息（自定义事件），并将输入框的内容传递出去，因此父容器需要监听该事件，父组件在在处理好数据后更新<code>comments</code>，<code>m-reply</code>会自动渲染最新的数据</p>\n</li>\n<li><p>对于<code>comments</code>，该属性是一个数组，每一项包含三项数据：评论内容<code>comment</code>、评论人头像<code>avatar</code>、评论人昵称<code>nickName</code></p>\n</li>\n</ol>\n<p>在设计好思路后，开干！</p>\n<p>先完成提交评论的功能，在这里，我们选择自定义事件的方法来实现组件间通信，在点击提交按钮时触发一个自定义事件<code>submitComment</code>，并将评论内容传递出去</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">connectedCallback</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> submitBtn = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#submitBtn&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> commentInput = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#input&#x27;</span>);\n  submitBtn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// 注意1：触发事件的是this</span>\n    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">dispatchEvent</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CustomEvent</span>(<span class=\"hljs-string\">&#x27;submitComment&#x27;</span>, {\n      <span class=\"hljs-comment\">// 注意2：需要将数据放在detail属性上</span>\n      <span class=\"hljs-attr\">detail</span>: commentInput.<span class=\"hljs-property\">value</span>,\n    }));\n  });\n}\n</code></pre>\n<p>有两个注意点注意：</p>\n<ol>\n<li><p>触发事件的是<code>this</code>，即当前组件</p>\n</li>\n<li><p>数据需要放置在自定义事件的<code>detail</code>属性上，直接传递数据或者放在其他属性上会接收不到</p>\n</li>\n</ol>\n<p>🚩</p>\n<p>接着是父组件监听该事件并处理数据</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 注意1：需要先获取当前组件，然后添加监听</span>\n<span class=\"hljs-keyword\">const</span> reply = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#reply&quot;</span>);\nreply.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;submitComment&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n  comments.<span class=\"hljs-title function_\">push</span>({\n    <span class=\"hljs-attr\">comment</span>: e.<span class=\"hljs-property\">detail</span>,\n    nickName,\n    avatar,\n  });\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;comments&quot;</span>, comments);\n  <span class=\"hljs-comment\">// 注意2：设置的属性会自动转为字符串，导致组件无法解析数据，因此需要JSON.stringify</span>\n  reply.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&quot;comments&quot;</span>, <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(comments));\n});\n</code></pre>\n<p>同样有两个注意点：</p>\n<ol>\n<li><p>需要先获取当前组件，然后<strong>在当前组件上添加监听</strong></p>\n</li>\n<li><p>组件的属性会自动将设置的值转为字符串类型，因此需要先<code>JSON.stringify</code></p>\n</li>\n</ol>\n<p>最后，完成渲染每一条评论的代码</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title function_\">renderComments</span>(<span class=\"hljs-params\">comments</span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Comment</span> = (<span class=\"hljs-params\">{ avatar, nickName, comment }</span>) =&gt; (<span class=\"hljs-string\">`\n    ...\n  `</span>);\n  <span class=\"hljs-keyword\">const</span> commentsContainer = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#commentsContainer&#x27;</span>);\n  commentsContainer.<span class=\"hljs-property\">innerHTML</span> = comments.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, cur</span>) =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${acc}</span><span class=\"hljs-subst\">${Comment(cur)}</span>`</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>);\n}\n</code></pre>\n<p>该函数会在<code>attributeChangedCallback</code>监听到<code>comments</code>变化时调用，渲染出最新的评论</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">attributeChangedCallback</span>(<span class=\"hljs-params\">name, oldValue, newValue</span>) {\n  <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&#x27;comments&#x27;</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">renderComments</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(newValue));\n  }\n}\n</code></pre>\n<p>最后的效果</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reply.gif\" alt=\"web component reply\"></p>\n<p>🎉</p>\n<p>ps：该组件还有不少待完善的地方：提交按钮没有<code>loading</code>、没有校验输入值，数据安全性较低，存在 XSS 攻击的隐患、写死提交时间等，这些都会在后面慢慢完善</p>\n<p>完整代码<a href=\"https://github.com/mrrs878/web-components/blob/main/reply.html\">在这里</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Web Component 可用来开发跨框架组件，特性基本够用，使用起来也挺方便，只是开发体验有待提高，需要不停地使用原生 api 操作 dom；其次，使用自定义事件来实现组件间通信，代码量有点多（可能还有更好的方法我没找到 🤔）。</p>\n<p>总体来说，使用 Web Component 来开发一套组件库也是一种新的的思路，新的选择，值得尝试</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\">MDN-Web Components</a></p>\n<p><a href=\"https://github.com/mdn/web-components-examples\">MDN/web-components-examples</a></p>\n"},{"title":"检测自定义字体是否加载","tags":["web-font","反爬虫","安全"],"categories":"反爬虫","description":"我们可以通过加载自定义字体来实现字体反爬虫，那么如何检测字体是否正常加载呢？\n\n有几个维度的检测：\n\n1. 检测字体是否加载成功\n\n2. 检测内容是否正常渲染\n\n## 检测字体是否加载\n\n最简单的方法是使用浏览器提供的[FontFaceSet API](https://developer.mozilla.org/zh-CN/docs/Web/API/FontFaceSet)来检测，其中要用到的","createDate":"2022-04-18 20:52:22","updateDate":"2022-04-18 21:32:33","body":"<p>我们可以通过加载自定义字体来实现字体反爬虫，那么如何检测字体是否正常加载呢？</p>\n<p>有几个维度的检测：</p>\n<ol>\n<li><p>检测字体是否加载成功</p>\n</li>\n<li><p>检测内容是否正常渲染</p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">检测字体是否加载</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>最简单的方法是使用浏览器提供的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FontFaceSet\">FontFaceSet API</a>来检测，其中要用到的是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FontFaceSet/check\">FontFaceSet.check()</a></p>\n<blockquote>\n<p>FontFaceSet 的check()方法会返回是否在给定的字体列表中的所有字体已经被加载并可用。--MDN</p>\n</blockquote>\n<p>示例：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">fonts</span>.<span class=\"hljs-title function_\">check</span>(<span class=\"hljs-string\">&quot;12px courier&quot;</span>);\n\n<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">fonts</span>.<span class=\"hljs-title function_\">check</span>(<span class=\"hljs-string\">&quot;12px MyFont&quot;</span>，<span class=\"hljs-string\">&quot;ß&quot;</span>); <span class=\"hljs-comment\">// 如果字体“MyFont”具有ß字符，则返回true。</span>\n</code></pre>\n<p>但这个检测较为简陋，无法检测字体错误的情况（字体正常加载，但不是我们想要的，页面上显示乱码）</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">检测内容是否正常渲染</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>针对这种情况，我们可以使用一些比较骚的操作：</p>\n<ol>\n<li><p>创建一个span标签</p>\n</li>\n<li><p>给标签添加特定字符</p>\n</li>\n<li><p>重置字体样式</p>\n</li>\n<li><p>分别测量在添<code>font-family</code>前后标签大小</p>\n</li>\n<li><p>大小一致 ? 字体加载失败 : 字体加载成功</p>\n</li>\n</ol>\n<p>（这里要创建<code>span</code>标签，如果是<code>div</code>的话宽度默认占满，无法测量真实的大小）</p>\n<p>使用代码表示就是：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/**\n * 检测字体是否正常渲染\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} font 字体名称\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">Array&lt;string&gt;</span>} phrase 待匹配的字符\n * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-type\">boolean</span>} 是否存在该字体\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkFont</span>(<span class=\"hljs-params\">font, phrase</span>) {\n\n  <span class=\"hljs-comment\">/**\n   * 可以使用上述的 FontFaceSet API 作简要的判断，如果字体都不存在，那么肯定渲染失败\n   */</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">fonts</span>) {\n    <span class=\"hljs-keyword\">const</span> fonts = [...<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">fonts</span>];\n    <span class=\"hljs-keyword\">if</span> (fonts.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> f.<span class=\"hljs-property\">family</span> === font) === -<span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;font dose not exist&#x27;</span>);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n  }\n\n  <span class=\"hljs-comment\">// 创建一个空的 span 标签来填充内容</span>\n  <span class=\"hljs-keyword\">let</span> node = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&quot;span&quot;</span>);\n\n  <span class=\"hljs-comment\">// 因为可以同时检测多个字符，因此需要存储一下各个字符的大小</span>\n  <span class=\"hljs-keyword\">const</span> sizes = [];\n\n  <span class=\"hljs-comment\">/**\n   * 计算单个字符的尺寸\n   * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} char 待计算的字符\n   */</span>\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkChar</span>(<span class=\"hljs-params\">char</span>) {\n    <span class=\"hljs-comment\">// 重置字体</span>\n    node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontFamily</span> = <span class=\"hljs-string\">&quot;sans-serif&quot;</span>;\n    \n    <span class=\"hljs-comment\">// 填充内容</span>\n    node.<span class=\"hljs-property\">innerHTML</span> = char;\n\n    <span class=\"hljs-keyword\">const</span> size = {};\n\n    <span class=\"hljs-comment\">// 先保存未设置字体时的尺寸</span>\n    size.<span class=\"hljs-property\">withoutFont</span> = {\n      <span class=\"hljs-attr\">width</span>: node.<span class=\"hljs-property\">offsetWidth</span>,\n      <span class=\"hljs-attr\">height</span>: node.<span class=\"hljs-property\">offsetHeight</span>,\n    };\n\n    <span class=\"hljs-comment\">// 设置待检测的字体</span>\n    node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontFamily</span> = font + <span class=\"hljs-string\">&quot;, sans-serif&quot;</span>;\n\n    <span class=\"hljs-comment\">// 保存设置字体后的尺寸</span>\n    size.<span class=\"hljs-property\">withFont</span> = {\n      <span class=\"hljs-attr\">width</span>: node.<span class=\"hljs-property\">offsetWidth</span>,\n      <span class=\"hljs-attr\">height</span>: node.<span class=\"hljs-property\">offsetHeight</span>,\n    };\n\n    <span class=\"hljs-comment\">// 保存该字符设置字体/未设置字体时的尺寸，待字符计算完毕后统一计算</span>\n    sizes.<span class=\"hljs-title function_\">push</span>(size);\n  }\n\n  <span class=\"hljs-comment\">// 隐藏该 span 标签</span>\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">position</span> = <span class=\"hljs-string\">&quot;absolute&quot;</span>;\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">left</span> = <span class=\"hljs-string\">&quot;-10000px&quot;</span>;\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">top</span> = <span class=\"hljs-string\">&quot;-10000px&quot;</span>;\n\n  <span class=\"hljs-comment\">// 字体大小设置大些误差小（offsetWidth和offsetHeight会四舍五入）</span>\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontSize</span> = <span class=\"hljs-string\">&quot;300px&quot;</span>;\n\n  <span class=\"hljs-comment\">// 重置字体样式</span>\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontFamily</span> = <span class=\"hljs-string\">&quot;sans-serif&quot;</span>;\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontVariant</span> = <span class=\"hljs-string\">&quot;normal&quot;</span>;\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontStyle</span> = <span class=\"hljs-string\">&quot;normal&quot;</span>;\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontWeight</span> = <span class=\"hljs-string\">&quot;normal&quot;</span>;\n  node.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">letterSpacing</span> = <span class=\"hljs-string\">&quot;0&quot;</span>;\n\n  <span class=\"hljs-comment\">// 插入页面中才会有 offsetWidth 和 offsetHeight</span>\n  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(node);\n\n  <span class=\"hljs-comment\">// 计算每一个字符的尺寸</span>\n  phrase.<span class=\"hljs-title function_\">forEach</span>(checkChar);\n\n  <span class=\"hljs-comment\">/**\n   * 1. 当 offsetWidth 和 offsetHeight 均不相同时说明字体存在\n   * 2. 有一个字符的尺寸相同就说明字体有误\n   */</span>\n  <span class=\"hljs-keyword\">const</span> res =\n    node &amp;&amp;\n    sizes.<span class=\"hljs-title function_\">reduce</span>(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">acc, cur</span>) =&gt;</span>\n        acc &amp;&amp;\n        (cur.<span class=\"hljs-property\">withFont</span>.<span class=\"hljs-property\">width</span> !== cur.<span class=\"hljs-property\">withoutFont</span>.<span class=\"hljs-property\">width</span> ||\n          cur.<span class=\"hljs-property\">withFont</span>.<span class=\"hljs-property\">height</span> !== cur.<span class=\"hljs-property\">withoutFont</span>.<span class=\"hljs-property\">height</span>),\n      <span class=\"hljs-literal\">true</span>\n    );\n\n  <span class=\"hljs-comment\">// 做一些善后工作</span>\n  node.<span class=\"hljs-property\">parentNode</span>.<span class=\"hljs-title function_\">removeChild</span>(node);\n  node = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-keyword\">return</span> res;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">指数退避算法检测内容是否正常渲染</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>由于网络字体的加载需要时间，我们可通过简单地设置一个延时调用上述的<code>checkFont</code>，但可能有更好的方式来实现：<a href=\"https://cloud.google.com/memorystore/docs/redis/exponential-backoff?hl=zh-cn\">指数退避算法</a></p>\n<p>（自己理解）简单来讲就是在不超过所设置的时间范围内，以指数级超市时间定期重试</p>\n<p>示例：</p>\n<ol>\n<li><p>向服务端发送请求</p>\n</li>\n<li><p>失败？等待1秒后重试</p>\n</li>\n<li><p>失败？等待2秒后重试</p>\n</li>\n<li><p>失败？等待4秒后重试</p>\n</li>\n<li><p>失败？等待8秒后重试</p>\n</li>\n<li><p>以此类推，直到达到超时时间</p>\n</li>\n</ol>\n<p>在检测字体是否正常加载时，我们也可以使用该算法来更好地检测</p>\n<p>（也可使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet/loadingdone_event\">FontFaceSet: loadingdone event</a>来作为时间点检测）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">check</span> = (<span class=\"hljs-params\">phrase, options = { timeout: <span class=\"hljs-number\">8192</span> }</span>) =&gt; {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doCheck</span>(<span class=\"hljs-params\">t</span>) {\n    <span class=\"hljs-keyword\">let</span> tid = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-built_in\">clearTimeout</span>(tid);\n      tid = <span class=\"hljs-literal\">null</span>;\n      <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title function_\">checkFont</span>(<span class=\"hljs-string\">&quot;m-font&quot;</span>, phrase);\n      <span class=\"hljs-keyword\">if</span> (res) {\n        <span class=\"hljs-comment\">// success!</span>\n      }\n      <span class=\"hljs-keyword\">if</span> (!res &amp;&amp; (t &lt;&lt; <span class=\"hljs-number\">1</span> &lt; options.<span class=\"hljs-property\">timeout</span>)) {\n        <span class=\"hljs-title function_\">doCheck</span>(t &lt;&lt; <span class=\"hljs-number\">1</span>);\n      }\n      <span class=\"hljs-keyword\">if</span> (!res &amp;&amp; (t &lt;&lt; <span class=\"hljs-number\">1</span>) &gt;= options.<span class=\"hljs-property\">timeout</span>) {\n        <span class=\"hljs-comment\">// parse error!</span>\n      }\n    }, t);\n  }\n\n  <span class=\"hljs-comment\">// 我们可以以64ms为起始时间点</span>\n  <span class=\"hljs-title function_\">doCheck</span>(<span class=\"hljs-number\">2</span> &lt;&lt; <span class=\"hljs-number\">5</span>);\n};\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li><p>可使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FontFaceSet\">FontFaceSet API</a>来做简单的字体是否加载判断，但无法检测字体是否正常渲染</p>\n</li>\n<li><p>不同字体下，大概率各个字符的大小是不一样的，可依次来检测字体是否正常渲染</p>\n</li>\n</ol>\n<p>结束！</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FontFaceSet\">FontFaceSet API</a></p>\n<p><a href=\"https://stackoverflow.com/questions/65095157/how-can-i-detect-when-a-font-is-downloaded-via-csss-unicode-range-descriptor\">How can I detect when a font is downloaded via CSS&#39;s &quot;unicode-range&quot; descriptor? </a></p>\n<p><a href=\"https://cloud.google.com/memorystore/docs/redis/exponential-backoff?hl=zh-cn\">指数退避算法</a></p>\n"},{"title":"Git学习-修改历史commit","tags":["Git","rebase"],"categories":"Git","description":"有时候我们在提交代码时选错了git账号或者初始化仓库时没有配置git账号，恰好你也忽略掉了git的提示：\n\n``` shell\nYour name and email address were configured automatically based\non your username and hostname. Please check that they are accurate.\nYo","createDate":"2022-04-17 20:42:00","updateDate":"2022-04-17 21:35:28","body":"<p>有时候我们在提交代码时选错了git账号或者初始化仓库时没有配置git账号，恰好你也忽略掉了git的提示：</p>\n<pre><code class=\"hljs language-shell\">Your name and email address were configured automatically based\non your username and hostname. Please check that they are accurate.\nYou can suppress this message by setting them explicitly:\n\n    git config --global user.name &quot;Your Name&quot;\n    git config --global user.email you@example.com\n\nAfter doing this, you may fix the identity used for this commit with:\n\n    git commit --amend --reset-author\n</code></pre>\n<p>在这之后，你可能又进行了几次提交......</p>\n<p>某一时刻你突然意识到好像有什么不对劲🤔</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/shiqingbingbujiandan.jpeg\" alt=\"事情并不简单\"></p>\n<p>慌忙中执行了一下<code>git log</code></p>\n<pre><code class=\"hljs language-shell\">git log\n\ncommit b9955bf47f6437c2d72daf99e809737bbb79f2e1 (HEAD -&gt; master)\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:49:01 2022 +0800\n\n    fix: fix 1.1\n\ncommit ee0c985a1f158dcfe72b319727f401ae0742ed23\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:48:44 2022 +0800\n\n    fix: fix 1.0\n\ncommit f6bac54c00f6b869894e8214aae7b8aaacdec5d5\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:47:23 2022 +0800\n\n    feat: 1.0\n</code></pre>\n<p>寄了🙁</p>\n<p><code>Author</code>全是另一个，假设刚好你的团队是按照 bug数/代码量 来进行代码质量评估的，那现在岂不是自己给自己挖坑，强行拉低分母</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/wtmlaji.jpeg\" alt=\"我tm怎么这么垃圾\"></p>\n<p>稳住别慌，问题不大。git这么牛逼的东西怎么可能没想到我们这种傻瓜操作呢？接下来我会分几种不同的情况分别给出解决方案</p>\n<p>首先，感谢祖师爷！</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">只修改最后一次提交</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>假如你只是提交了一次就发现不对劲，那么你可以很简单地挽救回来，执行以下命令即可：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">注意邮箱需包括&lt;&gt;尖括号</span>\ngit commit --amend --author=&quot;NewAuthor &lt;NewEmail@address.com&gt;&quot;\n</code></pre>\n<p>或者在项目目录下配置好git账号后执行：</p>\n<pre><code class=\"hljs language-shell\">git commit --amend --reset-author\n</code></pre>\n<p>此时<code>git log</code>长这样</p>\n<pre><code class=\"hljs language-shell\">git log\n\ncommit 8b7c9afb16d25a89cb2d8c3d864e8422c088966c (HEAD -&gt; master)\nAuthor: mrrs878 &lt;mrrs878@foxmail.com&gt;\nDate:   Sun Apr 17 20:49:01 2022 +0800\n\n    fix: fix 1.1\n\ncommit ee0c985a1f158dcfe72b319727f401ae0742ed23\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:48:44 2022 +0800\n\n    fix: fix 1.0\n\ncommit f6bac54c00f6b869894e8214aae7b8aaacdec5d5\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:47:23 2022 +0800\n\n    feat: 1.0\n</code></pre>\n<p>好耶！🎉</p>\n<p>那假如你是提交了好几次才记起来了呢</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/cangtianna.png\" alt=\"苍天呐\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">修改历史提交</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>依旧稳住别慌，问题不大</p>\n<p>此时就要祭出<code>git rebase</code>了</p>\n<p>假如你的<code>git log</code>长这样</p>\n<pre><code class=\"hljs language-shell\">git log\n\ncommit 8b7c9afb16d25a89cb2d8c3d864e8422c088966c (HEAD -&gt; master)\nAuthor: mrrs878 &lt;mrrs878@foxmail.com&gt;\nDate:   Sun Apr 17 20:49:01 2022 +0800\n\n    fix: fix 1.1\n\ncommit ee0c985a1f158dcfe72b319727f401ae0742ed23\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:48:44 2022 +0800\n\n    fix: fix 1.0\n\ncommit f6bac54c00f6b869894e8214aae7b8aaacdec5d5\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:47:23 2022 +0800\n\n    feat: 1.0\n</code></pre>\n<p>（没错，我还是拿的上面举例子👆）</p>\n<p>假如你要修复<code>commit message</code>为<code>fix: fix 1.0</code>的这个<code>commit</code>，执行这个命令：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">-i 后面跟的是fix: fix1.0之前的一个commit的<span class=\"hljs-built_in\">hash</span></span>\ngit rebase -i f6bac54c00f6b869894e8214aae7b8aaacdec5d5\n</code></pre>\n<p>或者这样:</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">HEAD~2 表示后退两步</span>\ngit rebase -i HEAD~2\n</code></pre>\n<p>（推荐直接写hash值，当你的commit落后太多不好计算🤣）</p>\n<p>此时你的终端大概率可能会变成这样：</p>\n<pre><code class=\"hljs language-shell\">echo@echodeMBP  ~/Frontend/test/git-commit-change  ➦ ee0c985 &gt;R&gt; \n</code></pre>\n<p>这两个命令执行的结果都是一样的：</p>\n<pre><code class=\"hljs language-shell\">pick ee0c985 fix: fix 1.0\npick 8b7c9af fix: fix 1.1\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">Rebase f6bac54..8b7c9af onto f6bac54 (2 commands)</span>\n<span class=\"hljs-meta\">#</span><span class=\"language-bash\">\n<span class=\"hljs-comment\"># Commands:</span></span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">p, pick &lt;commit&gt; = use commit</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">r, reword &lt;commit&gt; = use commit, but edit the commit message</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">e, edit &lt;commit&gt; = use commit, but stop <span class=\"hljs-keyword\">for</span> amending</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">f, fixup [-C | -c] &lt;commit&gt; = like <span class=\"hljs-string\">&quot;squash&quot;</span> but keep only the previous</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">                   commit<span class=\"hljs-string\">&#x27;s log message, unless -C is used, in which case</span></span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\"><span class=\"hljs-string\">                   keep only this commit&#x27;</span>s message; -c is same as -C but</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">                   opens the editor</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">x, <span class=\"hljs-built_in\">exec</span> &lt;<span class=\"hljs-built_in\">command</span>&gt; = run <span class=\"hljs-built_in\">command</span> (the rest of the line) using shell</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">b, <span class=\"hljs-built_in\">break</span> = stop here (<span class=\"hljs-built_in\">continue</span> rebase later with <span class=\"hljs-string\">&#x27;git rebase --continue&#x27;</span>)</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">d, drop &lt;commit&gt; = remove commit</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">l, label &lt;label&gt; = label current HEAD with a name</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">t, reset &lt;label&gt; = reset HEAD to a label</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [<span class=\"hljs-comment\"># &lt;oneline&gt;]</span></span>\n</code></pre>\n<p>此时会进入命令行交互状态</p>\n<p>光标移动到选择你要修改的那个<code>commit</code>，并将前方的<code>pick</code>改为<code>edit</code>，然后<code>:</code> + <code>wq</code>保存退出</p>\n<p>此时终端会打印这个消息</p>\n<pre><code class=\"hljs language-shell\">Stopped at ee0c985...  fix: fix 1.0\nYou can amend the commit now, with\n\n  git commit --amend \n\nOnce you are satisfied with your changes, run\n\n  git rebase --continue\n</code></pre>\n<p>接着执行这个命令：</p>\n<pre><code class=\"hljs language-shell\">git commit --amend --reset-author\n</code></pre>\n<p>或者最上面那个：</p>\n<pre><code class=\"hljs language-shell\">git commit --amend --author=&quot;NewAuthor &lt;NewEmail@address.com&gt;&quot;\n</code></pre>\n<p>此时又会进入命令行交互界面，类似于执行<code>git commit -m &quot;xxxx&quot;</code>时。由于我们什么都没改，因此可以<code>:</code> + <code>wq</code>退出即可</p>\n<p>最后执行：</p>\n<pre><code class=\"hljs language-shell\">git rebase --continue\n</code></pre>\n<p>这时候再<code>git log</code>一下看看效果👀</p>\n<pre><code class=\"hljs language-shell\">commit 24ff96047eeb5531841b1d93242af992b6e54fcc (HEAD -&gt; master)\nAuthor: mrrs878 &lt;mrrs878@foxmail.com&gt;\nDate:   Sun Apr 17 20:49:01 2022 +0800\n\n    fix: fix 1.1\n\ncommit 40074be6073f9f76817665d6de078143dbf6739d\nAuthor: mrrs878 &lt;mrrs878@foxmail.com&gt;\nDate:   Sun Apr 17 21:14:52 2022 +0800\n\n    fix: fix 1.0\n\ncommit f6bac54c00f6b869894e8214aae7b8aaacdec5d5\nAuthor: echo &lt;echo@echodeMBP.lan&gt;\nDate:   Sun Apr 17 20:47:23 2022 +0800\n\n    feat: 1.0\n</code></pre>\n<p>好耶！成功了 🎉</p>\n<p>到这里可以解决大多数的人的问题了，那可能会有人问了，如果我一开始就是错的怎么办呢？</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/male.jpeg\" alt=\"麻了\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">修改第一次提交</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>依旧问题不大，将上面的</p>\n<pre><code class=\"hljs language-shell\">git rebase -i xxx\n</code></pre>\n<p>替换成</p>\n<pre><code class=\"hljs language-shell\">git rebase -i --root\n</code></pre>\n<p>这时你会发现可以修改第一次提交了</p>\n<pre><code class=\"hljs language-shell\">pick f6bac54 feat: 1.0\npick 40074be fix: fix 1.0\npick 24ff960 fix: fix 1.1\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">Rebase 24ff960 onto fba660d (3 commands)</span>\n</code></pre>\n<p>接下来的就不用我教你了吧</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>如果是最后一次提交错误，可以简单地执行<code>git commit --amend --author=&quot;NewAuthor &lt;NewEmail@address.com&gt;&quot;</code>或<code>git commit --amend --reset-author</code>来修改信息</p>\n</li>\n<li><p>如果是某一次提交错误，可以通过<code>git rebase -i xxx</code> + 第一种的命令来修改信息</p>\n</li>\n<li><p>如果要修改第一次提交，可以将第二种的<code>git rebase -i xxx</code>替换成<code>git rebase -i --root</code>来修改信息</p>\n</li>\n</ul>\n<p>结束！</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://www.jianshu.com/p/51f5cbb81cae\">Git修改提交历史中的作者及邮箱信息</a></p>\n<p><a href=\"https://stackoverflow.com/questions/2246208/change-first-commit-of-project-with-git\">Change first commit of project with Git?</a></p>\n"},{"title":"webpack学习-source-map","tags":["webpack优化","source-map"],"categories":"webpack","description":"## WHAT\n\n提供构建后代码到源代码的映射\n\n接收以下值：`[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map`\n\n- `source-map`: 外部\n\n  错误代码准确信息 和 源代码的错误位置\n\n- `inline-source-map`: 内联\n\n  只生成-个内联`source-map`\n\n  错误代码准确信","createDate":"2022-02-10 21:01:15","updateDate":"2022-02-10 21:56:03","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>提供构建后代码到源代码的映射</p>\n<p>接收以下值：<code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p>\n<ul>\n<li><p><code>source-map</code>: 外部</p>\n<p>错误代码准确信息 和 源代码的错误位置</p>\n</li>\n<li><p><code>inline-source-map</code>: 内联</p>\n<p>只生成-个内联<code>source-map</code></p>\n<p>错误代码准确信息 和 源代码的错误位置</p>\n</li>\n<li><p><code>hidden-source-map</code>: 外部</p>\n<p>错误代码准确信息</p>\n<p>不能追踪源代码错误，只能提示到构建后代码的错误位置</p>\n</li>\n<li><p><code>eval-source-map</code>: 内联</p>\n<p>每一个文件都生成对应的<code>source-map</code>, 都在<code>eval</code>函数内</p>\n<p>错误代码准确信息 和 源代码的错误位置</p>\n</li>\n<li><p><code>nosources-source-map</code>: 外部</p>\n<p>错误代码准确信息</p>\n</li>\n<li><p><code>cheap-source-map</code>: 外部</p>\n<p>错误代码准确信息 和 源代码的错误位置</p>\n<p>只能精确的行</p>\n</li>\n</ul>\n<p>内联和外部的区别: </p>\n<ol>\n<li>外部生成了文件，内联没有</li>\n<li>内联构建速度更快</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>方便调试、定位错误位置</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在配置文件<code>webpack.config.js</code>中添加<code>devtool</code>配置</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">&#x27;source-map&#x27;</span>,\n}\n</code></pre>\n<p>生产环境和开发环境有不同的配置</p>\n<p>开发环境: 速度快，调试更友好</p>\n<ul>\n<li><p>速度快(<code>eval</code> &gt; <code>inline</code> &gt; <code>cheap</code> &gt; <code>...</code>)</p>\n<ul>\n<li><p><code>eval-cheap-source-map</code></p>\n</li>\n<li><p><code>eval-source-map</code></p>\n</li>\n</ul>\n</li>\n<li><p>调试更友好</p>\n<ul>\n<li><p><code>source-map</code></p>\n</li>\n<li><p><code>cheap-module-source-map</code></p>\n</li>\n<li><p><code>cheap-source-map</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>  --&gt; <code>eval-source-map</code> / <code>eval-cheap-module-source-map</code></p>\n<p>生产环境: 源代码要不要隐藏? 调试要不要更友好?</p>\n"},{"title":"HTML相关-script标签中的async和defer","tags":["async","defer"],"categories":"HTML","description":"script标签用于加载脚本与执行脚本，直接使用script脚本的话，浏览器会按照顺序来加载并执行脚本，在脚本加载&执行的过程中，会阻塞后续的DOM渲染。好在script提供了两种方式来解决上述问题，async和defer，这两个属性使得script都不会阻塞DOM的渲染","createDate":"2022-01-24 20:25:33","updateDate":"2022-01-24 22:01:46","body":"<p><code>script</code>标签用于加载脚本与执行脚本，直接使用<code>script</code>脚本的话，浏览器会按照顺序来加载并执行脚本，在脚本加载&amp;执行的过程中，会阻塞后续的<code>DOM</code>渲染</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/defer-0.png\" alt=\"默认script加载顺序\"></p>\n<p>好在<code>script</code>提供了两种方式来解决上述问题，<code>async</code>和<code>defer</code>，这两个属性使得<code>script</code><strong>都不会阻塞DOM的渲染</strong>。\n但既然会存在两个属性，那么就说明，这两个属性之间肯定是有差异的。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">defer</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>用来通知浏览器该脚本将在文档完成解析后，触发<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event\">DOMContentLoaded</a>事件前执行</p>\n<p>有<code>defer</code>属性的脚本会阻止<code>DOMContentLoaded</code>事件，直到脚本被加载并且解析完成</p>\n<p>如果有多个设置了<code>defer</code>的<code>script</code>标签存在，则会按照顺序执行所有的<code>script</code></p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/defer-1.png\" alt=\"defer\"></p>\n<p>虽然<code>script3</code>加载快于<code>script2</code>，但由于<code>defer</code>存在，因此<code>script3</code>只能等<code>script2</code>执行完毕后再执行</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">async</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对于普通脚本，如果存在<code>async</code>属性，那么普通脚本会被并行请求，并尽快解析和执行</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/defer-2.png\" alt=\"async\"></p>\n<p><code>script3</code>加载快于<code>script2</code>，因此<code>script3</code>早于<code>script2</code>执行</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">图示</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/defer-async.png\" alt=\"defer-async图示\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">推荐的应用场景</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">defer</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>如果你的脚本代码依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件依赖。\n例：</p>\n<ul>\n<li>评论框</li>\n<li>代码语法高亮</li>\n<li>polyfill.js</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">async</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>如果你的脚本并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。\n例：</p>\n<ul>\n<li>百度统计</li>\n</ul>\n<p>如果不太能确定的话，用defer总是会比async稳定。。。</p>\n"},{"title":"Web Component-初识","tags":["微前端","WebComponent"],"categories":"微前端","description":"Web Component 有点东西\n\n## 什么是 Web Component\n\n> Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。--MDN\n\n简单来讲就是浏览器提供的原生**组件复用**方案。主要由三种技术方案实现：\n\n- Custom elements（自定义元素）。可以用来定义标签（元素）","createDate":"2022-04-20 21:16:56","updateDate":"2022-01-08 22:40:37","body":"<p>Web Component 有点东西</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是 Web Component</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的 web 应用中使用它们。--MDN</p>\n</blockquote>\n<p>简单来讲就是浏览器提供的原生<strong>组件复用</strong>方案。主要由三种技术方案实现：</p>\n<ul>\n<li><p>Custom elements（自定义元素）。可以用来定义标签（元素）</p>\n</li>\n<li><p>Shadow DOM（影子 DOM）。可以用来做样式隔离</p>\n</li>\n<li><p>HTML templates（HTML 模板）。可以用来定义一个基础的组件的dom结构</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">怎么用 Web Component</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>实现 Web Component 的<strong>最基本</strong>流程：</p>\n<ol>\n<li>使用<code>template</code>来定义一个<em>组件</em>的dom</li>\n</ol>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeader&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span>我是头部<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n</code></pre>\n<ol start=\"2\">\n<li>接着基于👆创建的<code>template</code>创建一个<em>类组件</em></li>\n</ol>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">super</span>();\n    <span class=\"hljs-comment\">// attachShadow() 方法来将一个 shadow root 附加到任何一个元素上，该方法返回一个 shadow root 。</span>\n    <span class=\"hljs-keyword\">const</span> shadowRoot = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">attachShadow</span>({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;closed&quot;</span> });\n    <span class=\"hljs-keyword\">const</span> template = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#mHeader&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> content = template.<span class=\"hljs-property\">content</span>.<span class=\"hljs-title function_\">cloneNode</span>(<span class=\"hljs-literal\">true</span>);\n    shadowRoot.<span class=\"hljs-title function_\">appendChild</span>(content);\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CustomElementRegistry/define\">CustomElementRegistry.define()</a> 方法注册自定义标签（元素）</li>\n</ol>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">/**\n * 注意，组件名是有限制的，MHeader、header1等都是不能用的，浏览器会报错\n * \n * web-component.html:33 Uncaught DOMException: Failed to execute &#x27;define&#x27; on &#x27;CustomElementRegistry&#x27;: &quot;header1&quot; is not a valid custom element name\n    at file:///Users/echo/Desktop/web-component.html:33:27\n */</span>\n<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">customElements</span>.<span class=\"hljs-title function_\">define</span>(<span class=\"hljs-string\">&quot;m-header&quot;</span>, <span class=\"hljs-title class_\">MHeader</span>);\n</code></pre>\n<ol start=\"4\">\n<li>使用该<em>组件</em></li>\n</ol>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- 使用的地方没有限制，自闭合也是可以的 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">m-header</span> /&gt;</span>\n</code></pre>\n<ol start=\"5\">\n<li>给组件加点样式</li>\n</ol>\n<p>可以直接在<code>template</code>里添加<code>style</code>标签，在里面可以添加只在该<code>template</code>下生效的样式</p>\n<p><code>:host</code>选择器可以选择组件的根元素</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeader&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n    <span class=\"hljs-selector-pseudo\">:host</span> {\n      <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">32px</span>;\n    }\n    <span class=\"hljs-selector-class\">.content</span> {\n      <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#f00</span>;\n    }\n  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span>我是头部<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n</code></pre>\n<ol start=\"6\">\n<li>加点属性试试 🤔</li>\n</ol>\n<p>需要在第 2 步在定义组件时用到<code>this.getAttribute</code>来获取传入的属性</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&quot;title&quot;</span>);\n    <span class=\"hljs-keyword\">if</span> (title) {\n      content.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#content&quot;</span>).<span class=\"hljs-property\">innerText</span> = title;\n    }\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n\n&lt;m-header title=<span class=\"hljs-string\">&quot;hello&quot;</span> /&gt;;\n</code></pre>\n<ol start=\"7\">\n<li>添加一些交互</li>\n</ol>\n<p>可以使用<code>querySelector</code>获取到<code>template</code>内部的一些元素来添加事件</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeader&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;login&quot;</span>&gt;</span>login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n</code></pre>\n<p>接着绑定事件</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// ...</span>\n    content.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#login&quot;</span>).<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;login&quot;</span>);\n    });\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<ol start=\"8\">\n<li>与父组件的通信</li>\n</ol>\n<p>通过<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent\">CustomEvent</a>来进行通信</p>\n<p>完整代码</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeader&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        <span class=\"hljs-selector-pseudo\">:host</span> {\n          <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">32px</span>;\n        }\n\n        <span class=\"hljs-selector-class\">.content</span> {\n          <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#f00</span>;\n        }\n      </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span>我是头部<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;login&quot;</span>&gt;</span>login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">m-header</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeader&quot;</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;hello&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n      <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n        <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n          <span class=\"hljs-variable language_\">super</span>();\n          <span class=\"hljs-keyword\">const</span> shadowRoot = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">attachShadow</span>({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;closed&quot;</span> });\n          <span class=\"hljs-keyword\">const</span> template = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#mHeader&quot;</span>);\n          <span class=\"hljs-keyword\">const</span> content = template.<span class=\"hljs-property\">content</span>.<span class=\"hljs-title function_\">cloneNode</span>(<span class=\"hljs-literal\">true</span>);\n          <span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&quot;title&quot;</span>);\n          <span class=\"hljs-keyword\">if</span> (title) {\n            content.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#content&quot;</span>).<span class=\"hljs-property\">innerText</span> = title;\n          }\n          <span class=\"hljs-keyword\">const</span> myEvent = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CustomEvent</span>(<span class=\"hljs-string\">&quot;login&quot;</span>, {\n            <span class=\"hljs-attr\">detail</span>: <span class=\"hljs-string\">&quot;这是子组件传过来的消息&quot;</span>,\n          });\n          <span class=\"hljs-keyword\">const</span> loginBtn = content.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#login&quot;</span>);\n          loginBtn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n            <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;login&quot;</span>);\n          });\n          shadowRoot.<span class=\"hljs-title function_\">appendChild</span>(content);\n        }\n      }\n\n      <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">customElements</span>.<span class=\"hljs-title function_\">define</span>(<span class=\"hljs-string\">&quot;m-header&quot;</span>, <span class=\"hljs-title class_\">MHeader</span>);\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>未完待续</p>\n<p>to be continued...</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基于 Web Component 的落地应用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>GitHub。GitHub是基于 Web Components 来开发的</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6309ad13b5b24d23aaf42e426923d4c4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>其次，Vue.js和微信小程序也是基于 Web Components 来做组件化的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Web Component 是浏览器提供的可以用于组件复用的方案，可以实现样式隔离，自定义属性、父子组件通信等功能，有不少应用/框架都是基于Web Component来进行开发的，前景广阔。但Web Component书写起来还是有些不够便捷，需要用到原生 dom 操作 api</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\">MDN-Web Components</a></p>\n<p><a href=\"https://github.com/mdn/web-components-examples\">MDN/web-components-examples</a></p>\n"},{"title":"Web Component-自定义元素的生命周期","tags":["微前端","WebComponent"],"categories":"微前端","description":"在之前大概了解了 Web Component，知道是怎么玩的，不过在查阅资料后发现之前有些错误\n\n## Node.cloneNode 的局限性\n\n在之前，使用的是`template.content.cloneNode(true);`来创建出一个新的节点，这种方法有一些局限性：会复制原节点的所有属性及属性值，其中就包括`id`，这样页面中就有多个`id`一样的元素了\n\n> 拷贝它所有的属性以及属性","createDate":"2022-04-21 21:06:23","updateDate":"2022-01-08 22:40:37","body":"<p>在之前大概了解了 Web Component，知道是怎么玩的，不过在查阅资料后发现之前有些错误</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Node.cloneNode 的局限性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在之前，使用的是<code>template.content.cloneNode(true);</code>来创建出一个新的节点，这种方法有一些局限性：会复制原节点的所有属性及属性值，其中就包括<code>id</code>，这样页面中就有多个<code>id</code>一样的元素了</p>\n<blockquote>\n<p>拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如 onclick=&quot;alert(1)&quot;),但不会拷贝那些使用 addEventListener()方法或者 node.onclick = fn 这种用 JavaScript 动态绑定的事件. --mdn</p>\n</blockquote>\n<p>MDN 同样也给出警告</p>\n<blockquote>\n<p>注意:为了防止一个文档中出现两个 ID 重复的元素,使用 cloneNode()方法克隆的节点在需要时应该指定另外一个与原 ID 值不同的 ID</p>\n</blockquote>\n<p>而且，生成的节点的<code>ownerDocument</code>仍然指向源节点的<code>ownerDocument</code></p>\n<p>既然这个方法有一定的局限性，那么有没有更好的方法呢？有的！</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">document.importNode</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/importNode\">document.importNode</a>将外部文档的一个节点拷贝一份,然后可以把这个拷贝的节点插入到当前文档中</p>\n</blockquote>\n<p>使用方式</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// deep参数表示是否递归复制源节点的所有子节点</span>\n<span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">importNode</span>(externalNode, deep);\n</code></pre>\n<p>注意：</p>\n<p>新生成节点的 <code>parentNode</code> 是 <code>null</code>，因为它还没有插入当前文档的文档树中，<strong>属于游离状态</strong>，因此无法对其进行操作</p>\n<p>这样的话我们就可以很方便的修改新节点的<code>ownerDocument</code>（在<code>append</code>之后自动指向当前<code>document</code>）</p>\n<p>试试新的 api 来创建<em>组件</em></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-variable language_\">super</span>();\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">importNode</span>(template.<span class=\"hljs-property\">content</span>, <span class=\"hljs-literal\">true</span>);\n      <span class=\"hljs-comment\">/**\n       * 注意，要先将节点插入到shadowRoot后才能对其进行操作\n       */</span>\n      shadowRoot.<span class=\"hljs-title function_\">appendChild</span>(content);\n      <span class=\"hljs-comment\">// ...</span>\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTMLElement 的生命周期</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在之前，我们都是将各种操作直接写在构造函数里，这显然有些臃肿，那么有没有一些办法可以将这些逻辑分发出去呢？有的！</p>\n<p>在<code>HTMLElement</code>内，有一些<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements#%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\">生命周期</a></p>\n<ul>\n<li><p><code>connectedCallback</code>，当 <code>custom element</code> 首次被插入文档 DOM 时被调用</p>\n</li>\n<li><p><code>disconnectedCallback</code>，当 <code>custom element</code>从文档 DOM 中删除时被调用</p>\n</li>\n<li><p><code>adoptedCallback</code>， 当 <code>custom element</code>被移动到新的文档时被调用</p>\n</li>\n<li><p><code>attributeChangedCallback</code>，当 <code>custom element</code>增加、删除、修改自身属性时被调用</p>\n</li>\n</ul>\n<p>据此，我们可以重构一下之前的<em>组件</em></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">observedAttributes</span>() {\n      <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">&quot;title&quot;</span>];\n    }\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-variable language_\">super</span>();\n      <span class=\"hljs-comment\">// 会自动向this上挂载一个shadowRoot</span>\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">attachShadow</span>({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;open&quot;</span> });\n      <span class=\"hljs-keyword\">const</span> template = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#mHeaderTemplate&quot;</span>);\n      <span class=\"hljs-comment\">// const content = template.content.cloneNode(true);</span>\n      <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">importNode</span>(template.<span class=\"hljs-property\">content</span>, <span class=\"hljs-literal\">true</span>);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">appendChild</span>(content);\n    }\n\n    <span class=\"hljs-title function_\">connectedCallback</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">const</span> loginBtn = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#login&quot;</span>);\n      loginBtn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;登录成功&quot;</span>);\n      });\n    }\n\n    <span class=\"hljs-title function_\">attributeChangedCallback</span>(<span class=\"hljs-params\">name, oldValue, newValue</span>) {\n      <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&quot;title&quot;</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#content&quot;</span>).<span class=\"hljs-property\">innerText</span> = newValue;\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>在这里，我们使用<code>attributeChangedCallback</code>来监听<em>组件</em>属性变化，在<code>title</code>属性发生变化时，更新元素的值。该回调会返回三个参数：</p>\n<ul>\n<li><p><code>name</code>，变化的属性的名字</p>\n</li>\n<li><p><code>oldValue</code>，属性之前的值</p>\n</li>\n<li><p><code>newValue</code>，要设置的值</p>\n</li>\n</ul>\n<p>（react 写的多了，有点梦回 vue 的感觉 🤔）</p>\n<p>此外有一点要注意：</p>\n<p>需要在<code>static get observedAttributes</code>函数里声明一下要监听的属性名</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">observedAttributes</span>() {\n  <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">&quot;title&quot;</span>];\n}\n</code></pre>\n<p>完整代码</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeaderTemplate&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        <span class=\"hljs-selector-pseudo\">:host</span> {\n          <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">32px</span>;\n        }\n\n        <span class=\"hljs-selector-class\">.content</span> {\n          <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#f00</span>;\n        }\n      </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span>我是头部<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;login&quot;</span>&gt;</span>login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">m-header</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;mHeader&quot;</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;hello&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n      <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MHeader</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">HTMLElement</span> {\n        <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">observedAttributes</span>() {\n          <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">&quot;title&quot;</span>];\n        }\n        <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n          <span class=\"hljs-variable language_\">super</span>();\n          <span class=\"hljs-comment\">// 会自动向this上挂载一个shadowRoot</span>\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">attachShadow</span>({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;open&quot;</span> });\n          <span class=\"hljs-keyword\">const</span> template = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#mHeaderTemplate&quot;</span>);\n          <span class=\"hljs-comment\">// const content = template.content.cloneNode(true);</span>\n          <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">importNode</span>(template.<span class=\"hljs-property\">content</span>, <span class=\"hljs-literal\">true</span>);\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">appendChild</span>(content);\n        }\n\n        <span class=\"hljs-title function_\">connectedCallback</span>(<span class=\"hljs-params\"></span>) {\n          <span class=\"hljs-keyword\">const</span> loginBtn = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#login&quot;</span>);\n          loginBtn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&quot;title&quot;</span>, <span class=\"hljs-string\">&quot;登录成功&quot;</span>);\n          });\n        }\n\n        <span class=\"hljs-title function_\">attributeChangedCallback</span>(<span class=\"hljs-params\">name, oldValue, newValue</span>) {\n          <span class=\"hljs-keyword\">if</span> (name === <span class=\"hljs-string\">&quot;title&quot;</span>) {\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#content&quot;</span>).<span class=\"hljs-property\">innerText</span> = newValue;\n          }\n        }\n      }\n\n      <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">customElements</span>.<span class=\"hljs-title function_\">define</span>(<span class=\"hljs-string\">&quot;m-header&quot;</span>, <span class=\"hljs-title class_\">MHeader</span>);\n\n      <span class=\"hljs-keyword\">const</span> mHeader = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#mHeader&quot;</span>);\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>由于<code>Node.cloneNode</code>仍默认保留新节点的<code>ownerDocument</code>，因此使用起来没法放开，有些需要注意的地方。不过我们可以使用<code>document.importNode</code>来实现相同的功能，该API创建的节点处于游离状态，在进行<code>append</code>操作后会自动修正<code>ownerDocument</code>的指向</p>\n<p>通过使用<code>custom elements</code>提供的生命周期函数，我们可以很方便地监听属性变化来做一些逻辑，但还是那句话书写起来有些不够便捷，需要用到原生 dom 操作 api，没准 jQuery 会借着 Web Components 再重新活跃起来</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\">MDN-Web Components</a></p>\n<p><a href=\"https://github.com/mdn/web-components-examples\">MDN/web-components-examples</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/cloneNode\">Node.cloneNode(deep)</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/importNode\">document.importNode</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements#%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\">使用 custom elements</a></p>\n"},{"title":"生成自定义（unicode、字形）字体","tags":["反爬虫","字体","安全"],"categories":"反爬虫","description":"要想实现字体反爬虫，首先要有字体，那么如何制作字体呢\n\n## 原理\n\n一套字体是由多个字符组成，每个字符都有对应的字形，字形是由一系列`command`（类似svg）\n\n![制作字体](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b9fa3afe7d47dca17108785cc87800~tplv-k3u1fbpfcp-zoom-1.","createDate":"2022-01-08 09:38:17","updateDate":"2022-01-08 18:05:37","body":"<p>要想实现字体反爬虫，首先要有字体，那么如何制作字体呢</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一套字体是由多个字符组成，每个字符都有对应的字形，字形是由一系列<code>command</code>（类似svg）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b9fa3afe7d47dca17108785cc87800~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"制作字体\"></p>\n<p>我们要做的就是基于源字体，提取出特定的字符，调整该字符对应的字形（调整<code>command</code>的参数），最后导出一套新的字体</p>\n<p>变换规则：根据<code>strength</code>和<code>distance</code>调整<code>glyph.path.command</code>的坐标点</p>\n<p>基于<a href=\"https://opentype.js.org\">opentype.js</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">代码实现</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> opentype <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;opentype.js&#x27;</span>; \n<span class=\"hljs-keyword\">import</span> { clone } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;ramda&#x27;</span>\n<span class=\"hljs-keyword\">import</span> fs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;fs&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Chance</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;chance&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> snapX = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">const</span> snapY = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">const</span> snapDistance = <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// 随机数生成器</span>\n<span class=\"hljs-keyword\">const</span> chance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chance</span>();\n\n<span class=\"hljs-comment\">// 调整path点</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">snap</span>(<span class=\"hljs-params\">v, distance, strength</span>) {\n    <span class=\"hljs-keyword\">return</span> (v * (<span class=\"hljs-number\">1.0</span> - strength)) + (strength * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">round</span>(v / distance) * distance);\n}\n\n<span class=\"hljs-comment\">// 对每个字符的字形做调整</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doSnap</span>(<span class=\"hljs-params\">sourcePath, options</span>) {\n    <span class=\"hljs-keyword\">const</span> { snapStrength, snapDistance, snapPathCmdCnt } = options;\n    <span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-title function_\">clone</span>(sourcePath);\n    <span class=\"hljs-keyword\">if</span> (!path?.<span class=\"hljs-property\">commands</span>) <span class=\"hljs-keyword\">return</span> path;\n\n    <span class=\"hljs-keyword\">const</span> cursorLeft = chance.<span class=\"hljs-title function_\">integer</span>({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">max</span>: path.<span class=\"hljs-property\">commands</span>.<span class=\"hljs-property\">length</span> - snapPathCmdCnt });\n    <span class=\"hljs-keyword\">const</span> cursorRight = chance.<span class=\"hljs-title function_\">integer</span>({ <span class=\"hljs-attr\">min</span>: cursorLeft, <span class=\"hljs-attr\">max</span>: cursorLeft + snapPathCmdCnt });\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = cursorLeft; i &lt; cursorRight; i += <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">const</span> cmd = path?.<span class=\"hljs-property\">commands</span>?.[i];\n        <span class=\"hljs-keyword\">if</span> (cmd.<span class=\"hljs-property\">type</span> !== <span class=\"hljs-string\">&#x27;Z&#x27;</span>) {\n            cmd.<span class=\"hljs-property\">x</span> = <span class=\"hljs-title function_\">snap</span>(cmd.<span class=\"hljs-property\">x</span> + snapX, snapDistance, snapStrength) - snapX;\n            cmd.<span class=\"hljs-property\">y</span> = <span class=\"hljs-title function_\">snap</span>(cmd.<span class=\"hljs-property\">y</span> + snapY, snapDistance, snapStrength) - snapY;\n        }\n        <span class=\"hljs-keyword\">if</span> (cmd.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&#x27;Q&#x27;</span> || cmd.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&#x27;C&#x27;</span>) {\n            cmd.<span class=\"hljs-property\">x1</span> = <span class=\"hljs-title function_\">snap</span>(cmd.<span class=\"hljs-property\">x1</span> + snapX, snapDistance, snapStrength) - snapX;\n            cmd.<span class=\"hljs-property\">y1</span> = <span class=\"hljs-title function_\">snap</span>(cmd.<span class=\"hljs-property\">y1</span> + snapY, snapDistance, snapStrength) - snapY;\n        }\n        <span class=\"hljs-keyword\">if</span> (cmd.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&#x27;C&#x27;</span>) {\n            cmd.<span class=\"hljs-property\">x2</span> = <span class=\"hljs-title function_\">snap</span>(cmd.<span class=\"hljs-property\">x2</span> + snapX, snapDistance, snapStrength) - snapX;\n            cmd.<span class=\"hljs-property\">y2</span> = <span class=\"hljs-title function_\">snap</span>(cmd.<span class=\"hljs-property\">y2</span> + snapY, snapDistance, snapStrength) - snapY;\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> path;\n}\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@description</span>: TTF变码，基于一种字体，生成另一种新字体\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} sourceFontPath 源字体\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string</span>} words 要转换的字\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">string|Array&lt;string&gt;</span>} newFontPath 转换后的字体\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">SnapConfiguration</span>} snapConfig 字形变化配置\n * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-type\">object</span>} 转换规则(映射表)\n */</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">generateFont</span>(<span class=\"hljs-params\">sourceFontPath, words, newFontPath, snapConfig</span>) {\n    <span class=\"hljs-comment\">// 保存字符和unicode的映射关系</span>\n    <span class=\"hljs-keyword\">const</span> result = {};\n    <span class=\"hljs-keyword\">const</span> sourceFont = opentype.<span class=\"hljs-title function_\">loadSync</span>(sourceFontPath);\n\n    <span class=\"hljs-keyword\">const</span> notdefGlyph = <span class=\"hljs-keyword\">new</span> opentype.<span class=\"hljs-title class_\">Glyph</span>({\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;.notdef&#x27;</span>,\n        <span class=\"hljs-attr\">advanceWidth</span>: sourceFont.<span class=\"hljs-title function_\">getAdvanceWidth</span>(<span class=\"hljs-string\">&#x27;.&#x27;</span>),\n        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-keyword\">new</span> opentype.<span class=\"hljs-title class_\">Path</span>(),\n    });\n\n    <span class=\"hljs-keyword\">const</span> snapStrength = chance.<span class=\"hljs-title function_\">integer</span>({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10</span> });\n\n    <span class=\"hljs-comment\">// 生成新的字形</span>\n    <span class=\"hljs-comment\">// sourceFont.stringToGlyphs(words) 提取出要转换的字符的字形</span>\n    <span class=\"hljs-keyword\">const</span> subGlyphs = sourceFont.<span class=\"hljs-title function_\">stringToGlyphs</span>(words).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">glyph, index</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">const</span> word = words[index];\n        <span class=\"hljs-comment\">// 针对反爬虫需求，每个字符需要生成新的unicode</span>\n        <span class=\"hljs-keyword\">const</span> unicode = chance.<span class=\"hljs-title function_\">integer</span>({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">255</span>, <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">65535</span> });\n        <span class=\"hljs-keyword\">const</span> { consistent, isSnap, snapPathCmdCnt } = snapConfig;\n        <span class=\"hljs-keyword\">let</span> path = glyph.<span class=\"hljs-property\">path</span>;\n        \n        <span class=\"hljs-keyword\">if</span> (isSnap) {\n            <span class=\"hljs-comment\">// 每个字符共用一套字形变换配置or相互独立</span>\n            <span class=\"hljs-keyword\">const</span> snapConfiguration = consistent\n                ?   {   \n                        snapDistance,\n                        snapStrength,\n                        snapPathCmdCnt,\n                    }\n                :   { \n                        snapPathCmdCnt,\n                        snapDistance,\n                        <span class=\"hljs-attr\">snapStrength</span>: chance.<span class=\"hljs-title function_\">integer</span>({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10</span> }),\n                    }\n            path = <span class=\"hljs-title function_\">doSnap</span>(glyph.<span class=\"hljs-property\">path</span>, snapConfiguration);\n        }\n        \n        <span class=\"hljs-comment\">// 保存映射关系</span>\n        result[word] = <span class=\"hljs-string\">`&amp;#x<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">Number</span>(unicode).toString(<span class=\"hljs-number\">16</span>)}</span>;`</span>;\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> opentype.<span class=\"hljs-title class_\">Glyph</span>({\n            <span class=\"hljs-attr\">index</span>: index + <span class=\"hljs-number\">1</span>,\n            unicode,\n            <span class=\"hljs-attr\">name</span>: word,\n            path,\n            <span class=\"hljs-attr\">advanceWidth</span>: glyph.<span class=\"hljs-property\">advanceWidth</span>,\n        });\n    });\n\n    <span class=\"hljs-keyword\">const</span> { unitsPerEm, ascender, descender } = sourceFont;\n\n    <span class=\"hljs-comment\">// 生成新的字体文件</span>\n    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">new</span> opentype.<span class=\"hljs-title class_\">Font</span>({\n        <span class=\"hljs-attr\">familyName</span>: <span class=\"hljs-string\">&#x27;yqn-font&#x27;</span>,\n        <span class=\"hljs-attr\">styleName</span>: <span class=\"hljs-string\">&#x27;Medium&#x27;</span>,\n        unitsPerEm,\n        ascender,\n        descender,\n        <span class=\"hljs-attr\">glyphs</span>: [notdefGlyph, ...subGlyphs],\n    });\n\n    <span class=\"hljs-comment\">// 可能需要保存多份字体文件（不同格式，做浏览器兼容）</span>\n    <span class=\"hljs-keyword\">const</span> outputPath = [newFontPath].<span class=\"hljs-title function_\">flat</span>();\n    outputPath?.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">path</span>) =&gt;</span> {\n        res.<span class=\"hljs-title function_\">download</span>(path);\n    });\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">// 输出映射关系到单独的文件中</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">saveRule</span>(<span class=\"hljs-params\">rule</span>) {\n    fs.<span class=\"hljs-title function_\">writeFileSync</span>(<span class=\"hljs-string\">&#x27;rule.json&#x27;</span>, <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(rule, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">4</span>));\n}\n\n<span class=\"hljs-keyword\">export</span> { generateFont, saveRule };\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注意点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>有一些需要注意的地方</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">unicode值</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>一些资料中表述：在采用NCR时，数字取值为8192-8303（十六进制为<code>2000</code>-<code>206F</code>），但实测255-65535均可以使用</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">无法复用旧的Glyph</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>在上述代码中</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> opentype.<span class=\"hljs-title class_\">Glyph</span>({\n    <span class=\"hljs-attr\">index</span>: index + <span class=\"hljs-number\">1</span>,\n    unicode,\n    <span class=\"hljs-attr\">name</span>: word,\n    path,\n    <span class=\"hljs-attr\">advanceWidth</span>: glyph.<span class=\"hljs-property\">advanceWidth</span>,\n});\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>需要新生成一个<code>Glyph</code>，只能复用老的<code>Glyph</code>的一些参数</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>字体都是由一个个字符组成，每个字符都有自己对应的字形参数。我们可以基于源字体，提取出特定的字符，调整该字符对应的字形，最后生成一套新的字体</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://opentype.js.org/\">opentype</a></p>\n"},{"title":"CSS学习-clip path","tags":["clip:path()"],"categories":"CSS","description":"## WHAT\n\n一个CSS属性\n\n使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏\n\n起初是SVG里的，后挪用到CSS\n\n``` css\n/* Keyword values */\nclip-path: none;\n\n/* <clip-source> values */\nclip-path: url(resources.svg);\n\n/* <basic-shape> value","createDate":"2021-12-30 13:52:25","updateDate":"2021-12-30 21:53:08","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一个CSS属性</p>\n<p>使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏</p>\n<p>起初是SVG里的，后挪用到CSS</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* Keyword values */</span>\n<span class=\"hljs-attribute\">clip-path</span>: none;\n\n<span class=\"hljs-comment\">/* &lt;clip-source&gt; values */</span>\n<span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">resources.svg</span>);\n\n<span class=\"hljs-comment\">/* &lt;basic-shape&gt; values */</span>\n<span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">inset</span>(<span class=\"hljs-number\">100px</span> <span class=\"hljs-number\">50px</span>);\n<span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">circle</span>(<span class=\"hljs-number\">50px</span> at <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">100px</span>);\n<span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(<span class=\"hljs-number\">50%</span> <span class=\"hljs-number\">0%</span>, <span class=\"hljs-number\">100%</span> <span class=\"hljs-number\">50%</span>, <span class=\"hljs-number\">50%</span> <span class=\"hljs-number\">100%</span>, <span class=\"hljs-number\">0%</span> <span class=\"hljs-number\">50%</span>);\n<span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">path</span>(<span class=\"hljs-string\">&#x27;M0.5,1 C0.5,1,0,0.7,0,0.3 A0.25,0.25,1,1,1,0.5,0.3 A0.25,0.25,1,1,1,1,0.3 C1,0.7,0.5,1,0.5,1 Z&#x27;</span>);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>方便创建一些不规则的图形，如切角、内切圆角、箭头等</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>DEMO使用<code>clip-path: path()</code>来创建</p>\n<p><code>path</code>类似于svg的<code>path</code>标签，使用一系列 命令+参数 的序列来创建形状</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/path.png\" alt=\"SVG-PATH\"></p>\n<p><a href=\"https://yqnn.github.io/svg-path-editor/\">可视化编辑</a></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n    <span class=\"hljs-selector-class\">.img</span> {\n      <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">140px</span>;\n      <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">280px</span>;\n      <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">linear-gradient</span>(<span class=\"hljs-number\">90deg</span>, <span class=\"hljs-number\">#be0f2d</span>, <span class=\"hljs-number\">#cb364a</span>, <span class=\"hljs-number\">#f5abb7</span>);\n    }\n\n    <span class=\"hljs-selector-class\">.popover</span> {\n      <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">polygon</span>(<span class=\"hljs-number\">0%</span> <span class=\"hljs-number\">0%</span>, <span class=\"hljs-number\">100%</span> <span class=\"hljs-number\">0%</span>, <span class=\"hljs-number\">100%</span> <span class=\"hljs-number\">75%</span>, <span class=\"hljs-number\">75%</span> <span class=\"hljs-number\">75%</span>, <span class=\"hljs-number\">50%</span> <span class=\"hljs-number\">100%</span>, <span class=\"hljs-number\">25%</span> <span class=\"hljs-number\">75%</span>, <span class=\"hljs-number\">0%</span> <span class=\"hljs-number\">75%</span>);\n    }\n\n    <span class=\"hljs-selector-class\">.message</span> {\n      <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">path</span>(<span class=\"hljs-string\">&#x27;M 20 0 L 260 0 A 20 20 90 0 1 280 20 L 280 100 A 20 20 90 0 1 260 120 L 220 120 L 240 140 L 180 120 L 20 120 A 20 20 90 0 1 0 100 L 0 20 A 20 20 90 0 1 20 0&#x27;</span>);\n    }\n\n    <span class=\"hljs-selector-class\">.coupon</span> {\n      <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">path</span>(<span class=\"hljs-string\">&#x27;M 20 0 L 260 0 A 20 20 0 0 0 280 20 L 280 120 A 20 20 0 0 0 260 140 L 20 140 A 20 20 0 0 0 0 120 L 0 20 A 20 20 0 0 0 20 0&#x27;</span>);\n    }\n\n    <span class=\"hljs-selector-class\">.notching</span> {\n      <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">path</span>(<span class=\"hljs-string\">&#x27;M 40 0 L 280 0 L 280 100 L 240 140 L 0 140 L 0 40 L 40 0&#x27;</span>);\n    }\n\n    <span class=\"hljs-selector-class\">.outside-circle</span> {\n      <span class=\"hljs-attribute\">clip-path</span>: <span class=\"hljs-built_in\">path</span>(<span class=\"hljs-string\">&#x27;M 40 0 L 240 0 A 20 20 90 0 1 260 20 L 260 120 A 20 20 90 0 0 280 140 L 0 140 A 20 20 90 0 0 20 120 L 20 20 A 20 20 90 0 1 40 0&#x27;</span>);\n    }\n  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://bennettfeely.com/clippy/pics/pittsburgh.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;img popover&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://bennettfeely.com/clippy/pics/pittsburgh.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;img message&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://bennettfeely.com/clippy/pics/pittsburgh.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;img coupon&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://bennettfeely.com/clippy/pics/pittsburgh.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;img notching&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://bennettfeely.com/clippy/pics/pittsburgh.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;img outside-circle&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/clip-path.png\" alt=\"clip-path\"></p>\n"},{"title":"React.js学习-hooks原理简析","tags":["hooks"],"categories":"React.js","description":"让我们从实现两个简单的hook入手来探究hooks原理\n\n> [示例代码](https://github.com/mrrs878/review)\n\n## useState\n\n`useState`用于在函数式组件中声明并保存一个变量，`useState`的使用是这样的：\n\n``` ts\nconst [count, setCount] = useState(0);\n\nconsole.log(cou","createDate":"2021-12-23 11:25:20","updateDate":"2021-12-23 21:56:54","body":"<p>让我们从实现两个简单的hook入手来探究hooks原理</p>\n<blockquote>\n<p><a href=\"https://github.com/mrrs878/review\">示例代码</a></p>\n</blockquote>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useState</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>useState</code>用于在函数式组件中声明并保存一个变量，<code>useState</code>的使用是这样的：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count);\n\n<span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-title function_\">setCount</span>((pre) + pre + <span class=\"hljs-number\">1</span>);\n</code></pre>\n<p>有几个特点：</p>\n<ol>\n<li>接受一个函数或值作为变量的初始值</li>\n<li>返回一个数组(元组)，第一个参数是变量值，第二个参数是一个函数，可用来更新变量值</li>\n<li>返回的更新函数支持传入一个函数，改函数的参数是当前的变量值</li>\n</ol>\n<p>据此，可以实现一版简单的<code>useState</code></p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-params\">initialState</span>) {\n    <span class=\"hljs-comment\">// 没有考虑传入一个函数的情况</span>\n    <span class=\"hljs-keyword\">let</span> state = initialState;\n    \n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">setState</span> = (<span class=\"hljs-params\">newState</span>) =&gt; {\n        state = newState;\n    }\n    \n    <span class=\"hljs-keyword\">return</span> [state, setState];\n}\n</code></pre>\n<p>但在使用的时候会发现，当调用<code>setCount</code>的时候，<code>count</code> 并不会变化，这是因为我们没有存储<code>state</code>，导致每次渲染组件的时候，<code>state</code>都会重新设置</p>\n<p>为解决这个问题，会自然而然地想到，把<code>state</code>提取出来，存在<code>useState</code>外面：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">let</span> _state;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-params\">initialState</span>) {\n  _state = _state || initialState;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">setState</span> = (<span class=\"hljs-params\">newState</span>) =&gt; {\n    _state = <span class=\"hljs-keyword\">typeof</span> newState === <span class=\"hljs-string\">&#x27;function&#x27;</span> ? <span class=\"hljs-title function_\">newState</span>(_state) : newState;\n  };\n\n  <span class=\"hljs-keyword\">return</span> [\n    _state,\n    setState,\n  ];\n}\n</code></pre>\n<p>测试用例</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { renderHook, act } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/react-hooks&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useState_simple&#x27;</span>;\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;useState_simple&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;useState should be defined&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(useState).<span class=\"hljs-title function_\">toBeDefined</span>();\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;When the update function is called, the data is updated normally&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { result, rerender } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>));\n\n    <span class=\"hljs-keyword\">const</span> [, setState] = result.<span class=\"hljs-property\">current</span>;\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-number\">2</span>);\n      <span class=\"hljs-title function_\">rerender</span>();\n    });\n\n    <span class=\"hljs-keyword\">const</span> [state] = result.<span class=\"hljs-property\">current</span>;\n\n    <span class=\"hljs-title function_\">expect</span>(state).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">2</span>);\n  });\n});\n</code></pre>\n<p>至此，实现了一个简单的<code>useState</code>，后边会进一步完善</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useEffect</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>useEffect</code>的使用是这样的</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// do something</span>\n});\n\n<span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// do something</span>\n}, [])\n\n<span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// do something</span>\n}, [deps])\n</code></pre>\n<p><code>useEffect</code>的使用有几个特点：</p>\n<ol>\n<li>有两个参数<code>callback</code>和<code>deps</code>数组</li>\n<li>如果<code>deps</code>不存在，那么<code>callback</code>在每次<code>render</code>时都会执行</li>\n<li>如果<code>deps</code>存在，只有当它发生了变化，<code>callback</code>才会执行</li>\n</ol>\n<p>根据使用方法和特点，可以做一个简单地实现：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">let</span> _deps;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-params\">callback, deps</span>) {\n  <span class=\"hljs-keyword\">const</span> hasNoDeps = !deps;\n  <span class=\"hljs-keyword\">const</span> hasChangeDeps = _deps\n    ? !deps?.<span class=\"hljs-title function_\">every</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">dep, index</span>) =&gt;</span> _deps[index] === dep)\n    : <span class=\"hljs-literal\">true</span>;\n\n  <span class=\"hljs-keyword\">if</span> (hasNoDeps || hasChangeDeps) {\n    <span class=\"hljs-title function_\">callback</span>();\n    _deps = deps;\n  }\n}\n</code></pre>\n<p>测试用例</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { renderHook, act } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/react-hooks&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useEffect_simple&#x27;</span>;\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;useEffect_simple&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;useEffect should be defined&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(useEffect).<span class=\"hljs-title function_\">toBeDefined</span>();\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;When deps is empty, every rendering callback should be executed&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> callback = jest.<span class=\"hljs-title function_\">fn</span>();\n    <span class=\"hljs-keyword\">const</span> { rerender } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">useEffect</span>(callback));\n\n    <span class=\"hljs-title function_\">expect</span>(callback).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-title function_\">rerender</span>();\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(callback).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;When deps is an empty array, render multiple times but callback should only be called once&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> callback = jest.<span class=\"hljs-title function_\">fn</span>();\n    <span class=\"hljs-keyword\">const</span> { rerender } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">useEffect</span>(callback, []));\n\n    <span class=\"hljs-title function_\">expect</span>(callback).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-title function_\">rerender</span>();\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(callback).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;When deps is changed, callback should be called&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> callback = jest.<span class=\"hljs-title function_\">fn</span>();\n    <span class=\"hljs-keyword\">const</span> { rerender } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ name }</span>) =&gt;</span> <span class=\"hljs-title function_\">useEffect</span>(callback, [name]), {\n      <span class=\"hljs-attr\">initialProps</span>: {\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span>,\n      },\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(callback).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-title function_\">rerender</span>({\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;jerry&#x27;</span>,\n      });\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(callback).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n  });\n});\n</code></pre>\n<p>到这里，我们又实现了一个可以工作的丐版<code>useEffect</code>，hook貌似没有那么难</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">优化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>我们上边实现的两个简单的hook存在一个致命缺点，在一个组件内只能使用一次，对此，我们可以将<code>_state</code>和<code>_deps</code>保存至一个全局数组<code>memoizedState </code>中，并用一个变量存储当前<code>memoizedState</code>下标</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">let</span> memoizedStates = []; <span class=\"hljs-comment\">// hooks存放在这个数组</span>\n<span class=\"hljs-keyword\">let</span> cursor = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 当前memoizedState下标</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-params\">initialState</span>) {\n  memoizedStates[cursor] = memoizedStates[cursor] || initialState;\n\n  <span class=\"hljs-keyword\">const</span> currentCursor = cursor;\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">setState</span> = (<span class=\"hljs-params\">newState</span>) =&gt; {\n    memoizedStates[currentCursor] = <span class=\"hljs-keyword\">typeof</span> newState === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n      ? <span class=\"hljs-title function_\">newState</span>(memoizedStates[currentCursor])\n      : newState;\n  };\n\n  <span class=\"hljs-keyword\">const</span> res = [memoizedStates[cursor], setState];\n  cursor += <span class=\"hljs-number\">1</span>;\n\n  <span class=\"hljs-keyword\">return</span> res;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-params\">callback, deps</span>) {\n  <span class=\"hljs-keyword\">const</span> hasNoDeps = deps === <span class=\"hljs-literal\">undefined</span>;\n  <span class=\"hljs-keyword\">const</span> preDeps = memoizedStates[cursor];\n  <span class=\"hljs-keyword\">const</span> hasChangedDeps = preDeps\n    ? !deps.<span class=\"hljs-title function_\">every</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">dep, index</span>) =&gt;</span> dep === preDeps[index])\n    : <span class=\"hljs-literal\">true</span>;\n\n  <span class=\"hljs-keyword\">if</span> (hasNoDeps || hasChangedDeps) {\n    <span class=\"hljs-title function_\">callback</span>();\n    memoizedStates[cursor] = deps;\n  }\n\n  cursor += <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">resetCursor</span>(<span class=\"hljs-params\"></span>) {\n  cursor = <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">resetMemoizedStates</span>(<span class=\"hljs-params\"></span>) {\n  memoizedStates = [];\n}\n</code></pre>\n<p><strong>Not Magic, just Arrays</strong></p>\n<p>测试用例</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { act, renderHook } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/react-hooks&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> {\n  resetCursor, useEffect, useState, resetMemoizedStates,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useState_useEffect&#x27;</span>;\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;useState_simple&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;useState should be defined&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(useState).<span class=\"hljs-title function_\">toBeDefined</span>();\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;When the update function is called, the data is updated normally&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">usePeople</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n      <span class=\"hljs-keyword\">const</span> [age, setAge] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-keyword\">const</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>);\n\n      <span class=\"hljs-keyword\">return</span> [age, setAge, name, setName];\n    };\n    <span class=\"hljs-keyword\">const</span> { result, rerender } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">usePeople</span>());\n\n    <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">0</span>]).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">2</span>]).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>);\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">1</span>](<span class=\"hljs-function\">(<span class=\"hljs-params\">pre</span>) =&gt;</span> pre + <span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-title function_\">resetCursor</span>();\n      <span class=\"hljs-title function_\">rerender</span>();\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">0</span>]).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">2</span>]).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>);\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">3</span>](<span class=\"hljs-string\">&#x27;tom&amp;jerry&#x27;</span>);\n      <span class=\"hljs-title function_\">resetCursor</span>();\n      <span class=\"hljs-title function_\">rerender</span>();\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">0</span>]).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>[<span class=\"hljs-number\">2</span>]).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&#x27;tom&amp;jerry&#x27;</span>);\n  });\n});\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;useEffect_simple&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">resetCursor</span>();\n    <span class=\"hljs-title function_\">resetMemoizedStates</span>();\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;useEffect should be defined&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(useEffect).<span class=\"hljs-title function_\">toBeDefined</span>();\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;Different DEPs, Callback calls should also be differentcalls should also be different&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> callbackWithNoDeps = jest.<span class=\"hljs-title function_\">fn</span>();\n    <span class=\"hljs-keyword\">const</span> callbackWithEmptyDeps = jest.<span class=\"hljs-title function_\">fn</span>();\n    <span class=\"hljs-keyword\">const</span> callbackWithChangingDeps = jest.<span class=\"hljs-title function_\">fn</span>();\n\n    <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;tom&#x27;</span>;\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">useProple</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n      <span class=\"hljs-title function_\">useEffect</span>(callbackWithNoDeps);\n      <span class=\"hljs-title function_\">useEffect</span>(callbackWithEmptyDeps, []);\n      <span class=\"hljs-title function_\">useEffect</span>(callbackWithChangingDeps, [name]);\n    };\n\n    <span class=\"hljs-keyword\">const</span> { rerender } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">useProple</span>());\n\n    <span class=\"hljs-title function_\">expect</span>(callbackWithNoDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">expect</span>(callbackWithEmptyDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">expect</span>(callbackWithChangingDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      name = <span class=\"hljs-string\">&#x27;tom&amp;jerry&#x27;</span>;\n      <span class=\"hljs-title function_\">resetCursor</span>();\n      <span class=\"hljs-title function_\">rerender</span>();\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(callbackWithNoDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-title function_\">expect</span>(callbackWithEmptyDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">expect</span>(callbackWithChangingDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n\n    <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-title function_\">resetCursor</span>();\n      <span class=\"hljs-title function_\">rerender</span>();\n    });\n\n    <span class=\"hljs-title function_\">expect</span>(callbackWithNoDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-title function_\">expect</span>(callbackWithEmptyDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">expect</span>(callbackWithChangingDeps).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n  });\n});\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">真正的React实现</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>虽然我们用数组基本实现了一个可用的Hooks，了解了Hooks的原理，但在React中，实现方式却有一些差异的。</p>\n<ol>\n<li>React中是通过类似单链表的形式来代替数组的。通过<code>next</code>按顺序串联所有的<code>hook</code></li>\n<li><code>memoizedState</code>，<code>cursor</code>是存在哪里的？如何和每个函数组件一一对应的？</li>\n</ol>\n<p>我们知道，React会生成一棵组件树（或Fiber单链表），树中每个节点对应了一个组件，hooks的数据就作为组件的一个信息，存储在这些节点上，<strong>伴随组件一起出生，一起死亡</strong>。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Hooks</span> = {\n    <span class=\"hljs-comment\">// others</span>\n    <span class=\"hljs-attr\">memoizedState</span>: <span class=\"hljs-built_in\">any</span>, <span class=\"hljs-comment\">// useState中 保存 state 信息 ｜ useEffect 中 保存着 effect 对象 ｜ useMemo 中 保存的是缓存的值和 deps ｜ useRef 中保存的是 ref 对象</span>\n    <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">Hook</span> | <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// link 到下一个 hooks，通过 next 串联每一个hooks</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解惑</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Q. 为什么只能在函数最外层调用Hook，不要在循环、条件判断或者子函数中调用？</p>\n<p>A. <code>memoizedState</code>是按hook定义的顺序来放置数据的，如果hook顺序变化，<code>memoizedState</code>并不会感知到</p>\n<p>Q. 为什么<code>useEffect</code>第二个参数是空数组，在组件更新时回调只会执行一次？</p>\n<p>A. 因为依赖一直不变化，<code>callback</code>不会二次执行</p>\n<p>Q. 自定义的Hook是如何影响使用它的函数组件的？</p>\n<p>A. 共享同一个<code>memoizedState</code>，共享同一个顺序</p>\n<p>Q. Capture Value 特性是如何产生的？</p>\n<p>A. 每一次<code>rerender</code>的时候，都是重新去执行函数组件了，对于之前已经执行过的函数组件，并不会做任何操作。即<strong>每次渲染（执行），都有它自己的xxx</strong></p>\n"},{"title":"SVG学习-stroke-dashoffset和stroke-dasharray","tags":["SVG"],"categories":"前端架构&软实力","description":"## 起因\n\n周末玩游戏的时候发现游戏内有一个按钮的交互挺有趣，类似于这种效果\n\n![button-svg](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/button-svg.gif)\n\n点击后边框有一个进度条，鼠标长按进度会增加，抬起后回到起始位置\n\n咦，有点意思\n\n![因垂斯汀](https://mrrsblog.oss-cn-shangha","createDate":"2021-11-24 13:35:30","updateDate":"2021-11-25 21:54:36","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">起因</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>周末玩游戏的时候发现游戏内有一个按钮的交互挺有趣，类似于这种效果</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/button-svg.gif\" alt=\"button-svg\"></p>\n<p>点击后边框有一个进度条，鼠标长按进度会增加，抬起后回到起始位置</p>\n<p>咦，有点意思</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/interesting.gif\" alt=\"因垂斯汀\"></p>\n<p>于是就想着能不能使用前端的一些技术实现🤔</p>\n<p>于是开始一系列的尝试（此处省略若干字），发现触及到知识盲区了😭，根本无从下手</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/interesting2.png\" alt=\"知识盲区\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">转机</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>突然不知道怎么就想到SVG了，想着要不试试？没准能行，然后一顿搜索，眼前一亮</p>\n<p>有大佬使用<code>stroke</code>和<code>stroke-dashoffset</code>及<code>stroke-dasharray</code>做出进度条，同时又想到SVG可以和JavaScript交互，貌似可以实现我的需求</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/interesting3.png\" alt=\"奇怪的知识增加了\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">stork-dashoffset和stork-dasharray</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>那么<code>stroke</code>和<code>stroke-dashoffset</code>以及<code>stroke-dasharray</code>是何方神圣腻？🤔</p>\n<p><code>stroke</code>: 描边，接受一个颜色值。可作用于大部分SVG元素</p>\n<p><code>stroke-dasharray</code>: 用于创建虚线描边</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 表示：虚线长10，间距10，然后重复 虚线长10，间距10</span>\nstroke-dasharray = <span class=\"hljs-string\">&#x27;10&#x27;</span>\n\n<span class=\"hljs-comment\">// 表示：虚线长10，间距5，然后重复 虚线长10，间距5</span>\nstroke-dasharray = <span class=\"hljs-string\">&#x27;10, 5&#x27;</span>\n\n<span class=\"hljs-comment\">// 当然还有更复杂的设置这里就不细讲了</span>\n</code></pre>\n<p><code>stroke-dashoffset</code>：字如其意，表示stroke的偏移。这个属性是相对于起始点的偏移，<strong>正数</strong>偏移x值的时候，相当于往<strong>左</strong>移动了x个长度单位，<strong>负数</strong>偏移x的时候，相当于往<strong>右</strong>移动了x个长度单位</p>\n<p>需要注意的是，不管偏移的方向是哪边，要记得dasharray 是循环的，也就是 虚线-间隔-虚线-间隔。\n<code>stroke-dashoffset</code>要搭配<code>stroke-dasharray</code>才能看得出来效果，非虚线的话，是无法看出偏移的。</p>\n<p>概念有点抽象，来看一个MDN的例子，图中红线段是偏移的距离</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/stroke-dashoffset.png\" alt=\"stroke-dashoffset\"></p>\n<p>上图效果分别是：</p>\n<ol>\n<li>没有虚线</li>\n<li><code>stroke-dasharray=&quot;3 1&quot;</code> ，虚线没有设置偏移，也就是stroke-dashoffset值为0</li>\n<li><code>stroke-dashoffset=&quot;3&quot;</code>，偏移正数，虚线整体左移了3个单位，图中3后面的红线段，就是起始线段，线段之后是1个单位的间隔，我们可见区域从这个间隔开始，然后循环 3-1,3-1的虚线-间隔-虚线-间隔</li>\n<li><code>stroke-dashoffset=&quot;-3&quot;</code>，偏移负数，虚线整体右移动了3个单位，由于dasharray 是循环的，前面偏移的位置会有dasharray 填充上</li>\n<li><code>stroke-dashoffset=&quot;1&quot;</code>，偏移正数，虚线整体左移了1个单位，最终呈现出来的效果跟 线段4 一样</li>\n</ol>\n<p><strong>利用这两个属性，我们可以做出好看的动画效果</strong></p>\n<ol>\n<li><p>设置<code>stroke-dasharray</code>为<em>图形边长</em></p>\n</li>\n<li><p>设置<code>stroke-dashoffset</code>为<em>图形边长</em></p>\n</li>\n<li><p>动态减少<code>stroke-dashoffset</code>到0</p>\n</li>\n</ol>\n<p>简析：第一步后就有一个长度为图形边长的<em>长条</em>，第二步由于设置了<code>stroke-dashoffset</code>也为图形边长，因此<em>长条</em>会被推到不可见的位置，再通过第三步中动态减少<code>stroke-dashoffset</code>，第一步中绘制的<em>长条</em>就会慢慢<em>增长</em>并显示出来</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">再次挑战</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>刚开始是想使用<code>rect</code>来做的，但发现游戏中的按钮是有一定的圆角的，<code>rect</code>在设置圆角之后再添加<code>storke</code>有点丑，遂放弃，改用<code>path</code>实现</p>\n<p>观察原图，实现思路如下：</p>\n<ol>\n<li><p>边框可以使用<code>path</code>绘制出来</p>\n</li>\n<li><p>边框背景也使用<code>path</code>绘制（同一套<code>d</code>属性），设置一下<code>opacity</code>即可</p>\n</li>\n<li><p>背景色使用SVG的<code>fill</code>填充出来</p>\n</li>\n<li><p>文字使用<code>text</code>绘制</p>\n</li>\n</ol>\n<p>实现代码如下：</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>SVG<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        <span class=\"hljs-selector-id\">#svg</span><span class=\"hljs-selector-pseudo\">:active</span> {\n            <span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">0.9</span>;\n        }\n        <span class=\"hljs-selector-id\">#path</span>, <span class=\"hljs-selector-id\">#background</span> {\n            stroke-<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">3</span>;\n            stroke: <span class=\"hljs-number\">#f00</span>;\n            <span class=\"hljs-attribute\">cursor</span>: pointer;\n            \n            <span class=\"hljs-comment\">/** \n             * 修正位置，设置水平垂直居中\n             */</span>\n            <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(<span class=\"hljs-number\">5px</span>, <span class=\"hljs-number\">5px</span>);\n        }\n        <span class=\"hljs-selector-id\">#background</span> {\n            <span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">0.2</span>;\n        }\n        <span class=\"hljs-selector-id\">#text</span> {\n            user-select: none;\n            <span class=\"hljs-attribute\">cursor</span>: pointer;\n            fill: <span class=\"hljs-number\">#000</span>;\n            \n            <span class=\"hljs-comment\">/** \n             * 设置水平垂直居中\n             */</span>\n            dominant-baseline: middle;\n            text-anchor: middle;\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-keyword\">let</span> rafId = -<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">WIDTH</span> = <span class=\"hljs-number\">70</span>;\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">HEIGHT</span> = <span class=\"hljs-number\">30</span>;\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">RADIUS</span> = <span class=\"hljs-number\">6</span>;\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">DEFAULT_OFFSET</span> = <span class=\"hljs-number\">15</span>;\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">STORK_LENGTH</span> = (<span class=\"hljs-variable constant_\">WIDTH</span> + <span class=\"hljs-variable constant_\">HEIGHT</span>) &lt;&lt; <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">STEP</span> = <span class=\"hljs-number\">5</span>;\n\n        <span class=\"hljs-comment\">/**\n         * <span class=\"hljs-doctag\">@description</span>: 生成带有圆角的path\n         */</span>\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">roundedRect</span>(<span class=\"hljs-params\">w, h, tlr, trr, brr, blr</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`M 0 <span class=\"hljs-subst\">${tlr}</span> A <span class=\"hljs-subst\">${tlr}</span> <span class=\"hljs-subst\">${tlr}</span> 0 0 1 <span class=\"hljs-subst\">${tlr}</span> 0 L <span class=\"hljs-subst\">${w - trr}</span> 0 `</span>\n                + <span class=\"hljs-string\">`A <span class=\"hljs-subst\">${trr}</span> <span class=\"hljs-subst\">${trr}</span> 0 0 1 <span class=\"hljs-subst\">${w}</span> <span class=\"hljs-subst\">${trr}</span> L <span class=\"hljs-subst\">${w}</span> <span class=\"hljs-subst\">${h - brr}</span> `</span>\n                + <span class=\"hljs-string\">`A <span class=\"hljs-subst\">${brr}</span> <span class=\"hljs-subst\">${brr}</span> 0 0 1 <span class=\"hljs-subst\">${w - brr}</span> <span class=\"hljs-subst\">${h}</span> L <span class=\"hljs-subst\">${blr}</span> <span class=\"hljs-subst\">${h}</span> `</span>\n                + <span class=\"hljs-string\">`A <span class=\"hljs-subst\">${blr}</span> <span class=\"hljs-subst\">${blr}</span> 0 0 1 0 <span class=\"hljs-subst\">${h - blr}</span> Z`</span>;\n        }\n\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">animation</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#path&#x27;</span>);\n            <span class=\"hljs-keyword\">const</span> preOffset = path.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&#x27;stroke-dashoffset&#x27;</span>);\n            <span class=\"hljs-keyword\">const</span> newOffset = preOffset - <span class=\"hljs-variable constant_\">STEP</span>;\n            path.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;stroke-dashoffset&#x27;</span>, newOffset);\n            <span class=\"hljs-keyword\">if</span> (newOffset &gt;= <span class=\"hljs-number\">0</span>) {\n                rafId = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">requestAnimationFrame</span>(animation);\n            } <span class=\"hljs-keyword\">else</span> {\n                path.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;stroke-dashoffset&#x27;</span>, <span class=\"hljs-variable constant_\">STORK_LENGTH</span> - <span class=\"hljs-variable constant_\">DEFAULT_OFFSET</span>);\n                <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;success&#x27;</span>);\n            }\n        }\n\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseDown</span>(<span class=\"hljs-params\"></span>) {\n            rafId = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">requestAnimationFrame</span>(animation);\n        }\n\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseUp</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">cancelAnimationFrame</span>(rafId);\n            path.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;stroke-dashoffset&#x27;</span>, <span class=\"hljs-variable constant_\">STORK_LENGTH</span> - <span class=\"hljs-variable constant_\">DEFAULT_OFFSET</span>);\n        }\n\n        <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;load&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n            <span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#path&#x27;</span>);\n            <span class=\"hljs-keyword\">const</span> background = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#background&#x27;</span>);\n            path.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;stroke-dashoffset&#x27;</span>, <span class=\"hljs-variable constant_\">STORK_LENGTH</span> - <span class=\"hljs-variable constant_\">DEFAULT_OFFSET</span>);\n            path.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;stroke-dasharray&#x27;</span>, <span class=\"hljs-variable constant_\">STORK_LENGTH</span>);\n\n            <span class=\"hljs-keyword\">const</span> roundedPath = <span class=\"hljs-title function_\">roundedRect</span>(<span class=\"hljs-variable constant_\">WIDTH</span>, <span class=\"hljs-variable constant_\">HEIGHT</span>, <span class=\"hljs-variable constant_\">RADIUS</span>, <span class=\"hljs-variable constant_\">RADIUS</span>, <span class=\"hljs-variable constant_\">RADIUS</span>, <span class=\"hljs-variable constant_\">RADIUS</span>);\n            path.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, roundedPath);\n            background.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, roundedPath);\n        });\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;svg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;80&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;40&quot;</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">&quot;#ccc&quot;</span> <span class=\"hljs-attr\">onmousedown</span>=<span class=\"hljs-string\">&quot;onMouseDown()&quot;</span> <span class=\"hljs-attr\">onmouseup</span>=<span class=\"hljs-string\">&quot;onMouseUp()&quot;</span>\n        <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;background&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;40&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span>&gt;</span>click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>最终效果</p>\n<p><img src=\"https://mrrs878.github.io/awesome/static/img/button.gif\" alt=\"最终效果\"></p>\n<p><a href=\"https://mrrs878.github.io/awesome/interactive-button/index.html\">在线体验</a></p>\n<p>参考：</p>\n<p><a href=\"https://www.cnblogs.com/daisygogogo/p/11044353.html\">SVG学习之stroke-dasharray 和 stroke-dashoffset 详解</a></p>\n"},{"title":"typescript学习-拾遗","tags":["never"],"categories":"typescript","description":"`never` 类型是 TypeScript 中的底层类型。一些例子：\n\n- 一个从来不会有返回值的函数（如：如果函数内含有 `while(true) {}`）；\n- 一个总是会抛出错误的函数（如：`function foo() { throw new Error('Not Implemented') }`，`foo` 的返回类型是 `never`）；\n\n使用场景：详细的返回值检查\n``` t","createDate":"2021-10-08 13:20:35","updateDate":"2021-10-08 21:21:44","body":"<p><code>never</code> 类型是 TypeScript 中的底层类型。一些例子：</p>\n<ul>\n<li>一个从来不会有返回值的函数（如：如果函数内含有 <code>while(true) {}</code>）；</li>\n<li>一个总是会抛出错误的函数（如：<code>function foo() { throw new Error(&#39;Not Implemented&#39;) }</code>，<code>foo</code> 的返回类型是 <code>never</code>）；</li>\n</ul>\n<p>使用场景：详细的返回值检查</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">boolean</span> {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;string&#x27;</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;number&#x27;</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n\n  <span class=\"hljs-comment\">// 如果不是一个 never 类型，这会报错：</span>\n  <span class=\"hljs-comment\">// - 不是所有条件都有返回值 （严格模式下）</span>\n  <span class=\"hljs-comment\">// - 或者检查到无法访问的代码</span>\n  <span class=\"hljs-comment\">// 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型</span>\n  <span class=\"hljs-comment\">// 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fail</span>(<span class=\"hljs-string\">&#x27;Unexhaustive&#x27;</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fail</span>(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">never</span> {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(message);\n}\n</code></pre>\n<p>与 <code>void</code> 的差异：</p>\n<p><code>never</code> 表示一个从来不会优雅的返回的函数时，你可能马上就会想到与此类似的 <code>void</code>，然而实际上，<code>void</code> 表示没有任何类型，<code>never</code> 表示永远不存在的值的类型。</p>\n<p>当一个函数返回空值时，它的返回值为 <code>void</code> 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 <code>never</code> 类型。<code>void</code> 类型可以被赋值（在 <code>strictNullChecking</code> 为 <code>false</code>时），但是除了 <code>never</code> 本身以外，其他任何类型不能赋值给 <code>never</code></p>\n"},{"title":"typescript学习-命名空间&模块","tags":["namespace"],"categories":"typescript","description":"## 模块\n\nTypeScript 与 ES6 一样，任何包含顶级 `import` 或者 `export` 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 `import` 或者 `export` 声明，那么它的内容被视为全局可见的。\n\n例如我们在在一个 TypeScript 项目下任意文件中（不带有 `export` / `import` ）声明一个变量 `a` 。然后在另一个文","createDate":"2021-10-08 03:28:30","updateDate":"2021-10-08 16:36:57","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模块</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>TypeScript 与 ES6 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 <code>import</code> 或者 <code>export</code> 声明，那么它的内容被视为全局可见的。</p>\n<p>例如我们在在一个 TypeScript 项目下任意文件中（不带有 <code>export</code> / <code>import</code> ）声明一个变量 <code>a</code> 。然后在另一个文件同样声明一个变量 <code>a</code> ，这时候会出现错误信息：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/namespace-0.png\" alt=\"重复声明\"></p>\n<p>如果需要解决这个问题，则通过import或者export引入模块系统即可，具体不再赘述。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">命名空间</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>命名空间一个最明确的目的就是解决重名问题</p>\n<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>\n<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>\n<p>TypeScript 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title class_\">Util</span> {\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sum</span> = (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>) =&gt; a + b;\n}\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title class_\">Tools</span> {\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sub</span> = (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>) =&gt; a - b;\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Tools</span>.<span class=\"hljs-title function_\">sub</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>));\n</code></pre>\n<p>命名空间本质上是一个对象，作用是将一系列相关的<strong>全局变量</strong>组织到一个对象的属性，上述代码编译后如下：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Util</span>;\n(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Util</span>) {\n    <span class=\"hljs-title class_\">Util</span>.<span class=\"hljs-property\">sum</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) { <span class=\"hljs-keyword\">return</span> a + b; };\n})(<span class=\"hljs-title class_\">Util</span> || (<span class=\"hljs-title class_\">Util</span> = {}));\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Tools</span>;\n(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Tools</span>) {\n    <span class=\"hljs-title class_\">Tools</span>.<span class=\"hljs-property\">sub</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) { <span class=\"hljs-keyword\">return</span> a - b; };\n})(<span class=\"hljs-title class_\">Tools</span> || (<span class=\"hljs-title class_\">Tools</span> = {}));\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>命名空间是位于全局命名空间下的一个普通的带有名字的  JavaScript  对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它<strong>很难去识别组件之间的依赖关系</strong>，尤其是在大型的应用中</p>\n</li>\n<li><p>像命名空间一样，模块可以包含代码和声明。不同的是模块可以声明它的依赖</p>\n</li>\n<li><p>在正常的TS项目开发过程中并不建议用命名空间，但<strong>通常在通过 d.ts 文件标记 js 库类型</strong>的时候使用命名空间，主要作用是给编辑器/IDE编写代码的时候参考使用</p>\n</li>\n</ul>\n"},{"title":"CSS相关-0","tags":["CSS"],"categories":"CSS","description":"## 盒模型\n\n描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作为一个矩形盒子，这个盒子包含元素的内容、内边距、边框、外边距。\n\n盒模型分为两种：\n\n- 标准盒模型（box-sizing = content-box）\n\n  width = content-width\n\n  height = content-height\n\n- IE盒模型（box-sizi","createDate":"2020-03-24 23:29:35","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">盒模型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作为一个矩形盒子，这个盒子包含元素的内容、内边距、边框、外边距。</p>\n<p>盒模型分为两种：</p>\n<ul>\n<li><p>标准盒模型（box-sizing = content-box）</p>\n<p>width = content-width</p>\n<p>height = content-height</p>\n</li>\n<li><p>IE盒模型（box-sizing = border-box）</p>\n<p>width = content-width + padding + border</p>\n<p>height = content-height + padding + border</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">层叠上下文</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>层叠上下文是<strong>包含一组图层的元素</strong>。 在一组层叠上下文中，其子元素的<strong>z-index值是相对于该父元素</strong>而不是 <code>document root</code> 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的<code>z-index</code>值，元素 C 也永远不会在元素 B 之上.</p>\n<p>CSS 中的<code>z-index</code>属性控制重叠元素的垂直叠加顺序。<code>z-index</code>只能影响<code>position</code>值不是<code>static</code>的元素。</p>\n<p>产生层叠上下文：</p>\n<ol>\n<li><p>HTML中的根元素<code>&lt;html&gt;&lt;/html&gt;</code>本身就具有层叠上下文，称为<strong>根层叠上下文</strong>。</p>\n</li>\n<li><p>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</p>\n</li>\n<li><p>CSS3中的新属性也可以产生层叠上下文。</p>\n</li>\n<li><ul>\n<li>父元素的display属性值为<code>flex|inline-flex</code>，子元素<code>z-index</code>属性值不为<code>auto</code>的时候，子元素为层叠上下文元素；</li>\n<li>元素的<code>opacity</code>属性值不是1；</li>\n<li>元素的<code>transform</code>属性值不是<code>none</code>；</li>\n<li>元素<code>mix-blend-mode</code>属性值不是normal；</li>\n<li>元素的<code>filter</code>属性值不是<code>none</code>；</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/z-index.png\" alt=\"z-index\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">link标签的rel属性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>preload</code></p>\n<p>让你在你的HTML页面中<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head\">head</a>标签内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后即刻需要的。对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就进行预加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。</p>\n</li>\n<li><p><code>prefetch</code></p>\n<p>提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。</p>\n</li>\n</ul>\n"},{"title":"ES6重点-0","tags":["ES6"],"categories":"JavaScript","description":"## [Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n\n`Proxy`用于**修改某些操作的默认行为**，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。`Proxy`可以理解成在目标对象之前架设一层","createDate":"2020-02-18 23:43:05","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>Proxy</code>用于<strong>修改某些操作的默认行为</strong>，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。<code>Proxy</code>可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\">Reflect</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>**WHAT **😳</p>\n<p>ES6为了<strong>操作对象</strong>而提供的新的API</p>\n<p><strong>WHY</strong>   🤔</p>\n<ol>\n<li>将<code>Object</code>对象的一些明显是语语言内部的方法（比如<code>Object.defineProperty</code>）放到<code>Reflect</code>对象上，现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</li>\n<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></li>\n<li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为</li>\n<li><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为</li>\n</ol>\n<p><strong>HOW</strong>  😮</p>\n<p><code>Reflect</code>对象一共有13个静态方法</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 适用于函数定义了自己的 apply 方法</span>\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">apply</span>(target, thisArg, args)\n<span class=\"hljs-comment\">// 等同于new target(...args) 这提供了一种不使用 new 来调用构造函数的方法</span>\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">construct</span>(target, args)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, name, receiver)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, name, value, receiver)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, name, desc)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(target, name)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">has</span>(target, name)\n<span class=\"hljs-comment\">// 基本等同于Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和</span>\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">isExtensible</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">prevenExtensions</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target, name)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(target, prototype)\n</code></pre>\n<p><code>Reflect</code> + <code>Proxy</code>实现观察者模式</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> observers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-params\">fn</span>) {\n  observers.<span class=\"hljs-title function_\">add</span>(fn)\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">observable</span>(<span class=\"hljs-params\">obj</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, {\n    <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">target, key, value, receiver</span>) {\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver)\n      observers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> <span class=\"hljs-title function_\">observer</span>())\n      <span class=\"hljs-keyword\">return</span> result\n    }\n  })\n}\n\n<span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-title function_\">observable</span>({\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span>\n})\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${ person.name }</span>, <span class=\"hljs-subst\">${ person.age }</span>`</span>)\n}\n<span class=\"hljs-title function_\">observe</span>(print)\nperson.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;tom1&quot;</span> \n</code></pre>\n<p>📣 在观察者模式中，观察者是知道被观察者的，被观察者一一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过消息代理进行通信。在发布订阅模式中，组件时松散耦合的，正和观察者模式相反。观察者模式大多时候是同步的，比如当事件触发，被观察者就会调用观察者的方法；而发布订阅模式大多时候是异步的（使用消息队列）</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">Symbol</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong> 😳</p>\n<p><code>ES6</code>引入的一种新的原始数据类型，表示<strong>独一无二</strong>的值。它是<code>JavaScript</code>语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Object</code>、<code>Number</code></p>\n<p>📣 不支持 <code>new Symbol()</code></p>\n<p><strong>WHY</strong>   🤔</p>\n<p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。Symbol值可作为对象属性名</p>\n<p><strong>HOW</strong>   😮</p>\n<p>Symbol值通过<code>Symbol</code>函数生成</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nameProperty = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\n<span class=\"hljs-keyword\">let</span> a = {\n  [nameProperty]: <span class=\"hljs-string\">&quot;a&quot;</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyNames</span>(a))\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> a) {\n  <span class=\"hljs-keyword\">if</span> (a.<span class=\"hljs-title function_\">hasOwnProperty</span>(key)) {\n    <span class=\"hljs-keyword\">const</span> element = a[key];\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);\n  }\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(a));\n</code></pre>\n<p>API:</p>\n<ul>\n<li><p><code>Symbol.description</code></p>\n<p>创建<code>Symbol</code>的时候，可以添加一个描述，但读取这个描述需要将<code>Symbol</code>显式转为字符串。<code>Symbol.description</code>可以方便的读取<code>Symbol</code>对应的描述</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nameProp = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\nnameProp.<span class=\"hljs-title function_\">toString</span>()\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nameProp.<span class=\"hljs-property\">description</span>)\n</code></pre>\n</li>\n<li><p><code>Symbol.for</code></p>\n<p>重新使用同一个<code>Symbol</code>值。<code>Symbol.for</code>接受一个字符串作为参数，然后<strong>全局搜索</strong>有没有以该参数作为名称的Symbol值，若有，返回之；若没有，创建之</p>\n<p><code>Symbol.for(&quot;name&quot;)</code>和<code>Symbol(&quot;name&quot;)</code>的区别：两者都会生成<code>Symbol</code>值；前者会被登记在<strong>全局</strong>环境中供搜索，后者不会</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>) === <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\n<span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;name&quot;</span>) === <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\n<span class=\"hljs-comment\">// true</span>\n</code></pre>\n</li>\n<li><p><code>Symbol.keyFor</code></p>\n<p>返回一个已<strong>登记</strong>的<code>Symbol</code>的<code>key</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(<span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)));\n<span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-comment\">// name</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Set</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong> 😳</p>\n<p>ES6提供的一种数据结构，类似于数组，但成员的值都是唯一的，没有重复的值</p>\n<p>Set使用一种类似于<code>===</code>的算法“Same-value-zero equality”来判断值是否相等</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// &quot;5&quot; 和 5 不相等</span>\n<span class=\"hljs-comment\">// NaN 和 NaN 相等</span>\n<span class=\"hljs-comment\">// 两个空对象不相等</span>\n<span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&quot;5&quot;</span>)\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">5</span>)\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">NaN</span>)\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">NaN</span>)\nset.<span class=\"hljs-title function_\">add</span>({})\nset.<span class=\"hljs-title function_\">add</span>({})\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(set);\n<span class=\"hljs-comment\">// Set { &#x27;5&#x27;, 5, NaN, {}, {} }</span>\n</code></pre>\n<p><strong>WHY</strong>   🤔</p>\n<ul>\n<li>可以用作数组去重<code>[...new Set([1, 1, 2, 2, 3])]</code></li>\n<li>去除字符串里面的重复字符<code>[...new Set(&#39;aaabbbc&#39;)].join(&quot;&quot;)</code></li>\n</ul>\n<p><strong>HOW</strong>   😮</p>\n<p><code>Set</code>函数可以接受一个数组（或<strong>具有interable接口</strong>的其他数据结构）作为参数，用来初始化</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Map</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong> 😳</p>\n<p>ES6提供的一种数据结构，类似于对象，也是键-值对的集合，但键的范围不限于字符串，各章类型的值（包括对象）都可以作为键</p>\n<p><strong>WHY</strong>   🤔</p>\n<p>传统上的Object只能用字符串（[Symbol](## Symbol)）作为键，这给它的使用带来了很大的限制</p>\n<p>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性和原作者的属性同名</p>\n<p><strong>HOW</strong>   😮</p>\n<p>使用 <code>new Map</code> 来创建Map</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;2&quot;</span>]])\nmap.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;1&quot;</span>)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-number\">2</span>));\n</code></pre>\n<p>事实上，不仅仅是数组，任何具有<code>iterator</code>接口、且每个成员都是一个双元素的数组的数据结构都可以作为<code>Map</code>构造函数的参数</p>\n"},{"title":"ES6重点-1","tags":["ES6"],"categories":"JavaScript","description":"## 字符串新增方法\n\n- `padStart`\n\n  用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全\n\n  ```js\n  console.log('xxx'.padStart(4, 'ab'));\n  console.log('x'.padStart(4, 'ab')); //补全位数，有需要会重复或截取\n  console.log('x'.padStart(4));","createDate":"2020-02-19 23:01:48","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">字符串新增方法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>padStart</code></p>\n<p>用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>)); <span class=\"hljs-comment\">//补全位数，有需要会重复或截取</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>)); <span class=\"hljs-comment\">// 不传第二个参数默认使用空格补全</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 补全后的长度小于源字符串长度则不做任何改变</span>\n\n<span class=\"hljs-comment\">// abax</span>\n<span class=\"hljs-comment\">// axxx</span>\n<span class=\"hljs-comment\">//    x</span>\n<span class=\"hljs-comment\">// xxx</span>\n</code></pre>\n</li>\n<li><p><code>padEnd</code></p>\n<p>和<code>padStart</code>效果相反，从尾部开始补全</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;abc&#x27;</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">2</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>));\n\n<span class=\"hljs-comment\">// xabca</span>\n<span class=\"hljs-comment\">// x   </span>\n<span class=\"hljs-comment\">// xxx</span>\n<span class=\"hljs-comment\">// xxxa</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对象新增扩展</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>链判断运算符</p>\n<p>在ES5中，取对象属性时，往往需要判断以下该对象是否存在。如下</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = (store \n    &amp;&amp; store.<span class=\"hljs-property\">state</span> \n    &amp;&amp; store.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">user</span> \n    &amp;&amp; store.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">user</span>.<span class=\"hljs-property\">name</span>) || <span class=\"hljs-string\">&quot;tom&quot;</span>\n</code></pre>\n<p>这种层层判断过于麻烦，因此ES2020引入链判断运算符<code>?.</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = store?.<span class=\"hljs-property\">state</span>?.<span class=\"hljs-property\">user</span>?.<span class=\"hljs-property\">name</span>\n</code></pre>\n<p>如果左侧的对象为<code>null</code>或<code>undefined</code>则直接返回<code>undefined</code>，不再往下运算</p>\n</li>\n<li><p><code>null</code>判断运算符</p>\n<p>独去对象属性时，如果某个属性的值时<code>null</code>或<code>undefined</code>，有时需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = user.<span class=\"hljs-property\">name</span> || <span class=\"hljs-string\">&quot;tom&quot;</span>\n<span class=\"hljs-keyword\">const</span> age = user.<span class=\"hljs-property\">age</span> || <span class=\"hljs-number\">20</span>\n</code></pre>\n<p>原意是属性值为<code>null</code>或<code>undefined</code>时默认值就生效，但当<code>user.name</code>为空串或<code>user.age</code>为0时默认值也会生效</p>\n<p>为此ES2020引入新的<code>null</code>判断运算符<code>??</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = user.<span class=\"hljs-property\">name</span> ?? <span class=\"hljs-string\">&quot;tom&quot;</span>\n<span class=\"hljs-keyword\">const</span> age = user.<span class=\"hljs-property\">age</span> ?? <span class=\"hljs-number\">20</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对象新增方法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>Object.is</code></p>\n<p>用来替代 <code>==</code>和<code>===</code></p>\n<p><code>==</code> 会进行自动类型转换，<code>===</code> 在比较+0和-0时返回<code>true</code>，<code>NaN</code>不等于自身</p>\n</li>\n<li><p><code>Object.assign</code></p>\n<p>用于对象合并</p>\n<ul>\n<li>只拷贝源对象的<strong>自身、可枚举属性（含Symbol）</strong></li>\n<li>浅拷贝</li>\n<li>同名属性会被覆盖</li>\n<li>除首参数外（<code>null</code>、<code>undefined</code>会报错），非对象会被转换为对象</li>\n</ul>\n</li>\n<li><p><code>Object.keys</code></p>\n<p>返回对象<strong>自身的</strong>、<strong>可遍历的</strong>属性的键名<strong>数组</strong></p>\n</li>\n<li><p><code>Object.fromEntries/Object.entries</code></p>\n<p><code>Object.fromEntries</code>将一个键值对数组转换为一个对象，适合将<code>Map</code>转换为<code>Object</code></p>\n<p><code>Object.entries</code>逆操作，用于将<code>Object</code>转换为键值对数组</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Array扩展</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>Array.of</code></p>\n<p>弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Array</span>() <span class=\"hljs-comment\">//[]</span>\n<span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//[ , , ]</span>\n<span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">//[3, 4, 5]</span>\n\n<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>() <span class=\"hljs-comment\">// []</span>\n<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//[3]</span>\n<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">//[3, 4, 5]</span>\n</code></pre>\n</li>\n<li><p><code>Array.prototype.copyWithin()</code></p>\n<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">copyWithin</span>(target, start = <span class=\"hljs-number\">0</span>, end = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span>)\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-comment\">// [4, 5, 3, 4, 5]</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\n<span class=\"hljs-comment\">// [4, 2, 3, 4, 5]</span>\n</code></pre>\n</li>\n<li><p><code>Array.prototype.flat() &amp;&amp; Array.prototype.flatMap()</code></p>\n<p><code>flat()</code>用于将数据降维，参数为降低的维数（默认为1）,如果不管有多少层维，都要转为一维数组，可使用<code>Infinity</code>关键字作为参数</p>\n<p>如果原数组有空位<code>flat()</code>会跳过</p>\n<pre><code class=\"hljs language-js\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]].<span class=\"hljs-title function_\">flat</span>()\n<span class=\"hljs-comment\">// [1, 2, 1, 2]</span>\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>]]].<span class=\"hljs-title function_\">flat</span>()\n<span class=\"hljs-comment\">// [1, 2, 1, 2, 1, [2]]</span>\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>]]].<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// [1, 2, 1, 2, 1, 2]</span>\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>]]].<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-title class_\">Infinity</span>)\n<span class=\"hljs-comment\">// [1, 2, 1, 2, 1, 2]</span>\n</code></pre>\n<p><code>flatMap()</code>相当于<code>Array.prorotype.Map</code> + <code>Array.prorotype.flat</code></p>\n<pre><code class=\"hljs language-js\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> [x, x * <span class=\"hljs-number\">2</span>])\n<span class=\"hljs-comment\">// [1, 2, 2, 4, 3, 6]</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// [2, 4, 6]</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">iterator</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong></p>\n<p>遍历器（<code>iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了<code>iterator</code>接口，就可以完成<strong>遍历</strong>操作</p>\n<p><strong>WHY</strong></p>\n<p>JavaScript原有的表示集合的数据结构主要是数组（Array）和对象（Object），ES6又添加了<code>Map</code>、<code>Set</code>。这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样需要一种统一的接口机制来处理不同的数据结构</p>\n<p>主要作用</p>\n<ul>\n<li><p>为各种数据结构提供一个统一的、简便的访问接口</p>\n</li>\n<li><p>使得数据结构的成员能够按某种次序排列</p>\n</li>\n<li><p>为<code>for...of</code>所使用</p>\n<p>适合遍历Array，既有<code>forEach</code>的简洁又有<code>for</code>的<code>break</code>、<code>return</code>、<code>continue</code></p>\n</li>\n</ul>\n<p><strong>HOW</strong></p>\n<p><code>iterator</code>的遍历过程</p>\n<ol>\n<li>创建一个指针对象，指向当前的数据结构的起始位置。也就是说遍历器对象本质上就是一个指针对象</li>\n<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</li>\n<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</li>\n<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</li>\n</ol>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象，其中<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示是否遍历结束</p>\n<p>ES6规定，默认的<code>iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是可遍历的（<code>iterable</code>）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = {\n    <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>],\n    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>](): {\n        <span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-variable language_\">this</span>\n        <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-keyword\">if</span> (index &lt; self.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">length</span>) {\n                    <span class=\"hljs-keyword\">return</span> {\n                        <span class=\"hljs-attr\">value</span>: self.<span class=\"hljs-property\">data</span>[index++]\n                        <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>\n                    }\n                }\n                <span class=\"hljs-keyword\">return</span> {\n                    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>,\n                    <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>原生具备iterator接口的数据结构：<code>Map、Array、Set、String、TypedArray、arguments、NodeList对象</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">let VS const</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在let和const之间，建议优先使用const，尤其是在全局环境。const优于let的几个原因：</p>\n<ul>\n<li>const可以提醒阅读程序的人，这个变量不应该改变</li>\n<li>const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式计算</li>\n<li>JavaScript编译器会对const进行优化</li>\n<li>长远来看，JavaScript可能会有多线程的实现，这时let表示的变量只应出现在单线程运行的代码中，不是多线程共享的，这样有利于线程安全</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// bad</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>, b = <span class=\"hljs-number\">2</span>, c = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-number\">3</span>;\n<span class=\"hljs-comment\">// best</span>\n<span class=\"hljs-keyword\">const</span> [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">generator</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>ES6提供的一种异步编程解决方案</p>\n<p>形式上，<code>generator</code>函数是一个状态机，封装了多个内部状态。执行<code>generator</code>函数会返回一个<strong>遍历器对象</strong>。</p>\n<p>语法上，<code>generator</code>函数是一个普通函数。<code>function</code>关键字与函数名之间有一个<code>*</code>；函数体内部使用<code>yield</code>表达式定义不同的内部状态</p>\n<p>与普通函数不同，generator函数被调用后并不执行，返回的是一个指向内部状态的指针对象，也就是<strong>遍历器对象</strong>。下一步，必须调用遍历器对象的<code>next</code>方法使得指针移向下一个状态。也就是说每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> str1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;hello&quot;</span>\n  <span class=\"hljs-comment\">// str1 = 222</span>\n  <span class=\"hljs-keyword\">const</span> str2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;world&quot;</span>\n  <span class=\"hljs-comment\">// str2 = 333</span>\n  <span class=\"hljs-keyword\">return</span> str2\n}\n\n<span class=\"hljs-keyword\">const</span> iter = <span class=\"hljs-title function_\">gen</span>()\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>())\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">222</span>))\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">333</span>))\n</code></pre>\n<p>第一次调用，<code>generator</code>函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>值就是当前<code>yield</code>表达式的值，done的值为<code>false</code></p>\n<p>第二次调用，<code>generator</code>从上次yield表达式停下来的地方一直执行到下一个<code>yield</code>表达式 👆 ……</p>\n<p>第三次调用，<code>generator</code>函数从上次<code>yield</code>表达式停下来的地方一直执行到<code>return</code>语句，next返回的<code>value</code>值就是<code>return</code>后面表达式的值，<code>done</code>为true（如果是<code>yield</code>则为<code>false</code>）</p>\n<p><code>yield</code>表达式本身没有返回值（或者说总是返回undefined）。<code>next</code>方法可以带一个参数，该参数会被当作<strong>上一个</strong><code>yield</code>表达式的返回值</p>\n"},{"title":"HTML相关问题","tags":["HTML"],"categories":"HTML","description":"## cookie、sessionStorage、localStorage的区别\n\n|                          | cookie                                         | localStorage | sessionStorage |\n|","createDate":"2020-04-01 23:00:40","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">cookie、sessionStorage、localStorage的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>|                          | cookie                                         | localStorage | sessionStorage |\n| </p>\n"},{"title":"JavaScript相关-0","tags":["JavaScript"],"categories":"JavaScript","description":"## 事件委托 （event delegation）\n事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器，当触发子元素时，事件会冒泡到父元素，监听器就会触发，这种技术的好处是：\n\n1. 内存占用少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。\n2. 无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。\n\n## JavaScript中","createDate":"2020-02-10 23:18:10","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件委托 （event delegation）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器，当触发子元素时，事件会冒泡到父元素，监听器就会触发，这种技术的好处是：</p>\n<ol>\n<li>内存占用少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。</li>\n<li>无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript中的this指向</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单来讲，<code>this</code>的指向取决于函数的调用方式</p>\n<ol start=\"0\">\n<li>如果是箭头函数，<code>this</code>被设置为调用时的上下文</li>\n<li>如果使用<code>new</code>，函数内的<code>this</code>是一个全新的对象</li>\n<li>如果<code>apply、call、bind</code>方法用于调用/创建一个函数，函数内的<code>this</code>就是作为参数传入这些方法的对象</li>\n<li>当函数作为对象里的方法被调用时，函数内的<code>this</code>是调用该函数的对象，比如当<code>obj.method()</code>被调用时，函数内的<code>this</code>将绑定到<code>obj</code>对象</li>\n<li>如果不符合上述规则，那么<code>this</code>的值指向全局对象<code>global object</code>，浏览器环境下<code>this</code>的值指向<code>window</code>对象，但在严格模式下<code>use strict</code>，<code>this</code>的值为<code>undefined</code></li>\n<li>如果符合上述多个规则，从上到下权重依次递减</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">原型继承 <code>prototypal inheritance</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>所有的JS对象都有一个<code>prototype</code>对象，指向它的原型对象，当试图访问一个对象的属性时，如果没有在该对象上找到它还会搜索该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或达到原型链的末尾。这种行为是在模拟经典的继承，但与其说时继承还不如说是委托<code>delegation</code></p>\n<p>读取对象的属性值时，会自动到原型链中查找</p>\n<p>设置对象的属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值</p>\n<p><img src=\"./imgs/1581317824537.png\" alt=\"原型\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript的模块化机制</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>AMD</p>\n<p><strong>Asynchronous Module Definition 异步模块加载机制</strong>，ReqireJS实现了AMD规范</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//a.js</span>\n<span class=\"hljs-comment\">//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数</span>\n<span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n})\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-comment\">//数组中声明需要加载的模块，可以是模块名、js文件路径</span>\n<span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>], <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a</span>){\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<span class=\"hljs-comment\">// 1</span>\n});\n</code></pre>\n<p>特点：</p>\n<p>对于依赖的模块，AMD推崇<strong>依赖前置，提前执行</strong>，也就是说，在<code>define</code>方法里传入的依赖模块（数组）会在一开始就下载并执行。适合在<strong>浏览器端</strong>使用</p>\n</li>\n<li><p>CommonJS</p>\n<p>CommonJS规范为CommonJS小组所提出，目的是弥补JavaScript在服务器端缺少模块化机制，<strong>NodeJS、webpack</strong>都是基于该规范来实现的。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//a.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>)\n}\n\n<span class=\"hljs-comment\">//b.js</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a&#x27;</span>);\n\n<span class=\"hljs-title function_\">a</span>();<span class=\"hljs-comment\">//&quot;hello world&quot;</span>\n\n<span class=\"hljs-comment\">//或者</span>\n\n<span class=\"hljs-comment\">//a2.js</span>\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">num</span> = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">obj</span> = {<span class=\"hljs-attr\">xx</span>: <span class=\"hljs-number\">2</span>};\n\n<span class=\"hljs-comment\">//b2.js</span>\n<span class=\"hljs-keyword\">var</span> a2 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a2&#x27;</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a2);<span class=\"hljs-comment\">//{ num: 1, obj: { xx: 2 } }</span>\n</code></pre>\n<p>特点：</p>\n<ul>\n<li>所有代码都运行在<strong>模块作用域</strong>，不会污染全局作用域</li>\n<li>模块是<strong>同步加载</strong>的，即只有加载完成才能执行后面的操作</li>\n<li>模块在首次执行后就会<strong>缓存</strong>，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>\n<li><code>require</code>返回的是被输出的<strong>值的拷贝</strong>，模块内部的变化也不会影响这个值</li>\n</ul>\n</li>\n<li><p>ES6 Module</p>\n<p>ES6 Module是<strong>ES6</strong>中规定的模块体系</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//a.js</span>\n<span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;lin&#x27;</span>;\n<span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">13</span>;\n<span class=\"hljs-keyword\">var</span> job = <span class=\"hljs-string\">&#x27;ninja&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> { name, age, job};\n\n<span class=\"hljs-comment\">//b.js</span>\n<span class=\"hljs-keyword\">import</span> { name, age, job} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a.js&#x27;</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name, age, job);<span class=\"hljs-comment\">// lin 13 ninja</span>\n\n<span class=\"hljs-comment\">//或者</span>\n\n<span class=\"hljs-comment\">//a2.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;default &#x27;</span>);\n}\n\n<span class=\"hljs-comment\">//b2.js</span>\n<span class=\"hljs-keyword\">import</span> customName <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a2.js&#x27;</span>;\n<span class=\"hljs-title function_\">customName</span>(); <span class=\"hljs-comment\">// &#x27;default&#x27;</span>\n</code></pre>\n<p>特点（对比CommonJS）：</p>\n<p>|          | CommonJS     | ES6 Module     |\n|</p>\n</li>\n</ul>\n"},{"title":"JavaScript相关-1","tags":["JavaScript"],"categories":"JavaScript","description":"## document.write\n\n`document.write()` 方法将一个文本字符串写入一个由 [`document.open()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/open) 打开的文档流（document stream）。（[MDN](https://developer.mozilla.org","createDate":"2020-02-11 23:33:22","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">document.write</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>document.write()</code> 方法将一个文本字符串写入一个由 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/open\"><code>document.open()</code></a> 打开的文档流（document stream）。（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/write\">MDN</a>）</p>\n<p>作用：</p>\n<p>加载只有启用JavaScript后的样式文件</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">open</span>()\n    docuemnt.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;style_neads_js.css&quot; /&gt;&#x27;</span>)\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">close</span>()\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>弊端：</p>\n<ul>\n<li>在非loading阶段使用<code>docuemnt.write</code>会清除已加载的页面</li>\n<li><code>docuemnt.write</code>不能够在XHTML中使用</li>\n<li>嵌入script中的<code>docuemnt.write</code>不能给任意节点添加子节点，因为它是随着DOM的构建执行的</li>\n<li>利用<code>docuemnt.write</code>写入HTML字符流并不是一个好方法，它有违DOM操作的概念</li>\n<li>利用<code>docuemnt.write</code>添加script加载外部脚本时，浏览器的HTML解析会被script的加载所阻塞</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">功能检测（feature detection）、功能推断（feature inference）、和使用UA字符串之间有什么区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>功能检测（feature detection） 👍</p>\n<p>功能检测包括确定浏览器是否支持某段代码，以及是否能运行不同的代码（取决于它是否执行），一边浏览器能始终正确运行代码功能，而不会在某些浏览器中出现崩溃和错误</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;geolocation&quot;</span> <span class=\"hljs-keyword\">in</span> navigator) {\n    <span class=\"hljs-comment\">// 可以使用 navigator.geolocation</span>\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 处理 navigator.geolocation 功能缺失</span>\n}\n</code></pre>\n<p>功能推断（feature inference）👎</p>\n<p>功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后还会使用其他功能，因为它假设其他功能也可用</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">getElementsByTagName</span>) {\n  element = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(id);\n}\n</code></pre>\n<p>UA 👎</p>\n<p>这是一个浏览器报告的字符串，它允许网络协议对等方（network protocol peers）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过<code>navigator.userAgent</code>访问。然而，这个字符串很可能存在欺骗性，例如，chrome会同时作为chrome和safari进行报告，因此，要检测safari，除了检查safari字符串，还要检查是否同时存在chrome字符串。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ajax</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong></p>\n<p>Ajax（asynchronous JavaScript and XML）是使用客户端上的许多web技术，创建异步web应用的一种<strong>技术结合体</strong>。借助Ajax，web应用可以<strong>异步</strong>（在后台）向服务器发送数据可从服务器检索数据而不会干扰现有页面的显示和行为。通过将<strong>数据交互层与表示层分离</strong>，Ajax允许网页和扩展web应用程序动态更改内容而<strong>不需重新加载整个页面</strong>，实际上，现在通常将XML替换为JSON，因为JavaScript对JSON有原生支持优势</p>\n<p><strong>WHY</strong></p>\n<p>优点：</p>\n<ul>\n<li>交互性更好，来自服务器的新内容可以动态更改，无需重新加载整个页面</li>\n<li>减少与服务器的连接，因为脚本和样式只需要被请求一次</li>\n<li>状态可以维护在一个页面上，JavaScript变量和DOM状态将的到保持，因为主容器页面未被重新加载</li>\n<li>基本上包含大部分SPA的优点</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>动态网页很难收藏</li>\n<li>如果JavaScript在浏览器中被禁用则不起作用</li>\n<li>有些网络爬虫不执行JavaScript，也不会看到JavaScript加载的内容</li>\n</ul>\n<p><strong>HOW</strong></p>\n<ul>\n<li>使用<code>CSS</code>和<code>XHTML</code>来表示</li>\n<li>使用<code>DOM</code>模型来交互和动态显示</li>\n<li>使用<code>XMLHttpRequest</code>来和服务器进行异步通信</li>\n<li>使用<code>JavaScript </code>来绑定和调用</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> ajax = {};\najax.<span class=\"hljs-property\">httpRequest</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">XMLHttpRequest</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>();\n    }\n    <span class=\"hljs-keyword\">var</span> versions = [\n        <span class=\"hljs-string\">&quot;MSXML2.XmlHttp.6.0&quot;</span>,\n        <span class=\"hljs-string\">&quot;MSXML2.XmlHttp.5.0&quot;</span>,\n        <span class=\"hljs-string\">&quot;MSXML2.XmlHttp.4.0&quot;</span>,\n        <span class=\"hljs-string\">&quot;MSXML2.XmlHttp.3.0&quot;</span>,\n        <span class=\"hljs-string\">&quot;MSXML2.XmlHttp.2.0&quot;</span>,\n        <span class=\"hljs-string\">&quot;Microsoft.XmlHttp&quot;</span>\n    ];\n    <span class=\"hljs-keyword\">let</span> xhr;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; versions.<span class=\"hljs-property\">length</span>; i++) {\n        <span class=\"hljs-keyword\">try</span> {\n            xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ActiveXObject</span>(versions[i]);\n            <span class=\"hljs-keyword\">break</span>;\n        } <span class=\"hljs-keyword\">catch</span> (e) {\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> xhr;\n};\n\najax.<span class=\"hljs-property\">send</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">url, callback, method, data, <span class=\"hljs-keyword\">async</span></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">async</span> === <span class=\"hljs-literal\">undefined</span>) {\n        <span class=\"hljs-keyword\">async</span> = <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">let</span> httpRequest = ajax.<span class=\"hljs-title function_\">httpRequest</span>();\n    httpRequest.<span class=\"hljs-title function_\">open</span>(method, url, <span class=\"hljs-keyword\">async</span>);\n    httpRequest.<span class=\"hljs-property\">onreadystatechange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">if</span> (httpRequest.<span class=\"hljs-property\">readyState</span> == <span class=\"hljs-number\">4</span>) {\n            <span class=\"hljs-title function_\">callback</span>(httpRequest.<span class=\"hljs-property\">responseText</span>)\n        }\n    };\n    <span class=\"hljs-keyword\">if</span> (method == <span class=\"hljs-string\">&#x27;POST&#x27;</span>) {\n        httpRequest.<span class=\"hljs-title function_\">setRequestHeader</span>(<span class=\"hljs-string\">&#x27;Content-type&#x27;</span>, <span class=\"hljs-string\">&#x27;application/x-www-form-urlencoded&#x27;</span>);\n    }\n    httpRequest.<span class=\"hljs-title function_\">send</span>(data);\n};\n\najax.<span class=\"hljs-property\">get</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">url, data, callback, <span class=\"hljs-keyword\">async</span></span>) {\n    <span class=\"hljs-keyword\">let</span> query = [];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> data) {\n        query.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-built_in\">encodeURIComponent</span>(key) + <span class=\"hljs-string\">&#x27;=&#x27;</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[key]));\n    }\n    ajax.<span class=\"hljs-title function_\">send</span>(url + (query.<span class=\"hljs-property\">length</span> ? <span class=\"hljs-string\">&#x27;?&#x27;</span> + query.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&amp;&#x27;</span>) : <span class=\"hljs-string\">&#x27;&#x27;</span>), callback, <span class=\"hljs-string\">&#x27;GET&#x27;</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-keyword\">async</span>)\n};\n\najax.<span class=\"hljs-property\">post</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">url, data, callback, <span class=\"hljs-keyword\">async</span></span>) {\n    <span class=\"hljs-keyword\">let</span> query = [];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> data) {\n        query.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-built_in\">encodeURIComponent</span>(key) + <span class=\"hljs-string\">&#x27;=&#x27;</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(data[key]));\n    }\n    ajax.<span class=\"hljs-title function_\">send</span>(url, callback, <span class=\"hljs-string\">&#x27;POST&#x27;</span>, query.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&amp;&#x27;</span>), <span class=\"hljs-keyword\">async</span>)\n};\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JSONP</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong></p>\n<p>带填充的json（p for padding），是一种通常用于绕过浏览器中的跨域选址的方法，因为Ajax不允许跨域请求。</p>\n<p>原理：利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据。</p>\n<p><strong>WHY</strong></p>\n<p>解决跨域（只适用于GET请求）</p>\n<p><strong>HOW</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// jsonp.js</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">jsonp</span>(<span class=\"hljs-params\">{ url, params, cb }</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">let</span> script = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&quot;script&quot;</span>)\n        <span class=\"hljs-variable language_\">window</span>[cb] = <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n            <span class=\"hljs-title function_\">resolve</span>(data)\n            <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">removeChild</span>(script)\n        }\n        params = { ...params, cb }\n        <span class=\"hljs-keyword\">let</span> tmp = []\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> params)\n            tmp.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${ key }</span>=<span class=\"hljs-subst\">${ params[key] }</span>`</span>)\n        script.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${ url }</span>?<span class=\"hljs-subst\">${ tmp.join(<span class=\"hljs-string\">&quot;&amp;&quot;</span>) }</span>`</span>\n    })\n}\n\n<span class=\"hljs-title function_\">jsonp</span>({ \n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&quot;http://localhost:3000/say&quot;</span>,\n    <span class=\"hljs-attr\">params</span>: { <span class=\"hljs-attr\">wd</span>: <span class=\"hljs-string\">&quot;hello jsonp&quot;</span> },\n    <span class=\"hljs-attr\">cb</span>: <span class=\"hljs-string\">&quot;show&quot;</span>\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n})\n\n<span class=\"hljs-comment\">// server.js</span>\n<span class=\"hljs-keyword\">let</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;express&quot;</span>)\n<span class=\"hljs-keyword\">let</span> app = <span class=\"hljs-title function_\">express</span>()\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/say&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">res, res</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">let</span> { wd, cb } = req.<span class=\"hljs-property\">query</span>\n    res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${cb}</span>(&#x27;i am fine, and you?&#x27;)`</span>)\n})\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">变量提升</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>变量提升（hoisting）用于解释代码中变量声明行为的术语。使用<code>var</code>关键字声明或初始化的变量会将声明语句“提升”到当前作用域的顶部。但是只有声明才会触发提升，赋值语句将保持原样。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(foo) <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(foo) <span class=\"hljs-comment\">// 1</span>\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(foo) <span class=\"hljs-comment\">// ReferenceError: bar is not defined</span>\n<span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(foo) <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会提升</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// 函数声明</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(foo)\n<span class=\"hljs-title function_\">foo</span>(); <span class=\"hljs-comment\">// &#x27;foo&#x27;</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(foo); <span class=\"hljs-comment\">// [Function: foo]</span>\n\n<span class=\"hljs-comment\">// 函数表达式</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bar) <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-title function_\">bar</span>(); <span class=\"hljs-comment\">// Uncaught TypeError: bar is not a function</span>\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>)\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bar) <span class=\"hljs-comment\">// [Function: bar]</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件冒泡</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>当一个事件在DOM元素上触发时，如果有时间监听器，它尝试处理该事件，然后事件冒泡到其父级元素，并发生同样的事情，最后直至到达祖先元素。时间冒泡机制是实现事件委托（event delegation）的原理</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">attribute和property</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>attribute是在HTML中定义的，而property实在DOM上定义的。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;input1&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;hello&quot;</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;input1&quot;</span>)\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(input.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&quot;value&quot;</span>)) <span class=\"hljs-comment\">// hello</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(input.<span class=\"hljs-property\">value</span>) <span class=\"hljs-comment\">// hello</span>\n    \n    <span class=\"hljs-comment\">// 当在文本框中输入 ‘world’ 后</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(input.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&quot;value&quot;</span>)) <span class=\"hljs-comment\">// hello</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(input.<span class=\"hljs-property\">value</span>) <span class=\"hljs-comment\">// world</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">document的load事件和DOMContentLoaded事件之间的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>DOMContentLoaded：👍</p>\n<p>当初始的HTML文档本完全加载和解析完成之后，DOMContentLoaded事件被触发而无需等待样式表、图像和子框架的完成加载</p>\n<p>load：</p>\n<p>window的load事件仅在DOM和所有相关资源全部完成加载后才会触发</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;DOMContentLoaded&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;DOMContentLoaded&quot;</span>);\n})\n<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;load&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;window loaded&quot;</span>);\n})\n\n<span class=\"hljs-comment\">// DOMContentLoaded</span>\n<span class=\"hljs-comment\">// window loaded</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">同源策略</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>同源策略是由Netscape提出的一个著名的安全策略，浏览器出于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读取对方的资源。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源的定义:</a></p>\n<p>如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的<strong>源</strong>。我们也可以把它称为“协议/主机/端口 tuple”，或简单地叫做“tuple&quot;. (&quot;tuple&quot; ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元)</p>\n<p>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例:</p>\n<p>| URL                                               | 结果 | 原因         |\n| </p>\n"},{"title":"JavaScript相关-3","tags":["JavaScript"],"categories":"JavaScript","description":"## 执行上下文\n\n### 什么是执行上下文\n\n执行上下文就是当前JavaScript代码被解析和执行时所在环境的抽象概念。JavaScript中任何的代码都是在执行上下文中运行。\n\n执行上下文创建过程中，需要做以下几件事：\n\n1. 创建变量对象：首先初始化函数的参数`arguments`，提升变量声明和函数声明\n2. 创建作用域链（`scope chain`）：在执行上下文的创建阶段，作用域链","createDate":"2020-02-14 23:22:46","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">执行上下文</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是执行上下文</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>执行上下文就是当前JavaScript代码被解析和执行时所在环境的抽象概念。JavaScript中任何的代码都是在执行上下文中运行。</p>\n<p>执行上下文创建过程中，需要做以下几件事：</p>\n<ol>\n<li>创建变量对象：首先初始化函数的参数<code>arguments</code>，提升变量声明和函数声明</li>\n<li>创建作用域链（<code>scope chain</code>）：在执行上下文的创建阶段，作用域链是在变量对象之后创建的</li>\n<li>确定<code>this</code>的值，即<code>resolve thisbinding</code></li>\n</ol>\n<p>每个执行上下文中都有三种重要的属性：</p>\n<ul>\n<li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局执行上下文中访问（函数执行上下文中为AO）</li>\n<li>作用域链（<code>scope chain</code>），JavaScript采用词法作用域，也就是说变量的作用域实在定义的时候就决定了，包含自身变量对象和上级变量对象的列表，通过<code>[[Scope]]</code>属性查找上级变量</li>\n<li><code>this</code></li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">执行上下文的分类</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>全局执行上下文</li>\n<li>函数执行上下文</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">执行栈</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>执行栈，也叫做调用栈，具有LIFO结构，用于存储在代码执行期间创建的所有执行上下文</p>\n<p>有如下规则：</p>\n<ul>\n<li>首次运行JavaScript代码的时候会创建一个全局执行的上下文并push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并push当前执行栈的栈顶</li>\n<li>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中pop，上下文的控制权移动到当前执行栈的下一个执行上下文</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">作用域</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</p>\n<p>作用域有两种工作模型：<strong>词法作用域</strong>和<strong>动态作用域</strong>。JavaScript采用的时<strong>词法作用域</strong>，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">作用域的分类</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>全局作用域</li>\n<li>函数作用域</li>\n<li>块级作用域</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">作用域链</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到全局作用域链</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">变量提升</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>通俗解释：</p>\n<p>将声明的代码移动到了顶部</p>\n<p>准确解释：👍</p>\n<ol>\n<li>在生成执行上下文时，具体步骤是创建VO，JavaScript解释器会找出需要提升的变量和函数，并且给它们提前在内存中开辟好空间，函数的话会将整个函数存入内存，变量之生命并且赋值为<code>undefined</code></li>\n<li>代码执行阶段（可以直接使用变量/函数）</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">防抖</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在一定时间多次触发但内只调用一次</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span> (func, wait = <span class=\"hljs-number\">50</span>, immediate = <span class=\"hljs-literal\">true</span>) {\n  <span class=\"hljs-keyword\">let</span> timer, context, args;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">later</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    timer = <span class=\"hljs-literal\">null</span>\n    <span class=\"hljs-keyword\">if</span> (!immediate) {\n      func.<span class=\"hljs-title function_\">apply</span>(context, args)\n    }\n  }, wait)\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...params</span>) {\n    <span class=\"hljs-keyword\">if</span> (timer) {\n      <span class=\"hljs-built_in\">clearTimeout</span>(timer)\n      timer = <span class=\"hljs-title function_\">later</span>()\n    } <span class=\"hljs-keyword\">else</span> {\n      timer = <span class=\"hljs-title function_\">later</span>()\n      <span class=\"hljs-keyword\">if</span> (immediate) {\n        func.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, params)\n      } <span class=\"hljs-keyword\">else</span> {\n        context = <span class=\"hljs-variable language_\">this</span>\n        args = params\n      }\n    }\n  }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">可迭代对象</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>ES6规定，默认的<code>Iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性上，换个角度，也可以认为一个数据结构只要具有<code>Symbol.iterator</code>属性那么就可以认为其是可迭代的</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">可迭代对象的特点</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>具有<code>Symbol.iterator</code>属性，返回的是一个遍历器对象</li>\n<li>可以使用<code>for...of</code>循环遍历</li>\n<li>可以通过<code>Array.from</code>转换为数组</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">原生具有<code>Iterator</code>接口的数据结构</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>String</li>\n<li>TypedArray</li>\n<li>函数的arguments对象</li>\n<li>NodeList对象</li>\n</ul>\n"},{"title":"JavaScript相关-4","tags":["JavaScript"],"categories":"JavaScript","description":"## 模拟实现call、apply\n\n实现思路：\n\n- 不传入第一个参数，那么默认为`window`\n- 改变了`this`指向，让新对象可以执行该函数，那个思路可以变成给新对象添加一个函数，然后在执行完成之后删除\n\n``` javascript\nFunction.prototype.myCall = function (context) {\n  context = context || wi","createDate":"2020-02-17 22:25:05","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模拟实现call、apply</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>实现思路：</p>\n<ul>\n<li>不传入第一个参数，那么默认为<code>window</code></li>\n<li>改变了<code>this</code>指向，让新对象可以执行该函数，那个思路可以变成给新对象添加一个函数，然后在执行完成之后删除</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myCall</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) {\n  context = context || <span class=\"hljs-variable language_\">window</span>\n  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span>\n  <span class=\"hljs-keyword\">const</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">const</span> result = context.<span class=\"hljs-title function_\">fn</span>(...args)\n  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span>\n  <span class=\"hljs-keyword\">return</span> result\n}\n\n<span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myApply</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">context</span>) {\n  context = context || <span class=\"hljs-variable language_\">window</span>\n  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span>\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>] ? context.<span class=\"hljs-title function_\">fn</span>(...<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]) : context.<span class=\"hljs-title function_\">fn</span>()\n  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span>\n  <span class=\"hljs-keyword\">return</span> result\n}\n\n<span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myBind</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">context</span>) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>)\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&quot;error&quot;</span>)\n  <span class=\"hljs-keyword\">const</span> that = <span class=\"hljs-variable language_\">this</span>\n  <span class=\"hljs-keyword\">const</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span> <span class=\"hljs-keyword\">instanceof</span> F) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">that</span>(...args, ...<span class=\"hljs-variable language_\">arguments</span>)\n    }\n    <span class=\"hljs-keyword\">return</span> that.<span class=\"hljs-title function_\">apply</span>(context, args.<span class=\"hljs-title function_\">concat</span>(...<span class=\"hljs-variable language_\">arguments</span>))\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> tom = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n  say (tmp1, tmp2) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>, tmp1, tmp2);\n  }\n}\n<span class=\"hljs-keyword\">const</span> jack = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;jack&quot;</span>\n}\n\ntom.<span class=\"hljs-property\">say</span>.<span class=\"hljs-title function_\">myCall</span>(jack, <span class=\"hljs-string\">&quot;111&quot;</span>, <span class=\"hljs-string\">&quot;222&quot;</span>)\ntom.<span class=\"hljs-property\">say</span>.<span class=\"hljs-title function_\">call</span>(jack, <span class=\"hljs-string\">&quot;111&quot;</span>, <span class=\"hljs-string\">&quot;222&quot;</span>)\n\ntom.<span class=\"hljs-property\">say</span>.<span class=\"hljs-title function_\">myApply</span>(jack, [<span class=\"hljs-string\">&quot;111&quot;</span>, <span class=\"hljs-string\">&quot;222&quot;</span>])\ntom.<span class=\"hljs-property\">say</span>.<span class=\"hljs-title function_\">apply</span>(jack, [<span class=\"hljs-string\">&quot;111&quot;</span>, <span class=\"hljs-string\">&quot;222&quot;</span>])\n\ntom.<span class=\"hljs-property\">say</span>.<span class=\"hljs-title function_\">myBind</span>(jack)(<span class=\"hljs-string\">&quot;111&quot;</span>, <span class=\"hljs-string\">&quot;222&quot;</span>)\ntom.<span class=\"hljs-property\">say</span>.<span class=\"hljs-title function_\">bind</span>(jack)(<span class=\"hljs-string\">&quot;111&quot;</span>, <span class=\"hljs-string\">&quot;222&quot;</span>)\n\n<span class=\"hljs-comment\">// jack 111 222</span>\n<span class=\"hljs-comment\">// jack 111 222</span>\n<span class=\"hljs-comment\">// jack 111 222</span>\n<span class=\"hljs-comment\">// jack 111 222</span>\n<span class=\"hljs-comment\">// jack 111 222</span>\n<span class=\"hljs-comment\">// jack 111 222</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise 实现</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>Promise</code>是ES6新增的语法，解决了回调地狱的问题。可以把<code>Promise</code>看作是一个状态机，可以通过函数<code>resolve</code>和<code>reject</code>将状态转变为<code>resolved</code>或<code>rejected</code>，状态一旦转变就不能再次变化</p>\n<p><code>then</code>函数会返回一个新的<code>Promise</code>实例。因为<code>Promise</code>规范规定除了<code>pending</code>状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个<code>then</code>调用就失去意义了</p>\n<p>对于<code>then</code>，本质上可以把它看成是<code>flatMap</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Proxy</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>proxy是ES6中新增的功能，用来定义对象中的操作</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onwatch</span>(<span class=\"hljs-params\">obj, setBind, getLogger</span>) {\n  <span class=\"hljs-keyword\">const</span> handler = {\n    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, property, receiver</span>) {\n      <span class=\"hljs-title function_\">getLogger</span>(target, property)\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, property, receiver)\n    },\n    <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">target, property, value</span>) {\n      <span class=\"hljs-title function_\">setBind</span>(target, property, value)\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, property, value)\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, handler)\n}\n\n<span class=\"hljs-keyword\">let</span> obj = { <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> }\n<span class=\"hljs-keyword\">let</span> p = <span class=\"hljs-title function_\">onwatch</span>(obj, <span class=\"hljs-function\">(<span class=\"hljs-params\">target, property, value</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`set <span class=\"hljs-subst\">${ property }</span> = <span class=\"hljs-subst\">${ value }</span>`</span>);\n}, <span class=\"hljs-function\">(<span class=\"hljs-params\">target, property</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`get <span class=\"hljs-subst\">${ property }</span> = <span class=\"hljs-subst\">${ target[property] }</span>`</span>);\n})\n\np.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">a</span>);\n\n<span class=\"hljs-comment\">// set a = 2</span>\n<span class=\"hljs-comment\">// get a = 2</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">正则表达式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>元字符</strong></p>\n<p>| 元字符 |             作用             |\n| :</p>\n"},{"title":"MySQL-视图","tags":["MySQL","视图"],"categories":"MySQL","description":"# MySQL-视图\n## 什么是视图\n- 视图是由查询结果形成的一张**虚拟表**，可以当作一张表使用，但与持久表(permanent table)不同的是，视图中的数据**没有实际的物理存储**。\n\n## 视图的作用\n- 视图在一定程度上起到一个**安全层**的作用，可以进行**权限控制**\n- **简化查询**语句\n- 对于某张很大的表，可以将其分为多个视图，从而**加快查询**\n\n##","createDate":"2018-11-13 16:56:59","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">MySQL-视图</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是视图</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>视图是由查询结果形成的一张<strong>虚拟表</strong>，可以当作一张表使用，但与持久表(permanent table)不同的是，视图中的数据<strong>没有实际的物理存储</strong>。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">视图的作用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>视图在一定程度上起到一个<strong>安全层</strong>的作用，可以进行<strong>权限控制</strong></li>\n<li><strong>简化查询</strong>语句</li>\n<li>对于某张很大的表，可以将其分为多个视图，从而<strong>加快查询</strong></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">视图的使用条件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>如果某个查询结果出现的非常频繁，就是要经常那这个查询结果来做<strong>子查询</strong>，使用视图会更加方便</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">视图的基本操作</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><strong>创建视图</strong>：\n``` SQL\nCREATE\n[OR REPLACE]\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n[DEFINER = { user | CURRENT_USER }]\n[SQL SECURITY { DEFINER | INVOKER }]\nVIEW view_name [(column_list)]\nAS select_statement\n[WITH [CASCADED | LOCAL] CHECK OPTION]</li>\n</ul>\n<p>CREATE OR REPLACE VIEW view_name AS SELECT * FROM table_name</p>\n<pre><code>- **调取视图**\n``` SQL\nSELECT * FROM view_name\n</code></pre>\n<ul>\n<li><strong>修改视图</strong>\n``` SQL\nALTER\n[ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n[DEFINER = { user | CURRENT_USER }]\n[SQL SECURITY { DEFINER | INVOKER }]\nVIEW view_name [(column_list)]\nAS select_statement\n[WITH [CASCADED | LOCAL] CHECK OPTION]</li>\n</ul>\n<p>ALTER OR REPLACE VIEW view_name AS SELECT * FROM table_name</p>\n<pre><code>- **删除视图**\n``` SQL\nDROP VIEW IF EXISTS view_name\n</code></pre>\n<ul>\n<li><strong>查看视图</strong><pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">SHOW</span> TABLES;\n</code></pre>\n</li>\n<li><strong>查看视图的定义</strong><pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">TABLE</span> STATUS <span class=\"hljs-keyword\">FROM</span> table_name <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;view_name&#x27;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">视图的算法--存在两种执行的算法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    </li>\n<li>MERGE：<strong>合并模式</strong>，先将我们视图的SQL语句与外部查询视图的SQL语句，混合在一起，最终执行，也就是可以<strong>更新</strong>真实表中的数据。</li>\n<li>TEMPTABLE：<strong>临时表模式</strong>，每当查询的时候，将视图所使用的SELECT语句生成一个结果的临时表，再在当前的临时表内进行查询。</li>\n<li>UNDEFINED： 让MySQL选择所要使用的算法。如果可能，它<strong>倾向于MERGE</strong>而不是TEMPTABLE，这是因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">视图与表的关系</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>虽然视图是基于表的一个虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基表。一般称进行更新操作的视图为可更新视图(updatable view)。视图定义中的<strong>WITH CHECK OPTION</strong>就是针对于可更新表的。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WITH CHECK OPTION测试代码</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-SQL\"># 创建视图（<span class=\"hljs-keyword\">WITHOUT</span> <span class=\"hljs-keyword\">CHECK</span> OPTION）\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> REPLACE <span class=\"hljs-keyword\">VIEW</span> user_info_v <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> id <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-number\">10</span>\n# 查看视图（基表 <span class=\"hljs-operator\">+</span> 视图）\n<span class=\"hljs-keyword\">SHOW</span> TABLES\n# 只查看基表\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> information_schema.TABLES <span class=\"hljs-keyword\">WHERE</span> table_type <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;BASE TABLE&#x27;</span> <span class=\"hljs-keyword\">AND</span> table_schema <span class=\"hljs-operator\">=</span> database()\\G\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> user_info_v <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&#x27;lisi&#x27;</span>, <span class=\"hljs-string\">&#x27;5678&#x27;</span>\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> user_info_v <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;wangwu&#x27;</span>, <span class=\"hljs-string\">&#x27;9012&#x27;</span>\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info_v\n\n# 删除视图\n<span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">VIEW</span> IF <span class=\"hljs-keyword\">EXISTS</span> user_info_v;\n\n# 创建视图（<span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">CHECK</span> OPTION）\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> REPLACE <span class=\"hljs-keyword\">VIEW</span> user_info_v <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> id <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">CHECK</span> OPTION\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> user_info_v <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-number\">13</span>, <span class=\"hljs-string\">&#x27;zhaoliu&#x27;</span>, <span class=\"hljs-string\">&#x27;3456&#x27;</span>\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/13/JSO1Dr.png\" alt=\"enter image description here\">\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-13/37805165.jpg\" alt=\"enter image description here\">\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-13/67280010.jpg\" alt=\"enter image description here\">\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-13/47500056.jpg\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">视图的作用测试代码</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-SQL\">DELIMITER <span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">PROCEDURE</span> view_test(_cnt <span class=\"hljs-type\">INT</span> UNSIGNED)\n<span class=\"hljs-keyword\">BEGIN</span>\n    <span class=\"hljs-keyword\">SET</span> <span class=\"hljs-variable\">@cnt</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    WHILE <span class=\"hljs-variable\">@cnt</span> <span class=\"hljs-operator\">&lt;</span> _cnt DO\n        <span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> user_info(user_name, user_pwd) <span class=\"hljs-keyword\">values</span>(REPEAT(<span class=\"hljs-type\">CHAR</span>(<span class=\"hljs-number\">97</span><span class=\"hljs-operator\">+</span>RAND()<span class=\"hljs-operator\">*</span><span class=\"hljs-number\">26</span>), <span class=\"hljs-number\">20</span>), REPEAT(<span class=\"hljs-type\">CHAR</span>(<span class=\"hljs-number\">97</span><span class=\"hljs-operator\">+</span>RAND()<span class=\"hljs-operator\">*</span><span class=\"hljs-number\">26</span>), <span class=\"hljs-number\">20</span>));\n        <span class=\"hljs-keyword\">SET</span> <span class=\"hljs-variable\">@cnt</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">@cnt</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">END</span> WHILE;\n<span class=\"hljs-keyword\">END</span>;\n<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\nDELIMITER ;\n\n<span class=\"hljs-keyword\">call</span> view_test(<span class=\"hljs-number\">10000</span>);\n<span class=\"hljs-keyword\">call</span> view_test(<span class=\"hljs-number\">50000</span>);\n<span class=\"hljs-keyword\">call</span> view_test(<span class=\"hljs-number\">50000</span>);\n\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> REPLACE <span class=\"hljs-keyword\">VIEW</span> view_func_test0 <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> id <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">CHECK</span> OPTION;\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> REPLACE <span class=\"hljs-keyword\">VIEW</span> view_func_test1 <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> id <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">CHECK</span> OPTION;\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> REPLACE <span class=\"hljs-keyword\">VIEW</span> view_func_test2 <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> id <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">CHECK</span> OPTION;\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">OR</span> REPLACE <span class=\"hljs-keyword\">VIEW</span> view_func_test3 <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> id <span class=\"hljs-operator\">%</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">CHECK</span> OPTION;\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/13/JSWxYv.png\" alt=\"enter image description here\"></p>\n"},{"title":"MySQL-触发器","tags":["MySQL","触发器"],"categories":"数据库 MySQL","description":"# MySQL-触发器\n## 什么是触发器\n- 触发器是一种**特殊的存储过程**，它在插入/删除或修改表中的数据时**触发执行**，它比数据库本身有着更精细和更复杂的数据约束力。\n\n## 触发器的作用\n- 用于实现完整性约束\n- 通过触发器，用户可以实现MySQL数据库本身并不支持的一些特性，如对于传统CHECK约束的支持，物化视图，高级复制，审计等特性\n\n## 触发器的特性\n- 监视地点：一","createDate":"2018-11-13 22:51:06","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">MySQL-触发器</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是触发器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>触发器是一种<strong>特殊的存储过程</strong>，它在插入/删除或修改表中的数据时<strong>触发执行</strong>，它比数据库本身有着更精细和更复杂的数据约束力。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">触发器的作用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>用于实现完整性约束</li>\n<li>通过触发器，用户可以实现MySQL数据库本身并不支持的一些特性，如对于传统CHECK约束的支持，物化视图，高级复制，审计等特性</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">触发器的特性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>监视地点：一般就是某一张表</li>\n<li>监视/触发事件：UPDATE/INSERT/DELETE</li>\n<li>触发时间：AFTER/BEFORE</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">触发器的创建语法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">CREATE</span>\n[DEFINER <span class=\"hljs-operator\">=</span> { <span class=\"hljs-keyword\">user</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-built_in\">CURRENT_USER</span> }]\n<span class=\"hljs-keyword\">TRIGGER</span> trigger_name\ntrigger_time trigger_event\n<span class=\"hljs-keyword\">ON</span> tbl_name <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">EACH</span> <span class=\"hljs-type\">ROW</span>\ntrigger_body\n\ntrigger_time: { BEFORE <span class=\"hljs-operator\">|</span> AFTER }\ntrigger_event: { <span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">DELETE</span> }\n</code></pre>\n<ul>\n<li>触发程序是与表有关的数据库对象，当表上出现特定事件时将激活该对象。触发程序与tbl_name相关，tbl_name必须引用永久性表，不能将触发程序与TEMPORARY表或视图关联起来。</li>\n<li>对于具有相同触发程序动作事件和时间的给定表，不能有两个触发程序。</li>\n<li>trigger_body是当触发程序激活时执行的语句。可以使用BEGIN...END复合语句结构。</li>\n<li>对于INSERT而言，新插入的行用NEW表示，行中的每一列值用NEW.col_name表示。</li>\n<li>对于DELETE而言，欲删除的那一行用OLD表示，行中的每一列值用OLD.col_name表示。</li>\n<li>对于UPDATE而言，修改前的行用OLD表示，修改后的行用NEW表示。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">触发器的管理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>查看所有触发器<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">SHOW</span> TRIGGERS [<span class=\"hljs-keyword\">FROM</span> db_name] [like_or_where]\n</code></pre>\n</li>\n<li>MySQL中有一个information_schema.TRIGGERS表，存储所有库中的触发器，查看：<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">DESC</span> information_schema.TRIGGERS\n</code></pre>\n</li>\n<li>删除触发器<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">VIEW</span> [IF <span class=\"hljs-keyword\">EXISTS</span>]\nview_name [, view_name] ...\n[RESTRICT <span class=\"hljs-operator\">|</span> CASCADE]\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">触发器的使用示例</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基本使用</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-SQL\">DELIMITER <span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TRIGGER</span> user_trg\nAFTER <span class=\"hljs-keyword\">INSERT</span>\n<span class=\"hljs-keyword\">ON</span> user_info <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">EACH</span> <span class=\"hljs-type\">ROW</span>\n<span class=\"hljs-keyword\">BEGIN</span>\n   <span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> user_salaries <span class=\"hljs-keyword\">SELECT</span> new.id, new.user_name, <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">END</span>;\n<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\nDELIMITER;\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> user_info <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;张三&#x27;</span>， <span class=\"hljs-string\">&#x27;123456&#x27;</span>;\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/13/JS7x7L.png\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对于约束的支持</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> userCash(id <span class=\"hljs-type\">INT</span> UNSIGNED <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT <span class=\"hljs-keyword\">PRIMARY</span> KEY, \n                       cash <span class=\"hljs-type\">INT</span> UNSIGNED <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-number\">0</span>\n)ENGINE <span class=\"hljs-operator\">=</span> INNODB CHARSET <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;UTF8&#x27;</span>;\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> userCashErr_log (\n    id <span class=\"hljs-type\">INT</span> UNSIGNED <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT <span class=\"hljs-keyword\">PRIMARY</span> KEY,\n    old_cash <span class=\"hljs-type\">INT</span> UNSIGNED <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    new_cash <span class=\"hljs-type\">INT</span> UNSIGNED <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n    user_name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">20</span>),\n    <span class=\"hljs-type\">time</span> DATETIME\n)ENGINE <span class=\"hljs-operator\">=</span> INNODB CHARSET <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;UTF8&#x27;</span>;\n\nDELIMITER <span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TRIGGER</span> userCashUpdate_tgr \nBEFORE <span class=\"hljs-keyword\">UPDATE</span>\n<span class=\"hljs-keyword\">ON</span> userCash <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-keyword\">EACH</span> <span class=\"hljs-type\">ROW</span>\n<span class=\"hljs-keyword\">BEGIN</span>\n    IF new.cash <span class=\"hljs-operator\">-</span> old.cash <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">THEN</span>\n        <span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> userCashErr_log <span class=\"hljs-keyword\">SELECT</span> old.id, old.cash, new.cash, <span class=\"hljs-keyword\">USER</span>(), NOW();\n        <span class=\"hljs-keyword\">SET</span> new.cash <span class=\"hljs-operator\">=</span> old.cash;\n    <span class=\"hljs-keyword\">END</span> IF;\n<span class=\"hljs-keyword\">END</span>;\n<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\nDELIMITER ;\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> userCash <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10000</span>;\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> userCashErr_log;\n<span class=\"hljs-keyword\">UPDATE</span> userCash <span class=\"hljs-keyword\">SET</span> cash <span class=\"hljs-operator\">=</span> cash <span class=\"hljs-operator\">-</span> (<span class=\"hljs-number\">-20</span>) <span class=\"hljs-keyword\">WHERE</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> userCashErr_log;\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/13/JS7T9W.png\" alt=\"enter image description here\"></p>\n"},{"title":"MySQL-锁","tags":["MySQL"],"categories":"MySQL","description":"# MySQL-锁\n\n## 什么是锁\n- 锁机制用于管理对共享资源的并发访问\n\n## lock与latch\n- latch一般称为闩锁（轻量级的锁） ， 因为其要求锁定的时间必须非常短。 若持续的时间长， 则应用的性能会非常差。 在InnoDB存储引擎中， latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目是用来保证并发线程操作临界资源的正确性， 并且通常没有死锁检测的机制。","createDate":"2018-11-14 21:17:51","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">MySQL-锁</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是锁</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>锁机制用于管理对共享资源的并发访问</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">lock与latch</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>latch一般称为闩锁（轻量级的锁） ， 因为其要求锁定的时间必须非常短。 若持续的时间长， 则应用的性能会非常差。 在InnoDB存储引擎中， latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目是用来保证并发线程操作临界资源的正确性， 并且通常没有死锁检测的机制。</li>\n<li>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。</li>\n</ul>\n<p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/84119853.jpg\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">InnoDB存储引擎中的锁</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">锁的类型</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>共享锁（S Lock），允许事务读一行数据</li>\n<li>排他锁（X Lock），允许事务删除或更新一行数据</li>\n<li>意向锁（Intention Lock）是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁。对最细粒度的对象进行上锁， 那么首先需要对粗粒度的对象上锁。\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">各种锁之间的兼容性</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/91462658.jpg\" alt=\"enter image description here\">\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">三张表</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    </li>\n<li>INNODB_TRX显示了当前运行的InnoDB事务</li>\n<li>INNODB_LOCKS查看锁</li>\n<li>INNODB_LOCK_WAITS可以很直观地反映当前事务的等待</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一致性非锁定读</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>一致性的非锁定读（consistent nonlocking read） 是指InnoDB存储引擎通过行多版本控制（multi versioning） 的方式来读取当前执行时间数据库中行的数据。 如果读取的行正在执行DELETE或UPDATE操作， 这时读取操作不会因此去等待行上锁的释放。 相反地，InnoDB存储引擎会去读取行的一个快照数据。非锁定读机制大大地提高了数据库的并发性。\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/66097705.jpg\" alt=\"enter image description here\">\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注意</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    </li>\n<li>在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据(<strong>违反了隔离性</strong>)。 而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一致性锁定读</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">自增长与锁</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    \n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">概述</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <ul>\n<li>插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称做AUTO-INC Locking。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放。</li>\n<li>虽然AUTO-INC Locking从一定程度上提高了并发插入的效率， 但还是存在一些性能上的问题。 首先， 对于有自增长值的列的并发插入性能较差， 事务必须等待前一个插入的完成（虽然不用等待事务的完成） 。 其次， 对于INSERT…SELECT的大数据量的插入会影响插入的性能， 因为另一个事务中的插入会被阻塞。</li>\n</ul>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">自增长的模式</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <ul>\n<li>参数innodb_autoinc_lock_mode来控制自增长的模式\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/49495821.jpg\" alt=\"enter image description here\">\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/26079309.jpg\" alt=\"enter image description here\"></li>\n</ul>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注意</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <ul>\n<li>在InnoDB存储引擎中， 自增长值的列必须是索引， 同时必须是索引的第一个列。 如果不是第一个列， 则MySQL数据库会抛出异常， 而MyISAM存储引擎没有这个问题。\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/60316580.jpg\" alt=\"enter image description here\"></li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">外键与锁</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT父表。但是对于父表的SELECT操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此这时使用的是SELECT…LOCK IN SHARE MODE方式，即主动对父表加一个S锁。如果这时父表上已经这样加X锁，子表上的操作会被阻塞。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">锁的算法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">行锁的三种算法</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>Record Lock：单个行记录上的锁。</li>\n<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li>\n<li>Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注意</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身， 而不是范围。</li>\n<li>在InnoDB存储引擎中， 对于INSERT的操作， 其会检查插入记录的下一条记录是否被锁定， 若已经被锁定， 则不允许查询。</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解决phantom problem--针对其他提交前后，读取数据条数的对比</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回<strong>之前不存在的行，违反了事务的隔离性</strong>。</li>\n<li>InnoDB存储引擎采用Next-Key Locking的算法避免Phantom Problem。</li>\n</ul>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">幻影读示例</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/92904378.jpg\" alt=\"enter image description here\"></p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解决幻影读</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/19298541.jpg\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">锁问题</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>深入理解脏读/幻影读/不可重复读/丢失更新的区别：<a href=\"https://www.cnblogs.com/Hakuna-Matata/p/7772794.html\">https://www.cnblogs.com/Hakuna-Matata/p/7772794.html</a></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">脏读--针对未提交数据</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    \n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">脏页</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <ul>\n<li>脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘中的页的数据是不一致的。</li>\n</ul>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">脏数据</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <ul>\n<li>脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。</li>\n</ul>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">脏读</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <ul>\n<li>脏读指的就是在不同的事务下， 当前事务可以<strong>读到另外事务未提交的数据</strong>， 简单来说就是可以读到脏数据。</li>\n<li>对于脏页的读取，是非常正常的，但如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，则显然<strong>违反了数据库的隔离性</strong>。脏读发生的条件是需要事务的隔离级别为READ UNCOMMITTED。</li>\n<li>脏读隔离看似毫无用处， 但在一些比较特殊的情况下还是可以将事务的隔离级别设置为READ UNCOMMITTED。 例如replication环境中的slave节点， 并且在该slave上的查询并\n不需要特别精确的返回值。</li>\n</ul>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">脏读示例</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/27843486.jpg\" alt=\"enter image description here\"></p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解决脏读</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/90598726.jpg\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">不可重复读--针对其他提交前后，读取数据本身的对比</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些<strong>DML操作</strong>。这样就发生了在一个事务内两次读到的数据是不一样。</li>\n<li>在InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。</li>\n<li>不可重复读和脏读的区别是： 脏读是读到未提交的数据， 而不可重复读读到的却是已经提交的数据， 但是其<strong>违反了数据库事务一致性</strong>的要求。</li>\n<li>一般来说， 不可重复读的问题是可以接受的， 因为其读到的是已经提交的数据， 本身并不会带来很大的问题。 因此， 很多数据库厂商（如Oracle、 Microsoft SQL Server） 将其数据库事务的默认隔离级别设置为READ COMMITTED， 在这种隔离级别下允许不可重复读的现象。</li>\n<li>在InnoDB存储引擎中， 通过使用<strong>Next-Key Lock</strong>算法来避免不可重复读的问题。 在NextKey Lock算法下， 对于索引的扫描， 不仅是锁住扫描到的索引， 而且还锁住这些索引覆盖的范围（gap） 。 因此在这个范围内的插入都是不允许的。 这样就避免了另外的事务在这个范围内插入数据导致的不可重复读的问题。 因此， InnoDB存储引擎的默认事务隔离级别是READ REPEATABLE， 采用Next-Key Lock算法， 避免了不可重复读的现象。</li>\n</ul>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">不可重复读示例</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/61438726.jpg\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">丢失更新</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>丢失更新是另一个锁导致的问题，简单来说其就是一个事务的更新操作会被另一个事\n务的更新操作所<strong>覆盖</strong>，从而导致数据的不一致。</li>\n<li>要避免丢失更新， 需要让事务在这种情况下的操作变成<strong>串行化</strong>。</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结--<strong>仅供参考</strong></span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/33516594.jpg\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">阻塞</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>在默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。其实InnoDB存储引擎在大部分情况下都不会对异常进行回滚。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">死锁</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">死锁的概念及解决</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行.</li>\n<li>当前数据库还都普遍采用wait-for graph（等待图）的方式来进行死锁检测：</li>\n<li>锁的信息链表</li>\n<li>事务等待链表</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">死锁概率</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>事务发生死锁的概率与以下几点因素有关：</li>\n<li>系统中事务的数量（n） ， 数量越多发生死锁的概率越大。</li>\n<li>每个事务操作的数量（r） ， 每个事务操作的数量越多， 发生死锁的概率越大。</li>\n<li>操作数据的集合（R） ， 越小则发生死锁的概率越大。</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">死锁示例</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/71303703.jpg\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">锁升级</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>锁升级（Lock Escalation）是指将当前锁的粒度降低(减少开销)</li>\n<li>InnoDB存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。</li>\n</ul>\n"},{"title":"MySQL高级-函数","tags":["tags"],"categories":"数据库 MySQL","description":"# MySQL高级-函数\n\n@(mysql)[procedure]\n\n## **查看数据库是否支持函数** ：\n``` SQL\nSHOW VARIABLES LIKE '%FUN%';\n```\n- **若为off，则需要开启**\n``` SQL\nSET GLOBAL log_bin_trust_function_creators = TRUE;\n```\n\n### **创建函数的语法** ：\n``","createDate":"2018-11-12 20:12:37","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">MySQL高级-函数</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>@(mysql)[procedure]</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>查看数据库是否支持函数</strong> ：</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">SHOW</span> VARIABLES <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%FUN%&#x27;</span>;\n</code></pre>\n<ul>\n<li><strong>若为off，则需要开启</strong><pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">SET</span> <span class=\"hljs-keyword\">GLOBAL</span> log_bin_trust_function_creators <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">TRUE</span>;\n</code></pre>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>创建函数的语法</strong> ：</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">FUNCTION</span> func_name(variable1, variable2 ...)\n<span class=\"hljs-keyword\">RETURNS</span> return_type\n<span class=\"hljs-keyword\">BEGIN</span>\n    ...\n<span class=\"hljs-keyword\">END</span>;\n\nDELIMITER <span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">FUNCTION</span> func_add(a <span class=\"hljs-type\">INT</span>, b <span class=\"hljs-type\">INT</span>)\n<span class=\"hljs-keyword\">RETURNS</span> <span class=\"hljs-type\">INT</span>\n<span class=\"hljs-keyword\">BEGIN</span>\n    <span class=\"hljs-keyword\">RETURN</span> a <span class=\"hljs-operator\">+</span> b;\n<span class=\"hljs-keyword\">END</span>;\n<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\n</code></pre>\n<p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-12/68702030.jpg\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>函数的管理</strong> ：</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><strong>函数的管理类似于存储过程</strong>\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>查看函数</strong></span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> mysql.proc;\n<span class=\"hljs-keyword\">SHOW</span> <span class=\"hljs-keyword\">FUNCTION</span> STATUS <span class=\"hljs-keyword\">WHERE</span> db <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;test&#x27;</span>;\n</code></pre>\n<img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-12/68702030.jpg\" alt=\"enter image description here\">\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>删除函数</strong></span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">FUNCTION</span> IF <span class=\"hljs-keyword\">EXISTS</span> func_add;\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">实例：</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    </li>\n</ul>\n<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> user_info (id <span class=\"hljs-type\">INT</span> UNSIGNED <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> AUTO_INCREMENT <span class=\"hljs-keyword\">PRIMARY</span> KEY,\n                        user_name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-string\">&#x27;&#x27;</span>,\n                        user_pwd  <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-string\">&#x27;&#x27;</span>\n                        )ENGINE <span class=\"hljs-operator\">=</span> INNODB CHARSET <span class=\"hljs-operator\">=</span> utf8;\n                         \n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">FUNCTION</span> func_login(name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">20</span>), pwd <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">20</span>))\n<span class=\"hljs-keyword\">RETURNS</span> <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">30</span>)\n<span class=\"hljs-keyword\">BEGIN</span>\n    <span class=\"hljs-keyword\">DECLARE</span> cnt <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">INTO</span> cnt <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> user_name <span class=\"hljs-operator\">=</span> name;\n    IF cnt <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">THEN</span>\n        <span class=\"hljs-keyword\">RETURN</span> <span class=\"hljs-string\">&#x27;user not exists&#x27;</span>;\n    <span class=\"hljs-keyword\">END</span> IF;\n    <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">INTO</span> cnt <span class=\"hljs-keyword\">FROM</span> user_info <span class=\"hljs-keyword\">WHERE</span> user_name <span class=\"hljs-operator\">=</span> name <span class=\"hljs-keyword\">AND</span> user_pwd <span class=\"hljs-operator\">=</span> pwd;\n    IF cnt <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">THEN</span>\n        <span class=\"hljs-keyword\">RETURN</span> <span class=\"hljs-string\">&#x27;pwd input error&#x27;</span>;\n    <span class=\"hljs-keyword\">ELSE</span>\n        <span class=\"hljs-keyword\">RETURN</span> <span class=\"hljs-string\">&#x27;user login success&#x27;</span>;\n    <span class=\"hljs-keyword\">END</span> IF;\n<span class=\"hljs-keyword\">END</span>;\n<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\n</code></pre>\n<p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-12/35546849.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"MySQL高级-存储过程管理","tags":["MySQL","存储过程"],"categories":"MySQL","description":"# MySQL高级-存储过程管理\n\n@(mysql)[procedure]\n\n- **查看数据库的存储过程** ：\n``` SQL\nshow procedure status where db='test'\\G\n```\n- ![enter image description here](https://i.loli.net/2018/11/12/5be94f5043e82.png)\n\n- **查","createDate":"2018-11-12 17:07:28","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">MySQL高级-存储过程管理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>@(mysql)[procedure]</p>\n<ul>\n<li><p><strong>查看数据库的存储过程</strong> ：</p>\n<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">procedure</span> status <span class=\"hljs-keyword\">where</span> db<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;test&#x27;</span>\\G\n</code></pre>\n</li>\n<li><p><img src=\"https://i.loli.net/2018/11/12/5be94f5043e82.png\" alt=\"enter image description here\"></p>\n</li>\n<li><p><strong>查看当前数据库下的存储过程</strong> ：</p>\n<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">select</span> specific_name <span class=\"hljs-keyword\">from</span> mysql.proc;\\G\n</code></pre>\n</li>\n<li><p><img src=\"https://i.loli.net/2018/11/12/5be94ee471819.png\" alt=\"enter image description here\"></p>\n</li>\n<li><p><strong>查看存储过程的内容</strong> ：</p>\n<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">select</span> specific_name, body <span class=\"hljs-keyword\">from</span> mysql.proc\\G\n</code></pre>\n</li>\n<li><p><img src=\"https://i.loli.net/2018/11/12/5be94f5050259.png\" alt=\"enter image description here\"></p>\n</li>\n<li><p><strong>查看某个存储过程的内容</strong>：</p>\n<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">select</span> specific_name, body <span class=\"hljs-keyword\">from</span> mysql.proc <span class=\"hljs-keyword\">where</span> specific_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;load_t&#x27;</span>\\G\n</code></pre>\n</li>\n<li><p><img src=\"https://i.loli.net/2018/11/12/5be94f504e883.png\" alt=\"enter image description here\"></p>\n</li>\n<li><p><strong>删除某个存储过程</strong></p>\n<pre><code class=\"hljs language-SQL\"><span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">procedure</span> if <span class=\"hljs-keyword\">exists</span> load_t;\n</code></pre>\n</li>\n<li><p><img src=\"https://i.loli.net/2018/11/12/5be94f504cd4b.png\" alt=\"enter image description here\"></p>\n</li>\n</ul>\n"},{"title":"Node.js-基础","tags":["Node.js"],"categories":"Node.js","description":"# [Buffer](http://nodejs.cn/api/buffer.html)\nJS自身只能只有字符串数据类型，没有二进制数据类型，因此nodejs提供了一个与string对等的全局构造函数Buffer来提供对二进制数据的操作\n- `Buffer.form` 创建一个buffer\n    ``` javascript\n    Buffer.form([ 0x68, 0x65, 0x6","createDate":"2020-01-14 14:11:45","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"http://nodejs.cn/api/buffer.html\">Buffer</a></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>JS自身只能只有字符串数据类型，没有二进制数据类型，因此nodejs提供了一个与string对等的全局构造函数Buffer来提供对二进制数据的操作</p>\n<ul>\n<li><code>Buffer.form</code> 创建一个buffer<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title class_\">Buffer</span>.<span class=\"hljs-title function_\">form</span>([ <span class=\"hljs-number\">0x68</span>, <span class=\"hljs-number\">0x65</span>, <span class=\"hljs-number\">0x6c</span>, <span class=\"hljs-number\">0x6c</span>, <span class=\"hljs-number\">0x6f</span> ]).<span class=\"hljs-title function_\">toString</span>()\n<span class=\"hljs-comment\">// hello</span>\n</code></pre>\n</li>\n<li><code>Burrer</code>与<code>String</code>的一个重要区别就是字符串时只读的，并且对于字符串的任何修改得到的都是一个新的字符串，源字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组，例如，可以使用<code>[index]</code>方式直接修改某个位置的字节</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"http://nodejs.cn/api/stream.html\">Stream</a></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> rs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">copy</span> (src, dst) {\n    fs.<span class=\"hljs-title function_\">createReadStream</span>(src).<span class=\"hljs-title function_\">pipe</span>(fs.<span class=\"hljs-title function_\">createWriteSreeam</span>(dst));\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">main</span> (argv) {\n    <span class=\"hljs-title function_\">copy</span>(argv[<span class=\"hljs-number\">0</span>], argv[<span class=\"hljs-number\">1</span>])\n}\n\n<span class=\"hljs-title function_\">main</span>(process.<span class=\"hljs-property\">argv</span>.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">2</span>));\n</code></pre>\n</li>\n<li><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<a href=\"http://nodejs.cn/api/events.html#events_class_eventemitter\"><code>EventEmitter</code></a></li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"http://nodejs.cn/api/fs.html\">File System</a></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>NodeJS通过<code>fs</code>内置模块提供对文件的操作，<code>fs</code>模块提供的API基本上可以分为以下三类：</p>\n<ul>\n<li>文件属性读\n其中常见的有<code>fs.state</code> <code>fs.chmod</code> <code>fs.chown</code></li>\n<li>文件属性写\n其中常见的有<code>fs.readFile</code> <code>fs.readdir</code> <code>fs.writeFile</code> <code>fs.mkdir</code></li>\n<li>底层文件操作\n其中常见的操作有<code>fs.open</code> <code>fs.read</code> <code>fs.write</code> <code>fs.close</code>\n所有的<code>fs</code>模块API的回调参数都有两个，第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果<pre><code class=\"hljs language-javascript\">fs.<span class=\"hljs-title function_\">readFile</span>(pathname, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) {\n    <span class=\"hljs-keyword\">if</span> (err) {}\n    <span class=\"hljs-keyword\">else</span> {}\n})\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"http://nodejs.cn/api/path.html\">Path</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>操作文件时难免不与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。</p>\n<ul>\n<li><code>path.normalize</code>\n  将传入的参数转为标准路径，具体讲的话，除了解析路径中的<code>.</code>与<code>..</code>外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> cache = {}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">store</span> () {\n    cache[path.<span class=\"hljs-title function_\">normalize</span>(key)] = value\n}\n\n<span class=\"hljs-title function_\">store</span>(<span class=\"hljs-string\">&#x27;foo/bar&#x27;</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-title function_\">store</span>(<span class=\"hljs-string\">&#x27;foo//baz//../bar&#x27;</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(cache);  <span class=\"hljs-comment\">// =&gt; { &quot;foo/bar&quot;: 2 }</span>\n</code></pre>\n  标准化之后的路径里的斜杠在Windows系统下是\\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用<code>.replace(/\\\\/g, &#39;/&#39;)</code>再替换一下标准路径。</li>\n<li><code>path.join</code>\n  将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。<pre><code class=\"hljs language-javascript\">path.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;foo/&#x27;</span>, <span class=\"hljs-string\">&#x27;baz/&#x27;</span>, <span class=\"hljs-string\">&#x27;../bar&#x27;</span>); <span class=\"hljs-comment\">// =&gt; &quot;foo/bar&quot;</span>\n</code></pre>\n</li>\n<li><code>path.extname</code>\n  当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。<pre><code class=\"hljs language-javascript\">path.<span class=\"hljs-title function_\">extname</span>(<span class=\"hljs-string\">&#x27;foo/bar.js&#x27;</span>); <span class=\"hljs-comment\">// =&gt; &quot;.js&quot;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">遍历目录</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    ``` javascript\nconst fs = require(&#39;fs&#39;);\nconst path = require(&#39;path&#39;);</li>\n</ul>\n<p>function travel (dir, callback) {\n    fs.readdirSync(dir).forEach(file =&gt; {\n        let pathname = path.join(dir, file)\n        if (fs.statSync(pathname).isDirectory())\n            travel(pathname, callback)\n        else callback(pathname)\n    })\n}</p>\n<p>travel(__dirname, file =&gt; {\n    console.log(file)\n})</p>\n<p>// c:\\Users\\mrrs8\\Desktop\\desktop.ini\n// c:\\Users\\mrrs8\\Desktop\\Postman.lnk\n// c:\\Users\\mrrs8\\Desktop\\test.js\n// c:\\Users\\mrrs8\\Desktop\\微信开发者工具.lnk</p>\n<pre><code># 文本编码\n使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有`UTF8`和`GBK`两种，并且`UTF8`文件还可能带有`BOM`。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的`UTF8`编码字符串后才能正常处理。\n## BOM的移除\nBOM用于标记一个文本文件使用`Unicode`编码，其本身是一个`Unicode`字符`（&quot;\\uFEFF&quot;）`，位于文本文件头部。在不同的`Unicode`编码下，`BOM`字符对应的二进制字节如下：\n``` javascript\n    Bytes      Encoding\n</code></pre>\n"},{"title":"Python-requests库的使用","tags":["Python"],"categories":"Python","description":"# Python-requests库的使用\nurllib 的用法中有一些不方便的地方，比如处理网页验证和Cooki es 时，需要写 Opener 和 Handler 来处理。 为了更加方便地实现这些操作，就有了更为强大的库requests ，有了它 ， Cookies 、登录验证、代理设置等操作都变得极为简单。\n\n## 一切以官网为主\nhttp://docs.python-requests.o","createDate":"2018-11-14 11:41:55","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Python-requests库的使用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>urllib 的用法中有一些不方便的地方，比如处理网页验证和Cooki es 时，需要写 Opener 和 Handler 来处理。 为了更加方便地实现这些操作，就有了更为强大的库requests ，有了它 ， Cookies 、登录验证、代理设置等操作都变得极为简单。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一切以官网为主</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"http://docs.python-requests.org/en/master/\">http://docs.python-requests.org/en/master/</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基本用法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一个简单的例子</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>urllib库中的 urlopen()法实际上是以GET方式请求网页，而requests中相应的方法就是get()\n方法。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://www.baidu.com&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">type</span>(response))\n<span class=\"hljs-built_in\">print</span>(response.status_code)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">type</span>(response.text))\n<span class=\"hljs-built_in\">print</span>(response.text)\n<span class=\"hljs-built_in\">print</span>(response.cookies)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JShz6r.png\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">GET请求</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    \n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基本实例</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;simple test&#x27;</span>)\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://httpbin.org/get&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(response.text)\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;params test&#x27;</span>)\ndata = {<span class=\"hljs-string\">&#x27;name&#x27;</span>: <span class=\"hljs-string\">&#x27;germey&#x27;</span>, <span class=\"hljs-string\">&#x27;age&#x27;</span>: <span class=\"hljs-number\">22</span>}\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://httpbin.org/get&#x27;</span>, params=data)\n<span class=\"hljs-built_in\">print</span>(response.text)\n\n<span class=\"hljs-comment\"># 将json格式解析为字典格式</span>\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;json() test&#x27;</span>)\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://httpbin.org/get&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">type</span>(response.text))\n<span class=\"hljs-built_in\">print</span>(response.json())\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">type</span>(response.json()))\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JShDOJ.png\" alt=\"enter image description here\">\n<img src=\"https://t1.picb.cc/uploads/2018/11/14/JShYg1.png\" alt=\"enter image description here\">\n<img src=\"https://t1.picb.cc/uploads/2018/11/14/JShEP0.png\" alt=\"enter image description here\"></p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">抓取网页</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests, re\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;抓取网页测试&#x27;</span>)\nheaders = {<span class=\"hljs-string\">&#x27;User-Agent&#x27;</span>: <span class=\"hljs-string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&#x27;</span>}\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://www.zhihu.com/explore&#x27;</span>, headers = headers)\npattern = re.<span class=\"hljs-built_in\">compile</span>(<span class=\"hljs-string\">&#x27;explore-feed.*?question_link.*?&gt;(.*?)&lt;/a&gt;&#x27;</span>, re.S)\ntitle = re.findall(pattern, response.text)\n<span class=\"hljs-built_in\">print</span>(title)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JSvydu.png\" alt=\"enter image description here\"></p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">抓取二进制数据</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式， 我们才可以看到这些形形色色的多媒体 。 所以，想要抓取它们，就要拿到它们的二进制码。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;抓取二进制数据测试&#x27;</span>)\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://github.com/favicon.ico&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(response.text)\n<span class=\"hljs-built_in\">print</span>(response.content)  <span class=\"hljs-comment\"># Content of the response, in bytes</span>\n<span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&#x27;favicon.ico&#x27;</span>, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:\n    f.write(response.content)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JSvJuD.png\" alt=\"enter image description here\"></p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">添加headers</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;添加headers测试&#x27;</span>)\nheaders = {<span class=\"hljs-string\">&#x27;User-Agent&#x27;</span>: <span class=\"hljs-string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&#x27;</span>}\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://www.zhihu.com/explore&#x27;</span>, headers = headers)\n<span class=\"hljs-built_in\">print</span>(response.text)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JSvgsi.png\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">POST请求</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\ndata = {<span class=\"hljs-string\">&#x27;name&#x27;</span>: <span class=\"hljs-string\">&#x27;germy&#x27;</span>, <span class=\"hljs-string\">&#x27;age&#x27;</span>: <span class=\"hljs-string\">&#x27;22&#x27;</span>}\nresponse = requests.post(<span class=\"hljs-string\">&#x27;https://httpbin.org/post&#x27;</span>, data=data)\n<span class=\"hljs-built_in\">print</span>(response.text)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JSvt6L.png\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">响应</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>发送请求后，得到的自然就是响应 。 在上面的实例中，我们使用 text 和 content 获取了响应的内容。 此外，还有很多属性和方法可以用来获取其他信息，比如状态码、响应头、 Cookies 等。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;响应测试&#x27;</span>)\nheaders = {<span class=\"hljs-string\">&#x27;User-Agent&#x27;</span>: <span class=\"hljs-string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&#x27;</span>}\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://www.jianshu.com&#x27;</span>, headers = headers)\n<span class=\"hljs-built_in\">print</span>(response.headers)\n<span class=\"hljs-built_in\">print</span>(response.cookies)\n<span class=\"hljs-comment\"># print(response.status_code)</span>\nexit() <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> response.status_code == requests.codes.ok <span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;request successfully&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(response.content)\n<span class=\"hljs-built_in\">print</span>(response.text)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JSx5ST.png\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">高级用法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">文件上传</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\nfiles = {<span class=\"hljs-string\">&#x27;file&#x27;</span>: <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&#x27;favicon.ico&#x27;</span>, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)}\nresponse = requests.post(<span class=\"hljs-string\">&#x27;https://httpbin.org/post&#x27;</span>, files = files)\n<span class=\"hljs-built_in\">print</span>(response.text)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JSxvT1.png\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">会话维持</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>在 requests 中，如果直接利用 get()、post()等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的会话，也就是说相当于用了两个浏览器打开了不同的页面，其实解决这个问题的主要方法就是维持同一个会话 ， 也就是相当于打开一个新的浏览器选项卡而不是新开一个浏览器 。 但是又不想每次设置 cookies ，那该怎么办呢？这时候就有了新的利器--Session 对象 。利用它，我们可以方便地维护一个会话，而且不用担心cookies的问题，它会帮我们自动处理好。利用 Session ，可以做到模拟同一个会话而不用担心 Cookies 的问题。 它通常用于模拟登录成功之后再进行下一步的操作。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;session测试&#x27;</span>)\nsession = requests.Session()\nsession.get(<span class=\"hljs-string\">&#x27;https://httpbin.org/cookies/set/number/123456789&#x27;</span>)\nresponse = session.get(<span class=\"hljs-string\">&#x27;https://httpbin.org/cookies&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(response.text)\n</code></pre>\n<p><img src=\"https://t1.picb.cc/uploads/2018/11/14/JSLtir.png\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">SSL证书验证</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>如果请求一个 HTTPS 站点，但是证书验证错误的页面时，就会报这样的错误，那么如何避免这个错误呢？很简单，把 verify 参数设置为False 即可。当然，我们也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n<span class=\"hljs-keyword\">import</span> logging\n<span class=\"hljs-keyword\">from</span> requests.packages <span class=\"hljs-keyword\">import</span> urllib3\n\nurllib3.disable_warnings()  <span class=\"hljs-comment\"># 忽略警告</span>\nlogging.captureWarnings(true)  <span class=\"hljs-comment\"># 捕获警告</span>\nresponse = requests.get(url, **verify = false**)  <span class=\"hljs-comment\"># 设置verify</span>\nresponse = requests.get(url, cert = (crt_path, key_path))  <span class=\"hljs-comment\"># 设置证书文件地址</span>\n<span class=\"hljs-built_in\">print</span>(response)\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">代理设置</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>对于某些网站，在测试的时候请求几次 ， 能正常获取内容。 但是一旦开始大规模爬取，对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面 ， 更甚者可能会直接封禁客户端的 IP ，导致一定时间段内无法访问 。那么，为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到 proxies 参数。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\nproxies = {<span class=\"hljs-string\">&#x27;http&#x27;</span>: <span class=\"hljs-string\">&#x27;...&#x27;</span>\n           <span class=\"hljs-string\">&#x27;https&#x27;</span>: <span class=\"hljs-string\">&#x27;...&#x27;</span>\n           ...\n           }\nresponse = requests.get(url, proxies = proxies)\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">超时设置</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>在本机网络状况不好或者服务器网络响应太慢甚至无响应时，我们可能会等待特别久的时间才可能收到响应，甚至到最后收不到响应而报错。 为了防止服务器不能及时响应，应该设置一个超时时间 ，即超过了这个时间还没有得到响应，那就报错。 这需要用到 timeout 参数。 这个时间的计算是发归请求到服务器返回响应的时间。实际上，请求分两个阶段，即连接()connect )和读取(read )。如果想永久等待，可以直接将 timeout 设置为 None(默认) 。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;有timeout异常捕获&#x27;</span>)\n<span class=\"hljs-keyword\">try</span>:\n    response = requests.get(<span class=\"hljs-string\">&#x27;https://www.baidu.com&#x27;</span>, timeout = <span class=\"hljs-number\">0.01</span>)\n    <span class=\"hljs-built_in\">print</span>(response.status_code)\n<span class=\"hljs-keyword\">except</span> requests.exceptions.Timeout:\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;Timeout&#x27;</span>)\n<span class=\"hljs-keyword\">except</span> requests.exceptions.ConnectionError:\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;ConnextionError&#x27;</span>)\n<span class=\"hljs-keyword\">except</span> requests.exceptions.HTTPError:\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;HTTPError&#x27;</span>)\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;无timeout异常捕获&#x27;</span>)\nresponse = requests.get(<span class=\"hljs-string\">&#x27;https://www.baidu.com&#x27;</span>, timeout = (<span class=\"hljs-number\">0.01</span>, <span class=\"hljs-number\">0.01</span>))\n<span class=\"hljs-built_in\">print</span>(response.status_code)\n</code></pre>\n<p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/91035917.jpg\" alt=\"enter image description here\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">身份认证</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> requests\n<span class=\"hljs-keyword\">from</span> requests.auth <span class=\"hljs-keyword\">import</span> HTTPBasicAuth\n\nresponse = requests.get(url, auth=HTTPBasicAuth(username, userpassword))\nresponse = requests,get(url, auth=(username, userpassword))\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">prepared request</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>前面介绍 urllib 时，我们可以将请求表示为数据结构，其中各个参数都可以通过一个 Request 对象来表示 。 这在 requests 里同样可以做到，这个数据结构就叫 Prepared Request。有了 Request 这个对象，就可以将请求当作独立的对象来看待，这样在进行队列调度时会非常方便。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> requests <span class=\"hljs-keyword\">import</span> Request, Session\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;prepared request测试&#x27;</span>)\nurl = <span class=\"hljs-string\">&#x27;https://httpbin.org/post&#x27;</span>\ndata = {<span class=\"hljs-string\">&#x27;name&#x27;</span>: <span class=\"hljs-string\">&#x27;germey&#x27;</span>}\nheaders = {<span class=\"hljs-string\">&#x27;User-Agent&#x27;</span>: <span class=\"hljs-string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&#x27;</span>}\n\nsession = Session()\nrequest = Request(<span class=\"hljs-string\">&#x27;POST&#x27;</span>, url, data = data, headers = headers)\nprepped = session.prepare_request(request)\nresponse = session.send(prepped)\n<span class=\"hljs-built_in\">print</span>(response.status_code)\n<span class=\"hljs-built_in\">print</span>(response.text)\n</code></pre>\n<p><img src=\"http://hellomrrs-imgs.oss-cn-shanghai.aliyuncs.com/18-11-14/46350763.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"Vue.js学习-基础","tags":["Vue.js"],"categories":"Vue.js","description":"# 生命周期钩子函数\n\n- beforeCreate\n\n  获取不到props/data\n\n- created\n\n  可以获取到props/data，组件未挂载\n\n- beforeMount\n\n  开始创建VDOM\n\n- mounted\n\n  将VDOM渲染为真实DOM并渲染数据，组件中如果有子组件的话会递归挂载子组件，只有当所有子组件全部挂载完毕才会执行跟组件的挂载钩子\n\n- beforeU","createDate":"2020-04-18 21:04:39","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生命周期钩子函数</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>beforeCreate</p>\n<p>获取不到props/data</p>\n</li>\n<li><p>created</p>\n<p>可以获取到props/data，组件未挂载</p>\n</li>\n<li><p>beforeMount</p>\n<p>开始创建VDOM</p>\n</li>\n<li><p>mounted</p>\n<p>将VDOM渲染为真实DOM并渲染数据，组件中如果有子组件的话会递归挂载子组件，只有当所有子组件全部挂载完毕才会执行跟组件的挂载钩子</p>\n</li>\n<li><p>beforeUpdate/updated</p>\n<p>分别在数据更新前/更新时调用。不能在updated里做更新，会造成死循环</p>\n</li>\n<li><p>beforeDestory</p>\n<p>适合移移除事件、定时器等</p>\n</li>\n<li><p>destoryed</p>\n<p>所有子组件都销毁完毕后会执行根组件的destoryed</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组件通信</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p><code>props/$emit</code>\n通过props将数据自伤而下传递；通过$emit/v-on来向上传递消息</p>\n</li>\n<li><p>eventbus\n通过eventbus进行消息的发布订阅</p>\n</li>\n<li><p>vuex\n全局数据管理库，可通过vuex管理全局的数据流</p>\n</li>\n<li><pre><code>$attrs/$listeners\n</code></pre>\n<p>可以进行跨级的组件通信</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 父组件</span>\n&lt;template&gt;\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;home&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">m-input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;姓名&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">m-input</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">MInput</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/components/MInput.vue&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;home&quot;</span>,\n    <span class=\"hljs-title function_\">data</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;zhangsan&quot;</span>\n        };\n    },\n    <span class=\"hljs-attr\">components</span>: {\n        <span class=\"hljs-title class_\">MInput</span>\n    }\n};\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n<span class=\"hljs-comment\">// 子组件</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">&quot;$attrs&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">&quot;$attrs&quot;</span> @<span class=\"hljs-attr\">input</span>=<span class=\"hljs-string\">&quot;$emit(&#x27;input&#x27;,$event.target.value)&quot;</span> <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">&quot;value&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">props</span>: {\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-title class_\">String</span>,\n        <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">&quot;&quot;</span>\n    }\n};\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n</li>\n<li><p>proveded/inject\n允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并且在其上下游关系成立的时间内始终有效</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">mixin和mixins的区别</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>mixin用于全局混入，会影响到每个组件实例（vuex、vue-router等插件实现核心机制）</li>\n<li>mixins常用来扩展组件</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">computed和watch的区别</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>computed是计算属性，依赖其他属性计算值，并且computed的值有缓存，只有当计算值发生变化才返回内容</li>\n<li>watch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作</li>\n</ul>\n<p>一般来说需要依赖别的属性来动态获得值得时候可以使用computed，对于监听到值的变化需要做一些<strong>复杂业务逻辑</strong>的情况可以使用watch</p>\n<p><a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttp://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/%5D(http://blog.p18c.top/2020/03/03/Vue.js%E7%A0%94%E8%AF%BB-1/)\">实现原理</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">computed如何知道依赖</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>Vue.js实例初始化过程中，将所有计算属性包装为lazy watcher</li>\n<li>首次访问计算属性时，watcher为dirty，此时开始计算watcher的值</li>\n<li>计算开始之前，此watcher将被设置为依赖目标，开始收集依赖</li>\n<li>计算watcher值的过程中，被访问到属性的getter中会检查是否存在依赖目标，若存在依赖目标就会创建依赖关系</li>\n<li>watcher的值计算完成后，新的依赖被设置，旧的依赖会被删除，依赖收集完成</li>\n<li>当依赖属性更新时，会通知自身的依赖目标，watcher被设置为dirty</li>\n<li>再次访问该计算属性，重复计算及依赖收集步骤（3-6）</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">keep-alive有什么作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>如果需要在组件切换的时候<strong>保存一些组件的状态防止多次渲染</strong>，就可以使用<code>keep-alive</code>组件包裹需要保存的组件。对于<code>keep-alive</code>组件来说，它有两个独有的声明周期钩子函数，分别为<code>activated</code>、和<code>deactivated</code>。用<code>keep-alive</code>包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行<code>deactivated</code>钩子函数，命中缓存渲染后会执行<code>activated</code>钩子函数。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">v-show和v-if的区别</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><code>v-show</code>只是在<code>display:none</code>和<code>display:block</code>之间切换，无论初始条件是什么DOM都会被创建，后面只需切换CSS。所以总的来说<code>v-show</code>在初始渲染时有着更高的开销，但切换开销很小，适合频繁切换的场景。</li>\n<li><code>v-if</code>的话关于到Vue底层的编译。当初始属性为<code>false</code>时，组件就不会被渲染，直到条件为<code>true</code>。并且切换条件时会触发销毁/挂载组件及回流。所以总的来说在<strong>创建时开销较小，切换时开销大，适合不经常切换的场景</strong>，并且基于<code>v-if</code>这种惰性渲染机制，可以在必要的时候才去渲染组件，<strong>减少整个页面的初始渲染开销</strong></li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">data为什么使用函数</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><strong>组件复用时所有组件实例都会共享data</strong>，如果data是对象的话，就会造成一个组件修改data后影响其他组件，所以有必要将data写成函数，每次用到就调用一次函数获得新的数据</p>\n<p>当使用<code>new Vue()</code>的方式时，无论我们将data设置为对象函数函数都是可以的，因为<code>new Vue()</code>的方式是生成一个根组件，该组件不会被复用也就不会存在共享data的情况了</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js响应式原理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>对于Object，基于发布订阅模式，使用<code>Object.defineProperty</code>，在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖。当一个vue组件实例创建的时候，vue会遍历<code>data</code>选项的属性，用<code>Object.defineProperty</code>将它们转换为<code>getter/setter</code>并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的<code>watcher</code>实例，它会在组件渲染的过程中把属性记录为依赖，只有当依赖项的<code>setter</code>被调用时，会通知<code>watcher</code>重新计算从而使它管理的组件得以更新</p>\n<p>对于Array，基于函数劫持，改写数组原型方法，并遍历数组，对于是对象的项使用👆的方法进行观测</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js的特点</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>简洁</li>\n<li>数据驱动，自动计算属性和追踪依赖的模板表达式</li>\n<li>组件化，高科服用、解耦的组件来构建页面</li>\n<li>快速，精确有效批量DOM更新</li>\n<li>模板友好</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>$nextTick</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>Vue.js实现响应式并不是在数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。nextTick是在下次dom更新循环结束之后执行延迟回调，在修改数据之后使用<em>n<strong>e</strong>x<strong>t</strong>T<strong>i</strong>c**k</em>是在下次<em>d<strong>o</strong>m</em>更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的dom</p>\n<p>渲染节流</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>v-for</code>中<code>key</code>的作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>当vue更新通过v-for渲染的元素时，它默认使用<strong>就地复用</strong>的策略，如果数据项的顺序被改变，vue将不是移动dom元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定的索引下显示已经被渲染过的每个元素。为了给vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序所有元素，需要给vue提供一个唯一key属性</p>\n<p>key <strong>主要用在vue的虚拟dom算法</strong>，在新旧node对比时辨识vnodes。如果不使用key，vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法，使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>$router</code>和<code>$route</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><code>$router</code>是路由信息对象，包括<code>path、params、hash、query、fullPath、matched、name</code>等路由信息参数</li>\n<li><code>$route</code>是路由实例，包括了路由跳转方法、钩子函数等</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>@click.native</code>中<code>native</code>的作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>对于普通标签，<code>@click</code>会监听点击事件，而对于写在组件上的<code>@click</code>，如果不加<code>native</code>，则代表坚挺的是组件的点击事件，而不是组件内的点击事件，因此，在组件内写的<code>click handler</code>不会被执行</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>v-model</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>v-model</code>常用于表单元素上进行数据的双向绑定，比如``。除了原生的元素，它还能在自定义组件中使用</p>\n<pre><code>v-model`是一个语法糖，可以拆解为`props: value`和`events:input`。就是说组件必须提供一个名为`value`的`prop`以及名为`input`的自定义事件，满足这两个条件就能在自定义组件上使用`v-model\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">作用域插槽</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>一种带有数据的插槽</p>\n<p>普通插槽 = 父组件设置的样式 + 父组件通过props传递的数据</p>\n<p>作用域插槽 = 父组件设置的样式 + <strong>自身的数据</strong>（该数据父组件也可以访问得到）</p>\n"},{"title":"Vue.js研读-响应式","tags":["Vue.js","响应式"],"categories":"Vue.js","description":"## 响应式原理\n\n![响应式管理](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-1.png)\n\nData通过`Observer`转换成了**getter/setter**的形式类追踪变化\n\n当外界通过`Watcher`读取数据（Compile时会根据**{}**、**v-***来创建Watcher）时会触发getter从而将Watche","createDate":"2020-03-03 23:15:13","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">响应式原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-1.png\" alt=\"响应式管理\"></p>\n<p>Data通过<code>Observer</code>转换成了<strong>getter/setter</strong>的形式类追踪变化</p>\n<p>当外界通过<code>Watcher</code>读取数据（Compile时会根据**{}<strong>、</strong>v-***来创建Watcher）时会触发getter从而将Watcher添加到依赖中</p>\n<p>当数据发生变化时，会触发setter，从而向<code>Dep</code>中的依赖（Watcher）发送通知</p>\n<p>Wacher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">简易版响应式（Proxy + Observer/Watcher/Dep）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> uid = <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">parsePath</span>(<span class=\"hljs-params\">obj, path</span>) {\n    <span class=\"hljs-keyword\">if</span> (path === <span class=\"hljs-string\">&quot;&quot;</span>) <span class=\"hljs-keyword\">return</span> obj\n    <span class=\"hljs-keyword\">return</span> path.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;.&quot;</span>).<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data, current</span>) =&gt;</span> data[current], obj)\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">defineReactive</span> (data) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> data !== <span class=\"hljs-string\">&quot;object&quot;</span>) <span class=\"hljs-keyword\">return</span> data\n    <span class=\"hljs-keyword\">let</span> dep = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dep</span>()\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(data, {\n        <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">target, prop, value, receiver</span>) =&gt;</span> {\n            <span class=\"hljs-keyword\">const</span> oldVal = target[prop]\n            <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, prop, <span class=\"hljs-title function_\">defineReactive</span>(value), receiver)\n            <span class=\"hljs-keyword\">if</span> (oldVal !== value) dep.<span class=\"hljs-title function_\">notify</span>()\n            <span class=\"hljs-keyword\">return</span> res\n        },\n        <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">target, prop, receiver</span>) =&gt;</span> {\n            dep.<span class=\"hljs-title function_\">depend</span>()\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, prop, receiver)\n        }\n    })\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Observer</span> {\n    <span class=\"hljs-title function_\">constructor</span> (vm) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> vm !== <span class=\"hljs-string\">&quot;object&quot;</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&quot;vm must be an object&quot;</span>)\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">walk</span>(vm)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">defineReactive</span>(vm)\n    }\n    walk (vm) {\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(vm).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> vm[item] === <span class=\"hljs-string\">&quot;object&quot;</span>) <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">walk</span>(vm[item])\n            vm[item] = <span class=\"hljs-title function_\">defineReactive</span>(vm[item])\n        })\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dep</span> {\n    <span class=\"hljs-title function_\">constructor</span> () {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span> = uid++\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subs</span> = []\n    }\n    addSub (sub) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subs</span>.<span class=\"hljs-title function_\">push</span>(sub)\n    }\n    depend () {\n        <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> &amp;&amp; <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span>.<span class=\"hljs-title function_\">addDep</span>(<span class=\"hljs-variable language_\">this</span>)\n    }\n    notify () {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subs</span>.<span class=\"hljs-title function_\">slice</span>().<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-title function_\">update</span>())\n    }\n    removeSub (sub) {\n        <span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subs</span>.<span class=\"hljs-title function_\">indexOf</span>(sub)\n        index &gt; -<span class=\"hljs-number\">1</span> &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subs</span>.<span class=\"hljs-title function_\">splice</span>(index, <span class=\"hljs-number\">1</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watcher</span> {\n    <span class=\"hljs-title function_\">constructor</span> (vm, exp, cb) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span> = vm\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">exp</span> = exp\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">cb</span> = cb\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span> = []\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">depIds</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">get</span>() \n    }\n    get () {\n        <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-variable language_\">this</span>\n        <span class=\"hljs-keyword\">let</span> value = <span class=\"hljs-title function_\">parsePath</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">exp</span>)\n        <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-literal\">undefined</span>\n        <span class=\"hljs-keyword\">return</span> value\n    }\n    update () {\n        <span class=\"hljs-keyword\">const</span> oldValue = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">get</span>()\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">cb</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>, oldValue)\n    }\n    addDep (dep) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">depIds</span>.<span class=\"hljs-title function_\">has</span>(dep.<span class=\"hljs-property\">id</span>)) <span class=\"hljs-keyword\">return</span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">depIds</span>.<span class=\"hljs-title function_\">add</span>(dep.<span class=\"hljs-property\">id</span>)\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span>.<span class=\"hljs-title function_\">push</span>(dep)\n        dep.<span class=\"hljs-title function_\">addSub</span>(<span class=\"hljs-variable language_\">this</span>)\n    }\n    teardown () {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-title function_\">removeSub</span>(<span class=\"hljs-variable language_\">this</span>))\n    }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">watch</span>(<span class=\"hljs-params\">vm, exp, cb, options = {}</span>) {\n    <span class=\"hljs-keyword\">const</span> watcher = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(vm, exp, cb)\n    <span class=\"hljs-keyword\">if</span> (options.<span class=\"hljs-property\">immediate</span>) cb.<span class=\"hljs-title function_\">call</span>(vm, watcher.<span class=\"hljs-property\">value</span>)\n    <span class=\"hljs-keyword\">return</span> watcher.<span class=\"hljs-property\">teardown</span>.<span class=\"hljs-title function_\">bind</span>(watcher)\n}\n\n<span class=\"hljs-keyword\">export</span> { <span class=\"hljs-title class_\">Observer</span>, watch }\n</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./mvvm.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>({\n        <span class=\"hljs-attr\">student</span>: {\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n            <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span>\n        },\n        <span class=\"hljs-attr\">address</span>: {\n            <span class=\"hljs-attr\">province</span>: {\n                <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">41</span>,\n                <span class=\"hljs-attr\">view</span>: <span class=\"hljs-string\">&quot;河南&quot;</span>\n            }\n        },\n        <span class=\"hljs-attr\">friends</span>: [ <span class=\"hljs-string\">&quot;zhangsan&quot;</span>, <span class=\"hljs-string\">&quot;lisi&quot;</span>, <span class=\"hljs-string\">&quot;wangwu&quot;</span> ],\n    })\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(data, <span class=\"hljs-string\">&quot;student&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;update student&#x27;</span>, val)\n    })\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(data, <span class=\"hljs-string\">&quot;student.name&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;update student.name&#x27;</span>, val)\n    })\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(data, <span class=\"hljs-string\">&quot;student.age&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;update student.age&#x27;</span>, val)\n    })\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(data, <span class=\"hljs-string\">&quot;address.province.id&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;update address.province.id&quot;</span>, val);\n    })\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(data, <span class=\"hljs-string\">&quot;friends.length&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;update student.friends&#x27;</span>, data.<span class=\"hljs-property\">friends</span>[val - <span class=\"hljs-number\">1</span>]);\n    })\n    <span class=\"hljs-keyword\">const</span> unwatch = <span class=\"hljs-title function_\">watch</span>(data, <span class=\"hljs-string\">&quot;address.province.view&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;address.province.view&#x27;</span>, val);\n    })\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">$vm.watch(expOrFn, callback, [options])</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>用于观察一个表达式或computed函数在Vue.js实例上的变化。回调函数调用时，会从参数中得到oldValue和newValue</p>\n<p>vm.$watch其实是对Watcher的一种封装，没有缓存性，通过Watcher完全可以实现vm.$watch的功能</p>\n<ol>\n<li>先执行new Watcher来实现vm.$watch的基本功能</li>\n<li>判断用户是否使用immediate参数，如果使用了则立即执行一次cb</li>\n<li>判断用户是否使用deep参数，如果使用除了要触发当前这个被监听数据的依赖收集的逻辑之外，还要把当前监听的这个值在内的所有子值都要触发一遍依赖收集逻辑</li>\n<li>返回一个函数unwatchFn，用于取消观察数据</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">$vm.computed</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>computed</code>是定义在<code>vm</code>上的一个特殊的<code>getter</code>方法。之所以说特殊是因为在vm上定义<code>getter</code>方法时，<code>get</code>并不是由用户提供的函数，而是Vue.js内部的一个代理函数。在代理函数中可以结合<code>Watcher</code>实现缓存与收集依赖等功能。在模板中使用一个数据渲染视图时，如果这个数据恰好是计算属性，那么读取数据这个操作其实会触发计算属性的<code>getter</code>方法。</p>\n<p>当这个getter方法被触发时会做两件事：</p>\n<ol>\n<li>计算当前属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false，这样再次读取计算属性时将不再重新计算，除非计算属性所依赖的值发生了变化</li>\n<li>当计算属性中用到的树发生变化时，将得到通知从而进行重新渲染操作</li>\n</ol>\n<p>我们知道计算属性的结果会被缓存，且只有在计算属性所依赖的响应式属性或者计算属性的返回值发生变化时才会重新计算。这是结合<code>Watcher</code>的<code>dirty</code>属性来分辨的：当<code>dirty===true</code>时，说明需要重新计算“计算属性”的返回值；当计算属性中的内容发生变化后，计算属性的<code>Watcher</code>与组件的<code>Watcher</code>都会得到通知。计算属性的<code>Watcher</code>会将自己的<code>dirty</code>属性设置为true，当下一次读取计算属性时就会重新计算一次值。与此同时组件的<code>Watcher</code>也会得到通知，从而执行render函数进行重新渲染的操作。由于要重新执行<code>render</code>函数，所以会重新读取计算属性的值，这时候计算属性的Watcher已经把自己的<code>dirty</code>置为<code>true</code>，所以会重新计算一次计算属性的值用于本次渲染</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/computed-0.png\" alt=\"computed原理0\"></p>\n<p>这种方式实现的computed有一个弊端：只是观察它所用到的数据是否发生了变化，并<strong>没有真正去校验它自身的返回值是否有变化</strong>，所以当它所使用的数据发生变化后，组件<strong>总会重新走一遍渲染流程</strong>。</p>\n<p>为解决这个问题，新版计算属性做了一些改动：组件的Watcher不再观察计算属性用到的数据的变化，而是让计算属性的Watcher得到通知后计算一次计算属性的值，如果发现这一次计算属性的值与上一次计算出来的值不一样，再去主动通知组件的Watcher进行重新渲染操作。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/computed-1.png\" alt=\"computed原理1\"></p>\n"},{"title":"Vue.js研读-基础","tags":["Vue.js"],"categories":"Vue.js","description":"## Document.createDocumentFragment()\n\n`DocumentFragments` 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。\n\n因为文档片段存在于**内存中**，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面[回流](http","createDate":"2020-03-02 23:21:38","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Document.createDocumentFragment()</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>DocumentFragments</code> 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。</p>\n<p>因为文档片段存在于<strong>内存中</strong>，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow\">回流</a>（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">node.nodeType</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>1 元素</p>\n<p>2 属性</p>\n<p>3 文本</p>\n<p>8 注释</p>\n<p>9 document</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">node.textContext、node.innerText</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>textContent</code>会获取所有元素的内容，包括<code>script</code>和<code>style</code>元素。然而<code>innerText</code>只展示给人看的元素</p>\n<p><code>textContext</code>会返回节点中的每一个元素，相反，<code>innerText</code>受<code>CSS</code>样式的影响，不会返回隐藏元素的文本，并且会触发<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Reflow\">回流</a>去确保是最新的计算样式</p>\n<p>与<code>textContext</code>不同的是，在IE11以及下版本中，对<code>innerText</code>进行修改，不仅会移除当前元素的子节点，而且会永久性的破坏所有后代文本节点，在之后不可能再次将节点到任何其他元素或同同一元素</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">通过字符串路径获取对象属性的简单方法（暂不支持[]）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">parsePath</span> (obj, path) {\n    <span class=\"hljs-keyword\">return</span> path.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;.&quot;</span>).<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data, current</span>) =&gt;</span> data[current], obj)\n}\n\n<span class=\"hljs-keyword\">const</span> obj1 = {\n    <span class=\"hljs-attr\">tom</span>: {\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n        <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span>\n    }\n}\n\n<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title function_\">parsePath</span>(obj1, <span class=\"hljs-string\">&quot;tom.name&quot;</span>)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);\n<span class=\"hljs-comment\">// tom</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">e.target和e.currentTarget</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>e.target指向触发事件的对象</p>\n<p>e.currentTarget指向添加监听事件的对象</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js整体流程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-4.png\" alt=\"Vue.js整体流程\"></p>\n"},{"title":"Vue.js研读-模板编译","tags":["Vue.js","模板编译"],"categories":"Vue.js","description":"## 模板编译\n\n模板编译的主要目标是**生成渲染函数**。而渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的vnode，然后使用这份vnode进行渲染。\n\n## 将模板编译成渲染函数\n\n- 将模板编译成AST（解析器）\n\n- 遍历AST标记静态节点（优化器）\n\n- 使用AST生成渲染函数（代码生成器）\n\n  ![模板编译整体流程](https://mrrsblog.oss-c","createDate":"2020-03-05 22:54:17","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模板编译</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>模板编译的主要目标是<strong>生成渲染函数</strong>。而渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的vnode，然后使用这份vnode进行渲染。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">将模板编译成渲染函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>将模板编译成AST（解析器）</p>\n</li>\n<li><p>遍历AST标记静态节点（优化器）</p>\n</li>\n<li><p>使用AST生成渲染函数（代码生成器）</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91-0.png\" alt=\"模板编译整体流程\"></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解析器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>将模板编译成AST</p>\n<p>在解析器内部，分成了很多小解析器，其中包括过滤解析器、文本解析器和HTML解析器。然后再通过一条主线将这些解析器组装在一起。</p>\n<p>HTML解析器是解析器中最核心的模块，它的作用是解析HTML模板，每当解析到HTML标签的开始位置、结束位置、文本或注释时，都会<strong>触发钩子函数</strong>，然后将相关信息通过参数传递出来。在解析期间，使用栈来记录层级关系（触发start钩子函数时入栈，触发end钩子函数时出栈）。</p>\n<p>事实上，解析HTML模板的过程就是循环的过程，简单来说就是用HTML模板字符串来循环，每轮循环都从HTML模板中截取一小段字符串，然后重复上述过程👆，直到HTML模板被截成一个空字符串时结束。</p>\n<p>文本解析器的主要作用是对HTML解析器解析出来的文本进行二次加工，处理<strong>带变量</strong>的文本。HTML解析器在解析文本时并不会区分文本是否是带有变量的文本，如果是纯文本，不需要进行任何处理；但如果是带变量的文本那个需要使用文本解析器进一步解析。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">优化器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>优化器的目标是遍历AST，检测出所有静态子树（永远不会变化的DOM节点）并给其打标记</p>\n<p>标记静态子树有两点好处：</p>\n<ul>\n<li>每次重新渲染时，不需要为静态子树创建新节点</li>\n<li>在虚拟DOM中打补丁的过程中可以跳过</li>\n</ul>\n<p>优化器内部实现主要有以下两个步骤：</p>\n<ol>\n<li><p>在AST中找出所有静态节点并打上标记（<code>static === true</code>）</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>我是一个静态节点<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></pre>\n</li>\n<li><p>在AST中供找出所有静态根节点并打上标记（<code>staticRoot === true</code>）</p>\n<p>如果一个节点下边的所有<strong>子节点都是静态节点</strong>，并且它的<strong>父级是动态节点</strong>，那么它就是静态根节点</p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">代码生成器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>代码生成器是模板编译的最后一步，它的作用是将AST转换成渲染函数中的内容，这个内容称为<strong>代码字符串</strong>。之后交由渲染函数导出到外界。</p>\n<p>代码生成器其实就是字符串拼接的过程。通过递归AST来生成字符串，最先生成根节点，然后在子节点字符串生成后，将其拼接在根节点的参数中，子节点的子节点拼接在子节点的参数中，这样一层一层地拼接，直到最后拼接成完整的字符串。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">渲染函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Vue.js通过将模板编译转换成渲染函数（render function）执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染界面。</p>\n"},{"title":"Vue.js研读-生命周期","tags":["Vue.js"],"categories":"Vue.js","description":"## 生命周期概览\n\n![生命周期](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/lifecycle.png)\n\n## 生命周期函数\n\n- beforeCreate\n\n  `new Vue()`之后触发的第一个钩子，在当前阶段`data`、methods、`computed`以及watch上的数据和方法均不能被访问\n\n- created\n\n  在","createDate":"2020-03-06 23:29:53","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生命周期概览</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/lifecycle.png\" alt=\"生命周期\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生命周期函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>beforeCreate</p>\n<p><code>new Vue()</code>之后触发的第一个钩子，在当前阶段<code>data</code>、methods、<code>computed</code>以及watch上的数据和方法均不能被访问</p>\n</li>\n<li><p>created</p>\n<p>在实例创建完成之后触发，当前阶段已完成了数据观测，也就是可以使用数据，更改数据，在这个更改数据不会触发<code>updated</code>函数。可以做一些<strong>初始数据的获取</strong>，在当前阶段无法获取DOM（可使用vm.$nextTick）</p>\n</li>\n<li><p>beforeMounte</p>\n<p>发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟DOM已创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发<code>updated</code></p>\n</li>\n<li><p>mounted</p>\n<p>在挂载之后被触发。在当前阶段，真实的DOM被挂载完毕，数据完成双向绑定，可以访问到DOM阶段，使用$ref属性对DOM进行操作</p>\n</li>\n<li><p>beforeUpdate</p>\n<p>在界面发生更新之前被触发。也就是响应式数据发生改变之前、虚拟DOM重新渲染之前被触发，可以在此阶段进行更改数据，不会造成重渲染</p>\n</li>\n<li><p>updated</p>\n<p>在发生更新之后被触发。当前阶段DOM已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</p>\n</li>\n<li><p>beforeDestory</p>\n<p>在实例被销毁之前触发。在当前阶段实例完全可以被使用，可以在此阶段做些善后工作，如清除定时器</p>\n</li>\n<li><p>destoryed</p>\n<p>在实例被销毁之后触发。这个时候只剩下DOM，组件已被拆解，数据绑定被卸载、监听被移除、子实例也统统被销毁</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组件的生命周期函数调用顺序</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>加载渲染顺序</p>\n<p>父beforeCreate👉父created👉父beforeMmount👉子beforeCreate👉子created👉子beforeMount👉子mounted👉父mounted</p>\n</li>\n<li><p>更新顺序</p>\n<p>父beforeUpdate👉子beforeUpdate👉子updated👉父updated</p>\n</li>\n<li><p>销毁顺序</p>\n<p>父beforeDestory👉子beforeDestory👉子destoryed👉父destoryed</p>\n</li>\n</ul>\n"},{"title":"Vue.js研读-虚拟DOM","tags":["Vue.js","虚拟DOM"],"categories":"Vue.js","description":"## Vue.js为什么要引入虚拟DOM\n\n虚拟DOM是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上次生成的虚拟节点树进行对比，只渲染不同的部分\n\n在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对（Vue.js 1.0）。但这样做缺点很明显：因为粒度太细，每一个绑定都会有","createDate":"2020-03-04 23:18:13","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js为什么要引入虚拟DOM</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>虚拟DOM是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上次生成的虚拟节点树进行对比，只渲染不同的部分</p>\n<p>在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对（Vue.js 1.0）。但这样做缺点很明显：因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及依赖追踪的开销。当状态被越来越多的节点使用时，开销就越大。</p>\n<p>因此Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入虚拟DOM。组件级别是一个watcher实例。就是说即使一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对渲染，这是一个折中方案</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-0.png\" alt=\"虚拟DOM\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">VNode</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。渲染视图的过程是先创建vnode，然后再使用vnode去生成真实的DOM元素，最后再插入到页面渲染视图</p>\n<p>vnode的类型包括：注释节点(isComment=true)、文本节点、元素节点(具有tag属性)、组件节点、函数式组件、克隆节点</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-1.png\" alt=\"虚拟DOM\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">patch</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对比两个vnode之间的差异只是patch的一部分，这是手段，而不是目的。patch的目的是修改DOM节点，也可以理解为渲染视图。包括：创建新增的节点、删除已经废弃的节点、修改需要更新的节点</p>\n<p>path的核心算法diff是通过<strong>同层</strong>的树节点进行比较而非对树进行逐层遍历的方式，所以时间复杂度只有O(n)</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/patch-0.png\" alt=\"\"></p>\n<ul>\n<li><p>创建新节点</p>\n<p>事实上，只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点、文本节点</p>\n<ul>\n<li>oldVnode中不存在而vnode中存在</li>\n<li>oldVnode和vnode完全不是同一个节点</li>\n</ul>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-2.png\" alt=\"创建节点\"></p>\n</li>\n<li><p>删除节点</p>\n<p>某个节点只在oldVnode中存在</p>\n</li>\n<li><p>更新节点</p>\n<p>oldVnode和vnode相同（通过sameVnode判断）</p>\n<p>判断依据：key、tag、isComment、data、input的type均相同</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%E8%99%9A%E6%8B%9FDOM-3.png\" alt=\"更新节点\"></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">DOM Diff过程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单来说，diff有以下过程：</p>\n<ol>\n<li>同级比较，再比较子节点</li>\n<li>先判断一方有子节点而另一方没有子节点的情况</li>\n<li>比较都有子节点的情况（核心diff算法）</li>\n<li>递归比较子节点</li>\n</ol>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-0.png\" alt=\"diff过程\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">核心DIFF算法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Vue2.0采用了<strong>双端比较</strong>的算法：同时从新旧children的两端开始进行比较，借助key值可以找到可复用的节点，再进行相关操作。\n<img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/diff-1.png\" alt=\"diff-1\"></p>\n"},{"title":"go-gin-基础","tags":["go","gin"],"categories":"go","description":"# 获取`GET` `path`参数\n``` go\n  func main() {\n    r := gin.Default()\n    r.GET(\"/index/:id\", func(context *gin.Context){\n      r.JOSN(http.StatusOK, gin.H{\n        \"id\": context.Param(\"id\"),\n      })","createDate":"2020-01-14 14:05:44","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取<code>GET</code> <code>path</code>参数</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-go\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    r := gin.Default()\n    r.GET(<span class=\"hljs-string\">&quot;/index/:id&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(context *gin.Context)</span></span>{\n      r.JOSN(http.StatusOK, gin.H{\n        <span class=\"hljs-string\">&quot;id&quot;</span>: context.Param(<span class=\"hljs-string\">&quot;id&quot;</span>),\n      })\n    })\n  }\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取<code>POST</code> <code>raw json</code>参数</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li>定义一个公用<code>struct</code>，用于标准返回数据格式<pre><code class=\"hljs language-go\">  <span class=\"hljs-keyword\">type</span> ResBodyS <span class=\"hljs-keyword\">struct</span> {\n ErrCode <span class=\"hljs-type\">int</span> <span class=\"hljs-string\">`json:&quot;errCode&quot;`</span>\n Desc <span class=\"hljs-type\">string</span> <span class=\"hljs-string\">`json:&quot;description&quot; binding:&quot;required&quot;`</span> <span class=\"hljs-comment\">//参数存在性校验</span>\n  }\n</code></pre>\n</li>\n<li>定义针对于特定接口的<code>struct</code><pre><code class=\"hljs language-go\">  <span class=\"hljs-keyword\">type</span> IndexReqBodyS <span class=\"hljs-keyword\">struct</span> {\n ResBodyS\n Data <span class=\"hljs-type\">string</span> <span class=\"hljs-string\">`json:&quot;index&quot;`</span>\n  }\n</code></pre>\n</li>\n<li>使用<code>context.BindJSON()</code>解析请求中的body参数<pre><code class=\"hljs language-go\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n r := gin,Default()\n r.POST(<span class=\"hljs-string\">&quot;/index&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(context *gin.Context)</span></span>{\n   <span class=\"hljs-keyword\">var</span> reqInfo IndexReqBodyS\n   err := context.BindJSON(&amp;reqInfo)\n   <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n     fmt.PrintFln(<span class=\"hljs-string\">&quot;parse json data error! err:&quot;</span>, err)\n     <span class=\"hljs-keyword\">return</span>\n   }\n   context.JSON(http.StatusOK, reqInfo)\n })\n r.Run(<span class=\"hljs-string\">&quot;:9090&quot;</span>)\n  }\n</code></pre>\n</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">捕获异常</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>在 Go 中异常就是<code>panic</code>，它是在程序运行的时候抛出的，当<code>panic</code>抛出之后，如果在程序里没有添加任何保护措施的话，控制台就会在打印出<code>panic</code>的详细情况，然后终止运行。\n当程序发生<code>panic</code>后，在<code>defer</code>(延迟函数) 内部可以调用<code>recover</code>进行捕获。</p>\n<pre><code class=\"hljs language-go\">  <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n    err := <span class=\"hljs-built_in\">recover</span>();\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n      fmp.Println(err)\n    }\n  }\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">单元测试</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>使用<code>net/http/httptest</code>包\n与原生测试相比，使用<code>gin.Engine.ServeHTTP</code>发送请求(原生使用<code>http.HandlerFunc.ServeHTTP</code>)</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> engine *gin.Engine\n\n<span class=\"hljs-keyword\">const</span> accessToken = <span class=\"hljs-string\">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODA5OTE1NTUsInVzZXJfaWQiOjE4LCJuYW1lIjoidGVzdDEifQ.900X9t3qveW0NGn3_FhYxHXlgsLAdl1BkjfKxNlBNyE&quot;</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CreateRequest</span><span class=\"hljs-params\">(method constant.HttpRequestMethod, url <span class=\"hljs-type\">string</span>, params <span class=\"hljs-keyword\">interface</span>{})</span></span> (status constant.ResultCode, resBody *util.ResS, returnError <span class=\"hljs-type\">error</span>) {\n    <span class=\"hljs-keyword\">if</span> engine == <span class=\"hljs-literal\">nil</span> {\n        gin.SetMode(gin.ReleaseMode)\n        engine = gin.New()\n        database.SetUpDatabase()\n        controller.SetupRouter(engine)\n    }\n\n    <span class=\"hljs-keyword\">var</span> (\n        rr        = httptest.NewRecorder()\n        req       = <span class=\"hljs-built_in\">new</span>(http.Request)\n        err <span class=\"hljs-type\">error</span> = <span class=\"hljs-literal\">nil</span>\n    )\n    <span class=\"hljs-keyword\">if</span> params != <span class=\"hljs-literal\">nil</span> {\n        tmp, err := json.Encode(params)\n        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n            <span class=\"hljs-keyword\">return</span> constant.FAILED, <span class=\"hljs-literal\">nil</span>, err\n        }\n        req, err = http.NewRequest(<span class=\"hljs-type\">string</span>(method), url, bytes.NewBuffer([]<span class=\"hljs-type\">byte</span>(tmp)))\n    } <span class=\"hljs-keyword\">else</span> {\n        req, err = http.NewRequest(<span class=\"hljs-type\">string</span>(method), url, <span class=\"hljs-literal\">nil</span>)\n    }\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-keyword\">return</span> constant.FAILED, <span class=\"hljs-literal\">nil</span>, err\n    }\n\n    req.Header.Add(<span class=\"hljs-string\">&quot;Authorization&quot;</span>, fmt.Sprintf(<span class=\"hljs-string\">&quot;Bear %s&quot;</span>, accessToken))\n    engine.ServeHTTP(rr, req)\n\n    formatRes := util.ResS{}\n    err = json.Decode(rr.Body.Bytes(), &amp;formatRes)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-keyword\">return</span> constant.FAILED, <span class=\"hljs-literal\">nil</span>, err\n    }\n    <span class=\"hljs-keyword\">return</span> constant.SUCCESS, &amp;formatRes, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CreateTest</span><span class=\"hljs-params\">(t *testing.T, method constant.HttpRequestMethod, url <span class=\"hljs-type\">string</span>, params <span class=\"hljs-keyword\">interface</span>{})</span></span> {\n    _, resBody, err := CreateRequest(method, url, params)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        t.Errorf(<span class=\"hljs-string\">&quot;got error: %s&quot;</span>, err.Error())\n        <span class=\"hljs-keyword\">return</span>\n    }\n    <span class=\"hljs-keyword\">if</span> resBody != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-keyword\">if</span> resBody.Code != constant.SUCCESS {\n            t.Errorf(<span class=\"hljs-string\">&quot;GetInfo test failed, got: %v, info: %s&quot;</span>, resBody.Data, resBody.Message)\n        }\n    }\n}\n</code></pre>\n"},{"title":"go-极速入门","tags":["go"],"categories":"go","description":"# 依赖包管理工具\n\n- dep\n  未完待续...\n- go vendor\n  未完待续...\n- glide\n  未完待续...\n- **go modules**\n  \n  伴随Go 1.11出现，**官方推荐**\n\n# go mod 命令\n- `go mod tidy`\n  \n  拉取缺少的模块，移除不用的模块\n- `go mod vandor`\n  \n  将依赖复制到vendor下\n-","createDate":"2020-01-14 13:43:45","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">依赖包管理工具</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>dep\n未完待续...</p>\n</li>\n<li><p>go vendor\n未完待续...</p>\n</li>\n<li><p>glide\n未完待续...</p>\n</li>\n<li><p><strong>go modules</strong></p>\n<p>伴随Go 1.11出现，<strong>官方推荐</strong></p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">go mod 命令</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p><code>go mod tidy</code></p>\n<p>拉取缺少的模块，移除不用的模块</p>\n</li>\n<li><p><code>go mod vandor</code></p>\n<p>将依赖复制到vendor下</p>\n</li>\n<li><p><code>go mod download</code></p>\n<p>下载依赖包</p>\n</li>\n<li><p><code>go mod verify</code></p>\n<p>检测依赖</p>\n</li>\n<li><p><code>go mod graph</code></p>\n<p>打印模块依赖图</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片就像数组的引用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片拥有 <em>长度</em> 和 <em>容量</em></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>切片的长度就是它所包含的元素个数。</li>\n<li>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</li>\n<li>切片 s 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">切片可以用内建函数 <code>make</code> 来创建，这也是创建动态数组的方式。<code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\">a := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">5</span>)  <span class=\"hljs-comment\">// len(a)=5</span>\n\n<span class=\"hljs-comment\">// 要指定它的容量，需向 make 传入第三个参数：</span>\nb := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// len(b)=0, cap(b)=5</span>\nb = b[:<span class=\"hljs-built_in\">cap</span>(b)] <span class=\"hljs-comment\">// len(b)=5, cap(b)=5</span>\nb = b[<span class=\"hljs-number\">1</span>:]      <span class=\"hljs-comment\">// len(b)=4, cap(b)=4</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">向切片追加元素</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。append 的结果是一个包含原切片所有元素加上新添加元素的切片。当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个(<strong>cap值翻倍</strong>)更大的数组。返回的切片会指向这个新分配的数组。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> s []<span class=\"hljs-type\">int</span>\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=0 cap=0 []</span>\n\n    <span class=\"hljs-comment\">// cap不够用——&gt;cap翻倍——&gt;cap=2</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">0</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=1 cap=2 [0]</span>\n\n    <span class=\"hljs-comment\">// cap够用——&gt;保持不变——&gt;cap=2</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">1</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=2 cap=2 [0 1]</span>\n\n    <span class=\"hljs-comment\">// cap不够用——&gt;cap翻倍——&gt;cap=8</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=5 cap=8 [0 1 2 3 4]</span>\n\n    <span class=\"hljs-comment\">// cap够用——&gt;cap保持不变——&gt;cap=8</span>\n    s = <span class=\"hljs-built_in\">append</span>(s, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>)\n    printSlice(s)\n    <span class=\"hljs-comment\">// len=8 cap=8 [0 1 2 3 4 5 6 7]</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printSlice</span><span class=\"hljs-params\">(s []<span class=\"hljs-type\">int</span>)</span></span> {\n    fmt.Printf(<span class=\"hljs-string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"hljs-built_in\">len</span>(s), <span class=\"hljs-built_in\">cap</span>(s), s)\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>map</code>-无序的 <code>key-value</code> 数据结构</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>map集合中的 <code>key/value</code> 可以是任意类型，但所有<code>key</code>必须同属于一种数据类型，所有的<code>value</code>必须同属于一种数据类型。<code>key</code> 和 <code>value</code> 的数据类型可以不相同</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>for</code>循环</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-go\">person := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span> { <span class=\"hljs-string\">&quot;tom&quot;</span>, <span class=\"hljs-string\">&quot;john&quot;</span>, <span class=\"hljs-string\">&quot;jerry&quot;</span> }\n\n<span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> person {\n  fmt.Printf(<span class=\"hljs-string\">&quot;person[%d]: %s\\n&quot;</span>, k, v)\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>go</code>关键字</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>在go关键字后面加一个函数，就可以创建一个线程，函数可以为已经写好的函数，也可以是匿名函数</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  fmt.Printf(<span class=\"hljs-string\">&quot;main start&quot;</span>)\n  <span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n    fmt.Println(<span class=\"hljs-string\">&quot;goroutine&quot;</span>)\n  }()\n  time.sleep(<span class=\"hljs-number\">1</span> * time.Second)\n  fmt.Printf(<span class=\"hljs-string\">&quot;main end&quot;</span>)\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>chan</code>-类似于队列，遵循先进先出的规则</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">声明<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// 声明不带缓冲的通道</span>\nch1 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>)\n\n<span class=\"hljs-comment\">// 声明带10个缓冲的通道</span>\nch2 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">10</span>)\n\n<span class=\"hljs-comment\">// 声明只读通道</span>\nch3 := <span class=\"hljs-built_in\">make</span>(&lt;-<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>)\n\n<span class=\"hljs-comment\">// 声明只写通道</span>\nch4 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span>&lt;- <span class=\"hljs-type\">string</span>)\n</code></pre>\n<p>不带缓冲的通道，进何处都会阻塞\n带缓冲的通道，进一次长度+1，出一次长度-1，如果长度等于缓冲区长度时，再进就会阻塞</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">写入<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\">ch1 := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">10</span>)\nch1 &lt;- <span class=\"hljs-string\">&quot;a&quot;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">读取<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\">val, ok := &lt;- ch1\nval := &lt;- ch1\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">关闭<code>chan</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-go\"><span class=\"hljs-built_in\">close</span>(<span class=\"hljs-keyword\">chan</span>)\n</code></pre>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">productor</span><span class=\"hljs-params\">(ch <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>)</span></span> {\n  fmt.Println(<span class=\"hljs-string\">&quot;producer start&quot;</span>)\n  ch &lt;- <span class=\"hljs-string\">&quot;a&quot;</span>\n  ch &lt;- <span class=\"hljs-string\">&quot;b&quot;</span>\n  ch &lt;- <span class=\"hljs-string\">&quot;c&quot;</span>\n  ch &lt;- <span class=\"hljs-string\">&quot;d&quot;</span>\n  fmt.Println(<span class=\"hljs-string\">&quot;producer end&quot;</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  fmt.Println(<span class=\"hljs-string\">&quot;main start&quot;</span>)\n  ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">3</span>)\n  <span class=\"hljs-keyword\">go</span> producer(ch)\n\n  time.Sleep(<span class=\"hljs-number\">1</span> * time.Second)\n  fmt.Println(<span class=\"hljs-string\">&quot;main end&quot;</span>)\n}\n\n<span class=\"hljs-comment\">// main start</span>\n<span class=\"hljs-comment\">// producer start  发生阻塞</span>\n<span class=\"hljs-comment\">// main end</span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>defer</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>主要应用场景有异常处理、记录日志、清理数据、释放资源 等等。</p>\n<ul>\n<li><code>defer</code>在声明时不会立刻去执行，而是在函数 <code>return</code> 后去执行的。</li>\n<li><code>defer</code>函数定义的顺序与实际执行的顺序是相反的，也就是最先声明的最后才执行</li>\n</ul>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;a&quot;</span>)\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;b&quot;</span>)\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;c&quot;</span>)\n  <span class=\"hljs-keyword\">defer</span> fmt.Println(<span class=\"hljs-string\">&quot;d&quot;</span>)\n\n  fmt.Println(<span class=\"hljs-string\">&quot;main&quot;</span>)\n}\n\n<span class=\"hljs-comment\">// main</span>\n<span class=\"hljs-comment\">// d</span>\n<span class=\"hljs-comment\">// c</span>\n<span class=\"hljs-comment\">// b</span>\n<span class=\"hljs-comment\">// a</span>\n</code></pre>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">calc</span><span class=\"hljs-params\">(index <span class=\"hljs-type\">string</span>, a, b <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n    ret := a + b\n    fmt.Println(index, a, b, ret)\n    <span class=\"hljs-keyword\">return</span> ret\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    x := <span class=\"hljs-number\">1</span>\n    y := <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-keyword\">defer</span> calc(<span class=\"hljs-string\">&quot;A&quot;</span>, x, calc(<span class=\"hljs-string\">&quot;B&quot;</span>, x, y))\n    x = <span class=\"hljs-number\">3</span>\n    <span class=\"hljs-keyword\">defer</span> calc(<span class=\"hljs-string\">&quot;C&quot;</span>, x, calc(<span class=\"hljs-string\">&quot;D&quot;</span>, x, y))\n    y = <span class=\"hljs-number\">4</span>\n}\n\n<span class=\"hljs-comment\">// B 1 2 3</span>\n<span class=\"hljs-comment\">// D 3 2 5</span>\n<span class=\"hljs-comment\">// C 3 5 8</span>\n<span class=\"hljs-comment\">// A 1 3 4</span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>interface</code></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基本</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>一种<strong>抽象</strong>类型</li>\n</ul>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n\n<span class=\"hljs-keyword\">type</span> Sayer <span class=\"hljs-keyword\">interface</span> {\n    say()\n}\n\n<span class=\"hljs-keyword\">type</span> Cat <span class=\"hljs-keyword\">struct</span> {\n    Sayer\n}\n\n<span class=\"hljs-keyword\">type</span> Dog <span class=\"hljs-keyword\">struct</span> {\n    Sayer\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(cat *Cat)</span></span> say() {\n    fmt.Println(<span class=\"hljs-string\">&quot;miao miao miao~&quot;</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(dog *Dog)</span></span> say() {\n    fmt.Println(<span class=\"hljs-string\">&quot;wang wang wang~&quot;</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> dog Dog\n    dog.say()\n    <span class=\"hljs-keyword\">var</span> cat Cat\n    cat.say()\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">空接口的应用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>空接口作为函数的参数</li>\n<li>空接口作为<code>map</code>的值</li>\n<li>类型断言<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">var</span> x <span class=\"hljs-keyword\">interface</span>{}\n  x = <span class=\"hljs-string\">&quot;hello world&quot;</span>\n  v, ok := x.(<span class=\"hljs-type\">string</span>)\n  <span class=\"hljs-keyword\">if</span> ok {\n      fmt.Println(v)\n  } <span class=\"hljs-keyword\">else</span> {\n      fmt.Println(<span class=\"hljs-string\">&quot;类型断言失败&quot;</span>)\n  }\n}\n</code></pre>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">单元测试</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的<code>Go</code>代码过程是类似的。</p>\n<p><code>go test</code>命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>\n<p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th align=\"left\">格式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>测试函数</td>\n<td align=\"left\">函数名前缀为<code>Test</code></td>\n<td>测试程序的一些逻辑行为是否正确</td>\n</tr>\n<tr>\n<td>基准函数</td>\n<td align=\"left\">函数名前缀为<code>Benchmark</code></td>\n<td>测试函数的性能</td>\n</tr>\n<tr>\n<td>示例函数</td>\n<td align=\"left\">函数名前缀为<code>Example</code></td>\n<td>为文档提供示例文档</td>\n</tr>\n</tbody></table>\n<p>测试函数实例</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestName</span><span class=\"hljs-params\">(t *testing.T)</span></span>{\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n"},{"title":"hello world","tags":["tags"],"categories":"hello","description":"","createDate":"2018-11-08 15:04:00","updateDate":"10/1/2021, 3:34:43 AM","body":""},{"title":"vue-router剖析","tags":["Vue.js","vue-router"],"categories":"Vue.js","description":"# 路由\r\n\r\n路由最早由后端提出，用于根据不同的请求返回不同的页面。大致流程如下：\r\n\r\n1. 浏览器发出请求\r\n2. 服务器监听到端口有请求过来\r\n3. 根据服务器的路由配置，返回相应信息（可以是html、json、图片等）\r\n4. 浏览器根据数据包的`Context-Type`来决定如何解析\r\n\r\n# 前端路由\r\n\r\n随着`ajax`的流行，异步数据请求交互在不刷新浏览器的情况下运行","createDate":"2020-03-09 22:05:40","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">路由</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>路由最早由后端提出，用于根据不同的请求返回不同的页面。大致流程如下：</p>\n<ol>\n<li>浏览器发出请求</li>\n<li>服务器监听到端口有请求过来</li>\n<li>根据服务器的路由配置，返回相应信息（可以是html、json、图片等）</li>\n<li>浏览器根据数据包的<code>Context-Type</code>来决定如何解析</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">前端路由</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>随着<code>ajax</code>的流行，异步数据请求交互在不刷新浏览器的情况下运行。而异步交互体验的高级版本就是SPA-单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。类似于后端路由，前端路由就是匹配不同的url路径进行解析，然后动态渲染html内容。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">hash模式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>https://www.xxx.com/#/hash</code></p>\n<p>这种<code>#</code>后面<code>hash</code>值得变化，并不会触发新的请求，因此也不会刷新页面。每次<code>hash</code>值的变化都会触发<code>hashchange</code>事件，通过这个事件就可以知道更新哪些页面内容</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onhashchange</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e.<span class=\"hljs-property\">oldURL</span>, e.<span class=\"hljs-property\">newURL</span>)\n    <span class=\"hljs-keyword\">const</span> hash = location.<span class=\"hljs-property\">hash</span>.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)\n    app.<span class=\"hljs-property\">innerHTML</span> = hash\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">history模式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>https://www.xxx.com/login</code></p>\n<p>随着HTML5的发布，带来了两个新的API：<code>pushState</code>和<code>replaceState</code>，通过这两个API可以改变url地址且不会发送请求。同时还有<code>popstate</code>事件用来监听url的改变。使用history模式，url就不会出现丑陋的<code>#</code>，url也变得比较美观。</p>\n<p>通过history api去掉了丑陋的<code>#</code>，但也存在问题：不怕前进/后退，就怕<strong>刷新</strong>。因为刷新是去请求服务器的，在<code>hash</code>下，前端路由修改的是#之后的内容，在发送请求时是不会带上的，但在history下可以自由地修改路径、参数，当刷新时，如果服务器中没有相应的响应或资源，容易爆<code>404</code></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vue-router核心原理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li><p>通过<code>new VueRouter</code>中的<code>mode</code>参数来选择使用那种路由模式</p>\n</li>\n<li><p>在<code>router</code>中使用<code>current</code>保存当前url</p>\n</li>\n<li><p>作为一个插件，大部分功能都在<code>install</code>函数中完成</p>\n</li>\n<li><p>在<code>install</code>中使用<code>Vue.mixin</code>注入的<code>beforeCreate</code>来给组件添加全局唯一的<code>router</code>实例（挂载在根组件上，其余组件通过<code>$parent._routerRoot._router</code>挂载）</p>\n</li>\n<li><p>使用<code>popstate</code>或<code>hashchange</code>两个事件来监听url变化（针对于手动输入url）并设置<code>current</code></p>\n</li>\n<li><p>使用<code>Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)</code>来使<code>router</code>变为响应式</p>\n<p>current变化    👉    重新渲染<code>router-view</code>中的组件 </p>\n</li>\n<li><p>解析路由配置从而可以更加便利地找到url所对应的页面</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Array</span>&lt;{ <span class=\"hljs-attr\">name</span>: component }&gt;\n</code></pre>\n<p>👇</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Map</span>&lt;{ <span class=\"hljs-attr\">name</span>: component }&gt;\n</code></pre>\n</li>\n<li><p>实现<code>&lt;router-link&gt;&lt;/router-link&gt;</code>和<code>&lt;router-view / &gt;</code>两个组件</p>\n</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>vue-router</code>以插件方式侵入<code>Vue</code>，从而支持一个额外的<code>router</code>属性，以提供监听并改变组件路由数据的能力，这样每次路由发生变化后，可以同步到数据，从而响应式地触发组件的更新</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-router.png\" alt=\"vue-router\"></p>\n"},{"title":"vuex剖析","tags":["Vue.js","vuex"],"categories":"Vue.js","description":"vuex是专门为Vue.js设计的**状态管理工具**，它采用**集中式存储**管理应用的所有状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n## vuex的构成\n\n- 引入`State`、`Getter`对状态进行定义\n\n- 使用`Mutation`、`Action`对状态进行修改\n\n- 使用`Module`对状态进行模块化分割\n\n- 引入插件对状态进行快照、记录、跟踪等\n\n-","createDate":"2020-03-10 20:50:56","updateDate":"10/1/2021, 3:34:43 AM","body":"<p>vuex是专门为Vue.js设计的<strong>状态管理工具</strong>，它采用<strong>集中式存储</strong>管理应用的所有状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex的构成</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>引入<code>State</code>、<code>Getter</code>对状态进行定义</p>\n</li>\n<li><p>使用<code>Mutation</code>、<code>Action</code>对状态进行修改</p>\n</li>\n<li><p>使用<code>Module</code>对状态进行模块化分割</p>\n</li>\n<li><p>引入插件对状态进行快照、记录、跟踪等</p>\n</li>\n<li><p>提供<code>mapState</code>、<code>mapGetters</code>、<code>mapActions</code>、<code>mapMutations</code>辅助函数方便开发者处理store</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-0.png\" alt=\"vuex组成\"></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex的store是如何注入到组件中的</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p>通过vue的<a href=\"https://cn.vuejs.org/v2/guide/mixins.html\">mixin</a>机制，在<code>install</code>函数中借助于vue的<code>beforeCreate</code>生命周期函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">mixin</span>({ <span class=\"hljs-attr\">beforeCreate</span>: vuexInit })\n</code></pre>\n</li>\n<li><p>在<code>beforeCreate</code>中调用vuexInit将store挂载到当前实例上</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">vuexInit</span> () {\n    <span class=\"hljs-keyword\">const</span> options = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$options</span>\n    <span class=\"hljs-comment\">// store injection</span>\n    <span class=\"hljs-keyword\">if</span> (options.<span class=\"hljs-property\">store</span>) {\n        <span class=\"hljs-comment\">// 根组件通过options.store挂载</span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$store</span> = <span class=\"hljs-keyword\">typeof</span> options.<span class=\"hljs-property\">store</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n            ? options.<span class=\"hljs-title function_\">store</span>()\n            : options.<span class=\"hljs-property\">store</span>\n        <span class=\"hljs-comment\">// 其余组件通过父组件上的store挂载</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (options.<span class=\"hljs-property\">parent</span> &amp;&amp; options.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">$store</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$store</span> = options.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">$store</span>\n    }\n}\n</code></pre>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-1.jpg\" alt=\"store注入\"></p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex的state和getter是如何映射到各个组件实例中自动更新的</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    \n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">state</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Store</span> {\n    construcor () {\n        <span class=\"hljs-title function_\">resetStoreVM</span>()\n    }\n    get state () {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_vm</span>.<span class=\"hljs-property\">_data</span>.<span class=\"hljs-property\">$$state</span>\n    }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">resetStoreVM</span>(<span class=\"hljs-params\"></span>) {\n       store.<span class=\"hljs-property\">_vm</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>({\n           <span class=\"hljs-attr\">data</span>: {\n               <span class=\"hljs-attr\">$$state</span>: state\n           },\n          computed\n    })\n}\n</code></pre>\n<p>从源码得知，当使用<code>this.$store.state.xxx</code>时会被代理到<code>store._vm._data.$$state</code>上，而<code>store._vm</code>是一个Vue实例，由于示例中的data是响应式的，所以$$state也是响应式的，那么当更新state时，所有相关组件中的state也会自动更新</p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">getter</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">resetStoreVM</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">forEachValue</span>(wrappedGetters, <span class=\"hljs-function\">(<span class=\"hljs-params\">fn, key</span>) =&gt;</span> {\n        <span class=\"hljs-comment\">// use computed to leverage its lazy-caching mechanism</span>\n        <span class=\"hljs-comment\">// direct inline function use will lead to closure preserving oldVm.</span>\n        <span class=\"hljs-comment\">// using partial to return function with only arguments preserved in closure environment.</span>\n        computed[key] = <span class=\"hljs-title function_\">partial</span>(fn, store)\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(store.<span class=\"hljs-property\">getters</span>, key, {\n            <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">() =&gt;</span> store.<span class=\"hljs-property\">_vm</span>[key],\n            <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// for local getters</span>\n        })\n    })\n}\n</code></pre>\n<p>从源码得知，当使用<code>this.$store.getter.xxx</code>时会被代理到<code>store._vm.xxx</code>，其中添加<code>computed</code>属性</p>\n<p>从上面可以看出，vuex中的<code>state</code>是借助于一个Vue.js实例，将<code>state</code>存入实例的<code>data</code>中；Vuex中的<code>getter</code>则是借助于实例的计算属性<code>computed</code>实现数据监听</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-3.png\" alt=\"state、getter响应式\"></p>\n"},{"title":"webpack学习-0","tags":["webpack"],"categories":"webpack","description":"## webpack\n\n`webpack`是一个现代的`JavaScript`应用程序打包工具。当`webpack`处理应用程序时，会递归构建一个**依赖关系图**，其中包含应用程序需要的每个模块，然后将这个模块打包成一个或多个bundle\n\n![概念图](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack-0.png)\n\n## webp","createDate":"2020-03-12 23:51:35","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">webpack</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>webpack</code>是一个现代的<code>JavaScript</code>应用程序打包工具。当<code>webpack</code>处理应用程序时，会递归构建一个<strong>依赖关系图</strong>，其中包含应用程序需要的每个模块，然后将这个模块打包成一个或多个bundle</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack-0.png\" alt=\"概念图\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">webpack的核心概念</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>entry</code>（入口）</p>\n<p>入口指示<code>webpack</code>应该使用哪个模块来作为构建其内部<strong>依赖图</strong>的开始。进入入口起点后，<code>webpack</code>会找出有哪些模块是库入口起点（直接和间接）依赖的</p>\n<p>每个依赖项随即被处理，最后输出到称之为<code>bundles</code>的文件中。</p>\n<p>可以通过在<code>webpack</code>配置中配置entry属性来指定一个或多个入口起点。默认为<code>./src</code></p>\n</li>\n<li><p><code>output</code>（出口）</p>\n<p><code>output</code>告诉<code>webpack</code>在哪输出它所创建的<code>bundles</code>，以及如何命名这些文件，默认值为<code>./dist</code>。基本上，整个应用程序结构都会被编译到指定的输出路径的文件夹中。可以通过配置文件中的<code>output</code>字段来指定输出的文件夹</p>\n</li>\n<li><p><code>loader</code></p>\n<p><code>loader</code>让<code>webpack</code>能够去处理那些非<code>JavaScript</code>文件（<code>webpack</code>自身只理解<code>JavaScript</code>）。<code>loader</code>能够将所有类型的文件转换为<code>webpack</code>能够处理的有效模块，然后就可以利用<code>webpack</code>的打包能力对它们进行处理。</p>\n<p>同一个<code>rule</code>下的多个<code>loader</code>时将从右往左执行</p>\n</li>\n<li><p><code>plugin</code></p>\n<p><code>loader</code>被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括从打包优化和压缩一直到重新定义环境中的变量，插件接口功能极其强大，可以用来处理各种各样的任务。</p>\n<p>想要使用一个插件，只需要<code>require</code>它，然后把它添加到<code>plugins</code>配置项中。多数插件可以通过选项自定义。</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">配置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>webpack</code>的相关配置主要由根目录下的<code>webpack.config.js</code>来完成</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,\n    <span class=\"hljs-attr\">entry</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>]\n    <span class=\"hljs-attr\">output</span>: {},\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [{}]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [{}],\n    <span class=\"hljs-attr\">devServer</span>: {},\n    <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">&#x27;xxx&#x27;</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">处理JavaScript:babel-loader</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>webpack</code>本身可以识别<code>JavaScript</code>，但为了兼容老的浏览器，需要将<code>ES6</code>转换为向后兼容版本的<code>JavaScript</code>代码，<a href=\"https://babel.docschina.org/\">Babel</a>就是这么一种工具链。</p>\n<p>当<code>webpack</code>打包源代码时，可能会很难追踪到错误和警告在源代码中的起始位置。为了<strong>更容易追踪错误和警告</strong>，<code>JavaScript</code>提供了<a href=\"http://blog.teamtreehouse.com/introduction-source-maps\">source map</a>功能，将编译后的代码映射回原始代码。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//webpack.config.js</span>\n<span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n        {\n            <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.js?$/</span>,\n            <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>],\n            <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n        }\n    ],\n    <span class=\"hljs-comment\">// 开启source-map</span>\n    <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">&#x27;cheap-module-eval-source-map&#x27;</span>\n}\n\n<span class=\"hljs-comment\">//babel.config.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">api</span>) {\n    api.<span class=\"hljs-title function_\">cache</span>(<span class=\"hljs-literal\">true</span>)\n    <span class=\"hljs-keyword\">const</span> presets = [<span class=\"hljs-string\">&quot;@babel/preset-env&quot;</span>]\n    <span class=\"hljs-keyword\">const</span> plugins = [\n        [\n            <span class=\"hljs-string\">&quot;@babel/plugin-transform-runtime&quot;</span>,\n            {\n                <span class=\"hljs-attr\">corejs</span>: <span class=\"hljs-number\">3</span>\n            }\n        ]\n    ]\n\n    <span class=\"hljs-keyword\">return</span> {\n        presets,\n        plugins\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">处理HTML</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>有时为了清除缓存，打包文件时会带有hash，那么每次生成的文件名会有所不同。如果在<code>html</code>中引用了这些文件，则需要更改引入的文件名，手工改动不可取。我们可以使用<code>html-webpack-plugin</code>来帮助处理</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HtmlWebpackPlugin</span>({\n            <span class=\"hljs-comment\">// template指定生成html的模板文件</span>\n            <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;./public/index.html&#x27;</span>,\n            <span class=\"hljs-comment\">// 默认生成在./dist/index.html</span>\n            <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.html&#x27;</span>,\n            <span class=\"hljs-attr\">minify</span>: {\n                <span class=\"hljs-attr\">removeAttributeQuotes</span>: <span class=\"hljs-literal\">false</span>,\n                <span class=\"hljs-attr\">collapseWhitespace</span>: <span class=\"hljs-literal\">false</span>\n            }\n        })\n    ]\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">处理*ss</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>style-loader</code>，动态创建<code>style</code>标签，将<code>css</code>插入到<code>head</code>中</li>\n<li><code>css-loader</code>，负责处理<code>@import</code>等语句</li>\n<li><code>postcss-loader</code>和<code>autoprefixer</code>，自动生成浏览器兼容性前缀</li>\n<li><code>less-loader</code>，负责编译<code>.less</code>文件</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(le|c)ss$/</span>,\n                <span class=\"hljs-attr\">use</span>: [\n                    <span class=\"hljs-string\">&#x27;style-loader&#x27;</span>,\n                    <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>,\n                    {\n                        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">plugins</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                                <span class=\"hljs-keyword\">return</span> [\n                                    <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;autoprefixer&#x27;</span>)({\n                                        <span class=\"hljs-string\">&#x27;overrideBrowserslist&#x27;</span>: [\n                                            <span class=\"hljs-string\">&quot;&gt;0.25%&quot;</span>,\n                                            <span class=\"hljs-string\">&#x27;not dead&#x27;</span>\n                                        ]\n                                    })\n                                ]\n                            }\n                        }\n                    },\n                    <span class=\"hljs-string\">&#x27;less-loader&#x27;</span>\n                ],\n                <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n            }\n        ]\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">处理本地资源文件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>可以使用url-loader或file-loader来处理本地的资源文件。url-loader和file-loader功能类似，但是url-loader可以指定文件在小于某一特定值下返回DataURL，可以减少http请求，推荐使用</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(png|jpg|gif|jpeg|svg|ttf)$/</span>,\n                <span class=\"hljs-attr\">use</span>: [\n                    {\n                        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;url-loader&#x27;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">10240</span>,\n                            <span class=\"hljs-attr\">esModule</span>: <span class=\"hljs-literal\">false</span>,\n                            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;assets/[name]_[hash:6].[ext]&#x27;</span>\n                        }\n                    }\n                ],\n                <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n            }\n        ]\n    }\n}\n</code></pre>\n<p>此外，对于html中的图片，url-loader则无能为力，此时需要<code>html-withimg-loader</code>来协助</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.html/</span>,\n                <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-string\">&#x27;html-withimg-loader&#x27;</span>],\n                <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>\n            }\n        ]\n    }\n}\n</code></pre>\n"},{"title":"webpack学习-1","tags":["webpack"],"categories":"webpack","description":"# 模块解析\n\n## 解析规则\n\n- 解析相对路径\n  1. 查找相对当前模块的路径下是否有对应文件或文件夹\n  2. 是文件则直接加载\n  3. 是文件夹则继续查找文件夹下的 `package.json` 文件\n  4. 有 package.json 文件则按照文件中 `main` 字段的文件名来查找文件\n  5. 无 package.json 或者无 `main` 字段则查找 `index","createDate":"2020-04-13 23:19:33","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模块解析</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解析规则</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>解析相对路径<ol>\n<li>查找相对当前模块的路径下是否有对应文件或文件夹</li>\n<li>是文件则直接加载</li>\n<li>是文件夹则继续查找文件夹下的 <code>package.json</code> 文件</li>\n<li>有 package.json 文件则按照文件中 <code>main</code> 字段的文件名来查找文件</li>\n<li>无 package.json 或者无 <code>main</code> 字段则查找 <code>index.js</code> 文件</li>\n</ol>\n</li>\n<li>解析模块名\n查找当前文件目录下，父级目录及以上目录下的 <code>node_modules</code> 文件夹，看是否有对应名称的模块</li>\n<li>解析绝对路径（不建议使用）\n直接查找对应路径的文件</li>\n</ul>\n<p>在 webpack 配置中，和模块路径解析相关的配置都在 <code>resolve</code> 字段下：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">resolve</span>: {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">常用配置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>resolve.alias</code>， 配置别名</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">resolve</span>: {\n        <span class=\"hljs-attr\">alias</span>: {\n            <span class=\"hljs-attr\">utils$</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;src/utils&#x27;</span>) <span class=\"hljs-comment\">// 只会匹配 import &#x27;utils&#x27;</span>\n        }\n    }\n}\n</code></pre>\n</li>\n<li><p><code>resolve.extensions</code>，文件扩展名简写</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">resolve</span>: {\n        <span class=\"hljs-attr\">extensions</span>: {\n            <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">&#x27;.wasm&#x27;</span>, <span class=\"hljs-string\">&#x27;.mjs&#x27;</span>, <span class=\"hljs-string\">&#x27;.js&#x27;</span>, <span class=\"hljs-string\">&#x27;.json&#x27;</span>, <span class=\"hljs-string\">&#x27;.jsx&#x27;</span>],\n        }\n    }\n}\n</code></pre>\n</li>\n<li><p><code>resolve.modules</code>，配置直接声明依赖名的模块的解析路径</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">resolve</span>: {\n      <span class=\"hljs-attr\">modules</span>: [\n        path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;node_modules&#x27;</span>), <span class=\"hljs-comment\">// 指定当前目录下的 node_modules 优先查找</span>\n        <span class=\"hljs-string\">&#x27;node_modules&#x27;</span>, <span class=\"hljs-comment\">// 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录</span>\n      ],\n    }\n}\n</code></pre>\n</li>\n<li><p><code>resolve.mainFields</code>，有<code>package.json</code>文件入口文件的配置</p>\n</li>\n<li><p><code>resolve.mainFiles</code>，没有<code>package.json</code>文件时入口文件的配置</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">loader</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>webpack 的 <code>loader</code> 相关配置都在 <code>module.rules</code> 字段下，我们需要通过 <code>test</code>、<code>include</code>、<code>exclude</code> 等配置好应用 <code>loader</code> 的条件规则，然后使用 <code>use</code> 来指定需要用到的 <code>loader</code>，配置应用的 <code>loader</code> 时还需要注意一下 <code>loader</code> 的执行顺序。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">modules</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-comment\">//,</span>\n                <span class=\"hljs-attr\">include</span>: [],\n                <span class=\"hljs-attr\">use</span>: xxx\n            }\n        ]\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">规则条件配置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>{ test: ... }</code> 匹配特定条件</li>\n<li><code>{ include: ... }</code> 匹配特定路径</li>\n<li><code>{ exclude: ... }</code> 排除特定路径</li>\n<li><code>{ and: [...] }</code>必须匹配数组中所有条件</li>\n<li><code>{ or: [...] }</code> 匹配数组中任意一个条件</li>\n<li><code>{ not: [...] }</code> 排除匹配数组中所有条件</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">module type</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.js?$/</span>,\n  <span class=\"hljs-attr\">include</span>: [\n    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;src&quot;</span>)\n  ],\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;javascript/esm&quot;</span>\n}\n</code></pre>\n<p>现阶段webpack支持以下几种模块类型：</p>\n<ul>\n<li><code>javascript/auto</code>，默认类型，支持所有JS代码模块类型：CommonJS、AMD、ESM</li>\n<li><code>javascript/esm</code>，ECMAScript Modules</li>\n<li><code>javascript/dynamic</code>，CommonJS和AMD</li>\n<li><code>javascript/json</code>，JSON格式数据，<code>require</code>和<code>import</code>都可以引入，是<code>.json</code>文件的默认类型</li>\n<li><code>javascript/experimental</code>，WebAeesmbly Modules，是<code>.wasm</code>文件的默认类型</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">loader应用顺序</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>同一个rule下，<strong>从右往左执行</strong></p>\n</li>\n<li><p>多个rule匹配同一个模块文件：</p>\n<p>webpack 在 <code>rules</code> 中提供了一个 <code>enforce</code> 的字段来配置当前 rule 的 loader 类型，没配置的话是普通类型，可以配置 <code>pre</code> 或 <code>post</code>，分别对应前置类型或后置类型的 loader。</p>\n<p>执行顺序：<strong>前置 -&gt; 行内 -&gt; 普通 -&gt; 后置</strong></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用noParse</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>除了<code>module.rules</code>字段用于配置loader之外，还有一个<code>module.noParse</code>字段可以用于配置哪些模块文件的内容不需要进行解析。对于一些不需要解析依赖（即无依赖，没有使用<code>import</code>、<code>require</code>、<code>define</code>等导入机制）的第三方大型类库可以通过这个字段配置以提高整体的构建速度</p>\n"},{"title":"函数式编程-容器/函子","tags":["函数式编程","容器/函子"],"categories":"函数式编程","description":"# 声明式编程(Declarative) vs 命令式编程(Imperative)\n\n- 命令式编程就是对硬件操作的抽象， 程序员需要通过指令，精确的告诉计算机干什么事情；声明式编程只会将需要什么告诉计算机，剩下的将交由计算机自行完成。\n- 声明式编程写表达式， 命令式编程写一步一步的指示\n\n# 容器(container)\n\n- 一个对象\n- 可以装载任意类型的值（大多数容器只有一个）\n- 使","createDate":"2019-10-16 13:43:11","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">声明式编程(Declarative) vs 命令式编程(Imperative)</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>命令式编程就是对硬件操作的抽象， 程序员需要通过指令，精确的告诉计算机干什么事情；声明式编程只会将需要什么告诉计算机，剩下的将交由计算机自行完成。</li>\n<li>声明式编程写表达式， 命令式编程写一步一步的指示</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">容器(container)</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>一个对象</li>\n<li>可以装载任意类型的值（大多数容器只有一个）</li>\n<li>使用 of 替代 new</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Container</span> {\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-params\">x</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Container</span>(x);\n  }\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__value</span> = x;\n  }\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Container</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">//Container { __value: 3 }</span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">函子(functor)</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>functor 是实现了 map 函数并遵守一些特定规则的容器类型</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Functor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Container</span> {\n  <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-params\">f</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Container</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-title function_\">f</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__value</span>));\n  }\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Functor</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x + <span class=\"hljs-number\">3</span>));\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Maybe</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在 map 方法里设置了空值检查</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Maybe</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">x</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__value</span> = x;\n  }\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-params\">x</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Maybe</span>(x);\n  }\n  <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-params\">f</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__value</span> ? <span class=\"hljs-title class_\">Maybe</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-title function_\">f</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__value</span>)) : <span class=\"hljs-title class_\">Maybe</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-literal\">null</span>);\n  }\n}\n\n<span class=\"hljs-title class_\">Maybe</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-literal\">null</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Either</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>用于实现 if...else...，Either 函子内部有两个值，**左值(left)<strong>和</strong>右值(right)**，右值是正常情况下使用的值，左值是右值不存在的时候使用的默认值</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Either</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Functor</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">left, right</span>) {\n    <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-literal\">null</span>);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">left</span> = left;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">right</span> = right;\n  }\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-params\">left, right</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Either</span>(left, right);\n  }\n  <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-params\">f</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">right</span>\n      ? <span class=\"hljs-title class_\">Either</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">left</span>, <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">right</span>))\n      : <span class=\"hljs-title class_\">Either</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-title function_\">f</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">left</span>), <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">right</span>);\n  }\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Either</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x + <span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// Either { __value: null, left: 5, right: 7 }</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Either</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-literal\">null</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x + <span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// Either { __value: null, left: 6, right: null }</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">IO</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Task</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    "},{"title":"函数式编程-柯里化/组合","tags":["tags"],"categories":"函数式编程","description":"# 柯里化(curry)\n\n只传递给函数一个参数，让它返回一个函数去处理剩下的参数\n\n```javascript\nconst _ = require(\"ramda\");\nconst accounting = require(\"accounting\");\n\nfunction match(reg, str) {\n  return str.match(reg);\n}\nlet match_ = _.c","createDate":"2019-10-15 15:24:40","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">柯里化(curry)</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>只传递给函数一个参数，让它返回一个函数去处理剩下的参数</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> _ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;ramda&quot;</span>);\n<span class=\"hljs-keyword\">const</span> accounting = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;accounting&quot;</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">match</span>(<span class=\"hljs-params\">reg, str</span>) {\n  <span class=\"hljs-keyword\">return</span> str.<span class=\"hljs-title function_\">match</span>(reg);\n}\n<span class=\"hljs-keyword\">let</span> match_ = _.<span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">reg, str</span>) =&gt;</span> str.<span class=\"hljs-title function_\">match</span>(reg));\n<span class=\"hljs-keyword\">let</span> replace = _.<span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">reg, replacement, str</span>) =&gt;</span> str.<span class=\"hljs-title function_\">replace</span>(reg, replacement));\n<span class=\"hljs-keyword\">let</span> filter = _.<span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f, any</span>) =&gt;</span> any.<span class=\"hljs-title function_\">filter</span>(f));\n<span class=\"hljs-keyword\">let</span> map = _.<span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f, any</span>) =&gt;</span> any.<span class=\"hljs-title function_\">map</span>(f));\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;no curry&quot;</span>, <span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/\\s+/g</span>, <span class=\"hljs-string\">&quot;hello world&quot;</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;width curry:&quot;</span>, <span class=\"hljs-title function_\">match_</span>(<span class=\"hljs-regexp\">/\\s+/g</span>)(<span class=\"hljs-string\">&quot;hello world&quot;</span>)); <span class=\"hljs-comment\">// width curry: [ &#x27; &#x27; ]</span>\n\n<span class=\"hljs-keyword\">let</span> hasSpace = <span class=\"hljs-title function_\">match_</span>(<span class=\"hljs-regexp\">/\\s+/g</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">hasSpace</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>)); <span class=\"hljs-comment\">// [ &#x27; &#x27; ]</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">match_</span>(<span class=\"hljs-regexp\">/\\s+/g</span>)(<span class=\"hljs-string\">&quot;spaceless&quot;</span>)); <span class=\"hljs-comment\">// null</span>\n\n<span class=\"hljs-keyword\">let</span> findSpace = <span class=\"hljs-title function_\">filter</span>(hasSpace);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">findSpace</span>([<span class=\"hljs-string\">&quot;hello world&quot;</span>, <span class=\"hljs-string\">&quot;spaceless&quot;</span>])); <span class=\"hljs-comment\">// [ &#x27;hello world&#x27; ]</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title function_\">match_</span>(<span class=\"hljs-regexp\">/\\s+/g</span>))([<span class=\"hljs-string\">&quot;hello world&quot;</span>, <span class=\"hljs-string\">&quot;spaceless&quot;</span>])); <span class=\"hljs-comment\">// [ &#x27;hello world&#x27; ]</span>\n\n<span class=\"hljs-keyword\">let</span> noVowels = <span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/[aeiou]/gi</span>);\n<span class=\"hljs-keyword\">let</span> censored = <span class=\"hljs-title function_\">noVowels</span>(<span class=\"hljs-string\">&quot;*&quot;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">censored</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>)); <span class=\"hljs-comment\">// h*ll* w*rld</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/[aeiou]/gi</span>)(<span class=\"hljs-string\">&quot;*&quot;</span>)(<span class=\"hljs-string\">&quot;hello world&quot;</span>)); <span class=\"hljs-comment\">// h*ll* w*rld</span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组合(compose)</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>将多个函数结合产生另一个函数</p>\n<ul>\n<li>多个函数执行的过程中(<strong>由右致左</strong>)</li>\n<li>上一个函数的执行结果是下一个函数的参数</li>\n<li>compose 的分组满足结合律, compose(f, g, h) === compose(compose(f, g), h) === compose(f, compose(g, h))</li>\n</ul>\n<p>((y → z), (x → y), …, (o → p), ((a, b, …, n) → o)) → ((a, b, …, n) → z)</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">CARS</span> = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Ferrari FF&quot;</span>, <span class=\"hljs-attr\">horsepower</span>: <span class=\"hljs-number\">660</span>, <span class=\"hljs-attr\">dollar_value</span>: <span class=\"hljs-number\">700000</span>, <span class=\"hljs-attr\">in_stock</span>: <span class=\"hljs-literal\">true</span> },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Spyker C12 Zagato&quot;</span>,\n    <span class=\"hljs-attr\">horsepower</span>: <span class=\"hljs-number\">650</span>,\n    <span class=\"hljs-attr\">dollar_value</span>: <span class=\"hljs-number\">648000</span>,\n    <span class=\"hljs-attr\">in_stock</span>: <span class=\"hljs-literal\">false</span>\n  },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Jaguar XKR-S&quot;</span>,\n    <span class=\"hljs-attr\">horsepower</span>: <span class=\"hljs-number\">550</span>,\n    <span class=\"hljs-attr\">dollar_value</span>: <span class=\"hljs-number\">132000</span>,\n    <span class=\"hljs-attr\">in_stock</span>: <span class=\"hljs-literal\">false</span>\n  },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Audi R8&quot;</span>, <span class=\"hljs-attr\">horsepower</span>: <span class=\"hljs-number\">525</span>, <span class=\"hljs-attr\">dollar_value</span>: <span class=\"hljs-number\">114200</span>, <span class=\"hljs-attr\">in_stock</span>: <span class=\"hljs-literal\">false</span> },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Aston Martin One-77&quot;</span>,\n    <span class=\"hljs-attr\">horsepower</span>: <span class=\"hljs-number\">750</span>,\n    <span class=\"hljs-attr\">dollar_value</span>: <span class=\"hljs-number\">1850000</span>,\n    <span class=\"hljs-attr\">in_stock</span>: <span class=\"hljs-literal\">true</span>\n  },\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Pagani Huayra&quot;</span>,\n    <span class=\"hljs-attr\">horsepower</span>: <span class=\"hljs-number\">700</span>,\n    <span class=\"hljs-attr\">dollar_value</span>: <span class=\"hljs-number\">1300000</span>,\n    <span class=\"hljs-attr\">in_stock</span>: <span class=\"hljs-literal\">false</span>\n  }\n];\n\n<span class=\"hljs-keyword\">const</span> isLastInStock = _.<span class=\"hljs-title function_\">compose</span>(\n  _.<span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-string\">&quot;in_stock&quot;</span>),\n  _.<span class=\"hljs-property\">last</span>\n);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">isLastInStock</span>(<span class=\"hljs-variable constant_\">CARS</span>));\n\n<span class=\"hljs-keyword\">const</span> firstName = _.<span class=\"hljs-title function_\">compose</span>(\n  _.<span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-string\">&quot;name&quot;</span>),\n  _.<span class=\"hljs-property\">head</span>\n);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">firstName</span>(<span class=\"hljs-variable constant_\">CARS</span>));\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_average</span>(<span class=\"hljs-params\">xs</span>) {\n  <span class=\"hljs-keyword\">return</span> _.<span class=\"hljs-title function_\">reduce</span>(_.<span class=\"hljs-property\">add</span>, <span class=\"hljs-number\">0</span>, xs) / xs.<span class=\"hljs-property\">length</span>;\n}\n<span class=\"hljs-keyword\">var</span> averageDollarValue = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cars</span>) {\n  <span class=\"hljs-keyword\">var</span> dollar_values = _.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">c</span>) {\n    <span class=\"hljs-keyword\">return</span> c.<span class=\"hljs-property\">dollar_value</span>;\n  }, cars);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_average</span>(dollar_values);\n};\n\n<span class=\"hljs-keyword\">const</span> averageDollarValue_ = _.<span class=\"hljs-title function_\">compose</span>(\n  _average,\n  _.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-property\">dollar_value</span>)\n);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">averageDollarValue_</span>(<span class=\"hljs-variable constant_\">CARS</span>));\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_underscore</span>(<span class=\"hljs-params\">word</span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(word);\n}\n<span class=\"hljs-keyword\">const</span> sanitizeNames = _.<span class=\"hljs-title function_\">compose</span>(\n  _.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span>\n    _.<span class=\"hljs-title function_\">compose</span>(\n      _.<span class=\"hljs-property\">toLower</span>,\n      _.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">&quot;_&quot;</span>),\n      _.<span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\n    )(item)\n  )\n);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sanitizeNames</span>(<span class=\"hljs-variable constant_\">CARS</span>));\n\n<span class=\"hljs-keyword\">const</span> availablePrices = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cars</span>) {\n  <span class=\"hljs-keyword\">var</span> available_cars = _.<span class=\"hljs-title function_\">filter</span>(_.<span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-string\">&quot;in_stock&quot;</span>), cars);\n  <span class=\"hljs-keyword\">return</span> available_cars\n    .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) {\n      <span class=\"hljs-keyword\">return</span> accounting.<span class=\"hljs-title function_\">formatMoney</span>(x.<span class=\"hljs-property\">dollar_value</span>);\n    })\n    .<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;, &quot;</span>);\n};\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">availablePrices</span>(<span class=\"hljs-variable constant_\">CARS</span>));\n\n<span class=\"hljs-keyword\">const</span> availablePrices_ = _.<span class=\"hljs-title function_\">compose</span>(\n  _.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;, &quot;</span>),\n  _.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> accounting.<span class=\"hljs-title function_\">formatMoney</span>(item.<span class=\"hljs-property\">dollar_value</span>)),\n  _.<span class=\"hljs-title function_\">filter</span>(_.<span class=\"hljs-title function_\">prop</span>(<span class=\"hljs-string\">&quot;in_stock&quot;</span>))\n);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">availablePrices_</span>(<span class=\"hljs-variable constant_\">CARS</span>));\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pointfree</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>pointfree 模式指的是函数无须提及将要操作的数据是什么样的</p>\n<p>```javascript\n// 非pointfree </p>\n"},{"title":"函数式编程-纯函数","tags":["函数式编程","纯函数"],"categories":"函数式编程","description":"# 纯函数的基本概念\n\n纯函数是这样一种函数，相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。\n\n可能会导致不纯的情况：\n\n- 修改调用/传入的参数\n\n  ```javascript\n  let array = [1, 2, 3, 4, 5];\n\n  // 纯的\n  array.slice(0, 3); //[1, 2, 3]\n  array.slice(0, 3); //[1,","createDate":"2019-10-15 13:43:45","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">纯函数的基本概念</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>纯函数是这样一种函数，相同的输入永远会得到相同的输出，而且没有任何可观察的副作用。</p>\n<p>可能会导致不纯的情况：</p>\n<ul>\n<li><p>修改调用/传入的参数</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n\n<span class=\"hljs-comment\">// 纯的</span>\narray.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[1, 2, 3]</span>\narray.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[1, 2, 3]</span>\n\n<span class=\"hljs-comment\">// 不纯的 --&gt; 会修改array</span>\narray.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[1, 2, 3]</span>\narray.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//[4, 5]</span>\n</code></pre>\n</li>\n<li><p>依赖外部环境</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// 纯的</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkAge</span>(<span class=\"hljs-params\">minmun, age</span>) {\n  <span class=\"hljs-keyword\">return</span> age &gt; minmun;\n}\n\n<span class=\"hljs-comment\">// 不纯的 --&gt; 引入了外部的环境，从而增加了认知负荷(cognitive load)</span>\n<span class=\"hljs-keyword\">let</span> minmum = <span class=\"hljs-number\">21</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkAge</span>(<span class=\"hljs-params\">age</span>) {\n  <span class=\"hljs-keyword\">return</span> age &gt; minmun;\n}\n</code></pre>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">副作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p>\n<p>副作用可能包括：</p>\n<ul>\n<li>更改文件系统</li>\n<li>往数据库插入记录</li>\n<li>发送一个 http 请求</li>\n<li>修改传入的数据</li>\n<li>打印/log</li>\n<li>获取用户输入</li>\n<li>DOM 查询</li>\n<li>访问系统状态</li>\n<li>......</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">追求纯的理由</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>可缓存性(cacheable)</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">memoize</span>(<span class=\"hljs-params\">f</span>) {\n  <span class=\"hljs-keyword\">let</span> cache = {};\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> arg_str = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(<span class=\"hljs-variable language_\">arguments</span>);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(cache[arg_str]);\n    cache[arg_str] = cache[arg_str] || f.<span class=\"hljs-title function_\">apply</span>(f, <span class=\"hljs-variable language_\">arguments</span>);\n    <span class=\"hljs-keyword\">return</span> cache[arg_str];\n  };\n}\n\n<span class=\"hljs-keyword\">const</span> squareNumber = <span class=\"hljs-title function_\">memoize</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * x);\n\n<span class=\"hljs-title function_\">squareNumber</span>(<span class=\"hljs-number\">3</span>);\n<span class=\"hljs-title function_\">squareNumber</span>(<span class=\"hljs-number\">3</span>);\n</code></pre>\n</li>\n<li><p>可移植性/自文档化(portable/self-documenting)</p>\n</li>\n<li><p>可测试性(testable)</p>\n</li>\n<li><p>合理性(reasonable)</p>\n<p>使用纯函数的最大好处是<a href=\"https://en.wikipedia.org/wiki/Referential_transparency\">引用透明性(referential transparency)</a>。</p>\n<p>如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么就认为这段代码是引用透明的。由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。对于引用透明的代码，可以使用&quot;等式推导&quot;(equational reasoning)的技术来分析代码，所谓&quot;等式推导&quot;就是&quot;一对一&quot;替换，有点像在不考虑程序行执行的怪异行为(quirks of programmatic evaluation)的情况下手动执行相关代码。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Immutable</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;immutable&quot;</span>);\n\n<span class=\"hljs-comment\">// decrementHP是纯函数！！！因为player的来源是immutable.Map，set方法不会使map改变，而是返回一个新的map对象</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">decrementHP</span>(<span class=\"hljs-params\">player</span>) {\n  <span class=\"hljs-keyword\">return</span> player.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&quot;hp&quot;</span>, player.<span class=\"hljs-property\">hp</span> - <span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isSameTeam</span>(<span class=\"hljs-params\">player1, player2</span>) {\n  <span class=\"hljs-keyword\">return</span> player1.<span class=\"hljs-property\">team</span> === player2.<span class=\"hljs-property\">team</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">punch</span>(<span class=\"hljs-params\">player, target</span>) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isSameTeam</span>(player, target)) {\n    <span class=\"hljs-keyword\">return</span> target;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">decrementHP</span>(target);\n  }\n}\n\n<span class=\"hljs-keyword\">let</span> jobe = <span class=\"hljs-title class_\">Immutable</span>.<span class=\"hljs-title class_\">Map</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Jobe&quot;</span>, <span class=\"hljs-attr\">hp</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-attr\">team</span>: <span class=\"hljs-string\">&quot;red&quot;</span> });\n<span class=\"hljs-keyword\">let</span> michael = <span class=\"hljs-title class_\">Immutable</span>.<span class=\"hljs-title class_\">Map</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Michael&quot;</span>, <span class=\"hljs-attr\">hp</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-attr\">team</span>: <span class=\"hljs-string\">&quot;green&quot;</span> });\n\n<span class=\"hljs-title function_\">punch</span>(jobe, michael);\n<span class=\"hljs-comment\">//=&gt; Immutable.Map({name:&quot;Michael&quot;, hp:19, team: &quot;green&quot;})</span>\n</code></pre>\n<p><a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide/issues/244\">关于 decrementHP 是不是纯函数的讨论</a></p>\n</li>\n<li><p>并行代码</p>\n<p>可以并行运行任意纯函数，因为纯函数根本不需要访问共享内存，而且根据其定义，纯函数也不会因副作用而进入<a href=\"https://en.wikipedia.org/wiki/Race_condition\">竞态(race condition)</a></p>\n</li>\n</ul>\n"},{"title":"函数式编程","tags":["函数式编程"],"categories":"函数式编程","description":"# WHAT\n\n- 本质上，函数式编程只是**范畴论的运算方法**，跟数理逻辑、微积分、行列式是同一类痛惜，都是数学方法，只是碰巧它能用来写程序\n- FP 的目的是使用函数来抽象作用在数据之上的控制力和操作，从而在系统中消除副作用并减少对状态的改变\n- OOP 通过封装使得代码更易理解，FP 通过最小化变化使得代码更易理解\n\n  ps: 为什么函数式编程要求函数必须是纯的，不能有副作用？因为它","createDate":"2019-10-15 10:10:17","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>本质上，函数式编程只是<strong>范畴论的运算方法</strong>，跟数理逻辑、微积分、行列式是同一类痛惜，都是数学方法，只是碰巧它能用来写程序</p>\n</li>\n<li><p>FP 的目的是使用函数来抽象作用在数据之上的控制力和操作，从而在系统中消除副作用并减少对状态的改变</p>\n</li>\n<li><p>OOP 通过封装使得代码更易理解，FP 通过最小化变化使得代码更易理解</p>\n<p>ps: 为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了</p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>使用纯函数的代码绝不会更改或破环全局状态，有助于提高代码的可测性和可维护性</li>\n<li>FP 采用声明式的风格，易于推理，蹄盖代码的可读性</li>\n<li>函数式编程将函数视为积木，通过高阶函数来提高代码的模块化和可重用性</li>\n<li>可以利用响应式编程组合各个函数来降低事件驱动程序的复杂性</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>纯函数(pure function)\n相同的输入总是得到相同的输出，不依赖外部环境，完全做到&quot;自给自足&quot;</li>\n<li>合成(compose)\n如果一个值要经过多个函数才能编程另外一个值，就可以把所用中间步骤合并成一个函数，这叫做<strong>函数的合成(compose)</strong></li>\n<li>柯里化(curry)\n在 compose 时，如果函数有多个参数 compose 将会变得非常麻烦，所谓柯里化就是把一个多参数的函数转化为单参数的函数</li>\n<li>函字(functor)\nFP 里基本的运算单位和功能单位，可以将一个容器转换为另一个容器。任何具有 map 方法的数据结构都可当作函子的实现</li>\n</ul>\n"},{"title":"柯里化","tags":["函数式编程","柯里化"],"categories":"awesome","description":"# WHAT\n\n柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术\n\n# WHY\n\n- 参数复用\n  如果是相同的参数，在计算之后不需要再次重新传参计算\n- 提前返回\n  多次调用多次内部判断，可以直接把第一次判断的结果返回外部接收\n- 延迟执行\n  缓存参数，避免重复的去执行程序，等真正需要结果的时候再执行\n\n# HOW\n\n## 参数复用\n\n常见于函数式编程(funct","createDate":"2019-10-16 20:48:43","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>参数复用\n如果是相同的参数，在计算之后不需要再次重新传参计算</li>\n<li>提前返回\n多次调用多次内部判断，可以直接把第一次判断的结果返回外部接收</li>\n<li>延迟执行\n缓存参数，避免重复的去执行程序，等真正需要结果的时候再执行</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参数复用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>常见于函数式编程(functional programing)</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">x</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">y</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">z</span>) {\n      <span class=\"hljs-keyword\">return</span> x + y + z;\n    };\n  };\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 6</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">提前返回</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addEvent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">addEventListener</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">el, type, fn, capture</span>) {\n      el.<span class=\"hljs-title function_\">addEventListener</span>(type, <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> fn.<span class=\"hljs-title function_\">call</span>(el, e), capture);\n    };\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">el, type, fn</span>) {\n      el.<span class=\"hljs-title function_\">attachEvent</span>(<span class=\"hljs-string\">&quot;on&quot;</span> + type, <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> fn.<span class=\"hljs-title function_\">call</span>(el, e));\n    };\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> elBind = <span class=\"hljs-title function_\">addEvent</span>();\n<span class=\"hljs-title function_\">elBind</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;button&quot;</span>), <span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e), <span class=\"hljs-literal\">true</span>);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">延迟执行</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curryScore</span>(<span class=\"hljs-params\">fn</span>) {\n  <span class=\"hljs-keyword\">let</span> _allScore = [];\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">arguments</span>.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-literal\">null</span>, _allScore);\n    <span class=\"hljs-keyword\">else</span> _allScore = _allScore.<span class=\"hljs-title function_\">concat</span>([].<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>));\n  };\n}\n<span class=\"hljs-keyword\">let</span> allScore = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">const</span> curryAllScore = <span class=\"hljs-title function_\">curryScore</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-variable language_\">arguments</span>.<span class=\"hljs-property\">length</span>; ++i) allScore += <span class=\"hljs-variable language_\">arguments</span>[i];\n});\n\n<span class=\"hljs-title function_\">curryAllScore</span>(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-title function_\">curryAllScore</span>(<span class=\"hljs-number\">3</span>);\n<span class=\"hljs-title function_\">curryAllScore</span>(<span class=\"hljs-number\">4</span>);\n<span class=\"hljs-title function_\">curryAllScore</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(allScore);\n</code></pre>\n"},{"title":"浏览器相关-存储","tags":["浏览器存储"],"categories":"浏览器","description":"关于存储的问题都会涉及到三个问题:\n\n1. 存储场所\n2. 存储空间\n3. 存储时间\n\n(在哪儿存储，多少数据，到什么时候)这些特性决定了不同方案的用途\n\n## cookie\n\n- WHAT\n\n  **Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储**。通过cookie,可以让服务器知道请求是来源哪个客户端，","createDate":"2020-04-02 22:49:39","updateDate":"10/1/2021, 3:34:43 AM","body":"<p>关于存储的问题都会涉及到三个问题:</p>\n<ol>\n<li>存储场所</li>\n<li>存储空间</li>\n<li>存储时间</li>\n</ol>\n<p>(在哪儿存储，多少数据，到什么时候)这些特性决定了不同方案的用途</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">cookie</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>WHAT</p>\n<p><strong>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储</strong>。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f22b7029ca14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"cookie的原理\"></p>\n</li>\n<li><p>WHY</p>\n<p>cookie的本职工作并非进行本地存储，而是<strong>维持状态</strong>。因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了<strong>交互式Web程序</strong>的实现，于是就诞生了cookie。他就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取cookie中包含信息，借此维护用户跟服务器会话的状态</p>\n<p>cookie的缺陷：</p>\n<ul>\n<li>cookie不够大，各浏览器的cookie每一个<code>name=value</code>的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。</li>\n<li>过多的 Cookie 会带来巨大的性能浪费，每次请求都会携带cookie</li>\n<li>安全性较差，由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS</li>\n</ul>\n</li>\n<li><p>HOW</p>\n<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>\n<p>cookie的生成方式主要有两种：</p>\n<ol>\n<li><p><code>http response header</code>中的<code>set-cookie</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Set</span>-<span class=\"hljs-title class_\">Cookie</span>: id=a3fWa; <span class=\"hljs-title class_\">Expires</span>=<span class=\"hljs-title class_\">Wed</span>, <span class=\"hljs-number\">21</span> <span class=\"hljs-title class_\">Oct</span> <span class=\"hljs-number\">2019</span> <span class=\"hljs-number\">22</span>:<span class=\"hljs-number\">28</span>:<span class=\"hljs-number\">00</span> <span class=\"hljs-variable constant_\">GMT</span>;<span class=\"hljs-comment\">//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</span>\n</code></pre>\n</li>\n<li><p>js中通过<code>document.cookie</code>可以读写cookie，以键值对的形式展示</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">cookie</span> = <span class=\"hljs-string\">&quot;userName=mrrs878&quot;</span>\n<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">cookie</span> = <span class=\"hljs-string\">&quot;age=23&quot;</span>\n</code></pre>\n</li>\n</ol>\n<p>常用后缀及其含义：</p>\n<p>| 属性      | 作用                                                         |\n|</p>\n</li>\n</ul>\n"},{"title":"浏览器相关-模型","tags":["浏览器","浏览器模型"],"categories":"浏览器","description":"# 浏览器是多进程的\n\n## 浏览器包含的进程\n\n- browser 进程--浏览器的主进程，负责协调，主控，有且只有一个\n  - 负责浏览器界面的显示，与用户交互（前进，后退等）\n  - 负责各个页面的管理，创建和销毁其他进程\n  - 将 render 进程得到的内存中的 bitmap 绘制到用户界面上\n  - 网络资源的下载与管理等\n- 第三方插件进程--每种类型的插件对用一个进程，仅当使","createDate":"2019-06-30 14:01:50","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器是多进程的</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器包含的进程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>browser 进程--浏览器的主进程，负责协调，主控，有且只有一个<ul>\n<li>负责浏览器界面的显示，与用户交互（前进，后退等）</li>\n<li>负责各个页面的管理，创建和销毁其他进程</li>\n<li>将 render 进程得到的内存中的 bitmap 绘制到用户界面上</li>\n<li>网络资源的下载与管理等</li>\n</ul>\n</li>\n<li>第三方插件进程--每种类型的插件对用一个进程，仅当使用该插件时创建</li>\n<li>GUI 进程--最多只有一个，用于 3D 图形的绘制</li>\n<li>render 进程（浏览器内核），默认为一个 tab 页一个进程，互不影响<ul>\n<li>页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器使用多进程的优势</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>避免单个 page crash 后影响到整个浏览器</li>\n<li>避免第三方插件 crash 后影响整个浏览器</li>\n<li>多进程充分利用多核优势</li>\n<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">render 进程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>常驻线程</p>\n<ul>\n<li>GUI 渲染线程<ul>\n<li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等</li>\n<li>当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行</li>\n<li>GUI 线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程就会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即执行</li>\n</ul>\n</li>\n<li>JS 引擎线程<ul>\n<li>也称为 JS 内核，负责处理 JavaScript 脚本程序（例如 V8 引擎）</li>\n<li>JS 引擎线程负责解析 JavaScript 脚本，运行代码</li>\n<li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 tab 页（render 进程）中无论何时只有一个 js 线程在运行 js 程序</li>\n<li>GUI 线程与 js 引擎线程时互斥的，如果 js 执行时间过长，这样就会造成页面渲染不连贯，导致页面渲染加载阻塞</li>\n</ul>\n</li>\n<li>事件触发线程<ul>\n<li>归属于浏览器而不是 JS 引擎，用来<strong>控制事件循环</strong></li>\n<li>当 js 引擎执行代码块如 setimeout 时（也可来自浏览器内核的其他线程，如鼠标点击、Ajax 异步请求等），会将对应任务添加到事件线程中</li>\n<li>当对应的事件符合触发条件时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li>\n</ul>\n</li>\n<li>定时器触发线程<ul>\n<li>传说中的 setInterval 与 setTimeout 所在线程</li>\n<li>浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>\n<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</li>\n<li>注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li>\n</ul>\n</li>\n<li>异步 http 线程<ul>\n<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">browser 进程与 render 进程之间的通信</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程</li>\n<li>Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染</li>\n<li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染</li>\n<li>当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）</li>\n<li>最后 Render 进程将结果传递给 Browser 进程</li>\n<li>Browser 进程接收到结果并将结果绘制出来</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器内核（render 进程）中线程的关系</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">GUI 渲染线程与 JS 引擎线程互斥</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n因此为防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥，当 JS 引擎执行时 GUI 线程会被挂起。\nGUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JS 引擎阻塞</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">web worker 线程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>为解决上一个问题而提出</p>\n<ul>\n<li>创建 worker 时，JS 引擎会向浏览器申请开一个子线程</li>\n<li>JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API），需要通过序列化对象来与线程交互特定的数据\n所以，如果有非常耗时的操作，可以单独打开一个 worker 线程，这样不管如何天翻地覆都不会影响 JS 引擎主线程，只待计算出结果后，将结果通信给 JS 主线程即可</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">shared worker 线程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>web worker 与 shared worker 的区别</p>\n<ul>\n<li>web worker 只属于某个页面，不会和其他页面的 render 进程共享</li>\n<li>shared worker 是浏览器所有页面共享的，不能采用与 worker 同样的方式实现，不属于某个 render 进程</li>\n<li>web worker 相当于“线程”，shared worker 相当于“进程”</li>\n</ul>\n"},{"title":"浏览器相关-渲染","tags":["浏览器","浏览器渲染"],"categories":"浏览器","description":"## 渲染流程图示\n\n![浏览器渲染过程](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/render-0.png)\n\n### 解析 HTML 文件\n\n![解析HTML文件](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/render-1.png)\ntoken：标记，本质上还是字符串，是构成代码的最小单","createDate":"2019-06-30 15:10:22","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">渲染流程图示</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/render-0.png\" alt=\"浏览器渲染过程\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解析 HTML 文件</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/render-1.png\" alt=\"解析HTML文件\">\ntoken：标记，本质上还是字符串，是构成代码的最小单位，这一过程会将代码分为一块块，并在这些内容打上标记，便于理解这些最小单位的代码是什么意思\n<img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/render-2.png\" alt=\"token\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解析 CSS 文件</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/render-3.png\" alt=\"解析CSS文件\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生成渲染树</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>渲染树只会包含需要显示的节点和这些节点的样式信息，如果这个节点是 display: none，那么就不会在渲染树上显示。当浏览器生成渲染树以后就会根据渲染树来进行布局（回流），然后调用 GPU 绘制，合成图层，显示在屏幕上</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">操作 DOM 慢的原因</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>DOM 属于渲染引擎中的东西，JS 又是 JS 引擎中的东西，当通过 JS 操作 DOM 的时候，其实这个操作涉及到了<strong>两个线程之间的通信</strong>，那么势必会带来一些性能上的损耗，操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来<strong>重绘回流</strong>的情况，所以就导致了性能上的问题</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么情况阻塞渲染</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染，如果想渲染的越快，就越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器\n然后当浏览器解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始，也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\n当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。\n当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\n对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">重绘和回流</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>重绘会在设置节点样式时频繁出现，同时也会很大程度上影响性能</p>\n<ul>\n<li>重绘是当节点需要更改外观而不会影响布局的时候发生，比如改变 color 就叫重绘</li>\n<li>回流是布局或者几何属性需要改变就称为回流</li>\n</ul>\n<p>回流必然会引起重绘，重绘不一定为引发回流</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">会引起回流的操作</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>页面首次渲染</li>\n<li>浏览器窗口大小发生改变</li>\n<li>元素尺寸或者位置发生改变</li>\n<li>元素内容变化（文字数量或者图片发小发生改变）</li>\n<li>元素字体大小的变化</li>\n<li>添加或删除<strong>可见</strong>的DOM元素</li>\n<li>激活CSS伪类（:hover）</li>\n<li>查询某些属性或调用某些方法<ul>\n<li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li>\n<li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li>\n<li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li>\n<li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li>\n<li><code>getComputedStyle()</code></li>\n<li><code>getBoundingClientRect()</code></li>\n<li><code>scrollTo()</code></li>\n</ul>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">减少重绘和回流</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>使用 transform 代替 top</li>\n<li>使用 visiblity 代替 display: none（前者引起重绘，后者引起回流）</li>\n<li>不要把节点的属性值放在一个循环里当循环的变量</li>\n<li>不要使用 table 布局</li>\n<li>动画的选择</li>\n<li>CSS 选择符从右到左匹配查找，避免节点层级过多</li>\n</ul>\n"},{"title":"浏览器相关-跨域","tags":["跨域"],"categories":"浏览器","description":"# WHAT-什么是跨域及同源策略\n\n## 同源策略\n\n**同源策略**是一个重要的安全策略，它用于限制一个[origin](https://developer.mozilla.org/zh-CN/docs/Glossary/源)的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。\n\n如果两个 URL 的 [protocol](https://de","createDate":"2020-04-09 23:26:29","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT-什么是跨域及同源策略</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">同源策略</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90\">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>\n<p>如果两个 URL 的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol\">protocol</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/port\">port</a> (如果有指定的话)和 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/host\">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p>\n<p><strong>同源策略限制内容有：</strong></p>\n<ul>\n<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>\n<li>DOM 节点</li>\n<li>AJAX 请求发送后，结果被浏览器拦截了</li>\n</ul>\n<p>但是有三个标签是允许跨域加载资源：</p>\n<ul>\n<li><code>&lt;img src=XXX&gt;</code></li>\n<li><code>&lt;link href=XXX&gt;</code></li>\n<li><code>&lt;script src=XXX&gt;</code></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">跨域</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源就算做<strong>跨域</strong>。</p>\n<p>特别说明：</p>\n<ol>\n<li><p>如果是协议和端口造成的跨域问题，前端是无能为力的</p>\n</li>\n<li><p>在跨域问题上，仅仅是通过<strong>URL的首部</strong>来识别而不会根据域名对应的ip是否相同来判断。</p>\n</li>\n<li><p>请求跨域后，请求到底有没有发送出去：</p>\n<p>跨域不是请求发送不出去，请求能发送出去，服务端能接收到请求并正常的返回，只是结果被浏览器拦截了（同源策略）。</p>\n</li>\n<li><p>为什么通过表单的方式可以发起跨域请求，Ajax就不能？</p>\n<p>归根结底，跨域是因为了阻止用户读取到另一个域名下的内容，Ajax可以获取响应，浏览器任务这不安全所以拦截了响应；但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>\n</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY-为什么有同源策略</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><strong>安全</strong></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW-跨域解决方案</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JSONP</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>原理：利用<code>&lt;script&gt;</code>标签没有同源策略限制的漏洞，网页可以得到从其他源动态产生的JSON数据。JSONP请求一定需要对方的<strong>服务器支持</strong>。JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是<strong>仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">jsonp</span>(<span class=\"hljs-params\">{ url, params, callback }</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">let</span> script = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&quot;script&quot;</span>)\n        <span class=\"hljs-variable language_\">window</span>[callback] = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) {\n            <span class=\"hljs-title function_\">resolve</span>(data)\n            <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">removeChildren</span>(script)\n        }\n        params = { ...params, callback }\n        <span class=\"hljs-keyword\">let</span> arrs = []\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(params).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> arrs.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${ key }</span>=<span class=\"hljs-subst\">${ params[key] }</span>`</span>))\n        script.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${ url }</span>?<span class=\"hljs-subst\">${ arrs.join(<span class=\"hljs-string\">&#x27;&amp;&#x27;</span>) }</span>`</span>\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(script)\n    })\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CORS</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>CORS需要<strong>浏览器和后端同时支持</strong></p>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">简单请求</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>只要<strong>同时满足</strong>以下条件，就属于简单请求：</p>\n<ol>\n<li>method=GET/POST/HEAD</li>\n<li>Content-Type=text/plain或multipart/form-data或application/x-www-form-urlencoded</li>\n<li>请求中的任意<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload\"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器；<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload\"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload\"><code>XMLHttpRequest.upload</code></a> 属性访问</li>\n</ol>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">复杂请求</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p> 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为<strong>预检请求</strong>,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">postMessage</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\n<ul>\n<li>页面和其打开的新窗口的数据传递</li>\n<li>多窗口之间消息传递</li>\n<li>页面与嵌套的iframe消息传递</li>\n<li>上面三个场景的跨域数据传递</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">websocket</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Websocket是HTML5的一个持久化协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Nginx反向代理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>\n"},{"title":"网络相关-http","tags":["网络相关","http"],"categories":"网络","description":"# HTTP协议\n\n**超文本传输协议（HTTP）** 是一个用于传输超媒体文档（例如 HTML）的[应用层](https://en.wikipedia.org/wiki/Application_Layer)协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的[客户端-服务端模型](https://en.wikipedia.org/wik","createDate":"2020-04-16 21:00:05","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP协议</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><strong>超文本传输协议（HTTP）</strong> 是一个用于传输超媒体文档（例如 HTML）的<a href=\"https://en.wikipedia.org/wiki/Application_Layer\">应用层</a>协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的<a href=\"https://en.wikipedia.org/wiki/Client%E2%80%93server_model\">客户端-服务端模型</a>，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是<a href=\"http://en.wikipedia.org/wiki/Stateless_protocol\">无状态协议</a>，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的<a href=\"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82\">传输层</a>上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。<a href=\"https://en.wikipedia.org/wiki/Reliable_User_Datagram_Protocol\">RUDP</a>——作为 UDP 的可靠化升级版本——是一种合适的替代选择。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP版本</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP/1.0</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>最初的http只是使用在一些较为简单的网页和请求上，所以比较简单，每次请求都打开一个新的TCP连接，收到响应后立即断开连接</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP/1.1</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>HTTP/1.1引入了更多的缓存控制策略，如Entity tag、If-Unmidified-Since、If-Match、If-None-Match等</li>\n<li>HTTP/1.1允许范围请求，即在请求头中加入<code>Range</code>头部</li>\n<li>HTTP/1.1的请求消息和响应消息都必须包含<code>Host</code>头部，以区分同一个物理主机中的不同虚拟终极的域名</li>\n<li>HTTP/1.1默认开启持久连接，在一个TCP连接上可以传输多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP/2.0</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在HTTP/2.0中，有两个非常重要的概念，帧（frame）和流（stream），理解这两个概念是理解下面多路复用的前提。帧代表数据传输的最小单位，每个帧都又序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。</p>\n<ul>\n<li>新的二进制格式\nHTTP/1.x的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景 必然很多。二进制则不同，只识别0和1的组合。基于这种考虑HTTP/2.0的协议解析采用二进制格式，方便且强大</li>\n<li>多路复用\nHTTP/2.0支持多路复用，这是HTTP/1.1持久连接的升级版。多路复用，就是在一个TCP连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发地发起多个请求，每个请求及该请求地响应不需要等待其他地请求和响应，避免了线头阻塞问题。这样某个请求任务好事严重并不会影响到其他连接地正常执行，极大地提高了传输性能</li>\n<li>头部压缩\nHTTP/1.x的请求和响应头部带有大量信息，并且每次请求都要重新发送，HTTP/2.0使用encoder来减少需要传输的头部大小，通讯双方各自cache一份头部fields表，既避免了重复头部的传输，又减小了需要传输的大小</li>\n<li>服务端推送\n这里的服务端推送指的是和把客户端需要的css/js/img资源伴随着html一起发送到客户端，省去了客户端重复请求的步骤</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP报文</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>用户HTTP协议交互的信息被称为HTTP报文。客户端的HTTP报文称为请求报文，服务端的HTTP报文称为响应报文</p>\n<p>请求报文是由请求行（请求方法、协议版本）、请求首部（请求URI、客户端信息）和内容实体（用户信息和资源信息，可为空）构成</p>\n<p>响应报文是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">请求方法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>GET\nGET方法请求一个指定资源的表示形式，使用GET请求应该之被用于获取数据</li>\n<li>POST\nPOST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用</li>\n<li>PUT\nPUT方法用请求有效载荷替换目标的所有当前表示</li>\n<li>DELETE\nDELETE方法删除指定的资源</li>\n<li>HEAD\nHEAD方法请求一个与GET请求的响应相同的响应，但没有响应体</li>\n<li>OPTIONS\nOPTIONS方法用于描述目标资源的通信选项</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">状态码</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>响应分为五类：信息响应(<code>100</code>–<code>199</code>)，成功响应(<code>200</code>–<code>299</code>)，重定向(<code>300</code>–<code>399</code>)，客户端错误(<code>400</code>–<code>499</code>)和服务器错误 (<code>500</code>–<code>599</code>)</p>\n<p><a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)\">具体参照</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">首部字段</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>根据不同上下文，可将消息头分为：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/General_header\">General headers</a>: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Request_header\">Request headers</a>: 包含更多有关要获取的资源或客户端本身信息的消息头。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Response_header\">Response headers</a>: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Entity_header\">Entity headers</a>: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</li>\n</ul>\n<p><a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers%5D(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)\">具体参照</a></p>\n"},{"title":"网络相关-https","tags":["网络","https"],"categories":"网络","description":"# HTTPS是什么\n\nHTTPS（hyper text transfer protocol over secure socket layer），是以安全为目标的HTTP通道，简单说就是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。\n\n## HTTPS和HTTP的区别\n\n- HTTP是明文传输，HTTPS通过SSL/TLS进行了加密","createDate":"2020-04-15 22:38:54","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTPS是什么</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>HTTPS（hyper text transfer protocol over secure socket layer），是以安全为目标的HTTP通道，简单说就是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTPS和HTTP的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>HTTP是明文传输，HTTPS通过SSL/TLS进行了加密</li>\n<li>HTTP的端口是80，HTTPS的端口是443</li>\n<li>HTTPS需要CA证书</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么要有HTTPS</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>建立一个信息安全通道，来保证数据传输的安全</li>\n<li>确认网站的真实性，防止钓鱼网站</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTPS的原理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>整体上HTTP到HTTPS的历程是：\nHTTP --&gt; 对称加密 --&gt; 非对称加密 --&gt; 对称加密+非对称加密 --&gt; 中间人攻击 --&gt; CA证书</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对称加密</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>HTTP的通信是明文的，就相当于在网络上裸奔，任何组织或个人都可以监听、窥探数据包。安全行较差，此时对称加密出现了：每次传输之前，发送方用一个加密算法加密，然后再发送；接收方使用加密算法对应的密钥进行解密。因为加密/解密都用的同一个密钥，因此称之为对称加密</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-0.png\" alt=\"对称加密\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">弊端</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>密钥容易被截取</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">非对称加密</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用非对称加密的双方都有一对密钥：私钥（保密），公钥（公开）。使用私钥加密的数据只有对应的公钥才能解密；用公钥加密的数据只有对应的私钥才能解密。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-1.png\" alt=\"非对称加密\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">弊端</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>速度较慢</strong>，相较于对称加密算法，非对称加密算法的速度要慢上百倍</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对称加密+非对称加密</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用非对称加密传输对称加密的密钥，之后使用对称加密通信</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">弊端</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>不能确保接收人的身份，容易受到中间人攻击</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">中间人攻击</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在浏览器发送公钥的时候，有个中间人截取了浏览器的公钥，然后把自己的公钥发送给服务器来冒充浏览器，然后使用自己的私钥解密对称加密使用的公钥来进行通信。（类似于代理）</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-2.png\" alt=\"中间人攻击\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CA证书</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-3.png\" alt=\"CA证书\"></p>\n<p>👀：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">完整HTTPS流程</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-4.png\" alt=\"https完整流程图\"></p>\n"},{"title":"网络相关-tcp","tags":["网络","TCP"],"categories":"网络","description":"# TCP的特点\n\n- 三次握手\n- 四次挥手\n- 可靠连接\n- 面向字节流\n- 提供拥塞控制\n- 丢包重传\n\n# TCP如何保证可靠传输\n\ntcp在传输的过程中都有一个ack，接收方通过ack告诉发送方收到哪些包了。这样发送方就能知道丢包情况进而重传\n\n# TCP的三次握手\n\n1. client发送SYN到server发起握手\n2. server回复SYN+ACK给client\n3. cli","createDate":"2020-04-16 21:00:43","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP的特点</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>三次握手</li>\n<li>四次挥手</li>\n<li>可靠连接</li>\n<li>面向字节流</li>\n<li>提供拥塞控制</li>\n<li>丢包重传</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP如何保证可靠传输</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>tcp在传输的过程中都有一个ack，接收方通过ack告诉发送方收到哪些包了。这样发送方就能知道丢包情况进而重传</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP的三次握手</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li>client发送SYN到server发起握手</li>\n<li>server回复SYN+ACK给client</li>\n<li>client回复server一个ACK表示收到了server的SYN+ACK</li>\n</ol>\n<p>握手的核心目的是告知对方SEQ，对方回复ACK（收到的SEQ+包的大小），这样发送端就知道有没有丢包了。次要目的是告知和协商一些信息</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP的四次挥手</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li>client发送FIN包给server</li>\n<li>sever回复ACK（对应第一步FIN包的ACK）给client，表示server知道client要断开了</li>\n<li>sever发送FIN包给client，表示server也可以断开了</li>\n<li>client回复ACK给server，表示既然双方都发送FIN包表示断开，那就真的断开吧</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么要三次握手、四次挥手</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>挥手的时候多一次主要是收到第一个FIN包后单独回复了一个ACK包，如果FIN+ACK和并发送那么四次挥手也变成三次了。关于为什么要分开，收到FIN后，知道对方要关闭了，然后OS通知应用层要关闭啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回ACK，准备好了再发FIN。握手没有这个准备过程（服务端在LISTEN状态下）所以可以立即发送SYN+ACK</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ACK</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>ACK = SEQ + LEN(包的大小)</code>，这样发送方可以明确知道对方收到哪些东西</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">拥塞控制</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>拥塞控制主要作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。拥塞处理包括以下算法：慢开始、拥塞避免、快速重传</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">慢开始</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞</p>\n<p>慢开始算法步骤具体如下：</p>\n<ol>\n<li>连接初始设置拥塞窗口（Congestion Window）为1MSS（一个分段的最大数据量）</li>\n<li>每过一个RTT（表示发送端发送数据到接收到对端数据所需的往返时间）就将窗口大小x2</li>\n<li>指数级增长肯定不能没有限制，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">拥塞避免算法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>拥塞避免算法相比简单点，每过一个RTT，拥塞窗口大小+1，这样能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。在传输过程中可能会遇到定时器超时的情况，这时TCP就会认为网络拥塞了，会马上进行以下步骤：</p>\n<ol>\n<li>将阈值设为当前拥塞窗口的一半</li>\n<li>将拥塞窗口设为1MSS</li>\n<li>启动拥塞避免算法</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">快速重传</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一旦接收端收到的报文出现失序的情况，接收端指会回复最后一个顺序正确的报文序号（没有SACK的情况）。如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。</p>\n"},{"title":"网络相关-udp","tags":["网络","udp"],"categories":"网络","description":"# UDP的特点\n\n- 面向无连接\n- 有单播、多播、广播的功能\n- 面向报文\n- 不可靠\n- 头部开销小，传输高效\n\n# UDP传输数据高效的原因\n\n- 无连接，UDP不需要像TCP一样在发送数据之前进行三次握手建立连接，想发数据就可以直接发送。\n\n  具体来说就是：\n\n  - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，","createDate":"2020-04-16 22:51:09","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">UDP的特点</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>面向无连接</li>\n<li>有单播、多播、广播的功能</li>\n<li>面向报文</li>\n<li>不可靠</li>\n<li>头部开销小，传输高效</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">UDP传输数据高效的原因</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>无连接，UDP不需要像TCP一样在发送数据之前进行三次握手建立连接，想发数据就可以直接发送。</p>\n<p>具体来说就是：</p>\n<ul>\n<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>\n<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>\n</ul>\n</li>\n<li><p>UDP只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作</p>\n</li>\n<li><p>头部开销小</p>\n<p>UDP的头部包含了以下几个数据</p>\n<ul>\n<li>两个十六位的源目端口号</li>\n<li>整个数据报文的长度</li>\n<li>整个数据报文的校验和（IPv4可选择字段），该字段用于发现头部信息和数据中的错误</li>\n</ul>\n</li>\n</ul>\n"},{"title":"设计模式-OCP","tags":["设计模式","OCP"],"categories":"设计模式","description":"## 开放封闭原则\n\n对扩展开放，对修改封闭\n\n假设我们是一个大型 Web 项目的维护人员，在接手这个项目时，发现它已经拥有 10 万行以上的 JavaScript 代码和数百个 JS 文件。 不久后接到了一个新的需求，即在 window.onload 函数中打印出页面中的所有节点数量\n\n```javascript\n// 普通版\nwindow.onload = function() {\n  /","createDate":"2019-10-17 18:12:29","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">开放封闭原则</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对扩展开放，对修改封闭</p>\n<p>假设我们是一个大型 Web 项目的维护人员，在接手这个项目时，发现它已经拥有 10 万行以上的 JavaScript 代码和数百个 JS 文件。 不久后接到了一个新的需求，即在 window.onload 函数中打印出页面中的所有节点数量</p>\n<p>```javascript\n// 普通版\nwindow.onload = function() {\n  //原有代码\n  console.log(document.getElementByName(&quot;*&quot;).length);\n};</p>\n<p>// OCP版 </p>\n"},{"title":"设计模式-策略模式","tags":["tags"],"categories":"设计模式","description":"# WHAT\n\n定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\n\n一个基于策略模式的程序至少由两部分组成，第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二部分是环境类 Context,Context 接受客户的请求随后把请求委托给某一个策略类。要做到这一点，说明 Context 中要维持对某个策略类的引用。\n\n# WHY\n\n- 策略模式使用组合、委托和","createDate":"2019-10-20 10:43:35","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>\n<p>一个基于策略模式的程序至少由两部分组成，第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二部分是环境类 Context,Context 接受客户的请求随后把请求委托给某一个策略类。要做到这一点，说明 Context 中要维持对某个策略类的引用。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>策略模式使用组合、委托和多态等技术和思想，可以避免多重条件选择语句</li>\n<li>策略模式提供了对<strong>开放-封闭原则</strong>的完美支持，将算法封装在独立的 strategy 中，使得它们易于替换、理解、<strong>扩展</strong></li>\n<li>在策略模式中利用组合和委托让 context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">/* 计算奖金：绩效为S有四倍工资，绩效为A有3倍工资，绩效为B有2倍工资 */</span>\n\n<span class=\"hljs-comment\">// common  缺乏扩展性</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">calcBouns</span>(<span class=\"hljs-params\">type, salary</span>) {\n  <span class=\"hljs-keyword\">if</span>(type === <span class=\"hljs-string\">&#x27;S&#x27;</span>) <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">4</span>\n  <span class=\"hljs-keyword\">if</span>(type === <span class=\"hljs-string\">&#x27;A&#x27;</span>) <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">3</span>\n  <span class=\"hljs-keyword\">if</span>(type === <span class=\"hljs-string\">&#x27;B&#x27;</span>) <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">2</span>\n}\n<span class=\"hljs-title function_\">calcBouns</span>(<span class=\"hljs-string\">&#x27;S&#x27;</span>, <span class=\"hljs-number\">20000</span>)\n<span class=\"hljs-title function_\">calcBouns</span>(<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-number\">10000</span>)\n\n<span class=\"hljs-comment\">// stratety pattern</span>\n<span class=\"hljs-keyword\">const</span> strategy {\n  <span class=\"hljs-attr\">S</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">salary</span>) {\n    <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">4</span>\n  },\n  <span class=\"hljs-attr\">A</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">salary</span>) {\n    <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">3</span>\n  },\n  <span class=\"hljs-attr\">B</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">salary</span>) {\n    <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">2</span>\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> calcBouns = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type, salary</span>) {\n  <span class=\"hljs-keyword\">return</span> strategy[type](salary)\n}\n\n<span class=\"hljs-title function_\">calcBouns</span>(<span class=\"hljs-string\">&#x27;S&#x27;</span>, <span class=\"hljs-number\">20000</span>)\n<span class=\"hljs-title function_\">calcBouns</span>(<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-number\">10000</span>)\n\n<span class=\"hljs-comment\">// functional programing</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">S</span>(<span class=\"hljs-params\">salary</span>) {\n  <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">4</span>\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">A</span>(<span class=\"hljs-params\">salary</span>) {\n  <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">3</span>\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">B</span>(<span class=\"hljs-params\">salary</span>) {\n  <span class=\"hljs-keyword\">return</span> salary * <span class=\"hljs-number\">2</span>\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">calcBouns</span>(<span class=\"hljs-params\">fn, salary</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>(salary)\n}\n\n<span class=\"hljs-title function_\">calcBouns</span>(S, <span class=\"hljs-number\">20000</span>)\n<span class=\"hljs-title function_\">calcBouns</span>(B, <span class=\"hljs-number\">10000</span>)\n</code></pre>\n"},{"title":"设计模式-职责链模式","tags":["设计模式","职责链模式"],"categories":"设计模式","description":"# WHAT\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象练成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止\n\n![普通设计](../imgs/chainOfResponsibility0.png)\n\n![职责链模式](../imgs/chainOfResponsibility1.png)\n\n# WHY\n\n- 职责链模式解耦了请求发送者 A 和","createDate":"2019-10-21 10:51:52","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象练成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>\n<p><img src=\"../imgs/chainOfResponsibility0.png\" alt=\"普通设计\"></p>\n<p><img src=\"../imgs/chainOfResponsibility1.png\" alt=\"职责链模式\"></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>职责链模式解耦了请求发送者 A 和 N 个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需要把请求传递给第一个节点即可</li>\n<li>使用职责链后，链中的节点可以灵活拆分重组，增加/删除/改动一个节点都轻而易举</li>\n<li>可以手动指定起始节点，请求并不是非得从链中的第一个节点开始传递，这样就可以减少请求在链中的传递次数，更快的找到合适的请求接收者</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">a</span>(<span class=\"hljs-params\">x</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">b</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">c</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">3</span>);\n}\n\n<span class=\"hljs-comment\">// 职责链模式普通实现</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Chain</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">fn</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fn</span> = fn;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">successor</span> = <span class=\"hljs-literal\">null</span>;\n  }\n  <span class=\"hljs-title function_\">setNextSuccessor</span>(<span class=\"hljs-params\">successor</span>) {\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">successor</span> = successor);\n  }\n  <span class=\"hljs-title function_\">passRequest</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> ret = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fn</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-variable language_\">arguments</span>);\n    <span class=\"hljs-keyword\">if</span> (ret === <span class=\"hljs-literal\">false</span>)\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">successor</span> &amp;&amp;\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">successor</span>.<span class=\"hljs-property\">passRequest</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">successor</span>, <span class=\"hljs-variable language_\">arguments</span>)\n      );\n    <span class=\"hljs-keyword\">return</span> ret;\n  }\n}\n<span class=\"hljs-keyword\">let</span> aChain = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chain</span>(a);\n<span class=\"hljs-keyword\">let</span> bChain = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chain</span>(b);\n<span class=\"hljs-keyword\">let</span> cChain = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chain</span>(c);\naChain.<span class=\"hljs-title function_\">setNextSuccessor</span>(bChain);\nbChain.<span class=\"hljs-title function_\">setNextSuccessor</span>(cChain);\n\naChain.<span class=\"hljs-title function_\">passRequest</span>(<span class=\"hljs-number\">12</span>); <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-comment\">// AOP实现职责链模式</span>\n<span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">after</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">fn</span>) {\n  <span class=\"hljs-keyword\">let</span> _self = <span class=\"hljs-variable language_\">this</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> tmp = _self.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-variable language_\">arguments</span>);\n    <span class=\"hljs-keyword\">if</span> (tmp === <span class=\"hljs-literal\">false</span>) <span class=\"hljs-keyword\">return</span> fn &amp;&amp; fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-variable language_\">arguments</span>);\n    <span class=\"hljs-keyword\">return</span> tmp;\n  };\n};\n\na.<span class=\"hljs-title function_\">after</span>(b).<span class=\"hljs-title function_\">after</span>(c)(<span class=\"hljs-number\">12</span>); <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n"},{"title":"typescript学习-枚举的妙用","tags":["enum"],"categories":"typescript","description":"> 参考：[使用数字类型作为标志](https://jkchao.github.io/typescript-book-chinese/typings/enums.html#%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%A0%87%E5%BF%97)\n\n枚举的一个很好用途是使用枚举作为标志。","createDate":"2021-09-29 13:42:31","updateDate":"2021-09-30 14:28:46","body":"<blockquote>\n<p>参考：<a href=\"https://jkchao.github.io/typescript-book-chinese/typings/enums.html#%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%A0%87%E5%BF%97\">使用数字类型作为标志</a></p>\n</blockquote>\n<p>枚举的一个很好用途是使用枚举作为标志。这些标志允许你检查一组条件中的某个条件是否为真。考虑如下代码例子，我们有一组关于<code>animals</code>的属性：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-built_in\">enum</span> <span class=\"hljs-title class_\">AnimalFlags</span> {\n  <span class=\"hljs-title class_\">None</span>        = <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-title class_\">HasClaws</span>    = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-title class_\">CanFly</span>      = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-title class_\">EatsFish</span>    = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-title class_\">Endangered</span>  = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">3</span>\n}\n</code></pre>\n<p>在这里，我们使用了左移的位运算符，将数字 1 的二进制向左移动位置得到数字 0001、0010、0100 和 1000（换成十进制结果是：1, 2, 4, 8）。当你在使用这种标记的时候，这些位运算符 | (或)、&amp; （和）、~ （非）将会是你最好的朋友：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-built_in\">enum</span> <span class=\"hljs-title class_\">AnimalFlags</span> {\n  <span class=\"hljs-title class_\">None</span>        = <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-title class_\">HasClaws</span>    = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-title class_\">CanFly</span>      = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-title class_\">EatsFish</span>    = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">2</span>,\n  <span class=\"hljs-title class_\">Endangered</span>  = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">3</span>,\n  \n  <span class=\"hljs-comment\">// 可以组合标志，用来在枚举类型中定义方便快捷的方式，如下</span>\n  <span class=\"hljs-title class_\">EndangeredFlyingClawedFishEating</span> = <span class=\"hljs-title class_\">HasClaws</span> | <span class=\"hljs-title class_\">CanFly</span> | <span class=\"hljs-title class_\">EatsFish</span> | <span class=\"hljs-title class_\">Endangered</span>\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Animal</span> {\n  <span class=\"hljs-attr\">flags</span>: <span class=\"hljs-title class_\">AnimalFlags</span>;\n  [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printAnimalAbilities</span>(<span class=\"hljs-params\">animal: Animal</span>) {\n  <span class=\"hljs-keyword\">const</span> animalFlags = animal.<span class=\"hljs-property\">flags</span>;\n  <span class=\"hljs-keyword\">if</span> (animalFlags &amp; <span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">HasClaws</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;animal has claws&#x27;</span>);\n  }\n  <span class=\"hljs-keyword\">if</span> (animalFlags &amp; <span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">CanFly</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;animal can fly&#x27;</span>);\n  }\n  <span class=\"hljs-keyword\">if</span> (animalFlags == <span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">None</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;nothing&#x27;</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> animal = { <span class=\"hljs-attr\">flags</span>: <span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">None</span> };\n<span class=\"hljs-title function_\">printAnimalAbilities</span>(animal); <span class=\"hljs-comment\">// nothing</span>\nanimal.<span class=\"hljs-property\">flags</span> |= <span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">HasClaws</span>;\n<span class=\"hljs-title function_\">printAnimalAbilities</span>(animal); <span class=\"hljs-comment\">// animal has claws</span>\nanimal.<span class=\"hljs-property\">flags</span> &amp;= ~<span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">HasClaws</span>;\n<span class=\"hljs-title function_\">printAnimalAbilities</span>(animal); <span class=\"hljs-comment\">// nothing</span>\nanimal.<span class=\"hljs-property\">flags</span> |= <span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">HasClaws</span> | <span class=\"hljs-title class_\">AnimalFlags</span>.<span class=\"hljs-property\">CanFly</span>;\n<span class=\"hljs-title function_\">printAnimalAbilities</span>(animal); <span class=\"hljs-comment\">// animal has claws, animal can fly</span>\n</code></pre>\n<p>在这里：</p>\n<ul>\n<li>我们使用 |= 来添加一个标志；</li>\n<li>组合使用 &amp;= 和 ~ 来清理一个标志；</li>\n<li>| 来合并标志。</li>\n</ul>\n"},{"title":"React.js学习-单元测试-2","tags":["单元测试"],"categories":"React.js","description":"[React.js学习-单元测试-1](https://blog.mrrs.top/blog/view/5fcf500be531783853b2fc5c)\n\n[示例代码仓库](https://codesandbox.io/s/beautiful-mcclintock-8iqp8)\n\nReact.js + Typescript + Jest + @testing-library\n\n## 安装和配","createDate":"2021-08-30 13:33:10","updateDate":"2021-09-01 22:01:37","body":"<p><a href=\"https://blog.mrrs.top/blog/view/5fcf500be531783853b2fc5c\">React.js学习-单元测试-1</a></p>\n<p><a href=\"https://codesandbox.io/s/beautiful-mcclintock-8iqp8\">示例代码仓库</a></p>\n<p>React.js + Typescript + Jest + @testing-library</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装和配置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>需要以下库</p>\n<ul>\n<li><code>jest</code>, 自动化测试框架</li>\n<li><code>ts-jest</code>，添加对<code>typescript</code>的支持</li>\n<li><code>@testing-library/jest-dom</code>，添加了一些额外的匹配器，测试dom</li>\n<li><code>@testing-library/react</code>，测试react组件</li>\n<li><code>@testing-library/react-hooks</code>，测试自定义hooks</li>\n<li><code>Babel</code>，转译jsx与ESM</li>\n</ul>\n<pre><code class=\"hljs language-shell\">yarn add jest @testing-library/jest-dom @testing-library/react @testing-library/react-hooks ts-jest -D\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">配置</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>添加<code>jest</code>配置文件</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// jest.config.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">preset</span>: <span class=\"hljs-string\">&#x27;ts-jest&#x27;</span>,\n  <span class=\"hljs-attr\">testEnvironment</span>: <span class=\"hljs-string\">&#x27;jsdom&#x27;</span>,\n  <span class=\"hljs-attr\">transform</span>: {\n    <span class=\"hljs-string\">&#x27;^.+\\\\.js$&#x27;</span>: <span class=\"hljs-string\">&#x27;babel-jest&#x27;</span>,\n    <span class=\"hljs-string\">&#x27;^.+\\\\.(ts|tsx)$&#x27;</span>: <span class=\"hljs-string\">&#x27;ts-jest&#x27;</span>,\n  },\n  <span class=\"hljs-attr\">moduleFileExtensions</span>: [<span class=\"hljs-string\">&#x27;js&#x27;</span>, <span class=\"hljs-string\">&#x27;jsx&#x27;</span>, <span class=\"hljs-string\">&#x27;ts&#x27;</span>, <span class=\"hljs-string\">&#x27;tsx&#x27;</span>],\n  <span class=\"hljs-attr\">setupFilesAfterEnv</span>: [\n    <span class=\"hljs-string\">&#x27;&lt;rootDir&gt;/setupTests.js&#x27;</span>,\n  ],\n};\n\n<span class=\"hljs-comment\">// setupTests.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;@testing-library/jest-dom&#x27;</span>;\n</code></pre>\n<p><code>ts</code>编译配置文件要有以下配置</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-comment\">// tsconfig.json</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-attr\">&quot;compilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;jsx&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;react&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;lib&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n        <span class=\"hljs-string\">&quot;dom&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-string\">&quot;dom.iterable&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-string\">&quot;esnext&quot;</span>\n    <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;esModuleInterop&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;allowSyntheticDefaultImports&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span>\n<span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Jest简要教程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>describe</code>用来包含一块测试的代码，通常用它来对几个测试进行分组</p>\n<p><code>test</code>是每一个测试，内部包含需要测试的方法，别名为<code>it</code></p>\n<p><code>expect</code>翻译为预期，需要和很多匹配器结合使用</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;test useCookie&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should be defined&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(useCookie).<span class=\"hljs-title function_\">toBeDefined</span>();\n  });\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">常见DOM测试用例</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">测试按钮点击事件</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { render, fireEvent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;click events&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> onClick = jest.<span class=\"hljs-title function_\">fn</span>();\n\n    <span class=\"hljs-keyword\">const</span> { getByLabelText } = <span class=\"hljs-title function_\">render</span>(\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">&quot;Button&quot;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick}</span> /&gt;</span></span>\n    );\n\n    <span class=\"hljs-keyword\">const</span> btn = <span class=\"hljs-title function_\">getByLabelText</span>(<span class=\"hljs-string\">&quot;Button&quot;</span>);\n    fireEvent.<span class=\"hljs-title function_\">click</span>(btn);\n    <span class=\"hljs-title function_\">expect</span>(onClick).<span class=\"hljs-title function_\">toBeCalled</span>();\n    <span class=\"hljs-title function_\">expect</span>(onClick).<span class=\"hljs-title function_\">toBeCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n  });\n});\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">测试input输入事件</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { fireEvent, render } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;input element&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> onChange = jest.<span class=\"hljs-title function_\">fn</span>();\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&quot;change&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { getByTestId } = <span class=\"hljs-title function_\">render</span>(\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">data-testid</span>=<span class=\"hljs-string\">&quot;changeInput&quot;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{onChange}</span> /&gt;</span></span>\n    );\n\n    <span class=\"hljs-keyword\">const</span> input = <span class=\"hljs-title function_\">getByTestId</span>(<span class=\"hljs-string\">&quot;changeInput&quot;</span>);\n    fireEvent.<span class=\"hljs-title function_\">change</span>(input, { <span class=\"hljs-attr\">target</span>: { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&quot;hello&quot;</span> } });\n    <span class=\"hljs-title function_\">expect</span>(onChange).<span class=\"hljs-title function_\">toBeCalled</span>();\n    <span class=\"hljs-title function_\">expect</span>(input).<span class=\"hljs-title function_\">toHaveProperty</span>(<span class=\"hljs-string\">&quot;value&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>);\n  });\n});\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">测试props</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { render } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@testing-library/react&quot;</span>;\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;props&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\">{ loading }: { loading?: boolean }</span>) =&gt; (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">data-testid</span>=<span class=\"hljs-string\">&quot;span&quot;</span>&gt;</span>{loading ? &quot;loading...&quot; : &quot;hello&quot;}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>\n  );\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&quot;default props&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { getByTestId } = <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n    <span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-title function_\">getByTestId</span>(<span class=\"hljs-string\">&quot;span&quot;</span>);\n    <span class=\"hljs-title function_\">expect</span>(span).<span class=\"hljs-title function_\">toHaveTextContent</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&quot;props change&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { getByTestId, rerender } = <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n    <span class=\"hljs-keyword\">const</span> span = <span class=\"hljs-title function_\">getByTestId</span>(<span class=\"hljs-string\">&quot;span&quot;</span>);\n    <span class=\"hljs-title function_\">expect</span>(span).<span class=\"hljs-title function_\">toHaveTextContent</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);\n    <span class=\"hljs-comment\">// 通过rerender来模拟props对改变</span>\n    <span class=\"hljs-title function_\">rerender</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> <span class=\"hljs-attr\">loading</span>=<span class=\"hljs-string\">{true}</span> /&gt;</span></span>);\n    <span class=\"hljs-title function_\">expect</span>(span).<span class=\"hljs-title function_\">toHaveTextContent</span>(<span class=\"hljs-string\">&quot;loading...&quot;</span>);\n    <span class=\"hljs-title function_\">rerender</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> <span class=\"hljs-attr\">loading</span>=<span class=\"hljs-string\">{false}</span> /&gt;</span></span>);\n    <span class=\"hljs-title function_\">expect</span>(span).<span class=\"hljs-title function_\">toHaveTextContent</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);\n  });\n});\n</code></pre>\n"},{"title":"React.js学习-单元测试-1","tags":["单元测试"],"categories":"React.js","description":"[React.js学习-单元测试-2](https://blog.mrrs.top/blog/view/612cde1686ab9f13b4b96452)\n\n## 技术选型\n\nJest + React官方测试包\n\n- `@testing-library/dom`\n- `@testing-library/jest-dom`\n- `@testing-library/react`\n- `@testi","createDate":"2020-12-08 10:06:03","updateDate":"2021-08-30 21:52:23","body":"<p><a href=\"https://blog.mrrs.top/blog/view/612cde1686ab9f13b4b96452\">React.js学习-单元测试-2</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">技术选型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Jest + React官方测试包</p>\n<ul>\n<li><code>@testing-library/dom</code></li>\n<li><code>@testing-library/jest-dom</code></li>\n<li><code>@testing-library/react</code></li>\n<li><code>@testing-library/user-event</code></li>\n<li><code>jest</code></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Jest配置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// jest.config.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">testMatch</span>: [<span class=\"hljs-string\">&quot;&lt;rootDir&gt;/test/**/*.(spec|test).js?(x)&quot;</span>],\n  <span class=\"hljs-attr\">moduleFileExtensions</span>: [<span class=\"hljs-string\">&quot;js&quot;</span>, <span class=\"hljs-string\">&quot;jsx&quot;</span>],\n  <span class=\"hljs-attr\">setupFilesAfterEnv</span>: [\n    <span class=\"hljs-string\">&quot;&lt;rootDir&gt;/setupTests.js&quot;</span>,\n  ],\n  <span class=\"hljs-attr\">transform</span>: {\n    <span class=\"hljs-string\">&quot;^.+\\\\.js$&quot;</span>: <span class=\"hljs-string\">&quot;babel-jest&quot;</span>,\n  },\n};\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// setupTests.js</span>\n<span class=\"hljs-comment\">// 扩展jest matchers</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;@testing-library/jest-dom&quot;</span>;\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">访问DOM</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li><p>使用 <strong>@testing-library/react</strong> 包里的 <code>render</code> 函数渲染组件</p>\n</li>\n<li><p>使用 <strong>@testing-library/react</strong> 包里的 <code>screen</code> 属性访问界面快照</p>\n</li>\n<li><p>使用 <code>screen.getBy/screen.findBy</code>访问元素</p>\n</li>\n</ol>\n<p><code>render</code>: 将给定组件渲染到附加到<code>document.body</code>的容器中</p>\n<p><code>screen</code>: DOM测试库导出的所有查询均接受容器作为第一个参数。 因为查询整个document.body非常普遍，所以DOM测试库还会导出一个<code>screen</code>对象，该对象具有预先绑定到document.body的每个查询（使用内部功能）。</p>\n<p><code>findBy</code>和<code>getBy</code>: <code>getBy</code>会立即返回，<code>findBy</code>会等到超时或查询到元素才返回</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { fireEvent, render, screen } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/react&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [value, onChange] = <span class=\"hljs-title function_\">useInputValue</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{onChange}</span> /&gt;</span></span>\n  );\n};\n<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n<span class=\"hljs-keyword\">const</span> element = screen.<span class=\"hljs-title function_\">getByPlaceholderText</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模拟事件触发</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li><p>使用 <strong>@testing-library/react</strong> 包里的 <code>render</code> 函数渲染组件</p>\n</li>\n<li><p>使用 <strong>@testing-library/react</strong> 包里的 <code>fireEvent</code> 函数触发事件</p>\n</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> [value, onChange] = <span class=\"hljs-title function_\">useInputValue</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{onChange}</span> /&gt;</span></span>\n    );\n};\n<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n<span class=\"hljs-keyword\">const</span> element = screen.<span class=\"hljs-title function_\">getByPlaceholderText</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n<span class=\"hljs-title function_\">expect</span>(element.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&#x27;value&#x27;</span>)).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\nfireEvent.<span class=\"hljs-title function_\">input</span>(element, { <span class=\"hljs-attr\">target</span>: { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;hello world&#x27;</span> } });\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">act</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>这函数和React自带的test-utils的act函数是同一个函数。在组件状态更新的时候（setState），组件需要被重新渲染，而这个重渲染是需要React进行调度的，因此是个异步的过程，我们可以通过使用act函数将所有会更新到组件状态的操作封装在它的callback里面来保证act函数执行完之后我们定义的组件已经完成了重新渲染。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对比Object</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用<code>toEqual</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> tom = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span> }\n<span class=\"hljs-title function_\">expect</span>(tom).<span class=\"hljs-title function_\">toEqual</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span> })\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">大致规范</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-comment\">// 1. 测试函数是否定义</span>\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should be defined&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(xxx).<span class=\"hljs-title function_\">toBeDefined</span>();\n  });\n  <span class=\"hljs-comment\">// 2. 测试函数是否被调用</span>\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should be called&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">expect</span>(xxx).<span class=\"hljs-title function_\">toBeCalled</span>();\n  });\n\n});\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">测试实例</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">测试<code>useInputValue</code>hook</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// useInputValue.test.jsx</span>\n<span class=\"hljs-keyword\">import</span> { fireEvent, render, screen } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> useInputValue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../src/react/hooks/useInputValue&#x27;</span>;\n\n<span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;test useInputValue&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> [value, onChange] = <span class=\"hljs-title function_\">useInputValue</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{onChange}</span> /&gt;</span></span>\n    );\n  };\n  <span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n  <span class=\"hljs-keyword\">const</span> element = screen.<span class=\"hljs-title function_\">getByPlaceholderText</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n  <span class=\"hljs-title function_\">expect</span>(element.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&#x27;value&#x27;</span>)).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n  fireEvent.<span class=\"hljs-title function_\">input</span>(element, { <span class=\"hljs-attr\">target</span>: { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;hello world&#x27;</span> } });\n  <span class=\"hljs-title function_\">expect</span>(element.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&#x27;value&#x27;</span>)).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">&#x27;hello world&#x27;</span>);\n});\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// useInputValue.js</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ChangeEvent</span>, useCallback, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useInputValue</span>(<span class=\"hljs-params\">initValue</span>) {\n  <span class=\"hljs-keyword\">const</span> [value, setValue] = <span class=\"hljs-title function_\">useState</span>(initValue);\n\n  <span class=\"hljs-keyword\">const</span> onChange = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n    <span class=\"hljs-title function_\">setValue</span>(e.<span class=\"hljs-property\">currentTarget</span>.<span class=\"hljs-property\">value</span>);\n  }, []);\n\n  <span class=\"hljs-keyword\">return</span> [value, onChange, setValue];\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> useInputValue;\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用<code>@testing-library/react-hooks</code>测试<code>hook</code></span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// useCounter.js</span>\n\n<span class=\"hljs-keyword\">import</span> { useState, useCallback } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useCounter</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)\n\n  <span class=\"hljs-keyword\">const</span> increment = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> x + <span class=\"hljs-number\">1</span>), [])\n\n  <span class=\"hljs-keyword\">return</span> { count, increment }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> useCounter\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// useCounter.test.js</span>\n<span class=\"hljs-keyword\">import</span> { renderHook, act } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@testing-library/react-hooks&#x27;</span>\n<span class=\"hljs-keyword\">import</span> useCounter <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useCounter&#x27;</span>\n\n<span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;should increment counter&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> { result } = <span class=\"hljs-title function_\">renderHook</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">useCounter</span>())\n\n  <span class=\"hljs-title function_\">act</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    result.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">increment</span>()\n  })\n\n  <span class=\"hljs-title function_\">expect</span>(result.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">count</span>).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">1</span>)\n})\n</code></pre>\n"},{"title":"grid布局","tags":["grid"],"categories":"CSS","description":"## 一些属性\n\n### grid-auto-flow\n\n控制自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列\n\n``` css\ngrid-auto-flow: row;\ngrid-auto-flow: column;\ngrid-auto-flow: row dense;\ngrid-auto-flow: column dense;\n```\n\n取值：\n\n- row，指定自动布局算法","createDate":"2021-08-31 11:21:24","updateDate":"8/24/2021, 12:12:36 PM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一些属性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">grid-auto-flow</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>控制自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-attribute\">grid-auto-flow</span>: row;\n<span class=\"hljs-attribute\">grid-auto-flow</span>: column;\n<span class=\"hljs-attribute\">grid-auto-flow</span>: row dense;\n<span class=\"hljs-attribute\">grid-auto-flow</span>: column dense;\n</code></pre>\n<p>取值：</p>\n<ul>\n<li><p>row，指定自动布局算法按照通过逐行填充来排列元素，在必要时增加新行。如果既没有指定 row 也没有 column，则默认为 row</p>\n</li>\n<li><p>column，指定自动布局算法通过逐列填充来排列元素，在必要时增加新列</p>\n</li>\n<li><p>dense，指定自动布局算法使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。如果省略它，使用一种「稀疏」算法，在网格中布局元素时，布局算法只会「向前」移动，永远不会倒回去填补空白。这保证了所有自动布局元素「按照次序」出现，即使可能会留下被后面元素填充的空白</p>\n</li>\n</ul>\n"},{"title":"webpack复习-易混淆知识点","tags":["webpack"],"categories":"2021复习","description":"## module/bundle/chunk的区别\n\n![module、bundle、chunk](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack_1.png)\n\n1. 对于一份同逻辑代码，当我们手写下一个一个的文件，它们无论是ESM还是commonJS或AMD，它们都是module\n2. 当我们写module源文件传到webpack","createDate":"2021-05-17 12:56:41","updateDate":"2021-07-15 13:54:55","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">module/bundle/chunk的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack_1.png\" alt=\"module、bundle、chunk\"></p>\n<ol>\n<li>对于一份同逻辑代码，当我们手写下一个一个的文件，它们无论是ESM还是commonJS或AMD，它们都是module</li>\n<li>当我们写module源文件传到webpack进行打包时，webpack会根据文件引用关系生成chunk文件，webpack会对这个chunk文件进行一些操作</li>\n<li>webpack处理好chunk文件后，最后会输出bundle文件，这个bundle文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行</li>\n</ol>\n<p>一句话总结：<code>module</code>、<code>chunk</code>、<code>bundle</code>其实就是同一份逻辑代码在不同转换场景下取的三个名字：我们直接写出来的是<code>module</code>，<code>webpack</code>处理时是<code>chunk</code>，最后生成浏览器可以直接运行的<code>bundle</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">filename/chunkFilename</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>filename</code>对应于<code>entry</code>里面的输入文件，经过webpack 打包后输出文件的文件名</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n    entry<span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;index&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;/path/to/index.js&quot;</span>\n    <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n    output<span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        filename<span class=\"hljs-punctuation\">:</span> &#x27;<span class=\"hljs-punctuation\">[</span>name<span class=\"hljs-punctuation\">]</span>.<span class=\"hljs-punctuation\">[</span>hash<span class=\"hljs-punctuation\">:</span><span class=\"hljs-number\">8</span><span class=\"hljs-punctuation\">]</span>.js&#x27;\n    <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p><code>chunkFilename</code>指未列在<code>entry</code>中却又要被打包出来的<code>chunk</code>文件的名称。一般来说，这个<code>chunk</code>文件指的就是需要<strong>懒加载</strong>的代码</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">webpackPrefetch/webpackPreload/webpackChunkName</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">import</span>(<span class=\"hljs-comment\">/* webpackPrefetch: true */</span> <span class=\"hljs-string\">&#x27;./path/to/LoginModal.js&#x27;</span>);\n</code></pre>\n<p><code>webpackChunkName</code>是为预加载的文件取别名，<code>webpackPrefetch</code>会在浏览器闲置时下载文件，<code>webpackPreload</code>会在父<code>chunk</code>加载时并行下载文件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">hash/chunkhash/contenthash</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>hash一般是结合CDN缓存来使用的。如果文件内容改变的话，那么对应文件hash值也会改变，对应的html引用的url地址也会改变，触发cdn服务器从源服务器上拉取对应数据进而更新本地缓存</p>\n<p><code>hash</code>是整个项目构建使用的，项目中如果有些变动，hash一定会变，比如说改动了utils.js，index.js里的代码虽然没有改变，但是大家都是用的同一份hash，hash一变，缓存一定会失效，这样子CDN就没有意义了</p>\n<p><code>chunkHash</code>就是解决这个问题的，它根据不同的入口文件(<code>entry</code>)进行依赖文件解析、构建对应的chunk，生成对应的hash值。一般用在<code>output</code>配置上</p>\n<p><code>contentHash</code>计算与文件内容本身有关。一般用在抽离<code>css</code>文件的插件配置上</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">sourse-map 中 eval/cheap/inline</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>source-map会生成独立的文件</p>\n<p>cheap-source-map不会产生列映射</p>\n<p>eval-source-map会以<code>eval</code>函数打包运行模块，不产生独立的map文件，会显示报错的行列信息</p>\n<p>inline-source-map映射文件以base64格式编码，加载bundle文件最后，不产生独立的map文件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">loder vs plugin</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>loder: 文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</p>\n<p>plugin: 在webpack运行的生命周期中会广播许多事件，plugin可以监听这些事件，在合适的时机通过调用webpack提供的api改变输出结果</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s/To_p4eYJx_dkJr1ApcR4jA\">webpack 中最易混淆的 5 个知识点</a></p>\n<p><a href=\"https://webpack.docschina.org\">webpack文档</a></p>\n"},{"title":"JavaScript复习-手写题","tags":["JavaScript","手写题"],"categories":"2021复习","description":"## map、reduce、flatten函数\n\n``` js\nfunction myMap(src, cb) {\n  if (!Array.isArray(src)) throw new TypeError('src must be an array');\n  const tmp = [];\n  src.forEach((item) => tmp.push(cb(item)));\n  ret","createDate":"2021-05-27 02:07:18","updateDate":"2021-07-05 23:25:14","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">map、reduce、flatten函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myMap</span>(<span class=\"hljs-params\">src, cb</span>) {\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(src)) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;src must be an array&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> tmp = [];\n  src.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> tmp.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-title function_\">cb</span>(item)));\n  <span class=\"hljs-keyword\">return</span> tmp;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myReduce</span>(<span class=\"hljs-params\">src, cb, initialValue</span>) {\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(src)) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;src must be an array&#x27;</span>);\n  <span class=\"hljs-keyword\">let</span> init = initialValue || src[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">const</span> tmp = initialValue ? src : src.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>);\n  tmp.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =&gt;</span> {\n    init = <span class=\"hljs-title function_\">cb</span>(init, item, index, tmp);\n  });\n  <span class=\"hljs-keyword\">return</span> init;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">flatten</span> = (<span class=\"hljs-params\">arr, dep = <span class=\"hljs-number\">1</span></span>) =&gt; (dep &gt; <span class=\"hljs-number\">0</span>\n  ? arr.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">pre, cur</span>) =&gt;</span> pre.<span class=\"hljs-title function_\">concat</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(cur) ? <span class=\"hljs-title function_\">flatten</span>(cur, dep - <span class=\"hljs-number\">1</span>) : cur), [])\n  : arr.<span class=\"hljs-title function_\">slice</span>());\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">curry函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myCurry</span>(<span class=\"hljs-params\">fn</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> (fn.<span class=\"hljs-property\">length</span> === args.<span class=\"hljs-property\">length</span>\n    ? fn.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>, ...args)\n    : fn.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, ...args));\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">异步求和</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>原文地址: <a href=\"https://mp.weixin.qq.com/s/RBk-cLUU-ZT4ylqIR2XdJg\">一道字节笔试题，实现一个异步求和函数</a>\n提供一个异步 add 方法如下，需要实现一个<code>await sum(...args)</code>函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">asyncAdd</span>(<span class=\"hljs-params\">a, b, callback</span>) {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">callback</span>(<span class=\"hljs-literal\">null</span>, a + b);\n  }, <span class=\"hljs-number\">1000</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum2</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-title function_\">asyncAdd</span>(a, b, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, res</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-title function_\">reject</span>(err);\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-title function_\">resolve</span>(res);\n    });\n  });\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">...args</span>) {\n  <span class=\"hljs-keyword\">if</span> (args.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">if</span> (args.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(args[<span class=\"hljs-number\">0</span>]);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n    args.<span class=\"hljs-title function_\">reduce</span>(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">pre, cur</span>) =&gt;</span> pre.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total</span>) =&gt;</span> <span class=\"hljs-title function_\">sum2</span>(total, cur)),\n      <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">0</span>),\n    ).<span class=\"hljs-title function_\">then</span>(resolve);\n  });\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sumTmp</span>(<span class=\"hljs-params\">...args</span>) {\n  <span class=\"hljs-keyword\">if</span> (args.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(args[<span class=\"hljs-number\">0</span>]);\n  <span class=\"hljs-keyword\">const</span> res = args.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-keyword\">async</span> (a, b) =&gt; <span class=\"hljs-title function_\">sum2</span>(<span class=\"hljs-keyword\">await</span> a, b), <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">0</span>));\n  <span class=\"hljs-keyword\">return</span> res;\n}\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">performanceSum</span>(<span class=\"hljs-params\">...args</span>) {\n  <span class=\"hljs-keyword\">const</span> tmp = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(args));\n  <span class=\"hljs-keyword\">const</span> { length } = tmp;\n  <span class=\"hljs-keyword\">if</span> (length === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(tmp[<span class=\"hljs-number\">0</span>]);\n  <span class=\"hljs-keyword\">const</span> resultArray = [];\n  <span class=\"hljs-keyword\">if</span> (length % <span class=\"hljs-number\">2</span>) tmp.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; tmp.<span class=\"hljs-property\">length</span> / <span class=\"hljs-number\">2</span>; i += <span class=\"hljs-number\">1</span>) {\n    resultArray.<span class=\"hljs-title function_\">push</span>([tmp[i * <span class=\"hljs-number\">2</span>], tmp[i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>]]);\n  }\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(resultArray.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[a, b]</span>) =&gt;</span> <span class=\"hljs-title function_\">sum2</span>(a, b)));\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">performanceSum</span>(...res);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">rgb(255, 255, 255)转#ffffff</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">rgb2hex</span>(<span class=\"hljs-params\">rgb</span>) {\n  <span class=\"hljs-keyword\">const</span> [r, g, b] = rgb.<span class=\"hljs-title function_\">match</span>(<span class=\"hljs-regexp\">/\\d+/g</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`#<span class=\"hljs-subst\">${\n    [r, g, b].map((item) =&gt; (+item).toString(<span class=\"hljs-number\">16</span>).padStart(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;0&#x27;</span>)).join(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n  }</span>`</span>;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise.all</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">promiseAll</span>(<span class=\"hljs-params\">promises</span>) {\n  <span class=\"hljs-keyword\">if</span> (!promises[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;promises must be iterable&#x27;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> resolvedPromises = [];\n    promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(promise).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {\n      resolvedPromises.<span class=\"hljs-title function_\">push</span>(res);\n      <span class=\"hljs-keyword\">if</span> (resolvedPromises.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(resolvedPromises);\n    }, reject));\n  });\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise.allSettled</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">PromiseStatus</span> = {\n  <span class=\"hljs-attr\">resolved</span>: <span class=\"hljs-string\">&#x27;fulfilled&#x27;</span>,\n  <span class=\"hljs-attr\">rejected</span>: <span class=\"hljs-string\">&#x27;rejected&#x27;</span>,\n};\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">promiseAllSettled1</span>(<span class=\"hljs-params\">promises</span>) {\n  <span class=\"hljs-keyword\">if</span> (!promises[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;promises must be iterable&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onResolve</span> = (<span class=\"hljs-params\">value</span>) =&gt; ({ <span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">PromiseStatus</span>.<span class=\"hljs-property\">resolved</span>, value });\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onReject</span> = (<span class=\"hljs-params\">reason</span>) =&gt; ({ <span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">PromiseStatus</span>.<span class=\"hljs-property\">rejected</span>, reason });\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(promises.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(promise).<span class=\"hljs-title function_\">then</span>(onResolve, onReject)));\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">promiseAllSettled2</span>(<span class=\"hljs-params\">promises</span>) {\n  <span class=\"hljs-keyword\">if</span> (!promises[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;promises must be iterable&#x27;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> res = [];\n    promises.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(promise).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n      res.<span class=\"hljs-title function_\">push</span>({ <span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">PromiseStatus</span>.<span class=\"hljs-property\">resolved</span>, value });\n      <span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(res);\n    }, <span class=\"hljs-function\">(<span class=\"hljs-params\">reason</span>) =&gt;</span> {\n      res.<span class=\"hljs-title function_\">push</span>({ <span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">PromiseStatus</span>.<span class=\"hljs-property\">rejected</span>, reason });\n      <span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(res);\n    }));\n  });\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise.any</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">promiseAny</span>(<span class=\"hljs-params\">promises</span>) {\n  <span class=\"hljs-keyword\">if</span> (!promises[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;promises must be iterable&#x27;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { length } = promises;\n    <span class=\"hljs-keyword\">const</span> rejectedPromises = [];\n    promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(promise).<span class=\"hljs-title function_\">then</span>(resolve, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> {\n      rejectedPromises.<span class=\"hljs-title function_\">push</span>(err);\n      <span class=\"hljs-keyword\">if</span> (rejectedPromises.<span class=\"hljs-property\">length</span> === length) <span class=\"hljs-title function_\">reject</span>(rejectedPromises);\n    }));\n  });\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">shallowEqual</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">shallowEqual</span>(<span class=\"hljs-params\">obj1, obj2</span>) {\n  <span class=\"hljs-keyword\">if</span> (obj1 === obj2) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">if</span> (\n    <span class=\"hljs-keyword\">typeof</span> obj1 !== <span class=\"hljs-string\">&#x27;object&#x27;</span>\n    || obj1 === <span class=\"hljs-literal\">null</span>\n    || <span class=\"hljs-keyword\">typeof</span> obj2 !== <span class=\"hljs-string\">&#x27;object&#x27;</span>\n    || obj2 === <span class=\"hljs-literal\">null</span>\n  ) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(obj1).<span class=\"hljs-property\">length</span> !== <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(obj2).<span class=\"hljs-property\">length</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(obj1);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; keys.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">if</span> (obj1[keys[i]] !== obj2[keys[i]]) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">shuffle</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">shuffle</span> = (<span class=\"hljs-params\">list</span>) =&gt; list.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() - <span class=\"hljs-number\">0.5</span>)\n</code></pre>\n"},{"title":"React.js复习-v17新特性","tags":["React.js","React17"],"categories":"2021复习","description":"## 全新的jsx转换\n\nv17之前使用`jsx`需要导入`React`。这是因为v17之前需要使用`React.createElement`来编译`jsx`。\nv17之后自动从`React`的`package`中引入新的入口函数并调用\n\n## 事件委托的变更\n\nv17不再将事件添加到`document`上，而是添加到渲染`React`的根容器中\n\n当开发者需要在`document`上添加自定","createDate":"2021-05-29 14:47:45","updateDate":"2021-07-01 13:43:20","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">全新的jsx转换</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>v17之前使用<code>jsx</code>需要导入<code>React</code>。这是因为v17之前需要使用<code>React.createElement</code>来编译<code>jsx</code>。\nv17之后自动从<code>React</code>的<code>package</code>中引入新的入口函数并调用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件委托的变更</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>v17不再将事件添加到<code>document</code>上，而是添加到渲染<code>React</code>的根容器中</p>\n<p>当开发者需要在<code>document</code>上添加自定义事件时会发生意想不到的bug</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> [showModal, setShowModal] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">closeModal</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-title function_\">setShowModal</span>(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, closeModal);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, closeModal);\n    }\n  })\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{(e)</span> =&gt;</span> {\n        setShowModal(true);\n        // e.stopPropagation();\n        e.nativeEvent.stopImmediatePropagation();\n      }}&gt;showModal<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      {\n        showModal &amp;&amp; (\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;modal&quot;</span>&gt;</span>i am a modal<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        )\n      }\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#app&#x27;</span>));\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">去除事件池</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>v17之前，如果想要用异步的方式使用事件对象<code>e</code>，则必须先调用<code>e.persist()</code>才可以，这是因为<code>React</code>在旧浏览器中重用了不同事件的事件对象以提高性能，并将所有事件字段在它们之前设置为<code>null</code></p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Name</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n    \n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onChange</span> = (<span class=\"hljs-params\">e</span>) =&gt; {\n        e.<span class=\"hljs-title function_\">persist</span>();\n        <span class=\"hljs-title function_\">setValue</span>(<span class=\"hljs-function\">() =&gt;</span> e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>);\n    }\n    \n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{name}</span> <span class=\"hljs-attr\">onInput</span>=<span class=\"hljs-string\">{onChange}</span> /&gt;</span></span>\n    )\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">副作用清理时间</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>v17之前，<code>useEffect</code>、<code>useLayoutEffect</code>的清理函数都是同步运行的，对于大型程序来讲，这并不是理想选择，因为同步操作会影响页面的显示。v17之后，<code>useEffect</code>的清理函数将变为异步运行，<code>useLayoutEffect</code>的清理函数仍保持同步运行</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> instance = someRef.<span class=\"hljs-property\">current</span>;\n    instance.<span class=\"hljs-title function_\">someSetupMethod</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> {\n        instance.<span class=\"hljs-title function_\">someCleanupMethod</span>();\n    }\n})\n</code></pre>\n"},{"title":"React.js复习-一些理解","tags":["React.js"],"categories":"2021复习","description":"## 对React的理解\n\n> 用于构建用户界面的JavaScript库\n\n具有声明式、组件化、跨平台等特点\n\n- 声明式\n    React采用声明式来编写UI，语法简洁高效\n    ``` jsx\n    // 声明式\n    const Element = <h1>hello</h1>\n    ReactDOM.render(<Element />, document.querySele","createDate":"2021-06-01 01:47:25","updateDate":"2021-07-01 13:42:45","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对React的理解</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>用于构建用户界面的JavaScript库</p>\n</blockquote>\n<p>具有声明式、组件化、跨平台等特点</p>\n<ul>\n<li>声明式\n  React采用声明式来编写UI，语法简洁高效<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// 声明式</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Element</span> = <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Element</span> /&gt;</span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#app&quot;</span>));\n\n<span class=\"hljs-comment\">// 命令式</span>\n<span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&quot;div&quot;</span>);\ndiv.<span class=\"hljs-property\">innerText</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>;\n<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#app&quot;</span>).<span class=\"hljs-title function_\">appendChild</span>(element);\n</code></pre>\n</li>\n<li>组件化\n  可以编写具有管理自身状态能力的封装组件，然后对其组合以构成复杂的UI。方便复用。由于组件逻辑使用JavaScript编写而非模板，因此你可以轻松地在应用中传递数据，并保持状态与DOM分离</li>\n<li>跨平台\n  <code>react-dom</code>用于构建网站应用；<code>react-native</code>用于构建移动端原生应用</li>\n<li>jsx\n  使用jsx来开发，方便灵活，表达能力强</li>\n<li>虚拟DOM\n  引入虚拟DOM的概念，整合更新视图的方法，使开发者不再去手动更新DOM，操作更高效</li>\n<li>新的Reconciler（fiber架构）\n  最新的的fiber架构使得DOM更新更加流畅、高效。分离出commit和render阶段，使得更新异步可中断，不会长时间阻塞渲染线程，从而避免在一些大型应用中执行一些操作后页面卡死的问题</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对virtualDOM的理解</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一个JavaScript对象，用于描述真实的DOM节点</p>\n<p>在react中通过<code>React.createElement</code>创建（babel在转译jsx的时候调用）</p>\n<p>通过引入虚拟DOM，开发者可以方便得解决浏览器兼容性与跨平台问题。开发者只需要告诉react最新的DOM结构，渲染交由react统一处理，开发者不用再关心不同浏览器下api的兼容性问题；而且通过引入不同的渲染库，可以进行跨平台开发。此外，虚拟DOM在更新的时候可以实现差异化与精准更新，效率更高</p>\n<p>但虚拟DOM也有其缺点，首先是引入虚拟DOM会后额外的内存消耗；其次是虚拟DOM在某些情况下的效率也不一定比手动操作DOM高</p>\n<p>ps：虚拟DOM一定效率高吗？</p>\n<p>答：不一定。比如在初次渲染的时候和手动操作一样，都需要创建节点然后插入，效率并不高。虚拟DOM的真正优势是跨平台、处理兼容性问题、增量更新等</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对fiber的理解</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>具有三种不同的含义</p>\n<ul>\n<li>一种架构。之前React15的<code>reconciler</code>采用递归的方式执行更新DOM的操作，数据保存在递归调用栈中，所以被称为<code>stack Reconciler</code>。React16的<code>reconciler</code>基于Fiber节点实现，被称为<code>Fiber Reconciler</code></li>\n<li>一种数据结构。每个<code>Fiber</code>节点对应一个<code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息</li>\n<li>一个执行任务。（工作单元） 每个<code>Fiber</code>节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对函数式组件的理解</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>为了解决类组件在异步时数据一致性的问题</p>\n<p>函数式组件vs类组件：</p>\n<ul>\n<li>编程思想不同。类组件需要创建实例，而函数式组件不需要，接收输入，返回输出，是基于函数式编程的思想写的</li>\n<li>内存占用。类组件需要实例化，占用一定的内存</li>\n<li>捕获特性。函数式组件具有值捕获特性</li>\n<li>可测试性。函数值组件更容易编写测试用例</li>\n<li>生命周期。类组件具有复杂的生命周期函数，函数式组件可使用<code>useEffect</code>来执行副作用</li>\n<li>逻辑复用。类组件可以使用子组件/继承来实现复用，函数式组件使用自定义<code>hook</code>来实现逻辑复用</li>\n<li>跳过更新。类组件可以使用<code>shouldComponentUpdate</code>和<code>React.PureComponent</code>来跳过更新。函数式组件可使用<code>React.memo</code></li>\n<li>发展前景。函数式组件可以更好的解决<code>this</code>指向、逻辑复用、时间分片、并发渲染等问题</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">合成事件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>React为处理各浏览器兼容性问题所设计的一种时间处理机制。原生DOM事件流分为两种：IE、W3C。IE标准中只有冒泡；W3C分为捕获+冒泡阶段。合成事件基于事件委托机制，统一处理事件绑定。</p>\n<p>在React17之前，所有事件均绑定到<code>document</code>元素上，17之后绑定到根元素上。这样做有以下几点优势：</p>\n<ul>\n<li>解决事件触发顺序不一致问题</li>\n<li>多React版本共存问题</li>\n</ul>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#parent&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handler</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;native clickPropagation&#x27;</span>);\n    };\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handlerCapture</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;native clickCapture&#x27;</span>);\n    };\n    node.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, handler);\n    node.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, handlerCapture, <span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> {\n      node.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, handler);\n      node.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, handlerCapture, <span class=\"hljs-literal\">true</span>);\n    }\n  })\n\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onClick</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;react clickPropagation&#x27;</span>);\n  }\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onClickCapture</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;react clickCapture&#x27;</span>);\n  }\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;parent&quot;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onClick}</span> <span class=\"hljs-attr\">onClickCapture</span>=<span class=\"hljs-string\">{onClickCapture}</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#app&#x27;</span>))\n\n<span class=\"hljs-comment\">// v16</span>\n<span class=\"hljs-comment\">// native clickCapture</span>\n<span class=\"hljs-comment\">// native clickPropagation</span>\n<span class=\"hljs-comment\">// react clickCapture</span>\n<span class=\"hljs-comment\">// react clickPropagation</span>\n\n<span class=\"hljs-comment\">// v17</span>\n<span class=\"hljs-comment\">// react clickCapture</span>\n<span class=\"hljs-comment\">// navive clickCapture</span>\n<span class=\"hljs-comment\">// native clickPropagation</span>\n<span class=\"hljs-comment\">// react clickPropagation</span>\n</code></pre>\n<p>源码层面分别给<code>root</code>添加一个冒泡事件和捕获事件，在捕获事件里模拟合成事件的捕获，在冒泡事件里模拟合成事件的冒泡</p>\n<pre><code class=\"hljs language-js\">root.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-title function_\">dispatchEvent</span>(e, <span class=\"hljs-literal\">true</span>), <span class=\"hljs-literal\">true</span>);\nroot.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-title function_\">dispatchEvent</span>(e, <span class=\"hljs-literal\">false</span>));\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dispatchEvent</span>(<span class=\"hljs-params\">event, useCapture</span>) {\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">if</span> (useCapture) {\n        <span class=\"hljs-comment\">// 模拟合成事件的捕获</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 模拟合成事件的冒泡</span>\n    }\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对DOM-diff的理解</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单来讲就是拿新的jsx(数组)与fiber(链表)进行比对，生成副作用数组和新的fiber树的过程，发生在<code>reconciler</code>阶段。比较时会进行遍历，根据<code>type</code>和<code>key</code>来判断节点是否有更新以及更新的类型（新增？修改？删除？移动？），给老fiber节点添加对应的标记</p>\n<p>有三个预设限制：</p>\n<ul>\n<li>同层比较</li>\n<li>元素类型不同时不再去比较子树，直接生成新的</li>\n<li>可为元素添加key来指示哪些元素在更新时保持稳定</li>\n</ul>\n<p>根据同级节点不同有两种不同的diff算法</p>\n<ol>\n<li>当newChild类型为object、number、string，代表同级只有一个节点</li>\n<li>当newChild类型为Array，同级有多个节点</li>\n</ol>\n<p>对于单节点，根据<code>key</code>和<code>type</code>来决定元素是否复用</p>\n<p>对于多节点，会发生两轮遍历</p>\n<ol>\n<li>处理更新的节点</li>\n<li>处理删除、添加、位置发生变化的节点</li>\n</ol>\n<p>第一轮循环过程中当节点不能复用时或遍历完成后开启第二轮循环</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React.js对比Vue.js</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>都是用来开发现代前端应用的库/框架，两者都采用了一种叫做虚拟DOM的机制来方便开发者来操作真实的DOM</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">设计思想</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Vue.js是一个渐进式框架，采用自底向上增量开发的模式。</p>\n<p>所谓渐进式就是把框架分层。最核心的部分是视图层渲染，然后往外是组件系统，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。所谓分层，就是说既可以只用最核心的视图层渲染功能快速开发一些需求，也可以使用一整套全家桶来开发大型应用。Vue.js由足够的灵活性来适应不同的需求，所以开发者可以根据自己的需求选择不同的层级。</p>\n<p>React.js是用来构建界面的JavaScript库。具有声明式、组件化、跨平台的特点。可以编写具有管理自身状态能力的封装组件，然后对其组合以构成复杂的UI。方便复用。由于组件逻辑使用JavaScript编写而非模板，因此你可以轻松地在应用中传递数据，并保持状态与DOM分离。通过引入虚拟DOM来整合更新视图的方法，使开发者不再去手动更新DOM，操作更高效</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">响应式</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Vue.js通过使用<code>Object.defineProperty</code>和<code>Proxy</code>来劫持数据变化，当更新数据的时候进行DOM-DIFF，更新视图。此外，Vue.js通过<code>v-model</code>这一语法糖指令可实现双向数据绑定功能</p>\n<p>React.js在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分，从而避免整棵树重构，提高性能</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组件间数据交互</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Vue.js中父组件通过props传递数据给子组件，子组件使用$emit触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据</p>\n<p>React.js中父组件使用props传递数据和回调函数给子组件，子组件通过props传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据</p>\n"},{"title":"前端架构&软实力复习-性能优化","tags":["性能优化"],"categories":"2021复习","description":"## 性能优化\n\n### 网络层面\n\n1. 压缩代码，删除不必要的代码和注释以及空格，尽量做到最小化文件\n\n2. 合理的代码合并与分割，降低资源请求时间\n\n3. 合理使用缓存\n\n4. 静态资源存放cdn\n\n#### 渲染过程\n\n优化dom结构\n\n- css文件放在head中，JavaScript文件放在body底部\n\n  js的执行会阻碍render（两个不同的线程）\n\n优化css\n\n- 减少","createDate":"2021-06-30 05:48:56","updateDate":"2021-07-01 12:29:25","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">性能优化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">网络层面</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ol>\n<li><p>压缩代码，删除不必要的代码和注释以及空格，尽量做到最小化文件</p>\n</li>\n<li><p>合理的代码合并与分割，降低资源请求时间</p>\n</li>\n<li><p>合理使用缓存</p>\n</li>\n<li><p>静态资源存放cdn</p>\n</li>\n</ol>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">渲染过程</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>优化dom结构</p>\n<ul>\n<li><p>css文件放在head中，JavaScript文件放在body底部</p>\n<p>js的执行会阻碍render（两个不同的线程）</p>\n</li>\n</ul>\n<p>优化css</p>\n<ul>\n<li><p>减少重绘回流</p>\n<p>重绘会在设置节点样式时频繁出现，同时也会很大程度上影响性能，重绘是当节点需要更改外观而不会影响布局的时候发生，比如改变 color 就叫重绘\n回流是布局或者几何属性需要改变就称为回流，回流必然会引起重绘，重绘不一定为引发回流</p>\n<ol>\n<li>使用transform代替top</li>\n<li>使用visibility代替display:none</li>\n<li>直接改变className（把要修改的样式集中到一个class内统一修改）</li>\n<li>避免使用table布局（尽量不要使用table布局。如果没有定宽，表格一列的宽度则由最宽的一列决定，那个很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定- 好其在渲染树中节点的属性）</li>\n</ol>\n</li>\n<li><p>扁平化css选择器，避免嵌套过深</p>\n<p>选择器嵌套不超过三级</p>\n</li>\n</ul>\n<p>优化JavaScript</p>\n<ul>\n<li><p>事件委托（<strong>慎用，存在兼容性</strong>），减少事件绑定</p>\n</li>\n<li><p>合理更新dom</p>\n<ol>\n<li><p>dom离线操作</p>\n</li>\n<li><p><a href=\"https://blog.mrrs.top/blog/view/5f68c0ee41416660fc5c4a3a\">异步更新（包装成micro任务）</a></p>\n</li>\n</ol>\n</li>\n<li><p>减少重绘回流</p>\n<p>一些api会引起回流（getBoundingClientRect/getComputedStyle/clientTop/scrollTop/offsetTop），避免频繁使用</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">开发工具优化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用一系列工具使得开发更加方便、高效</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用webpack打包代码</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><img src=\"https://pics.sdoprofile.com/sdo5/M01/A1/13/CoEpPGAc-0aAIGWzABDaeq_2mCc412_x.png\" alt=\"使用webpack打包代码\"></p>\n<ul>\n<li><p>版本号问题</p>\n<p>打包后资源文件名自动添加8位hash值</p>\n</li>\n<li><p>代码压缩/混淆</p>\n<p>使用webpack插件压缩/混淆代码，减小文件体积</p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用babel处理兼容性</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>可以使用es6+高级语法进行开发</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用eslint规范代码</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>参考：</p>\n<ul>\n<li><a href=\"https://web.dev\">web dev</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/98880815\">Web性能领域常见的专业术语</a></li>\n<li><a href=\"https://blog.mrrs.top/blog/view/5f68c0ee414166469a5c4a38\">浏览器相关-渲染</a></li>\n<li><a href=\"https://blog.mrrs.top/blog/view/5f68c0ee41416663715c4a39\">浏览器相关-模型</a></li>\n<li><a href=\"https://blog.mrrs.top/blog/view/5f68c0ee41416660fc5c4a3a\">JavaScript-执行机制</a></li>\n</ul>\n"},{"title":"CSS复习-0","tags":["CSS"],"categories":"2021复习","description":"## flex组合属性\n\n``` css\nflex: 1 1 100px;\n```\n\n是下面三个属性的缩写：\n\n``` css\n/* 指定了flex容器中剩余空间的多少应该分配给项目（flex增长系数） */\nflex-grow: 1;\n/*  flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值 */\nflex-","createDate":"2021-05-19 14:07:45","updateDate":"2021-06-30 10:32:57","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">flex组合属性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-css\"><span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">100px</span>;\n</code></pre>\n<p>是下面三个属性的缩写：</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* 指定了flex容器中剩余空间的多少应该分配给项目（flex增长系数） */</span>\n<span class=\"hljs-attribute\">flex-grow</span>: <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">/*  flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值 */</span>\n<span class=\"hljs-attribute\">flex-shrink</span>: <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">/* 指定了 flex 元素在主轴方向上的初始大小 */</span>\n<span class=\"hljs-attribute\">flex-basis</span>: <span class=\"hljs-number\">100px</span>;\n</code></pre>\n<p>不同组合所代表的意义：</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* 关键字值 */</span>\n<span class=\"hljs-attribute\">flex</span>: auto;\n<span class=\"hljs-attribute\">flex</span>: initial;\n<span class=\"hljs-attribute\">flex</span>: none;\n\n<span class=\"hljs-comment\">/* 一个值, 无单位数字: flex-grow */</span>\n<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">/* 一个值, width/height: flex-basis */</span>\n<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">10em</span>;\n<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">30px</span>;\n<span class=\"hljs-attribute\">flex</span>: min-content;\n\n<span class=\"hljs-comment\">/* 两个值: flex-grow | flex-basis */</span>\n<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">30px</span>;\n\n<span class=\"hljs-comment\">/* 两个值: flex-grow | flex-shrink */</span>\n<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">/* 三个值: flex-grow | flex-shrink | flex-basis */</span>\n<span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">10%</span>;\n\n<span class=\"hljs-comment\">/*全局属性值 */</span>\n<span class=\"hljs-attribute\">flex</span>: inherit;\n<span class=\"hljs-attribute\">flex</span>: initial;\n<span class=\"hljs-attribute\">flex</span>: unset;\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">media query</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width:600px) and (max-width:900px)&quot; href=&quot;style.css&quot; type=&quot;text/css&quot; /&gt; </code></p>\n<p><code>max-width</code>: 屏幕大小;</p>\n<p><code>max-device-width</code>: 分辨率大小</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">offset/screen/scroll xxx</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/offset.png\" alt=\"offset/screen/scroll\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">居中</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>grid</code>布局<pre><code class=\"hljs language-css\"><span class=\"hljs-attribute\">display</span>: grid;\nplace-items: center;\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">BFC</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域</p>\n</blockquote>\n<p>通俗解释：</p>\n<ol>\n<li>一个独立的布局环境。BFC内部的元素布局与外部互不影响。</li>\n<li>一个工具。可以通过一些条件触发BFC，从而实现布局上的需求或解决一些问题</li>\n</ol>\n<p>BFC的触发条件：</p>\n<ul>\n<li>根元素<code>&lt;html&gt;&lt;/html&gt;</code></li>\n<li><code>float</code>不为<code>none</code></li>\n<li><code>overflow</code>不为<code>visible</code></li>\n<li><code>display</code>为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code></li>\n<li><code>position</code>为<code>absoulte</code>、<code>fixed</code></li>\n</ul>\n<p>BFC的特性：</p>\n<ul>\n<li>属于同一个BFC的两个<strong>相邻</strong>容器的<strong>上下</strong><code>margin</code>会发生重叠</li>\n<li>BFC的高度包括内部的浮动元素</li>\n<li>BFC不会与浮动元素发生重叠</li>\n</ul>\n<p>清除浮动：</p>\n<p>父元素设置<code>overflow: hidden</code>或<code>clear: both</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">link vs @import</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>link</code>是HTML方式，<code>@import</code>是css方式</li>\n<li><code>link</code>最大限度支持并行下载，<code>@imoprt</code>过多嵌套导致串行下载</li>\n<li><code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li>\n<li>浏览器对于<code>link</code>的支持早于<code>@import</code></li>\n<li><code>@import</code>必须放在css顶部</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">flex宽度问题</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;left&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;right&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"> \n<span class=\"hljs-selector-class\">.container</span>{ \n    <span class=\"hljs-comment\">/* width: 600px; */</span>\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">400px</span>; \n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">300px</span>; <span class=\"hljs-attribute\">display</span>:flex; \n} \n<span class=\"hljs-selector-class\">.left</span>{ \n    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">300px</span>;\n} \n<span class=\"hljs-selector-class\">.right</span>{ \n    <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">200px</span>;\n} \n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n</code></pre>\n<p><code>.left</code> + <code>.right</code>的宽度已经超过<code>.container</code>的宽度了，所以会发生缩放，<code>flex-grow</code>不起作用，<code>flex-shrink</code>和<code>width</code>(<code>flex-basis</code>)决定具体的大小</p>\n<p>具体的计算公式：</p>\n<pre><code class=\"hljs language-js\">\nitemSkrinkScaledWidth = flex-shrink * width\n\nshrinkRatio = itemSkrinkScaledWidth / totalShrinkScaledWidth\n\nrealWidth = width - shrinkRatio * negativeWidth \n\n<span class=\"hljs-comment\">// itemSkrinkScaledWidth 项目收缩比例宽度，flex-shrink * width</span>\n<span class=\"hljs-comment\">// totalShrinkScaledWidth 总的收缩比例宽度，total(flex-shrink * width)</span>\n<span class=\"hljs-comment\">// shrinkRatio 收缩比例</span>\n<span class=\"hljs-comment\">// negativeWidth 溢出的尺寸</span>\n<span class=\"hljs-comment\">// width 所设置的大小，width或flex-basis</span>\n<span class=\"hljs-comment\">// realWidth 真实大小</span>\n</code></pre>\n<p>所以</p>\n<pre><code class=\"hljs language-js\">leftWidth = <span class=\"hljs-number\">300</span> - (<span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">300</span> / (<span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">300</span> + <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">200</span>)) * <span class=\"hljs-number\">100</span> = <span class=\"hljs-number\">225</span>\nrightWidth = <span class=\"hljs-number\">200</span> - (<span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">200</span> / (<span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">300</span> + <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">200</span>)) * <span class=\"hljs-number\">100</span> = <span class=\"hljs-number\">175</span>\n</code></pre>\n<p>注意：经测试，使用<code>min-width</code>设置时上述计算方法失效，大小正常，不发生缩小</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CSS3新特性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>选择器 <code>:nth-child(x)</code></li>\n<li>样式<code>flex</code> <code>grid</code> <code>filter</code> <code>transform</code> <code>box-sizing</code></li>\n<li>动画<code>animation</code></li>\n<li>颜色<code>rgba</code></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">清除浮动</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">::after + clear: both</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.clear-float</span><span class=\"hljs-selector-pseudo\">::after</span> {\n  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;020&quot;</span>; \n  <span class=\"hljs-attribute\">display</span>: block; \n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>; \n  <span class=\"hljs-attribute\">clear</span>: both; \n  <span class=\"hljs-attribute\">visibility</span>: hidden;  \n}\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">overflow不为none</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">父元素设置浮动</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">匹配前N个子元素及最后N个子元素</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>匹配前三个<code>:nth-child(-n+3)</code></p>\n<p>匹配最后三个<code>:nth-last-child(-n+4)</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex\">MDN-flex</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\">MDN-bfc</a></p>\n<p><a href=\"https://www.cnblogs.com/qs-cnblogs/p/12349887.html\">BFC是什么？BFC有什么用？看完全明白</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000010780991\">个人总结（css3新特性）</a></p>\n"},{"title":"HTML复习-0","tags":["HTML"],"categories":"2021复习","description":"## 节点关系\n\n![节点关系](http://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_relation.png)\n\n## ParentNode.append/Node.appendChild\n\n- `ParentNode.append()`允许追加  `DOMString` 对象，而 `Node.appendChild()` 只接受 `Node`","createDate":"2021-05-18 02:48:23","updateDate":"2021-06-29 19:07:42","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">节点关系</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_relation.png\" alt=\"节点关系\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ParentNode.append/Node.appendChild</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>ParentNode.append()</code>允许追加  <code>DOMString</code> 对象，而 <code>Node.appendChild()</code> 只接受 <code>Node</code> 对象</li>\n<li><code>ParentNode.append()</code> 没有返回值，而 <code>Node.appendChild()</code> 返回追加的 <code>Node</code> 对象</li>\n<li><code>ParentNode.append()</code> 可以追加多个节点和字符串，而 <code>Node.appendChild()</code> 只能追加一个节点</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">cookie</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/cookie_0.png\" alt=\"cookie格式\"></p>\n<ul>\n<li>Name: <code>cookie</code>的名字</li>\n<li>Value: <code>cookie</code>的值</li>\n<li>Domain: 指定了哪些域名可以接收<code>cookie</code>。如果不指定，默认为<code>origin</code>，不包含子域名，如果制定则包含子域名</li>\n<li>Path: 制定了域名下的哪些路径可以接受<code>cookie</code>。子路径也会被匹配</li>\n<li>Expires/Max-Age: 定义<code>cookie</code>的生命周期</li>\n<li>HttpOnly: 限制JavaScript通过<code>document.cookie</code>访问</li>\n<li>Secure: 标记为<code>Secure</code>的<code>cookie</code>只应通过被HTTPS协议加密过的请求发送给服务端</li>\n<li>SameSite: 设置某个<code>cookie</code>在跨站请求时会不会被发送<ul>\n<li>None 浏览器会在同站请求、跨站请求下继续发送<code>cookie</code></li>\n<li>Strict 浏览器将只在访问相同站点时发送<code>cookie</code></li>\n<li>Lax 与Strict类似，但不包括用户从外部站点导航至该URL</li>\n</ul>\n</li>\n<li>Priotity: chrome的提案，<code>Low/Medium/Hight</code>，低优先级的<code>cookie</code>会在<code>cookie</code>数量超出时被移除</li>\n</ul>\n<p>不设置<code>max-age</code>和<code>expires</code>，此<code>cookie</code>就是会话级别的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件机制</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>IE 事件流被称为<strong>事件冒泡</strong>。事件从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）</p>\n<p>Netscape Communicator提出<strong>事件捕获</strong>机制。最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件</p>\n<p>DOM2 Events规范规定事件流分为个阶段：事件捕获、到达事件目标、事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。</p>\n<p>添加/移除事件处理程序：</p>\n<ul>\n<li>DOM0<pre><code class=\"hljs language-js\">element.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-function\">() =&gt;</span> {};\nelement.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-comment\">// 同一事件不能添加多个处理函数</span>\n</code></pre>\n</li>\n<li>DOM2<pre><code class=\"hljs language-js\">element.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, handler);\nelement.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, handler);\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">MutationObserver</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>可以在DOM被修改时异步执行回调，使用<code>MutationObserver</code>可以观察整个文档、DOM树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> elementRef = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onElementClick</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    elementRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&#x27;observer&#x27;</span>;\n  };\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MutationObserver</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">record</span>) =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(record[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">name</span>);\n    });\n    observer.<span class=\"hljs-title function_\">observe</span>(elementRef.<span class=\"hljs-property\">current</span>, { <span class=\"hljs-attr\">attributes</span>: <span class=\"hljs-literal\">true</span> });\n  }, []);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{elementRef}</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onElementClick}</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;button&quot;</span>&gt;</span>click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<p>默认情况下，只要被观察元素不被垃圾回收，MutationObserver的回调就会响应DOM变化事件，从而被执行，要提前终止执行回调，可以调用<code>disconnect()</code>方法。</p>\n<p><code>observe</code>配置</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>subtree</td>\n<td><code>boolean</code></td>\n<td>表示除了目标节点，是否观察目标节点的子树(后代)</br>如果是<code>false</code>则只观察目标节点的变化</br>如果是<code>true</code>则观察目标阶段及其整个子树</td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>attributes</td>\n<td><code>boolean</code></td>\n<td>表示是否观察目标阶段的属性变化</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>attributeFilter</td>\n<td><code>Array&lt;string&gt;/boonean</code></td>\n<td>表示要观察哪些属性的变化</br>把这个值置为<code>true</code>也会将<code>attributes</code>的值转换为<code>true</code></td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>attributeOldValue</td>\n<td><code>boolean</code></td>\n<td>表示<code>MutationObserver</code>是否记录变化之前的属性值</br>把这个值置为<code>true</code>也会将<code>attributes</code>置为<code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>characterData</td>\n<td><code>boolean</code></td>\n<td>表示修改字符数据是否触发变化事件</td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>characterDataOldValue</td>\n<td><code>boolean</code></td>\n<td>表示<code>MutationObserver</code>是否记录变化之前的字符数据</br>把这个值置为<code>true</code>也会将<code>characterData</code>的值置为<code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>childList</td>\n<td><code>boolean</code></td>\n<td>表示修改目标节点的子节点是否触发变化事件</td>\n<td><code>false</code></td>\n</tr>\n</tbody></table>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Node类型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>DOM1描述了名为<code>Node</code>的接口，这个接口是所有DOM节点类型都必须实现的。Node接口在JavaScript中被实现为<code>Node</code>类型，在除IE外的所有浏览器中都可以直接访问这个类型。在JavaScript中，所有节点都继承<code>Node</code>类型，因此所有类型都共享相同的基本属性和方法</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">DOCTYPE作用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>浏览器使用<code>DOCTYPE</code>声明来选择是否使用更符合Web标准或兼容旧浏览器的bug的模式。现代浏览器主要有两种渲染模式：</p>\n<ul>\n<li>怪异模式，又称向后兼容模式。旧浏览器使用的非标准渲染规则</li>\n<li>标准模式。严格遵守W3C标准</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- HTML5的doctype声明 --&gt;</span>\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">HTML</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">HTML</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>&gt;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTML5新特性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>新的文档类型声明(<code>DOCYPE</code>)</li>\n<li>新的语义元素，比如<code>&lt;header&gt;</code>,<code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>等</li>\n<li>新的表单控件，比如数字、日期、时间、日历和滑块</li>\n<li>强大的图像支持（借由<code>&lt;canvas&gt;</code>和<code>&lt;svg&gt;</code>）</li>\n<li>强大的多媒体支持（借由<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>）</li>\n<li>新的API（如<code>localStorage</code>）</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/orphaned/Web/API/ParentNode/append\">MDN-append</a></p>\n"},{"title":"webpack复习-0","tags":["webpack"],"categories":"2021复习","description":"## 构建过程\n\n1. 初始化参数。从配置文件和命令行读取参数后合并，得到最终的参数\n2. 开始编译。用上一步得到的参数初始化`Compiler`对象，加载所有配置的插件，执行对象的`run`方法开始执行编译\n3. 确定入口。根据配置中的`entry`找出所有的入口文件\n4. 编译模块。从入口文件出发，调用所有配置的`loader`对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入","createDate":"2021-05-26 14:54:22","updateDate":"2021-06-29 18:53:40","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">构建过程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>初始化参数。从配置文件和命令行读取参数后合并，得到最终的参数</li>\n<li>开始编译。用上一步得到的参数初始化<code>Compiler</code>对象，加载所有配置的插件，执行对象的<code>run</code>方法开始执行编译</li>\n<li>确定入口。根据配置中的<code>entry</code>找出所有的入口文件</li>\n<li>编译模块。从入口文件出发，调用所有配置的<code>loader</code>对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>\n<li>完成模块编译。在经过第4步使用<code>loader</code>翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li>\n<li>输出资源。根据入口和模块之间的依赖关系，组装成一个个包含多个模块的<code>chunk</code>，再把每个<code>chunk</code>转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>\n<li>输出完成。在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件内</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Hash&amp;ChunkHash&amp;ContentHash的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>hash</code>，根据构建目录生成，只要项目中有文件修改，则整个项目构建出来的<code>hash</code>都会改变</li>\n<li><code>chunkHash</code>，和webpack打包到chunk有关，不同entry会生成不同的<code>chunkHash</code>。chunk之间互不影响（一般用来打包公用js）</li>\n<li><code>contentHash</code>，根据文件内容生成<code>hash</code>，只要文件内容不变，生成的<code>contentHash</code>就不变（一般用来打包css）</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">loader和plugin</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>loader用来处理非JavaScript文件。webpack将一切文件视为模块，但webpack只能处理JavaScript文件，如果想将其他文件也打包的话就要用到对应的loader</p>\n<p>plugin用来扩展webpack的能力。webpack在运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">webpack5新特性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>启动命令变化<pre><code class=\"hljs language-js\">{\n    <span class=\"hljs-comment\">// v4</span>\n    <span class=\"hljs-string\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server&quot;</span>\n    <span class=\"hljs-comment\">// v5</span>\n    <span class=\"hljs-string\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;webpack serve&quot;</span>\n}\n</code></pre>\n</li>\n<li>内置持久化缓存</li>\n<li>资源模块</li>\n<li>moduleIds和chunkIds优化</li>\n<li>移除Node.js的polyfill</li>\n<li><code>tree-shaking</code></li>\n<li><code>module federation</code>。主要是用来解决多个应用之间代码共享的问题，可以让我们的更加优雅的实现跨应用的代码共享</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">tree shaking</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一种优化，可以去除不必要的代码，减小打包后的体积</p>\n<p>基于模块静态加载来实现。由于导入了哪些模块是确定的，编译的时候可以正确判断到底加载了哪些模块和变量，可以删除那些未被使用的变量或者引用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">常用配置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HtmlWebpackPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;html-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ProgressBarPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;progress-bar-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> chalk = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;chalk&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">CleanWebpackPlugin</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;clean-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;mini-css-extract-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">CssMinimizerPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;css-minimizer-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">DefinePlugin</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;webpack&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">TerserPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;terser-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> entry = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./webpack.entry&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-variable constant_\">PORT</span>, <span class=\"hljs-variable constant_\">MODE</span>, <span class=\"hljs-variable constant_\">MOCK</span> } = process.<span class=\"hljs-property\">env</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">generateHTMLPluginConfig</span>(<span class=\"hljs-params\">pages</span>) {\n  <span class=\"hljs-keyword\">const</span> items = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(pages).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> (\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HtmlWebpackPlugin</span>({\n      <span class=\"hljs-attr\">chunks</span>: [item, <span class=\"hljs-string\">&#x27;common&#x27;</span>],\n      <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`./src/html/<span class=\"hljs-subst\">${item}</span>.html`</span>,\n      <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${item}</span>.html`</span>,\n    })\n  ));\n  <span class=\"hljs-keyword\">return</span> items;\n}\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-variable constant_\">MODE</span>,\n  entry,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;static/js/[name].[hash:8].js&#x27;</span>,\n    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n  },\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CleanWebpackPlugin</span>(),\n    ...<span class=\"hljs-title function_\">generateHTMLPluginConfig</span>(entry),\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ProgressBarPlugin</span>({\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${chalk.green(<span class=\"hljs-string\">&#x27;Progressing&#x27;</span>)}</span>[:bar]<span class=\"hljs-subst\">${chalk.green(<span class=\"hljs-string\">&#x27;:percent&#x27;</span>)}</span>(:elapsed seconds)`</span>,\n      <span class=\"hljs-attr\">clear</span>: <span class=\"hljs-literal\">false</span>,\n    }),\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>({\n      <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;static/css/[name].[hash:8].css&#x27;</span>,\n      <span class=\"hljs-attr\">chunkFilename</span>: <span class=\"hljs-string\">&#x27;static/css/[id].css&#x27;</span>,\n    }),\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefinePlugin</span>({\n      <span class=\"hljs-string\">&#x27;process.env&#x27;</span>: {\n        <span class=\"hljs-attr\">MODE</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(<span class=\"hljs-variable constant_\">MODE</span>),\n        <span class=\"hljs-variable constant_\">MOCK</span>,\n      },\n    }),\n  ],\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(html)$/</span>,\n        <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-string\">&#x27;html-withimg-loader&#x27;</span>],\n        <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>,\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.m?js$/</span>,\n        <span class=\"hljs-attr\">use</span>: [{\n          <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,\n          <span class=\"hljs-attr\">options</span>: {\n            <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&#x27;@babel/preset-env&#x27;</span>],\n          },\n        },\n        <span class=\"hljs-string\">&#x27;eslint-loader&#x27;</span>],\n        <span class=\"hljs-attr\">exclude</span>: [<span class=\"hljs-regexp\">/node_modules/</span>, <span class=\"hljs-regexp\">/lib/</span>, <span class=\"hljs-regexp\">/polyfill/</span>],\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>,\n        <span class=\"hljs-attr\">use</span>: [\n          {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>.<span class=\"hljs-property\">loader</span>,\n            <span class=\"hljs-attr\">options</span>: {\n              <span class=\"hljs-attr\">publicPath</span>: <span class=\"hljs-string\">&#x27;../&#x27;</span>,\n            },\n          },\n          <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>,\n          <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>,\n        ],\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.less$/</span>,\n        <span class=\"hljs-attr\">use</span>: [\n          {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-title class_\">MiniCssExtractPlugin</span>.<span class=\"hljs-property\">loader</span>,\n            <span class=\"hljs-attr\">options</span>: {\n              <span class=\"hljs-attr\">publicPath</span>: <span class=\"hljs-string\">&#x27;../&#x27;</span>,\n            },\n          },\n          <span class=\"hljs-string\">&#x27;css-loader&#x27;</span>,\n          <span class=\"hljs-string\">&#x27;postcss-loader&#x27;</span>,\n          <span class=\"hljs-string\">&#x27;less-loader&#x27;</span>,\n        ],\n      },\n      {\n        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.(png|jpg|gif|jpeg|svg|ttf)$/</span>,\n        <span class=\"hljs-attr\">use</span>: [\n          {\n            <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;url-loader&#x27;</span>,\n            <span class=\"hljs-attr\">options</span>: {\n              <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">10240</span>,\n              <span class=\"hljs-attr\">esModule</span>: <span class=\"hljs-literal\">false</span>,\n              <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;static/img/[name].[hash:6].[ext]&#x27;</span>,\n              <span class=\"hljs-attr\">publicPath</span>: <span class=\"hljs-variable constant_\">MODE</span> === <span class=\"hljs-string\">&#x27;development&#x27;</span> ? <span class=\"hljs-string\">&#x27;/&#x27;</span> : <span class=\"hljs-string\">&#x27;/loginfe&#x27;</span>,\n            },\n          },\n        ],\n        <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>,\n      },\n    ],\n  },\n  <span class=\"hljs-attr\">optimization</span>: {\n    <span class=\"hljs-attr\">minimize</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">minimizer</span>: [\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CssMinimizerPlugin</span>(),\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TerserPlugin</span>(),\n    ],\n    <span class=\"hljs-attr\">splitChunks</span>: {\n      <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&#x27;all&#x27;</span>,\n      <span class=\"hljs-attr\">cacheGroups</span>: {\n        <span class=\"hljs-attr\">common</span>: {\n          <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;common&#x27;</span>,\n          <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/.js$/</span>,\n          <span class=\"hljs-attr\">minChunks</span>: <span class=\"hljs-number\">2</span>,\n          <span class=\"hljs-attr\">minSize</span>: <span class=\"hljs-number\">0</span>,\n        },\n      },\n    },\n  },\n  <span class=\"hljs-attr\">devServer</span>: {\n    <span class=\"hljs-attr\">contentBase</span>: path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n    <span class=\"hljs-attr\">compress</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-variable constant_\">PORT</span>,\n    <span class=\"hljs-attr\">disableHostCheck</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,\n    <span class=\"hljs-attr\">proxy</span>: {\n      <span class=\"hljs-string\">&#x27;/v1/*&#x27;</span>: {\n        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;xxx&#x27;</span>,\n        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">secure</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">headers</span>: {},\n      },\n    },\n  },\n  <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-variable constant_\">MODE</span> === <span class=\"hljs-string\">&#x27;production&#x27;</span> ? <span class=\"hljs-literal\">false</span> : <span class=\"hljs-string\">&#x27;eval-source-map&#x27;</span>,\n};\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">循环引用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在<code>CommonJS</code>规范中，当遇到<code>require()</code>语句时，会执行<code>require</code>模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果</p>\n<p>在<code>ESM</code>中，因为<code>import</code>是在编译阶段执行的，这样就使得程序在编译时就能确定模块的依赖关系，一旦发现循环依赖，ES6 本身就不会再去执行依赖的那个模块了，所以程序可以正常结束。这也说明了 ES6 本身就支持循环依赖，保证程序不会因为循环依赖陷入无限调用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://segmentfault.com/a/1190000038962700\">小红书面试官：介绍一下 tree shaking 及其工作原理</a> </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/33049803\">探索 JavaScript 中的依赖管理及循环依赖</a></p>\n"},{"title":"前端架构&软实力复习-0","tags":["前端架构","软实力"],"categories":"2021复习","description":"## npm版本\n\n``` js\n\"5.0.3\",\n\"~5.0.3\",\n\"^5.0.3\"\n```\n\n- \"5.0.3\"表示安装指定的5.0.3版本\n- \"～5.0.3\"表示安装5.0.X中最新的版本\n- \"^5.0.3\"表示安装5.X.X中最新的版本\n\n## fullScreen\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>","createDate":"2021-05-14 08:20:12","updateDate":"2021-06-28 10:59:47","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">npm版本</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-string\">&quot;5.0.3&quot;</span>,\n<span class=\"hljs-string\">&quot;~5.0.3&quot;</span>,\n<span class=\"hljs-string\">&quot;^5.0.3&quot;</span>\n</code></pre>\n<ul>\n<li>&quot;5.0.3&quot;表示安装指定的5.0.3版本</li>\n<li>&quot;～5.0.3&quot;表示安装5.0.X中最新的版本</li>\n<li>&quot;^5.0.3&quot;表示安装5.X.X中最新的版本</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">fullScreen</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onFullScreenClick</span>(<span class=\"hljs-params\"></span>) {\n          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">111</span>);\n          <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#fullScreenImage&#x27;</span>).<span class=\"hljs-title function_\">requestFullscreen</span>();\n        }\n      </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;onFullScreenClick()&quot;</span>&gt;</span>\n        full screen\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;fullScreenImage&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://ns-strategy.cdn.bcebos.com/ns-strategy/upload/fc_big_pic/part-00139-2321.jpg&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">img</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">git命令</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>git commit --amend -m &#39;提交原因&#39;</code> 修改最近一次commit的信息</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">有限状态机</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>有限状态机（finite state machine），计算机科学中用来对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态队列，以及如何响应来自外界的各种事件</p>\n<p>状态机有基本几个要素：</p>\n<ul>\n<li>当前所处状态。在各个时刻只处于一种状态</li>\n<li>状态转移函数。在某种条件下，会从一种状态转移至另一种状态</li>\n<li>有限状态序列。拥有有限，可枚举的状态数</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">监听页面崩溃</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>被监听页面和监听者建立一种<strong>心跳机制</strong>，每隔一定时间向监听者发送一次心跳；监听者根据心跳来推断被监听者的情况。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">微前端</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>将一个大型应用划分为一个主应用和一个或多个小应用，应用间相互独立，可相互通信</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">白屏时间/渲染时间</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>白屏时间: <code>window.performance.timing.domLoading - window.performance.timing.navigationStart</code></p>\n<p>首屏时间：<code>window.performance.timing.domInteractive - window.performace.timing.navigationStart</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">npm ci</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>npm ci</code>（6.0版本以上）</p>\n<ol>\n<li>会删除项目中的<code>node_modules</code>文件夹</li>\n<li>按照项目中的<code>package-lock.json</code>来安装确切版本的依赖项</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">continuous-local-storage</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>continuous-local-storage</code>是nodejs中类似本地存储的，它可以实现多个文件中数据共享，但是不用挂载到全局对象</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//a.js</span>\n<span class=\"hljs-keyword\">const</span> storage=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;continuous-local-storage&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> space=stroage.<span class=\"hljs-title function_\">createNameSpace</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>);\nspace.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;user&#x27;</span>,<span class=\"hljs-string\">&#x27;xx&#x27;</span>)\n \n<span class=\"hljs-comment\">//b.js</span>\n<span class=\"hljs-keyword\">const</span> storage=<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;continuous-local-storage&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> space=storage.<span class=\"hljs-title function_\">getNameSpace</span>(<span class=\"hljs-string\">&#x27;data&#x27;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(space.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;user&#x27;</span>))\n<span class=\"hljs-comment\">//输出xx</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s/uQ6YFaFPUkaVkS8Y_F865w\">前端:从状态管理到有限状态机的思考</a></p>\n"},{"title":"浏览器复习-安全","tags":["浏览器安全"],"categories":"2021复习","description":"## 同源策略、CSP、CORS\n\n> 同源的定义: 如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源\n\n同源策略：控制不同的源之间如何交互资源\n\nCSP: 内容安全策略（Content-Security-Policy）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS和数据注入等。核心思想是**让服务器决定浏览","createDate":"2021-05-16 15:04:37","updateDate":"2021-06-24 23:23:08","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">同源策略、CSP、CORS</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>同源的定义: 如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源</p>\n</blockquote>\n<p>同源策略：控制不同的源之间如何交互资源</p>\n<p>CSP: 内容安全策略（Content-Security-Policy）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS和数据注入等。核心思想是<strong>让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong></p>\n<p>CORS: 跨域资源共享（Cross-Origin Resource Sharing）是一种机制，它由一系列HTTP头部组成，这些头部决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。同源安全策略 默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。</p>\n<p>跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的&quot;预检&quot;请求。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头</p>\n<p>对于一些<strong>简单请求</strong>，并不会发送<strong>OPTION预检请求</strong></p>\n<ul>\n<li>使用GET/POST/HEAD方法</li>\n<li>Context-type为&#39;test/plain&#39;或&#39;multipart/form-data&#39;或&#39;application/x-www-form-urlencoded&#39;</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">XSS</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。</p>\n</blockquote>\n<p>如果 Web 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取 cookie，session tokens，或者其它敏感的网站信息，或者让恶意脚本重写HTML内容。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">XSS攻击的分类</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p>存储型</p>\n<p>  注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器上传回并执行。</p>\n</li>\n<li><p>反射型</p>\n<p>  用户将含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击</p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">XSS攻击的危害</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>利用虚假表单骗取用户个人信息</li>\n<li>利用脚本窃取用户的cookie值，被害者在不知情的情况下帮助攻击者发送恶意请求</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">预防XSS攻击</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>过滤用户输入</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">filter</span> (str) {\n    <span class=\"hljs-keyword\">return</span> str\n      .<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/&amp;/g</span>, <span class=\"hljs-string\">&#x27;&amp;amp;&#x27;</span>)\n      .<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/ /g</span>, <span class=\"hljs-string\">&#x27;&amp;nbsp;&#x27;</span>)\n      .<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/&lt;/g</span>, <span class=\"hljs-string\">&#x27;&amp;lt;&#x27;</span>)\n      .<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/&gt;/g</span>, <span class=\"hljs-string\">&#x27;&amp;gt;&#x27;</span>)\n      .<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/&quot;/g</span>, <span class=\"hljs-string\">&#x27;&amp;quot;&#x27;</span>)\n      .<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/&#x27;/g</span>, <span class=\"hljs-string\">&#x27;&amp;#39;&#x27;</span>)\n      .<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/\\r{0,}\\n/g</span>, <span class=\"hljs-string\">&#x27;&lt;br/&gt;&#x27;</span>)\n}\n</code></pre>\n<p>CSP</p>\n<p>cookie设置<code>HttpOnly</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CSRF</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>跨站请求伪造（CSRF，Cross-site request forgery）是一种冒充受信任用户，向服务器发送非预期请求的攻击方式</p>\n</blockquote>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">攻击流程</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ol>\n<li>受害者登录<a href=\"http://a.com%EF%BC%8C%E5%B9%B6%E4%BF%9D%E7%95%99%E4%BA%86%E7%99%BB%E5%BD%95%E5%87%AD%E8%AF%81(Cookie)\">http://a.com，并保留了登录凭证(Cookie)</a></li>\n<li>攻击者引诱受害者访问<a href=\"http://b.com\">http://b.com</a></li>\n<li><a href=\"http://b.com\">http://b.com</a> 发送了一个请求： <a href=\"http://a.com?act=xxx\">http://a.com?act=xxx</a> 。浏览器会默认携带<a href=\"http://a.com%E7%9A%84cookie\">http://a.com的cookie</a></li>\n<li><a href=\"http://a.com\">http://a.com</a> 接收到请求后，对请求进行验证，确认是受害者，误以为是受害者自己发送的请求</li>\n<li><a href=\"http://a.com\">http://a.com</a> 以受害者的名义执行了act=xxx</li>\n<li>攻击完成，受害者在不知情的情况下冒充受害者，让<a href=\"http://a.com\">http://a.com</a> 执行了攻击者自定义的操作</li>\n</ol>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/csrf.png\" alt=\"CSRF攻击\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何防御</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>防范CSFR攻击可以遵循以下几种规则：</p>\n<ul>\n<li>不让第三方网站访问到用户cookie</li>\n<li>阻止第三方网站请求接口</li>\n<li>敏感接口请求时附带验证信息，比如token或验证码</li>\n</ul>\n<p>具体防范方法：</p>\n<ol>\n<li><p>samesite</p>\n<p> 可以对cookie设置samesite属性。</p>\n<blockquote>\n<p>samesite选项有<code>strict</code> <code>Lax</code> <code>None</code> 三个值。<code>strict</code>：浏览器完全禁止第三方拿到cookie；<code>Lax</code>：相对宽松一点，在跨站点的情况下，从第三方站点点的链接打开或<code>Get</code>方式的表单提交这两种方式都会携带<code>Cookie</code></p>\n</blockquote>\n</li>\n<li><p>referer</p>\n<p> <code>referer</code>是header的一部分，当浏览器向web服务器发送请求时，一般会带上referer信息告诉服务器是从哪个页面来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。</p>\n</li>\n<li><p>anti CSRF token</p>\n<p> 目前比较完善的方案是加入anti-csrf token。即发送请求时在http请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>\n<p> <strong>这种方法相比Referer检查要安全很多</strong>，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。</p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">SQL注入</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">MDN-CORS</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/CSRF\">MDN-CSRF</a></p>\n"},{"title":"JavaScript复习-异步","tags":["JavaScript","Promise","Generator","Promise"],"categories":"2021复习","description":"JavaScript为异步非阻塞，ES6之前主要靠回调函数来实现异步，但由于回调函数容易出现回调地狱等问题，于是ES6+提供了了`Generator`、`Promise`、`async/await`这些API来降低异步编程的难度与复杂度。\n\n## 回调函数\n\n回调函数容易出现回调地狱，可读性差\n\n``` js\nfunction ajax(url, options, onSuccess) {","createDate":"2021-05-12 10:36:56","updateDate":"2021-06-24 18:47:28","body":"<p>JavaScript为异步非阻塞，ES6之前主要靠回调函数来实现异步，但由于回调函数容易出现回调地狱等问题，于是ES6+提供了了<code>Generator</code>、<code>Promise</code>、<code>async/await</code>这些API来降低异步编程的难度与复杂度。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">回调函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>回调函数容易出现回调地狱，可读性差</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ajax</span>(<span class=\"hljs-params\">url, options, onSuccess</span>) {\n    <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-title function_\">ajax</span>(<span class=\"hljs-string\">&#x27;/api/xxx&#x27;</span>, {}, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">ajax</span>(<span class=\"hljs-string\">&#x27;/api/yyy&#x27;</span>, {}, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">ajax</span>(<span class=\"hljs-string\">&#x27;/api/zzz&#x27;</span>, (), <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n        })\n    })\n})\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Generator</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>形式上，<code>generator</code>函数是一个状态机，封装了多个内部状态。执行<code>generator</code>函数会返回一个<strong>遍历器对象</strong></p>\n<p>语法上，<code>generator</code>函数是一个普通函数。<code>function</code>关键字与函数名之间有一个<code>*</code>；函数体内使用<code>yield</code>表达式定义不同的内部状态</p>\n<p>与普通函数不同，<code>generator</code>函数被调用后<strong>并不执行</strong>，返回的是一个指向内部状态的指针对象，也就是<strong>遍历器对象</strong>。下一步，<strong>必须调用遍历器对象的<code>next</code>方法</strong>使得指针移向下一个状态，也就是说每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>或<code>return</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> str1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;hello&quot;</span>\n  <span class=\"hljs-comment\">// str1 = 222</span>\n  <span class=\"hljs-keyword\">const</span> str2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;world&quot;</span>\n  <span class=\"hljs-comment\">// str2 = 333</span>\n  <span class=\"hljs-keyword\">return</span> str2\n}\n\n<span class=\"hljs-keyword\">const</span> iter = <span class=\"hljs-title function_\">gen</span>()\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>())\n<span class=\"hljs-comment\">// { value: &quot;hello&quot;, done: false }</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">222</span>))\n<span class=\"hljs-comment\">// { value: &quot;world&quot;, done: false }</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">333</span>))\n<span class=\"hljs-comment\">// { value: 333, done: false }</span>\n</code></pre>\n<p>第一次调用，<code>generator</code>函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>值就是当前<code>yield</code>表达式的值，<code>done</code>的值为<code>false</code></p>\n<p>第二次调用，<code>generator</code>从上次<code>yield</code>表达式停下来的地方一直执行到下一个<code>yield</code>表达式 👆 ……</p>\n<p>第三次调用，<code>generator</code>函数从上次<code>yield</code>表达式停下来的地方一直执行到<code>return</code>语句，<code>next</code>返回的<code>value</code>值就是<code>return</code>后面表达式的值，<code>done</code>为<code>true</code></p>\n<p><code>yield</code>表达式本身没有返回值（或者说总是返回<code>undefined</code>）。<code>next</code>方法可以带一个参数，该参数会被当作<strong>上一个</strong><code>yield</code>表达式的返回值</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>ES6提供的一种异步编程方案</p>\n<p>一个<code>Promise</code>对象必然处于以下三种状态：</p>\n<ul>\n<li>pending，初始状态</li>\n<li>fulfilled，成功</li>\n<li>rejected，失败</li>\n</ul>\n<p><code>pending</code>状态的<code>Promise</code>对象可以转换为<code>fulfilled</code>或<code>rejected</code>状态，而且此过程是不可逆的。当状态变更时，<code>then()</code>方法注册的回调就会被调用</p>\n<p><code>then()</code> 或者 <code>catch()</code> 的参数期望是函数，传⼊⾮函数则会发⽣值透传<code>(value =&gt; value)</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>)\n .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// .then(1 =&gt; 1)</span>\n .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\">// .then(1 =&gt; 1)</span>\n .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>)\n<span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\">url, options = {}</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>();\n    xhr.<span class=\"hljs-title function_\">open</span>(options.<span class=\"hljs-property\">method</span> || <span class=\"hljs-string\">&#x27;GET&#x27;</span>, url);\n    <span class=\"hljs-keyword\">const</span> headers = { <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>, ...options.<span class=\"hljs-property\">headers</span> || {} };\n    <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(headers)\n      .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">header</span>) =&gt;</span> xhr.<span class=\"hljs-title function_\">setRequestHeader</span>(header, headers[header]));\n    xhr.<span class=\"hljs-title function_\">send</span>(options.<span class=\"hljs-property\">method</span> === <span class=\"hljs-string\">&#x27;POST&#x27;</span> ? <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(options.<span class=\"hljs-property\">data</span> || {}) : <span class=\"hljs-literal\">null</span>);\n    xhr.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> <span class=\"hljs-title function_\">reject</span>(e);\n    xhr.<span class=\"hljs-property\">onreadystatechange</span> = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">readyState</span> === <span class=\"hljs-title class_\">XMLHttpRequest</span>.<span class=\"hljs-property\">DONE</span>\n        &amp;&amp; [<span class=\"hljs-number\">200</span>, <span class=\"hljs-number\">201</span>, <span class=\"hljs-number\">301</span>, <span class=\"hljs-number\">302</span>, <span class=\"hljs-number\">304</span>].<span class=\"hljs-title function_\">includes</span>(xhr.<span class=\"hljs-property\">status</span>)) {\n        <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(xhr.<span class=\"hljs-property\">responseText</span>));\n      }\n    };\n  });\n}\n<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;http://localhost:3004/get&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);\n}).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e);\n})\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>)=&gt;</span>{\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;1&quot;</span>)\n    <span class=\"hljs-title function_\">resolve</span>();\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">()=&gt;</span>{\n    <span class=\"hljs-comment\">// 外部第1个then</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;2&quot;</span>)\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>)=&gt;</span>{\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;3&quot;</span>)\n        <span class=\"hljs-title function_\">resolve</span>();\n    }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">()=&gt;</span>{\n        <span class=\"hljs-comment\">// 内部第1个then</span>\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;4&quot;</span>)\n    }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-comment\">// 内部第2个then</span>\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;5&quot;</span>)\n    })\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>)=&gt;</span>{\n    <span class=\"hljs-comment\">// 外部第2个then</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;6&quot;</span>)\n})\n</code></pre>\n<p>简单来讲就是then回调的注册需要上一个then里面的同步代码执行完毕</p>\n<p>拿上面的代码来讲，当外部第1个then里的resovle()执行完毕后，该Promise的状态已经更改，会将内部第1个then回调添加（注册）到微任务队列中；内部第2个then由于上一个then回调没有执行完毕，因此不会注册。此时外部第1个then里的同步代码执行完毕，会注册外部第2个then回调</p>\n<p>整理一下：then回调注册的顺序是：外部第1个then --&gt; 内部第1个then --&gt; 外部第2个then --&gt; 内部第2个then</p>\n<p>ps: 如果将外部第1个then里的new Promise(xxx)改为return new Promise(xxx)的话内部第2个then的注册将早于* 外部第2个then*</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">async/await</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>目前来讲，最为优秀的一种异步编程方案，与ES2017提出</p>\n<p>实现上是<code>Generator</code>+<code>Promise</code>的语法糖</p>\n<p>通过在<code>onFulFilled()</code>里调用<code>next()</code>、在<code>next()</code>里调用<code>onFulfilled()</code>形成一个自执行器，只有当全部代码执行完毕后才会终止</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;http://localhost:3004/get&#x27;</span>);\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res);\n    } <span class=\"hljs-keyword\">catch</span> (e) {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(e);\n    }\n}\n</code></pre>\n<p><code>async/await</code>原理: <strong>自动执行generator函数</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getData</span> = (<span class=\"hljs-params\"></span>) =&gt;\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;data&quot;</span>), <span class=\"hljs-number\">1000</span>));\n\n<span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">testG</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// await被编译成了yield</span>\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">getData</span>();\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;data: &quot;</span>, data);\n  <span class=\"hljs-keyword\">const</span> data2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">getData</span>();\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;data2: &quot;</span>, data2);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;success&quot;</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">asyncToGenerator</span>(<span class=\"hljs-params\">generatorFunc</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-keyword\">const</span> gen = generatorFunc.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">step</span>(<span class=\"hljs-params\">key, arg</span>) {\n        <span class=\"hljs-keyword\">let</span> generatorResult;\n        <span class=\"hljs-keyword\">try</span> {\n          generatorResult = gen[key](arg);\n        } <span class=\"hljs-keyword\">catch</span> (error) {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">reject</span>(error);\n        }\n\n        <span class=\"hljs-keyword\">const</span> { value, done } = generatorResult;\n\n        <span class=\"hljs-keyword\">if</span> (done) {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">resolve</span>(value);\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(value).<span class=\"hljs-title function_\">then</span>(\n            <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onResolve</span>(<span class=\"hljs-params\">val</span>) {\n              <span class=\"hljs-title function_\">step</span>(<span class=\"hljs-string\">&quot;next&quot;</span>, val);\n            },\n            <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onReject</span>(<span class=\"hljs-params\">err</span>) {\n              <span class=\"hljs-title function_\">step</span>(<span class=\"hljs-string\">&quot;throw&quot;</span>, err);\n            }\n          );\n        }\n      }\n      <span class=\"hljs-title function_\">step</span>(<span class=\"hljs-string\">&quot;next&quot;</span>);\n    });\n  };\n}\n\n<span class=\"hljs-keyword\">const</span> testGAsync = <span class=\"hljs-title function_\">asyncToGenerator</span>(testG);\n<span class=\"hljs-title function_\">testGAsync</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">result</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result);\n});\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN-Promise</a></p>\n<p><a href=\"https://github.com/imtaotao/co-share\">co-share</a></p>\n"},{"title":"JavaScript复习-0","tags":["JavaScript"],"categories":"2021复习","description":"## JavaScript数据类型\n\n原始Primitive类型：\n\n`Number`、`String`、`Boolean`、`Undefined`、`Null`、`Symbol`、`Bigint`\n\n引用类型\n\n`Object`、`Array`、`Date`、`Function` \n\n## Symbol和Bigint\n\n`Symbol`表示唯一、不可变的值。用于确保对象属性使用唯一标识符，不","createDate":"2021-05-07 14:34:34","updateDate":"2021-06-21 23:49:44","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript数据类型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>原始Primitive类型：</p>\n<p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Undefined</code>、<code>Null</code>、<code>Symbol</code>、<code>Bigint</code></p>\n<p>引用类型</p>\n<p><code>Object</code>、<code>Array</code>、<code>Date</code>、<code>Function</code> </p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Symbol和Bigint</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>Symbol</code>表示唯一、不可变的值。用于确保对象属性使用唯一标识符，不会发生属性名冲突的危险</p>\n<p><code>BigInt</code>是一种数字类型的数据，它可以表示任意精度格式的整数，使用<code>BigInt</code>可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">var vs let/const</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>作用域问题</li>\n<li>重复声明/赋值问题</li>\n<li>变量提升</li>\n<li>暂时性死区</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数据属性/访问器属性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对象的属性有两种类型，<strong>数据属性</strong>和<strong>访问器属性</strong></p>\n<ul>\n<li>创建对象时默认就存在的属性为数据属性</li>\n<li>通过<code>Object.defineProperty</code>设置的属性描述符中含有<code>set/get</code>的属性为访问器属性</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">内部属性[[Class]]</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"\">Object.prototype.toString传送门</a></p>\n<p><del>所有对象(<code>typeof</code>返回为<code>object</code>)都包含有一个内部属性<code>[[Class]]</code>，该属性不能直接访问，\n可使用<code>Object.prototype.toString</code>来查看</del></p>\n<p><strong>ES6移除了这个属性</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>([])  \n<span class=\"hljs-comment\">//&quot;[object Array]&quot;</span>\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-function\">() =&gt;</span> {})\n<span class=\"hljs-comment\">// &quot;[object Function]&quot;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Object.prototype.toString</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>拿到变量准确的类型</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>([])  \n<span class=\"hljs-comment\">//&quot;[object Array]&quot;</span>\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-function\">() =&gt;</span> {})\n<span class=\"hljs-comment\">// &quot;[object Function]&quot;</span>\n\n<span class=\"hljs-comment\">/*\n基本类型值string、number、boolean都可以打印这是因为JavaScript为基本类型值包装\n了一个封装对象使它们变成了对象，而String()、Number()、Boolean()上有属性[[Class]]\n*/</span>\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// &quot;[object Number]&quot;</span>\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;a&quot;</span>)\n<span class=\"hljs-comment\">// &quot;[object String]&quot;</span>\n</code></pre>\n<p>可通过重写变量的toString方法修改输出</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> a = {\n    get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;A&#x27;</span>;\n    }\n}\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;a&quot;</span>)\n<span class=\"hljs-comment\">// &quot;[object A]&quot;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">上下文、作用域链、闭包</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>上下文：每个上下文都有一个关联的<strong>变量对象(variable object)<strong>，存储这个上下文中定义的所有变量和函数。函数局部上下文中的叫做</strong>活动对象(activity object)</strong>(活动对象最初只有一个定义变量<code>arguments</code>，全局上下文中没有这个变量)。上下文会在其所有代码都执行完毕后被销毁（全局上下文会在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）</p>\n<p>作用域链：执行上下文的集合。上下文中的代码在执行时会创建变量对象的一个<strong>作用域链</strong>，代码正在执行的上下文的变量对象始终位于作用域链的最前端。全局上下文的变量对象始终位于作用域链尾部</p>\n<p>闭包（JS高程4）：指那些引用了另一个函数作用域中变量的<strong>函数</strong>。在一个函数内定义的函数会把其包含函数的活动(变量)对象添加到自己的作用域链中，外部函数的活动(变量)对象是内部函数作用域链上的第二个对象。闭包的本质是内部函数加长了其作用域链</p>\n<p>闭包（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\">MDN</a>）：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createComparisonFunction</span>(<span class=\"hljs-params\">propertyName</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">object1, object2</span>) {\n        <span class=\"hljs-keyword\">let</span> value1 = object1[propertyName];\n        <span class=\"hljs-keyword\">let</span> values = object2[propertyName];\n        \n        <span class=\"hljs-keyword\">if</span> (value1 &lt; value2) {\n            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (value1 &gt; value2) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> compare = <span class=\"hljs-title function_\">createComparisonFunction</span>(<span class=\"hljs-string\">&quot;name&quot;</span>);\n<span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title function_\">compare</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Nicholas&quot;</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;&quot;</span><span class=\"hljs-title class_\">Matt</span> });\n</code></pre>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/closure.png\" alt=\"closure\"></p>\n<p>作用域和上下文的区别：</p>\n<p>作用域是静态的，只要函数定义好了就一直存在并且不再发生变化。执行上下文是动态的，调用函数时创建，调用结束后会释放</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">this</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/this.png\" alt=\"this\"></p>\n<ul>\n<li>先判断函数类型(箭头函数？bind生成？普通函数？)</li>\n<li>普通函数判断调用方式(new？foo()？obj.foo()？)</li>\n<li>不管 <code>bind</code> 几次，<code>fn</code>中的<code>this</code>始终由第一次<code>bind</code>决定</li>\n<li>箭头函数中的<code>this</code>一旦被绑定就不会再改变</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>?.<span class=\"hljs-property\">a</span>);\n}\n\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">12</span>;\n\n<span class=\"hljs-keyword\">const</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">13</span>,\n  fn\n};\n\n<span class=\"hljs-keyword\">const</span> obj2 = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">14</span>,\n  <span class=\"hljs-attr\">fn</span>: obj.<span class=\"hljs-property\">fn</span>,\n  <span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-title function_\">fn</span>();\n  },\n};\n\n<span class=\"hljs-title function_\">fn</span>(); <span class=\"hljs-comment\">// undefined</span>\nobj.<span class=\"hljs-title function_\">fn</span>(); <span class=\"hljs-comment\">// 13</span>\nobj2.<span class=\"hljs-title function_\">fn</span>(); <span class=\"hljs-comment\">// 14</span>\nobj2.<span class=\"hljs-title function_\">fn2</span>(); <span class=\"hljs-comment\">// undefined</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">==时的类型转换</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%3D%3D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png\" alt=\"==时的类型转换\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对象转原始类型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对象转原始类型会调用内置的[[ToPrimitive]]函数：</p>\n<ol>\n<li>如果存在<code>Symbol.toPrimitive()</code>方法，调用后返回</li>\n<li>调用<code>valueOf()</code>，如果转换为原始类型则返回（使用<code>obj.valueOf = xxx</code>来定义）</li>\n<li>调用<code>toString()</code>，如果转换为原始类型则返回</li>\n<li>如果都没有返回原始类型则报错</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">原型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>每个构造函数都有(<code>prototype</code>)一个原型对象，原型有一个属性(<code>constructor</code>)指回构造函数，而实例有一个内部指针(<code>__proto__</code>)指向原型</p>\n<p>如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地如果另一个原型也有一个指针指向另一个构造函数。这样就在原型和实例之间构造了一条原型链。</p>\n<p><code>__proto_</code>_指向<strong>构造函数</strong>的原型，存在于<strong>对象</strong>中，指向<strong>原型</strong></p>\n<p><code>prototype</code>存在于<strong>函数</strong>中，指向<strong>原型</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">User</span>(<span class=\"hljs-params\"></span>) {}\n\n<span class=\"hljs-keyword\">const</span> tom = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>();\n\ntom.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">User</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-title class_\">User</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">User</span> <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/prototype.png\" alt=\"原型\"></p>\n<p><a href=\"\">new的原理及手动实现</a>\n<a href=\"\">继承</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">new</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>过程：</p>\n<ol>\n<li>在内存中创建一个新的空对象</li>\n<li>这个新对象内部的<code>__proto__</code>指针被赋值为构造函数的<code>prototype</code>值</li>\n<li>构造函数内部的<code>this</code>被赋值为这个新对象（即<code>this</code>指向新对象）</li>\n<li>执行构造函数内部的代码（给新对象添加属性）</li>\n<li>如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>()\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Con</span> = [].<span class=\"hljs-property\">shift</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>)\n    obj.<span class=\"hljs-property\">__proto__</span> = <span class=\"hljs-title class_\">Con</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>\n    <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title class_\">Con</span>.<span class=\"hljs-title function_\">apply</span>(obj, <span class=\"hljs-variable language_\">arguments</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">&#x27;object&#x27;</span> ? result : obj\n}\n</code></pre>\n"},{"title":"JavaScript复习-模块化","tags":["JavaScript","模块化"],"categories":"2021复习","description":"## 模块化解决的问题\n\n- 外部模块的管理\n- 内部模块的组织\n- 模块源码到目标代码的编译和转换\n\n## 时间线\n\n|  生态  |  诞生时间  |\n| -- | -- |\n|Node.js|2009|\n|NPM|2010|\n|requireJS(AMD)|2010|\n|seaJS(cmd)|2011|\n|browserify|2011|\n|webpack|2012|\n|grunt|20","createDate":"2021-05-12 04:30:39","updateDate":"2021-06-21 23:26:16","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模块化解决的问题</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>外部模块的管理</li>\n<li>内部模块的组织</li>\n<li>模块源码到目标代码的编译和转换</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">时间线</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <table>\n<thead>\n<tr>\n<th>生态</th>\n<th>诞生时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.js</td>\n<td>2009</td>\n</tr>\n<tr>\n<td>NPM</td>\n<td>2010</td>\n</tr>\n<tr>\n<td>requireJS(AMD)</td>\n<td>2010</td>\n</tr>\n<tr>\n<td>seaJS(cmd)</td>\n<td>2011</td>\n</tr>\n<tr>\n<td>browserify</td>\n<td>2011</td>\n</tr>\n<tr>\n<td>webpack</td>\n<td>2012</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>2012</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>2013</td>\n</tr>\n<tr>\n<td>react</td>\n<td>2013</td>\n</tr>\n<tr>\n<td>vue</td>\n<td>2014</td>\n</tr>\n<tr>\n<td>angular</td>\n<td>2016</td>\n</tr>\n<tr>\n<td>vite</td>\n<td>2020</td>\n</tr>\n<tr>\n<td>snowpack</td>\n<td>2020</td>\n</tr>\n</tbody></table>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">外部模块的管理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">script标签</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>如果我们要在项目里使用某个外部模块，最简单的方法就是去官网把相关的js文件下载下来放在项目目录，在要使用的html页面里通过script标签引用。这样简单粗暴的方法缺点明显：</p>\n<ul>\n<li>使用上缺乏便利性</li>\n<li>难以跟踪各个外部模块的来源</li>\n<li>没有统一的版本管理机制</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">npm</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>2010年，npm伴随着Node.js的新版本一起发布。此后，外部模块管理从原始社会进入现代社会。</p>\n<ul>\n<li>npm是一个远程的JavaScript代码仓库，所有的开发者都可以向这里提交可共享的模块，供其他开发者下载使用</li>\n<li>npm还包含一个命令行工具，开发者通过运行<code>npm publish</code>将自己写的模块发布到npm仓库，通过运行<code>npm install xxx</code>可以将别人的模块下载到自己项目根目录下一个叫<code>node_modules</code>的文件夹里</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">内部模块的组织</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">script标签</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>同引入外部模块一样，通过IIFE去组织内部模块并通过<code>script</code>标签引用</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-keyword\">var</span> moduleA = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// ...</span>\n})(<span class=\"hljs-variable language_\">window</span>);\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-keyword\">var</span> moduleB = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// ...</span>\n})(<span class=\"hljs-variable language_\">window</span>);\n</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>&quot;/<span class=\"hljs-attr\">path</span>/<span class=\"hljs-attr\">to</span>/<span class=\"hljs-attr\">a.js</span>&quot;&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>&quot;/<span class=\"hljs-attr\">path</span>/<span class=\"hljs-attr\">to</span>/<span class=\"hljs-attr\">b.js</span>&quot;&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这种简单粗暴的方式缺点比较明显：</p>\n<ul>\n<li>随着项目扩大，html文件中会包含大量<code>script</code>标签</li>\n<li>模块间的复杂依赖关系仅靠<code>script</code>标签引用顺序来组织</li>\n<li>污染全局环境，可能存在命名冲突</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AMD&amp;CMD&amp;CommonJS&amp;ESM</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>AMD/CMD只是一种设计规范，而不是实现。AMD的主要实现有两个(RequireJS和curl.js)，CMD的主要实现有(sea.js)</p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AMD(Asynchronous Module Define)主要包含两个API：<strong>define</strong>和<strong>require</strong></span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>define方法用于定义一个模块，接收两个参数：</p>\n<ul>\n<li>第一个参数是数组表示这个模块所依赖的其他模块</li>\n<li>第二个参数是一个回调函数，通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，返回值将作为其他依赖模块的引用</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&#x27;Module1&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"><span class=\"hljs-variable language_\">module</span></span>) {\n    <span class=\"hljs-keyword\">return</span> {\n    }\n}); \n\n<span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;math&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">math</span>) {\n　 math.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-number\">15</span>)\n});\n</code></pre>\n<p><code>define</code>能自定义模块而<code>require</code>只能引用其他模块，<code>require</code>的真正作用是执行模块加载</p>\n<p>AMD规范去除了纯粹用script便签顺组组织模块带来的问题</p>\n<ol>\n<li>通过依赖数组的方式声明依赖关系，具体依赖关系交给具体的AMD框架处理</li>\n<li>避免生命全局变量带来的环境污染和变量冲突问题</li>\n<li>模块异步加载，防止JS加载阻塞页面渲染</li>\n</ol>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CMD(Common Module Definition)</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>有一个<code>define</code>API,接收一个<code>factory</code>回调函数，有三个参数：</p>\n<ul>\n<li>require：一个方法标识符，调用它可以动态的获取一个依赖模块的输出</li>\n<li>exports：一个对象，用于对其他模块提供输出接口，例如<code>exports.name = xxx</code></li>\n<li>module：一个对象，存储了当前模块相关的一些属性和方法，其中<code>module.exports</code>等同于<code>exports</code></li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">require</span>, <span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-variable language_\">module</span></span>) {\n    <span class=\"hljs-keyword\">var</span> moduleA = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;/path/to/ModuleA&#x27;</span>);\n    <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {}\n})\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CMD&amp;AMD的区别</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>一方面，在依赖的处理上</p>\n<ul>\n<li>AMD依赖前置，即通过依赖数组的方式提前声明当前模块的依赖</li>\n<li>CMD依赖就近，在需要用到的时候通过调用<code>require</code>方法动态导入</li>\n</ul>\n<p>另一方面，在本模块的输出上</p>\n<ul>\n<li>AMD通过返回值的方式对外输出</li>\n<li>CMD通过给<code>module.exports</code>赋值的方式对外输出</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CommonJS&amp;ESM</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><code>CommonJS</code>是Node.js使用的模块化方式</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> ramda = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ramda&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {}\n</code></pre>\n<p><code>ESM</code>是<code>ES6</code>提出的模块化方案</p>\n<pre><code class=\"hljs language-js\">impot { clone } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;ramda&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>CommonJS</th>\n<th>ESM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>加载时间</td>\n<td>运行时加载</td>\n<td>编译时输出接口</td>\n</tr>\n<tr>\n<td>输出方式</td>\n<td>值的拷贝</td>\n<td>值的引用</td>\n</tr>\n</tbody></table>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">输出方式比对</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// CommonJS</span>\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">increaseA</span>(<span class=\"hljs-params\"></span>) {\n    a += <span class=\"hljs-number\">1</span>;\n}\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = { a, increaseA };\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-title function_\">increaseA</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 1</span>\n\n<span class=\"hljs-comment\">// ESM</span>\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">increaseB</span>(<span class=\"hljs-params\"></span>) {\n    b += <span class=\"hljs-number\">1</span>;\n}\n<span class=\"hljs-keyword\">export</span> { b, increaseB };\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-title function_\">increaseB</span>();\nconosle.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">webpack/browserify</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>AMD/CMD可以看作在线编译模块的方法，也就是等浏览器下载了这些js文件后才进行模块依赖分析，确定加载顺序和执行顺序，带来了一些问题</p>\n<ul>\n<li>增加代码加载时间，影响用户体验</li>\n<li>http请求过多，降低页面性能</li>\n</ul>\n<p>于是有以下对应方法去解决：</p>\n<ul>\n<li>提前将模块组织好</li>\n<li>进行代码合并，把多个<code>script</code>的代码合并到少数几个文件中减少http请求个数</li>\n</ul>\n<p>具有代表性的是<code>webpack</code>和<code>browserify</code></p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack.png\" alt=\"webpack\"></p>\n<p>打包工具面临的问题&amp;&amp;解决方案</p>\n<p><strong>打包后的文件体积过大</strong></p>\n<p>代码打包的初衷是减少AMD/CMD等框架造成的加载脚本数量过多的问题，但也带来了打包后单个文件体积过大的问题：如此一来，首屏加载时间缓慢，体验较差</p>\n<p>于是webpack引入了代码拆分的功能(Code Splitting)来解决这个问题, 从全部打包后退一步：可以打包成多个包</p>\n<ul>\n<li>第三方库和业务代码的分离：业务代码更新频率快，而第三方库代码更新频率是比较慢的。分离之后可利用浏览器缓存机制加载第三方库，从而加快页面访问速度</li>\n<li>按需加载: 例如我们经常通过前端路由分割不同页面，除了首页外的很多页面(路由)可能访问频率较低，我们可将其从首次加载的资源中去掉，而等到相应的触发时刻再去加载它们。这样就减少了首屏资源的体积，提高了页面加载速度。</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">bundleless(snowpack/vite)</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>利用现代浏览器对ES6普遍支持良好的现状，开发环境下不进行打包。借助浏览器 ESM 的能力，一些代码基本可以做到无需构建直接运行。代表性工具是vite和snowpack</p>\n<p>为什么要打包？</p>\n<p>对于早期的 web 应用而言，打包模块既能够处理 JS 模块化，又能将多个模块打包合并网络请求。使用这类构建工具打包项目的确是个不错的选择。时至今日基本上主流的浏览器版本都支持 ESM，并且并发网络请求带来的性能问题，在 HTTP/2 普及下不像以前那么凸显的情况下，大家又将目光转向了 ESM。就目前的体验而言，基于原生 ESM 在开发过程中的构建速度似乎远远优于 webpack 之类的打包工具的。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://zhuanlan.zhihu.com/p/265632724\">前端模块化的十年征程</a></p>\n<p><a href=\"https://juejin.cn/post/6947890290896142350\">ESM vs Webpack 面向高性能构建的探索</a></p>\n"},{"title":"JavaScript复习-1","tags":["JavaScript"],"categories":"2021复习","description":"## Proxy和Reflect\n\n可以给目标对象定义一个关联的对象，而这个代理对象可以作为抽象的目标对象来使用。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。使用`new Proxy(target, handler)`来创建\n\n`handler`对象中所有可以捕获的方法都有对应的反射`Reflect` API方法，这些方法与捕获器拦截的方法具有相同的名称，也具有与被拦截方","createDate":"2021-05-11 14:27:01","updateDate":"2021-06-15 23:15:37","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Proxy和Reflect</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>可以给目标对象定义一个关联的对象，而这个代理对象可以作为抽象的目标对象来使用。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。使用<code>new Proxy(target, handler)</code>来创建</p>\n<p><code>handler</code>对象中所有可以捕获的方法都有对应的反射<code>Reflect</code> API方法，这些方法与捕获器拦截的方法具有相同的名称，也具有与被拦截方法相同的行为</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> target = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(target, {\n    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-property\">get</span>,\n})\n</code></pre>\n<p><code>Proxy.prototype</code>为<code>undefined</code>，因此不能使用<code>instanceof</code>操作符，会抛出<code>TypeError</code></p>\n<p><code>Proxy.revocable</code>方法会返回一个<code>revoke</code>方法，用来撤销代理。撤销代理的操作是不可逆、幂等的，撤销后再次访问代理会抛出<code>TypeError</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> revocableProxy = <span class=\"hljs-title class_\">Proxy</span>.<span class=\"hljs-title function_\">revocable</span>({\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span>\n}, {\n  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-property\">get</span>,\n  <span class=\"hljs-attr\">set</span>: <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-property\">set</span>,\n});\n\nrevocableProxy.<span class=\"hljs-property\">proxy</span>.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// tom</span>\nrevocableProxy.<span class=\"hljs-title function_\">revoke</span>();\nrevocableProxy.<span class=\"hljs-property\">proxy</span>.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">//TypeError</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">instanceof原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>原型链</strong>。通过检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上，运算符左侧是实例对象，右侧是构造函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myInstanceof</span>(<span class=\"hljs-params\">instance, object</span>) {\n  <span class=\"hljs-keyword\">const</span> proto = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(instance);\n  <span class=\"hljs-keyword\">if</span> (proto === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">if</span> (object.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> === proto) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">myInstanceof</span>(proto, object);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">防抖、节流</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一种性能优化手段，避免函数过多执行（多用来优化滑动/点击事件回调）</p>\n<p>防抖:：在规定的时间内若再次触发则重新及时</p>\n<p>节流：在规定的时间内若再次触发(触发间隔大于规定的时间)只会执行一次</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">cb, timeout</span>) {\n  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">let</span> canceled = <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_denounce</span>(<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-keyword\">let</span> res;\n    <span class=\"hljs-built_in\">clearTimeout</span>(timer);\n    <span class=\"hljs-keyword\">if</span> (canceled) {\n      res = cb.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n    } <span class=\"hljs-keyword\">else</span> {\n      timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        res = cb.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n      }, timeout);\n    }\n\n    <span class=\"hljs-keyword\">return</span> res;\n  }\n\n  _denounce.<span class=\"hljs-property\">cancel</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    canceled = <span class=\"hljs-literal\">true</span>;\n  };\n\n  <span class=\"hljs-keyword\">return</span> _denounce;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">cb, timeout</span>) {\n  <span class=\"hljs-keyword\">let</span> lastTime = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> canceled = <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_throttle</span>(<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-keyword\">const</span> now = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();\n    <span class=\"hljs-keyword\">let</span> res;\n    <span class=\"hljs-keyword\">if</span> (canceled) {\n      res = cb.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (lastTime + timeout &lt; now) {\n      lastTime = now;\n      res = cb.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n    }\n\n    <span class=\"hljs-keyword\">return</span> res;\n  }\n\n  _throttle.<span class=\"hljs-property\">cancel</span> = <span class=\"hljs-function\">() =&gt;</span> {\n    canceled = <span class=\"hljs-literal\">true</span>;\n  };\n\n  <span class=\"hljs-keyword\">return</span> _throttle;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">函数的name属性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>es6所有的函数都会暴露出一个<code>name</code>属性，其中包含关于函数的信息。多数形况下这个属性是一个字符串化的变量名，等于该函数的名字。</p>\n<p>如果使用<code>Function</code>构造函数创建的，则会标识成<code>anonymous</code></p>\n<p>如果函数是一个<code>get</code>、<code>set</code>或使用<code>bind()</code>实例化，那么标识符前会加一个前缀</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">箭头函数的特性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>不能使用<code>arguments</code>、<code>super</code>、<code>new.target</code></li>\n<li>不能用作构造函数</li>\n<li>没有<code>prototype</code>属性</li>\n<li>没有<code>this</code></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">函数重载</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>JavaScript中没有函数重载。因为ECMAScript函数<strong>没有签名</strong>，函数的参数在内部表现为一个包含零个或多个值的数组。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">new.target</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>ES6新增了检测函数是否使用<code>new</code>关键字调用的<code>new.target</code>属性。如果函数是正常调用的<code>new.target</code>的值是<code>undefined</code>；如果是使用<code>new</code>关键字调用的，则<code>new.target</code>将引用被调用的构造函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">User</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(errorMessage);\n  }\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(successMessage);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">arguments.callee</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><del><code>arguments</code>对象有一个<code>callee</code>属性，是一个指向<code>arguments</code>对象所在函数的指针。使用<code>arguments.callee</code>可以让函数逻辑与函数名解耦：</del></p>\n<p>不推荐使用<code>arguments</code>（VSCode+eslint使用时会报错），因为<strong>访问arguments是个很昂贵的操作，它是个很大的对象</strong>，每次递归调用时都需要重新创建，影响现代浏览器的性能，还会影响闭包。推荐创建临时函数+闭包实现</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">num</span>) {\n  <span class=\"hljs-keyword\">let</span> tmp = num;\n  <span class=\"hljs-keyword\">if</span> (tmp &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> res = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"></span>) {\n    res *= tmp;\n    tmp -= <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">if</span> (tmp !== <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>();\n    <span class=\"hljs-keyword\">return</span> res;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>();\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">尾调用优化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>ES6新增了一项内存管理机制，让JavaScript引擎在满足响应条件时可以重用栈帧。具体来说这项优化非常适合<em>尾调用</em>即<strong>外部函数的返回值是一个内部函数的返回值</strong></p>\n<p>尾调用优化的条件：</p>\n<ol>\n<li>代码在严格模式下运行</li>\n<li>外部函数的返回值是对尾调函数的引用</li>\n<li>尾调用函数返回后不需要执行额外的操作</li>\n<li>尾调用函数没有产生闭包(无法释放外部函数的栈帧)</li>\n</ol>\n<p>优化<code>factorial</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">factorialPerform</span>(<span class=\"hljs-params\">num</span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\">m, n</span>) {\n    <span class=\"hljs-keyword\">if</span> (n === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> m;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>(m * n, n - <span class=\"hljs-number\">1</span>);\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>(num, num - <span class=\"hljs-number\">1</span>);\n}\n</code></pre>\n<p>优化<code>fib</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-params\">num</span>) {\n  <span class=\"hljs-keyword\">if</span> (num &lt; <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">return</span> num;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fib</span>(num - <span class=\"hljs-number\">1</span>) + <span class=\"hljs-title function_\">fib</span>(num - <span class=\"hljs-number\">2</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fibPerform</span>(<span class=\"hljs-params\">num</span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fibImpl</span>(<span class=\"hljs-params\">m, n, x</span>) {\n    <span class=\"hljs-keyword\">if</span> (x === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> m;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fibImpl</span>(n, m + n, x - <span class=\"hljs-number\">1</span>);\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fibImpl</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, num);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JSON.stringify</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>JSON.stringify(value[, replacer [, space]])</code>，将一个JavaScript对象或值转换为JSON字符串，如果指定了<code>replacer</code>，则可以选择性地替换值，或将指定的<code>replacer</code>是数组，则可选择性地仅包含数组指定的属性</p>\n<p>注意：</p>\n<ul>\n<li>当在<code>value</code>存在循环引用时会抛出异常<code>TypError(&quot;cyclic object value&quot;)</code></li>\n<li>当尝试去转换<code>BigInt</code>类型的值会抛出<code>TypeError(&quot;BigInt value can&#39;t be serialized in JSON&quot;)</code></li>\n<li>如果<code>vaule</code>存在<code>toJSON()</code>方法，则返回该函数返回值</li>\n<li>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中</li>\n<li><code>Boolean</code>、<code>Number</code>、<code>String</code>包装对象会在序列化过程中自动转换为原始值</li>\n<li>非数组对象的属性值为<code>undefined</code>、任意的函数、<code>symbol</code>会在序列化中被忽略，数组对象则会转换成<code>null</code></li>\n<li><code>Map</code>、<code>Set</code>、<code>WeakMap</code>、<code>WeakSet</code>仅会序列化可枚举属性</li>\n<li>函数、<code>undefined</code>被单独转换时会返回<code>undefined</code></li>\n<li><code>Date</code>类型会转化为<code>Date.toISOString()</code>返回的值</li>\n</ul>\n<p><code>replacer</code>为函数时：</p>\n<ul>\n<li>如果返回一个<code>Number</code>，转换为相应地字符串作为属性值被添加到JSON字符串</li>\n<li>如果返回一个<code>String</code>，该字符串作为属性值被添加入JSON字符串</li>\n<li>如果返回一个<code>Boolean</code>，<code>true</code>或<code>false</code>作为属性值被添加到JSON字符串</li>\n<li>如果返回其他对象，该对象递归地序列化为JSON字符串，对每个属性调用<code>replacer</code>方法。如果该对象是一个函数，则忽略</li>\n<li>如果返回<code>undefined</code>则忽略</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">jsonp</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">jsonp</span>(<span class=\"hljs-params\">url</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> script = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&#x27;script&#x27;</span>);\n    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">jsonpCallback</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> {\n      <span class=\"hljs-title function_\">resolve</span>(data);\n      <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">removeChild</span>(script);\n    }\n    script.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${url}</span><span class=\"hljs-subst\">${url.includes(<span class=\"hljs-string\">&#x27;?&#x27;</span>) ? <span class=\"hljs-string\">&#x27;&amp;&#x27;</span> : <span class=\"hljs-string\">&#x27;?&#x27;</span>}</span>cb=jsonpCallback`</span>;\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(script);\n  })\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">取消网络请求</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>根据所使用的API的不同，有不同的解决方案：</p>\n<ul>\n<li><code>XMLHttpRequest</code>\n  使用<code>XMLHttpRequest.abort()</code><pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>();\nxhr.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&#x27;GET&#x27;</span>, <span class=\"hljs-string\">&#x27;url&#x27;</span>, <span class=\"hljs-literal\">true</span>);\nxhr.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-literal\">null</span>);\nxhr.<span class=\"hljs-title function_\">abort</span>();\n</code></pre>\n</li>\n<li><code>fetch</code>\n  使用<code>AbortController</code><pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();\n<span class=\"hljs-keyword\">const</span> signal = controller.<span class=\"hljs-property\">signal</span>;\n<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;url&#x27;</span>, { signal });\ncontroller.<span class=\"hljs-title function_\">abort</span>();\n</code></pre>\n</li>\n<li><code>axios</code>\n  使用<code>CancelToken</code><pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> source = axiox.<span class=\"hljs-property\">CancelToken</span>.<span class=\"hljs-title function_\">source</span>();\n<span class=\"hljs-keyword\">const</span> cancelToken = source.<span class=\"hljs-property\">token</span>;\n\naxios.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;url&#x27;</span>, { cancelToken });\nsource.<span class=\"hljs-title function_\">cancel</span>();\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">findIndex和indexOf</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>findIndex</code>根据所给函数进行匹配，<code>indexOf</code>使用<code>===</code>进行匹配</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> students = [{ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;jerry&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">32</span> }]\n\nstudents.<span class=\"hljs-title function_\">indexOf</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span> }) <span class=\"hljs-comment\">// -1</span>\nstudents.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.<span class=\"hljs-property\">name</span> === <span class=\"hljs-string\">&#x27;tom&#x27;</span> &amp;&amp; item.<span class=\"hljs-property\">age</span> === <span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// 0</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TDZ(暂时性死区)</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在JavaScript中，当控制流进入到它们出现的范围内，所有绑定都会被实例化。传统的<code>var</code>和<code>function</code>声明允许在实际声明之前访问那些绑定，并且值（<code>value</code>）为<code>undefined</code>。这种遗留行为被称为<strong>变量提升（hosting）</strong>。<code>let</code>和<code>const</code>声明也会被实例化，但<strong>运行到实际声明之前禁止访问</strong>。这称为<strong>暂时性死区(TDZ)</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WeakMap</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在JavaScript中，map API可以通过使用其四个API方法共用两个数组（一个存放key，一个存放value）来实现。给这种map设置value时会同时将key和value添加到这两个数组的尾部。从而使得key和value的索引在两个数组中相对应。当从该map取值的时候，需要遍历所有的key，然后再使用索引从存储value的数组中检索出相应的value</p>\n<p>但这样的实现会有两个很大的缺点，首先赋值和搜索操作都是O(n)的时间复杂度。另一个缺点是可能导致内存泄漏，因为数组会一直引用着每个key和value。这种引用使得垃圾回收算法不能回收处理它们，即使没有其他引用存在了</p>\n<p>相比之下，原生的WeakMap持有的是每个键对象的<strong>弱引用</strong>，这意味着没有其他引用存在时垃圾回收能正确进行。原生的WeakMap的结构是特殊且<strong>有效</strong>的，其用于映射的key只有在其没有被回收时才是有效的</p>\n<p>正由于这样的弱引用，WeakMap的key是<strong>不可枚举</strong>的（没有办法给出所有的key，key取决于垃圾回收器的状态，是不可预知的）。如果key是可枚举的，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\">mdn-JSON.stringify()</a></p>\n<p><a href=\"https://github.com/shfshanyue/Daily-Question/issues/502\">如何取消请求的发送</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\">mdn-WeakMap</a></p>\n"},{"title":"前端架构&软实力复习-有限状态机和状态管理","tags":["状态管理","有限状态机"],"categories":"2021复习","description":"## 有限状态机\n\n在计算机科学中对象行为建模的工具。其主要作用是描述对象在其生命周期内所经历的状态队列以及对外界事件的响应\n\n有限状态机有以下基本要素：\n\n- 当前状态。\n- 状态转移函数。\n- 拥有有限个可枚举的状态。","createDate":"2021-05-20 14:10:46","updateDate":"2021-06-15 12:46:35","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">有限状态机</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在计算机科学中对象行为建模的工具。其主要作用是描述对象在其生命周期内所经历的状态队列以及对外界事件的响应</p>\n<p>有限状态机有以下基本要素：</p>\n<ul>\n<li>当前状态。</li>\n<li>状态转移函数。</li>\n<li>拥有有限个可枚举的状态。</li>\n</ul>\n"},{"title":"算法复习-常用数据结构","tags":["算法"],"categories":"2021复习","description":"## 数组\n\n⼀组连续的储存结构，⽤来储存同⼀种类型的数据\n\n- 随机访问，O(1)\n- 对插入、删除不友好，O(n)\n\n``` js\nclass JSArray: public JSObject {}\n```\n\n`JSArray`是继承⾃`JSObject`的，所以在JavaScript中，数组可以是⼀个特殊的对象，内部也是以 `key-value`形式存储数据，所以JavaScript中的","createDate":"2021-06-08 13:35:13","updateDate":"2021-06-13 23:14:25","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数组</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>⼀组连续的储存结构，⽤来储存同⼀种类型的数据</p>\n<ul>\n<li>随机访问，O(1)</li>\n<li>对插入、删除不友好，O(n)</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JSArray</span>: public <span class=\"hljs-title class_\">JSObject</span> {}\n</code></pre>\n<p><code>JSArray</code>是继承⾃<code>JSObject</code>的，所以在JavaScript中，数组可以是⼀个特殊的对象，内部也是以 <code>key-value</code>形式存储数据，所以JavaScript中的数组可以存放不同类型的值。</p>\n<p>JSArray有两种存储方式：</p>\n<ul>\n<li>fast，基于<code>FixedArray</code>，<code>push</code>和<code>pop</code>时可能会伴随着动态扩容或减容</li>\n<li>slow，基于<code>HashTable</code>，以数组下标作为<code>key</code></li>\n</ul>\n<p><code>FixedArray</code>是V8实现的⼀个类似于数组的类，它表示⼀段连续的内存，可以使⽤索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的⻓度达到数组在内存中申请的内存容量最⼤值）的时候，继续<code>push</code>时，<code>JSArray</code>会进⾏动态的扩容，以存储更多的元素。当加⼊的索引值<code>index</code>⽐当前容量 <code>capacity</code>差值⼤于等于1024时（<code>index - capacity &gt;= 1024</code>）或快数组新容量是扩容后的容量3倍之多时，快数组会被转成慢数组</p>\n<p>慢数组以哈希表的形式存储在内存空间⾥，它不需要开辟连续的存储空间，但需要额外维护⼀个哈希表，与快数组相⽐，性能相对较差</p>\n<p><a href=\"https://blog.mrrs.top/blog/view/60bb53d1830576874275bbea\">常见算法题</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">栈</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>⼀种遵从后进先出<code>(LIFO / Last In First Out)</code>原则的有序集合</p>\n<p>JavaScript使用(调用)栈来管理函数<strong>执行上下⽂</strong>，它记录了当前函数执⾏的位置，哪个函数正在被执⾏。</p>\n<p>JavaScript基本类型保存在栈中</p>\n<p><a href=\"https://dashboard.blog.mrrs.top/articles/60bf86a67da910d68a85abdd\">常见算法题</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">链表</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>链表不需要连续的内存空间，它是由⼀组零散的内存块通过指针连接⽽成。JavaScript中可以通过数组来模拟栈</p>\n<p>链表有不同的结构，常见的有：</p>\n<ul>\n<li><p>单链表，节点有一个<code>next</code>属性，指向下一个节点。尾节点指向<code>null</code></p>\n</li>\n<li><p>双链表，节点有<code>next</code>和<code>pre</code>属性分别指向上一个和下一个节点</p>\n</li>\n<li><p>单循环链表，和单链表类似，不同的是单循环链表的尾节点指向的是头节点</p>\n</li>\n<li><p>查找：从头节点开始查找，时间复杂度为O(n)</p>\n</li>\n<li><p>插⼊或删除：在某⼀节点后插⼊或删除⼀个节点（后继节点）的时间复杂度为O(1)</p>\n</li>\n</ul>\n<p>常结合<strong>双指针</strong>来解决相关问题</p>\n<p><a href=\"https://blog.mrrs.top/blog/view/60bdaa0e8305760f4b75bbec\">常见算法题</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">队列</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>和栈类似，遵循先进先出 (FIFO) 原则的有序集合</p>\n<ul>\n<li>查找：从队头开始查找，从时间复杂度为O(n)</li>\n<li>插⼊或删除：进栈与出栈的时间复杂度为O(1)</li>\n</ul>\n<p>常用来实现<strong>滑动窗口</strong>来解决实际问题</p>\n<p><a href=\"https://blog.mrrs.top/blog/view/60bf851d7da910c98785abdc\">常见算法题</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">散列表</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>解决线性表在查找时的性能问题O(nlgn)~O(n)</p>\n<p>通过<strong>散列算法</strong>，将<strong>key</strong>转换为<strong>散列值</strong>，而后通过散列值去<strong>散列表</strong>中查找</p>\n<p>🌰：通过学号010121可以知道对应的同学在1年级1班21号</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/hash.png\" alt=\"散列算法、key、散列值、散列表的关系\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">树</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一种非线性结构</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">BST</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>二叉搜索树</p>\n<p>在⼆叉树的基础上，增加了对⼆叉树上节点存储位置的限制：</p>\n<ul>\n<li>左子节点值小于父节点的值</li>\n<li>右节点的值大于父节点的值</li>\n</ul>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/bst.png\" alt=\"BST\"></p>\n<p>在理想情况下，⼆叉树每多⼀层，可以存储的元素都增加⼀倍。也就是说 n 个元素的⼆叉搜索树，对应的树⾼为 O(logn)。所以我们查找元素、插⼊元素的时间也为 O(logn)。当然这是理想情况下，但在实际应⽤中，并不是那么理想，例如⼀直递增或递减的给⼀个⼆叉查找树插⼊数据，那么所有插⼊的元素就会⼀直出现在⼀个树的左节点上，数型结构就会退化为链表结构，时间复杂度就会趋于 O(n)，这是不好的。</p>\n<p>AVL树用来解决这个问题</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AVL</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>平衡搜索二叉树</p>\n<p>在二叉搜索树的基础上满⾜左右⼦树⾼度不⼤于1</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avl.png\" alt=\"AVL\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">红黑树</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>红黑树也是一种特殊的二叉搜索树</p>\n<p>在二叉搜索树的基础上添加以下限制：</p>\n<ul>\n<li>节点是红⾊或⿊⾊</li>\n<li>根节点必须是⿊⾊节点</li>\n<li>所有的叶⼦节点都必须是值为<code>NULL</code>的⿊节点</li>\n<li>如果⼀个节点是红⾊的，则它两个⼦节点都是⿊⾊的</li>\n<li>从任⼀节点到达它的每个叶⼦节点的所有的路径，都有相同数⽬的⿊⾊节点</li>\n</ul>\n"},{"title":"前端架构&软实力-301/302对SEO的影响","tags":["重定向","SEO"],"categories":"前端架构&软实力","description":"网站优化中，经常会面临网站链接修改或改变的事情，其中一个解决办法就是使用网站跳转的方式，处理变化的链接，下面讲述301和302跳转对SEO的影响。\n\n## 301（永久）\n\n请求的网页已被永久移动到新位置。服务器返回此响应(作为对GET或HEAD请求的响应)时，会自动将请求者转到新位置。使用此代码可通知搜索引擎，某个网页或网站已被永久移动到新位置。\n\n## 302（临时）\n\n服务器目前正从不同","createDate":"2021-05-06 02:55:44","updateDate":"2021-06-12 12:41:03","body":"<p>网站优化中，经常会面临网站链接修改或改变的事情，其中一个解决办法就是使用网站跳转的方式，处理变化的链接，下面讲述301和302跳转对SEO的影响。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">301（永久）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>请求的网页已被永久移动到新位置。服务器返回此响应(作为对GET或HEAD请求的响应)时，会自动将请求者转到新位置。使用此代码可通知搜索引擎，某个网页或网站已被永久移动到新位置。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">302（临时）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此如果某个页面或网站已被移动时，不要使用此代码来通知搜索引擎。</p>\n<p>在以下情况下适合使用302:</p>\n<ol>\n<li><p>网站发生故障时，给出新的临时地址让用户访问</p>\n</li>\n<li><p>测试网站的新功能或网站页面时</p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">怎么理解301/302跳转</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>跳转使用情况：假如原先有个页面的地址是<code>http://www.xxxx.com/A.html</code>（下面简称A页面），现在因业务需要设置成<code>http://www.xxxx.com/B.html</code>（下面简称B页面），虽然对于访问者来说没有任何区别，但是对于搜索引擎来说，由于A页面和B页面是不同的页面，所以我们需要告诉搜索引擎，B页面就是原来的A页面，这时就需要使用跳转的方式来处理，可以需要选择301或者302，他们的区别在于：</p>\n<ul>\n<li><p>使用301表示永久性跳转，如果A页面已经被搜索引擎收录了，那么搜索引擎会知道以后再也没有A页面这个页面了，它已经转移到B页面上去了，搜索引擎会把原来对于<strong>A页面的排名权重转移到B页面上去</strong>，平稳过渡，然后在搜索引擎的数据库中删除A页面，替换成B页面。</p>\n</li>\n<li><p>使用302表示暂时性跳转，302与301的区别在于，搜索引擎的数据库不会删除A页面，但仍会增加B页面。</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">不使用301、302的后果</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果网站管理员修改了页面链接，将A页面改成了B页面，但是没有在服务器上设置跳转属性（IIS、Apache、Websphere等等），那么虽然对于用户访问是没有影响，但是搜索引擎并不知道，会导致两个不好的结果：</p>\n<p>它仍然会试图去访问原来的A页面（有两种可能：1.搜索引擎数据库还没有更新，仍然保留着A页面，因此会去访问。2.外面有些网站的友情链接仍然是A页面，搜索引擎爬到之后就仍然去访问A页面），结果发现成了404状态，由于404表示网站出错，搜索引擎认为网站没有做好，因此就会给予网站惩罚，网站的排名就会下降。</p>\n<p>过了一段时间，搜索引擎发现了网站多了一个B页面，并进行了收录，但是由于没有设置跳转，因此它认为这是全新的页面，跟原来的A页面没有关系，原来A页面的排名就不会传导给B页面，B页面就要重新开始排名的计算，一般来说需要3个月左右，假如A页面原来的排名不错，那B页面重新开始计算，就会非常吃亏。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用301/302不当的后果</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>从表面上看，302比301更友好，但因为302是暂时性跳转的含义，如果被用来做长期跳转，搜索引擎就会认为这是网站在利用302跳转转移A页面的权重，为B页面作弊，就会给予网站惩罚。由于搜索引擎对于跳转时间判断规则的不确定，因此不建议使用302跳转。</p>\n<p>参考：</p>\n<p><a href=\"https://www.cnblogs.com/datang6777/p/7243088.html\">301 和 302 对 SEO 的影响</a></p>\n<p><a href=\"https://www.feiniaomy.com/post/531.html\">301重定向对网站SEO的影响</a></p>\n"},{"title":"网络复习-0","tags":["keep-alive","多路复用"],"categories":"2021复习","description":"## keep-alive\n\nhttp协议是建立在tcp协议上的应用层协议，http协议的早期版本(HTTP/0.9和早期HTTP/1.0)最初是一个非常简单的协议，通信方式也是采用简单的请求-应答模式，即：客户端与服务器的每次请求都需要建立连接，服务器响应后即断开，再请求再重新创建\n\n![http多次创建tcp](http://mrrsblog.oss-cn-shanghai.aliyunc","createDate":"2021-05-19 04:51:30","updateDate":"2021-06-11 18:39:18","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">keep-alive</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>http协议是建立在tcp协议上的应用层协议，http协议的早期版本(HTTP/0.9和早期HTTP/1.0)最初是一个非常简单的协议，通信方式也是采用简单的请求-应答模式，即：客户端与服务器的每次请求都需要建立连接，服务器响应后即断开，再请求再重新创建</p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/http-5.png\" alt=\"http多次创建tcp\"></p>\n<p>tcp连接的新建成本较高，因为客户端和服务器建立连接时需要<strong>三次握手</strong>，传输一次数据耗时2xRTT + 数据传输时间:</p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/request_http_time.png\" alt=\"http传输一次数据耗时\"></p>\n<p>释放时则是<strong>四次挥手</strong>，需要2xRTT</p>\n<p>所以HTTP/1.0引入了<code>keep-alive</code>，HTTP/1.0中默认是关闭的，可在请求头中添加<code>Connection: keep-alive</code>开启；HTTP/1.1默认开启</p>\n<p>所谓<code>keep-alive</code>就是服务器在发送响应后在一定时间（通过http请求头<code>Keep-Alive: timeout max</code>设置）内仍然保持这条连接，使得同一个客户端可以继续使用这条连接传输后续的http请求报文和响应报文</p>\n<blockquote>\n<p>需要将 Connection 首部的值设置为  &quot;keep-alive&quot; 这个首部才有意义。同时需要注意的是，在HTTP/2 协议中， Connection 和 Keep-Alive  是被忽略的；在其中采用其他机制来进行连接管理。</p>\n</blockquote>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/http-6.png\" alt=\"http多次创建tcp\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">http2多路复用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>为什么HTTP/2引入多路复用：</p>\n<p>HTTP/1.0引入的<code>Keep-Alive</code>有两种工作方式： <strong>非流水线<code>without pipelining</code></strong> 和 <strong>流水线<code>with pipeling</code></strong> </p>\n<ul>\n<li><p>非流水线\n  客户在收到上一个请求的响应后才能发送下一个请求。因此在TCP连接已建立后客户每访问一次对象就要用一个RTT，相较于非持续连接节省了一个RTT。但这仍然有一定的缺点：服务器在发送完一个对象后其TCP连接就处于空闲状态，浪费资源</p>\n</li>\n<li><p>流水线\n  客户在收到HTTP响应报文之前可以继续发送新的报文。于是一个接一个的请求报文到达服务器后，服务器就可以连续发回响应报文，但这要求服务器必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 (Head-Of-Line Blocking)</p>\n</li>\n</ul>\n<p>HTTP2的多路复用</p>\n<p>首先引入帧(frame)和流(stream)，因为HTTP/1.x是基于文本的，就导致在传输时只能串行去传。HTTP/2是基于流的，它就可以把HTTP消息分解为独立的帧，交错发送，然后在另一端通过帧中的标示重新组装，这就是<strong>多路复用</strong>。多路复用实现了在同一个TCP连接中，同一时刻可以发送多个请求和响应，且不用按照顺序一一对应，即使某个请求任务耗时严重，也不影响其他连接的正常执行</p>\n<p>steam是一个独立的、客户端和服务端在HTTP/2连接下交换帧的双向序列集</p>\n<p>HTTP/2在端点之间建立连接后，以Frame为基本单位交换数据。stream为一组共享同一streamID的frame集合</p>\n<p>Connection,Stream,Frame 构成了这样的关系：Connection 和 Stream 是一对多的关系，Stream 和Frame也是一对多的关系</p>\n<p>这样，就可以允许来自多个Stream 的多个Frame 交错发送，在一个Connection上执行多播通信 （multiplexed communication）</p>\n<p>并且，客户端也可以在一个TCP Connection 上发送多个请求。在同一个Connection上的请求现在可以不按次序给出响应——服务端可以根据QoS（服务质量）规则来决定响应内容的次序</p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/http-7.png\" alt=\"http2的多路复用\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">http常见首部字段</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <table>\n<thead>\n<tr>\n<th>名称</th>\n<th>意义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache-Control</td>\n<td>缓存设置<code>Cache-Control: private, max-age=0, no-cache</code></td>\n<td>no-cache: no-cache 无 强制向源服务器再次验证</br>no-store: 不缓存</br>max-age: 100: 100s后失效</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>控制不再转发给代理的首部字段；管理持久连接</td>\n<td><code>Connection: Upgrade/Keep-Alive</code></td>\n</tr>\n<tr>\n<td>Date</td>\n<td>创建HTTP报文的日期和时间</td>\n<td>Date: Tue, 03 Jul 2012 04:40:59 GMT</td>\n</tr>\n<tr>\n<td>Accept</td>\n<td>告知服务器客户端可以处理的媒体类型及媒体类型的想对优先级</td>\n<td>Accept: text/html,application/xhtml+xml,application/xml</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>本次返回的数据长度</td>\n<td></td>\n</tr>\n<tr>\n<td>Host</td>\n<td>服务器域名/ip</td>\n<td></td>\n</tr>\n</tbody></table>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">cache-control</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">请求头部</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-http\"><span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>max-age=&lt;seconds&gt;\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>max-stale[=&lt;seconds&gt;]\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>min-fresh=&lt;seconds&gt;\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>no-cache\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>no-store\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>no-transform\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>only-if-cached\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">响应头部</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-http\"><span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>must-revalidate\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>no-cache\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>no-store\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>no-transform\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>private\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>public\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>proxy-revalidate\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>max-age=&lt;secnonds&gt;\n<span class=\"hljs-attribute\">Cache-Control</span><span class=\"hljs-punctuation\">: </span>s-maxage=&lt;seconds&gt;\n</code></pre>\n<p><code>public</code>: 表示可以被任何对象（浏览器、服务器、代理服务器等）缓存</p>\n<p><code>private</code>: 表示只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存）</p>\n<p><code>no-cache</code>: 使用协商缓存</p>\n<p><code>no-store</code>: 不使用任何缓存</p>\n<p><code>max-age=&lt;seconds&gt;</code>: 设置缓存存储的最大周期，超过这个时间（相对于请求的时间）缓存被认为过期</p>\n<p><code>s-maxage=&lt;seconds&gt;</code>: 针对于缓存服务器</p>\n<p><code>max-stale[=&lt;seconds&gt;]</code>: 表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示缓存最大的超时时间，该时间内可正常接收</p>\n<p><code>min-fresh=&lt;seconds&gt;</code>: 要求缓存服务器返回至少还未过指定时间的缓存资源。比如当指定<code>min-fresh</code>为60，过了 60 秒的资源都无法作为响应返回了</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">http的演进</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/evo_of_http.png\" alt=\"http的演进\"></p>\n<p>http1.1使用添加了keep-clive来复用tcp连接，改善了http1.0频繁创建tcp连接的性能开销。此外支持流水线(with pipeling)传输，使得客户端可以专注于发送而不必等待上一个请求的响应。可以在一定程度上减少整体的响应时间。但流水线也存在问题，虽然客户端可以一直发送，但服务器需要顺序响应，如果某一响应较耗时，那个客户端也一直收不到其他的响应（对头阻塞问题）。此外http1.1还有请求、响应头部(Header)较大(未经压缩就发送)、没有请求优先级控制等问题。</p>\n<p>http2.0是基于https的，首先安全性有了保障，此外性能上较http1.1也有了不少改进。</p>\n<ol>\n<li><p>http2.0会进行头部压缩：如果你发出多个请求，它们的头部是一样或相似的，那么协议会帮你消除重复的部分。</p>\n</li>\n<li><p>http2不再像http1.x里的纯文本形式的报文，http/2是基于二进制的，头部和数据体统称为帧(frame)，这样虽然对人不太友好，但对于计算机来讲不用再将数据从文本转为二进制，而是直接解析二进制报文，增加了数据传输线率</p>\n</li>\n<li><p>http/2的数据包不是顺序发送的，而是基于流的，同一个连接里可能有不同的请求/响应。因此每一个数据流都标记这独一无二的编号，客户端还可以指定数据流的优先级。</p>\n</li>\n<li><p>http/2采用了多路复用的策略来进一步提升性能，移除了http/1.x中的流水线式的串行请求/响应方式。http/2可以在同一个连接中并发处理多个请求或响应，而不用排队等待，再也不会出现对头阻塞的问题了</p>\n</li>\n<li><p>服务器推送。</p>\n</li>\n</ol>\n<p>http/3把tcp改成了udp</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s/194SJUQz-mZBtg-kLd9fhA\">了解 HTTP/1.x 的 keep-alive 吗？它与 HTTP/2 多路复用的区别是什么？</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive\">MDN</a>\n<a href=\"https://stackoverflow.com/a/48516829/12241567\">Why HTTP/2 does multiplexing altough tcp does same thing?</a></p>\n"},{"title":"网络复习-OSI七层模型","tags":["OSI"],"categories":"2021复习","description":"## OSI七层模型\n\n开放系统互联(Open Systems Interconncection )\n\n![OSI模型](http://mrrsblog.oss-cn-shanghai.aliyuncs.com/osi.png)\n\n## TCP\n\n传输层协议\n\n- 面向连接\n- 每一个tcp连接只能是点对点的（一对一）\n- 提供可靠交付服务\n- 提供全双工服务\n- 面向字节流\n\n应用程序和TC","createDate":"2021-05-17 02:39:27","updateDate":"2021-06-11 17:38:16","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">OSI七层模型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>开放系统互联(Open Systems Interconncection )</p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/osi.png\" alt=\"OSI模型\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>传输层协议</p>\n<ul>\n<li>面向连接</li>\n<li>每一个tcp连接只能是点对点的（一对一）</li>\n<li>提供可靠交付服务</li>\n<li>提供全双工服务</li>\n<li>面向字节流</li>\n</ul>\n<p>应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送</p>\n<p>当网络通信采用TCP协议时，在真正的读写操作之前，客户端与服务端之间必须建立一个连接，当读写完成之后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠<strong>三次握手</strong>，而释放需要<strong>四次挥手</strong>，所以每个连接的建立都是需要资源消耗和时间消耗的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP连接的建立过程（三次握手/四次挥手）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/three-wayHandshake.png\" alt=\"三次握手\"></p>\n<p>三次握手的过程：</p>\n<ol>\n<li><p>第一次握手</p>\n<p> 客户端向服务端发送连接请求建立报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入<code>SYN-SENT</code>状态</p>\n</li>\n<li><p>第二次握手</p>\n<p> 服务端收到请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完便进入<code>SYN-RECEIVED</code>状态</p>\n</li>\n<li><p>第三次握手</p>\n<p> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入<code>ESTABLISHED</code>状态，服务端收到这个应答后也进入<code>ESTABLISHED</code>状态，此时连接建立成功</p>\n</li>\n</ol>\n<p>为什么需要三次握手？</p>\n<p><a href=\"https://www.zhihu.com/question/24853633/answer/63668444\">TCP 为什么是三次握手，而不是两次或四次？ - wuxinliulei的回答 - 知乎</a></p>\n<p>存在这样一种情况：client发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间地滞留了，以致延误到达已经释放连接后的server。本来这是一个早已失效的报文段，但server收到此失效的连接请求报文段后，就误以为这是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用<em>三次握手</em>而是<em>两次握手</em>，那么只要server发出确认，新的连接就建立了；由于现在client并没有发出去建立连接的请求，因此不会理睬server的确认请求，也不会向server发送数据。但server却以为新的连接已经建立，并一直等待client发送数据。这样，server的很多资源就白白浪费掉了。采用<strong>三次握手</strong>的方法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接。</p>\n<p>这个问题的本质是<strong>信道不可靠，但是通信双方需要就某个问题达成一致，而要解决这个问题，无论你在消息中包含什么信息，三次通信是理论上的最小值</strong>，所以<strong>三次握手并不是tcp本身的要求，而是为了满足在不可靠的信道上可靠传输信息这一需求所导致的</strong>。三次达到了，那后面你想接着握手也好，发数据也好，跟进行可靠信息传输的需求就没关系了，因此如果信道是可靠的，即无论什么时候发出消息对方一定能收到，或者不关心是否要保证对方收到你的消息，那样就能像udp那样直接发送消息就可以了</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/four-wayHandshake.png\" alt=\"四次挥手\"></p>\n<p>为什么A(发起关闭的那一端)在TIME-WAIT状态必须等待2MSL的时间？</p>\n<ol>\n<li>保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送FIN+ACK报文段的确认，B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在发送完ACK报文段后立即释放连接，没有等待2MSL，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，这样B就无法按照正常步骤进入CLOSED状态</li>\n<li>防止<em>已失效的连接请求报文段</em>出现在本连接中，A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这样旧的连接请求报文段</li>\n</ol>\n"},{"title":"浏览器复习-渲染","tags":["浏览器渲染","重绘","回流","合成"],"categories":"2021复习","description":"## 浏览器渲染流程\n\n构建DOM树、构建渲染树、布局、绘制、合成\n\n1. 构建DOM树\n    浏览器将HTML解析成树形结构的DOM树，一般来说，这个过程发生在页面初次加载，或页面JavaScript修改了DOM节点结构的时候\n2. 构建渲染树\n    浏览器将CSS解析成树形结构的CSSOM树，再和DOM树合并成渲染树\n3. 布局（Layout）\n    浏览器根据渲染树所体现的节点、各","createDate":"2021-05-21 05:30:12","updateDate":"2021-06-11 14:18:48","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器渲染流程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>构建DOM树、构建渲染树、布局、绘制、合成</p>\n<ol>\n<li>构建DOM树\n 浏览器将HTML解析成树形结构的DOM树，一般来说，这个过程发生在页面初次加载，或页面JavaScript修改了DOM节点结构的时候</li>\n<li>构建渲染树\n 浏览器将CSS解析成树形结构的CSSOM树，再和DOM树合并成渲染树</li>\n<li>布局（Layout）\n 浏览器根据渲染树所体现的节点、各个节点的CSS定义以及它们的从属关系，计算出每个节点在屏幕中的位置。web页面中元素的布局是相对的，在页面元素位置、大小发生变化时，往往会导致其他节点联动，需要重新计算布局，这时候布局过程一般被称为回流（Reflow）</li>\n<li>绘制（paint）\n 遍历渲染树，调用渲染器的<code>paint()</code>方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的CSS修改引起的屏幕局部重画，这时候被称为重绘（Reapint）。实际上，绘制过程是在多个层上完成的，这些层我们称为渲染层（RenderLayer）</li>\n<li>合成（Composite）\n 多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器渲染原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>从浏览器的渲染过程中知道，页面HTML会解析成DOM树，每个HTML元素对应了树结构上的一个node节点。而从DOM树转化到一个个的渲染层，并最终执行合并、绘制的过程中，中间其实还存在一些过渡的数据结构，它们记录了DOM树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/render.png\" alt=\"浏览器渲染原理\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">渲染对象（RenderObject）</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>一个DOM节点对应了一个渲染对象，渲染对象依然维持着DOM树的树形结构。一个渲染对象知道如何绘制一个DOM节点的内容，它通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制DOM节点</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">渲染层（RenderLayer）</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标的渲染对象将形成<strong>多个渲染层</strong>，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。</p>\n<p>创建新的渲染层的情况：</p>\n<ul>\n<li>根元素（<code>document</code>）</li>\n<li>有明确的定位属性（<code>relative</code> <code>fixed</code> <code>absolute</code> <code>sticky</code>）</li>\n<li><code>opacity</code> &lt; 1</li>\n<li>CSS <code>filter</code> <code>mask</code> <code>transform</code>不为<code>none</code> <code>overflow</code>不为<code>visible</code></li>\n</ul>\n<p>DOM节点和渲染对象是一一对应的，满足以上条件的渲染对象就能拥有<strong>独立的渲染层</strong>。此外，不满足上述条件的渲染对象将会与其第一个拥有渲染层的父元素共用一个渲染层</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">图形层（GraphicsLayer）</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>GraphicsLayer其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsLayer会负责输出该层的位图。存储再共享内存中的位图将作为纹理上传到GPU，最后有GPU将多个位图进行合成，然后绘制到屏幕上</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">合成层（CompositingLayer）</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有独立的GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有GraphicsLayer的复层共用一个。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">隐式合成&amp;&amp;层爆炸</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>除了显式设定一些属性来将渲染层提升合成层外，还有一些<strong>隐式合成</strong>，部分渲染层在一些特定的场景下会被默认提升为合成层：</p>\n<p>两个<code>absolute</code>定位的<code>div</code>在屏幕上交叠了，根据<code>z-index</code>的关系，其中一个<code>div</code>就会盖在了另外一个上边。这个时候，如果处于下方的<code>div</code>被加上了<code>CSS</code>属性：<code>transform: translateZ(0)</code>，就会被浏览器提升为合成层。提升后的合成层位于<code>Document</code>上方，假如没有隐式合成，原本应该处于上方的<code>div</code>就依然还是跟 <code>Document</code>共用一个<code>GraphicsLayer</code>，层级反而降了，就出现了元素交叠关系错乱的问题。所以为了纠正错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/implicitComposite.png\" alt=\"隐式合成\"></p>\n<p>一些产生合成层的原因太过于隐蔽了，尤其是隐式合成。在平时的开发过程中，我们很少会去关注层合成的问题，很容易就产生一些不在预期范围内的合成层，当这些不符合预期的合成层达到一定量级时，就会变成<strong>层爆炸</strong></p>\n<p>消除隐式合成就是要消除元素交叠，拿这个DEMO来说，只需要给上层<code>div</code>的<code>z-index</code>属性设置一个较高的数值，就能让它高于页面中其他元素，自然也就没有合成层提升的必要了</p>\n<p>当然了，面对这种问题，浏览器也有相应的应对策略，<strong>层压缩</strong>。如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个<code>GraphicsLayer</code>中，以防止由于重叠原因导致可能出现的层爆炸</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">回流</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>当对DOM的修改引发DOM<strong>几何尺寸</strong>发生变化的时候，就会发生<strong>回流</strong></p>\n<p>具体表现在以下操作：</p>\n<ul>\n<li>设置<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>border</code>、<code>left</code>等属性</li>\n<li>添加或删除dom节点</li>\n<li>读写<code>offset-*</code>、<code>scroll-*</code>、<code>client-*</code>属性。浏览器为了获取这些值，需要进行回流操作</li>\n<li>调用<code>getCompoutedStyle</code>、<code>getBoundingClientRect</code>、<code>scrooTo</code>方法</li>\n</ul>\n<p>发生回流时，将重新渲染DOM树，比较耗时</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">重绘</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>当对DOM的修改导致了样式的变化，比如修改了<code>color</code>，并没有影响几何属性，这时会触发重绘</p>\n<p>由于没有导致DOM几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，相较于回流比较节省资源开销</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">合成</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>利用CSS3的<code>transform</code>、<code>opacity</code>、<code>filter</code>这些属性就可以实现<strong>合成</strong>的效果，也就是大家常说的GPU加速</p>\n<ol>\n<li>能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成</li>\n<li>独占一个<code>GraphicsLayer</code></li>\n</ol>\n<p>提升为合成层的情况：</p>\n<ul>\n<li><code>translate3d</code> <code>translateZ</code></li>\n<li><code>video</code> <code>canvas</code> <code>iframe</code></li>\n<li>通过<code>Element.animate()</code>实现的<code>opacity</code>动画转换</li>\n<li>通过CSS动画实现的<code>opacity</code>动画转换</li>\n<li>CSS <code>will-change</code>属性</li>\n<li>对<code>opacity</code> <code>transform</code> <code>filter</code>应用了<code>animation</code>或者<code>transition</code></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://juejin.cn/post/6844903966573068301\">浏览器层合成与页面渲染优化</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work\">渲染页面：浏览器的工作原理</a></p>\n"},{"title":"浏览器复习-缓存","tags":["浏览器缓存"],"categories":"2021复习","description":"对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。直接使用缓存而不发起请求或发起了请求但后端存储的数据与浏览器缓存中的一致那就没必要将数据传输回来，直接读取缓存中的数据节省网络传输开销\n\n缓存的意义在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也能减轻服务器压力。所以最佳实践就是**尽可能命中强缓存，同时能","createDate":"2021-05-16 08:10:35","updateDate":"2021-06-11 10:55:56","body":"<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。直接使用缓存而不发起请求或发起了请求但后端存储的数据与浏览器缓存中的一致那就没必要将数据传输回来，直接读取缓存中的数据节省网络传输开销</p>\n<p>缓存的意义在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也能减轻服务器压力。所以最佳实践就是<strong>尽可能命中强缓存，同时能在版本更新的时候让客户端的缓存失效</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">缓存位置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">memory cache</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>memory cache就是内存中的缓存，读取数据的速度比较快。虽然内存缓存高效，但是缓存持续性很短，会<strong>随着进程的释放而释放</strong>，一旦我们关闭页面，内存中的数据也就被释放了。（刷新页面不会丢失）</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">disk cache</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>存储在硬盘中的缓存，读取速度较内存慢，但存储量大，存储时间长。较<code>memory cache</code>胜在容量和时效性上</p>\n<p>在所有浏览器缓存中，disk cache覆盖面基本是最大的。它会根据 <code>http header</code>中的某些字段判断哪些资源需要被缓存，哪些资源可以直接从缓存取而不用发送请求去获取。<strong>即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来就不会再去请求数据</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">push cache</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>http/2中的内容，仅在会话(session)中存在</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">缓存策略</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置http header来实现的</p>\n<ol>\n<li>浏览器每次发起请求，都会先在浏览器中查找该请求的结果及缓存标识</li>\n<li>浏览器每次拿到返回的结果请求都会将该结果和缓存标识存入浏览器缓存中</li>\n</ol>\n<p>发起请求及缓存处理流程：</p>\n<ol>\n<li>浏览器在加载资源时，现根据这个资源的一些http header字段判断它是否命中强缓存，强缓存如果命中，浏览器会直接从自己的缓存中读取资源不会发送请求到服务器</li>\n<li>当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据http header中的一些字段判断这个资源是否命中协商缓存，如果协商缓存命中，服务器会以<strong>304</strong>响应这个请求，不会返回该资源，告诉浏览器可以从缓存中读取；如果没命中则返回该资源</li>\n</ol>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_cache.png\" alt=\"浏览器缓存策略\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">强缓存</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>强缓存可以通过设置两种http header来实现：<code>Expires</code>和<code>Cache-Control</code></p>\n<ul>\n<li>Expires</li>\n</ul>\n<p><code>Expires: Web, 22 Oct 2021 08:41:00 GMT</code></p>\n<p><code>Expires</code>是http/1的产物，表示资源会在<code>Web, 22 Oct 2021 08:41:00 GMT</code>后过期，需要再次请求。<code>Expires</code>受限于本地时间，如果修改了本地时间可能会造成缓存失效</p>\n<ul>\n<li>Cache-Control</li>\n</ul>\n<p><code>Cache-Control: public, max-age=31536000</code></p>\n<p><code>Cache-Control</code>出现在http/1.1，优先级高于Expires。该属性表示资源会在31536000秒后失效需要再次请求</p>\n<p><code>Cache-Control</code>可以在请求或响应头中设置，并且可以组合使用多种指令</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/cache_1.png\" alt=\"cache-control\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">协商缓存</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>协商缓存可以通过设置两种http header实现：<code>Last-Modified</code>和<code>ETag</code></p>\n<ul>\n<li><code>Last-Modified</code>和<code>If-Modified-Since</code></li>\n</ul>\n<p><code>Last-Modified</code>会随着访问资源时返回，表示该资源在浏览器上最后修改时间。浏览器再次请求资源时，<code>If-Modified-Since</code>会将<code>Last-Modified</code>的值携带上，询问服务器在该日期后资源是否有更新，有的话就会将新的资源送回来，否则返回<strong>304</strong>，即命中缓存</p>\n<p>和<code>Expires</code>一样，本地打开缓存文件一样会导致缓存失效。此外，Last-Modified以秒计时，如果以更细粒度的时间内修改文件，服务器还是认为文件没有更新告诉浏览器可以使用缓存中的文件</p>\n<ul>\n<li><code>ETag</code>和<code>If-None-Match</code></li>\n</ul>\n<p><code>ETag</code>类似文件指纹，也会随着请求资源时返回(浏览器生成)。浏览器再次请求资源时，<code>If-None-Match</code>会将<code>ETag</code>的值携带上，询问该资源的<code>ETag</code>是否有过变动，有变动的话就将最新的资源返回，否则返回<strong>304</strong>，即命中缓存</p>\n<p><code>ETag</code>的优先级高于<code>Last-Modified</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">强缓存和协商缓存的异同</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>强缓存和协商缓存的共同点是如果命中都是从缓存中读取资源数据；区别是协商缓存总是会发送一个请求而强缓存不会</p>\n"},{"title":"前端架构&软实力-工程化","tags":["工程化"],"categories":"2021复习","description":"> 工程化：使用一些列具有模块化、代码分割、代码转译、对非JavaScript文件支持良好的工具，构建有效的、高质量的、高可维护性、实用的中大型前端应用\n\n这些工具所要支持的特性主要包括以下几个维度\n\n## 模块化\n\n即对ESM、CommonJS等主流模块化机制的支持。随着前端应用的日渐庞大，将应用或按业务划分或按功能划分为多个模块已是大势所趋，因此良好的模块化支持将有助于开发出健壮、可维护性","createDate":"2021-06-10 14:55:25","updateDate":"2021-06-10 23:18:07","body":"<blockquote>\n<p>工程化：使用一些列具有模块化、代码分割、代码转译、对非JavaScript文件支持良好的工具，构建有效的、高质量的、高可维护性、实用的中大型前端应用</p>\n</blockquote>\n<p>这些工具所要支持的特性主要包括以下几个维度</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模块化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>即对ESM、CommonJS等主流模块化机制的支持。随着前端应用的日渐庞大，将应用或按业务划分或按功能划分为多个模块已是大势所趋，因此良好的模块化支持将有助于开发出健壮、可维护性高的应用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">代码分割</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在构建时能够将静态资源拆分，因此在页面加载时，可以实现合理的按需加载策略</p>\n<p>包括公共文件提取、动态导入等</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">处理非JavaScript资源</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在开发前端应用时，有相当一部分代码/资源为非JavaScript，其中包括CSS、图片等，如何处理这些资源也变得至关重要</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">代码转译</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>处理代码兼容</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Tree Shaking</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>剔除无用代码</p>\n"},{"title":"JavaScript复习-2","tags":["JavaScript"],"categories":"2021复习","description":"## Array.prototype.sort算法\n\n> sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的\n\n## Symbol用处\n\n1. 表示一个独一无二的变量防止命名冲突\n2. 提供一些特殊的属性`[Symbol.itertor]`(可通过`Reflect.ownKeys(Symbol)`查","createDate":"2021-05-31 14:58:19","updateDate":"2021-06-10 22:53:18","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Array.prototype.sort算法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</p>\n</blockquote>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Symbol用处</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>表示一个独一无二的变量防止命名冲突</li>\n<li>提供一些特殊的属性<code>[Symbol.itertor]</code>(可通过<code>Reflect.ownKeys(Symbol)</code>查看)</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">工程化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>通过一系列工具构建和维护有效的、实用的、高质量的前端应用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\">MDN-Array.prototype.sort</a></p>\n"},{"title":"JavaScript复习-垃圾回收","tags":["JavaScript"],"categories":"2021复习","description":"## GC做了什么：\n\n1. 找到内存空间中的垃圾\n2. 回收垃圾，让程序能再次利用这部分空间\n\n## 常用的几种GC算法\n\n### 引用计数法\n\n记录对象有多少程序在引用它，当引用计数为0时就会被回收\n\n优势：\n\n- 可即刻回收垃圾，当引用计数为0时，对象马上会把自己作为空闲空间连到空闲链表上。也就是说在变成垃圾的时候就立刻被回收\n- `GC`效果短、平、快\n\n劣势：\n\n- 计数器可能会占用","createDate":"2021-05-10 11:25:34","updateDate":"2021-06-10 18:38:58","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">GC做了什么：</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>找到内存空间中的垃圾</li>\n<li>回收垃圾，让程序能再次利用这部分空间</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">常用的几种GC算法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">引用计数法</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>记录对象有多少程序在引用它，当引用计数为0时就会被回收</p>\n<p>优势：</p>\n<ul>\n<li>可即刻回收垃圾，当引用计数为0时，对象马上会把自己作为空闲空间连到空闲链表上。也就是说在变成垃圾的时候就立刻被回收</li>\n<li><code>GC</code>效果短、平、快</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>计数器可能会占用很大的空间</li>\n<li>无法解决循环引用无法被回收的问题</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">标记清除法👍</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>将<code>GC</code>过程分为两个阶段：</p>\n<ul>\n<li>标记阶段：把所有活动对象做上标记</li>\n<li>清除阶段：把所有没有被标记的对象销毁</li>\n</ul>\n<p>优势：</p>\n<ul>\n<li>实现简单</li>\n<li>可以解决循环引用的问题</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>造成碎片化</li>\n<li>不能实时回收（采用定时任务定时<code>GC</code>）</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">复制算法</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>将一个内存空间分为两部分，一部分是From空间，另一部分是To空间，将From空间里面的活动对象复制到To空间，然后释放掉整个From空间，然后此刻将From空间和To空间的身份互换，那么就完成了一次GC。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/copy_gc.png\" alt=\"复制算法GC\"></p>\n"},{"title":"JavaScript复习-继承","tags":["JavaScript"],"categories":"2021复习","description":"使用继承的原因：**复用**\n\n## 基于原型链\n\n每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也可能是一个对象...这样就在实例和原型之间构造了一条原型链\n\n``` js\nfunction SuperType() {\n    this.property","createDate":"2021-05-10 14:17:07","updateDate":"2021-06-10 18:24:51","body":"<p>使用继承的原因：<strong>复用</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基于原型链</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也可能是一个对象...这样就在实例和原型之间构造了一条原型链</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">property</span> = <span class=\"hljs-literal\">true</span>;\n}\n<span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSuperValue</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">property</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">property</span> = <span class=\"hljs-literal\">false</span>;\n}\n<span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SuperType</span>();\n    <span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSubValue</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">property</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance.<span class=\"hljs-title function_\">getSuperValue</span>());\n<span class=\"hljs-keyword\">const</span> instance2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance2.<span class=\"hljs-title function_\">getSuperValue</span>());\n<span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-comment\">// false</span>\n</code></pre>\n<p><code>getSuperTypeValue()</code>方法还在<code>SuperType.prototype</code>上，而<code>prototype</code>却在<code>SubType.prototype</code>上。这是因为<code>getSuperType()</code>是一个原型方法，而<code>property</code>是一个实例属性</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/extends_prototype.png\" alt=\"基于原型链模式的继承\"></p>\n<p>问题：</p>\n<ol>\n<li>原型中包含的引用值会在所有实例中共享</li>\n<li>子类在实例化时不能给父类的构造函数传参</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">盗用构造函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在子类构造函数中调用父类的构造函数</p>\n<p>问题：</p>\n<p>只继承了父类的属性，没有继承父类的方法</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\">name</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n}\n<span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSuperValue</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">property</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\">name, age</span>) {\n    <span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = age;\n}\n\n<span class=\"hljs-keyword\">const</span> instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>, <span class=\"hljs-number\">21</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance);\n<span class=\"hljs-keyword\">const</span> instance2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&#x27;jerry&#x27;</span>, <span class=\"hljs-number\">22</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance2);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance2.<span class=\"hljs-property\">getSuperValue</span>);\n<span class=\"hljs-comment\">// SubType { name: &#x27;tom&#x27;, age: 21 }  </span>\n<span class=\"hljs-comment\">// SubType { name: &#x27;jerry&#x27;, age: 22 }</span>\n<span class=\"hljs-comment\">// undefined</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组合继承</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用原型链继承方法，使用构造函数继承属性</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\">name</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n}\n<span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSuperValue</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\">name, age</span>) {\n    <span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = age;\n}\n<span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SuperType</span>();\n<span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSubValue</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>, <span class=\"hljs-number\">21</span>);\n<span class=\"hljs-keyword\">const</span> instance2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&#x27;jerry&#x27;</span>, <span class=\"hljs-number\">23</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance.<span class=\"hljs-title function_\">getSubValue</span>());\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance.<span class=\"hljs-title function_\">getSuperValue</span>());\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance2.<span class=\"hljs-property\">name</span>);\n<span class=\"hljs-comment\">// SuperType { name: &#x27;tom&#x27;, age: 21 }</span>\n<span class=\"hljs-comment\">// 21</span>\n<span class=\"hljs-comment\">// tom</span>\n<span class=\"hljs-comment\">// jerry</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">寄生组合式继承</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>组合式继承的缺点在于调用了两次父类的构造函数，造成了子类构造函数和实例上有一组相同的属性</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/prorotype_constructor_inheritance.png\" alt=\"组合式继承的缺点\"></p>\n<p>寄生组合式继承通过盗用构造函数继承属性，使用混合式原型链继承方法</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inheritance</span>(<span class=\"hljs-params\">superType, subType</span>) {\n    <span class=\"hljs-keyword\">const</span> pro = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(superType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);\n    pro.<span class=\"hljs-property\">constructor</span> = subType;\n    subType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = pro;\n}\n  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SuperType</span>(<span class=\"hljs-params\">name, friends</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">friends</span> = friends;\n}\n<span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSuperValue</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SubType</span>(<span class=\"hljs-params\">name, age, friends, colors</span>) {\n    <span class=\"hljs-title class_\">SuperType</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name, friends);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = age;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">colors</span> = colors;\n}\n<span class=\"hljs-title function_\">inheritance</span>(<span class=\"hljs-title class_\">SuperType</span>, <span class=\"hljs-title class_\">SubType</span>);\n<span class=\"hljs-title class_\">SubType</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getSubValue</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> instance = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>, <span class=\"hljs-number\">21</span>, [], []);\ninstance.<span class=\"hljs-property\">friends</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;jerry&#x27;</span>);\ninstance.<span class=\"hljs-property\">colors</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;pink&#x27;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance.<span class=\"hljs-title function_\">getSuperValue</span>());\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance.<span class=\"hljs-title function_\">getSubValue</span>());\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance.<span class=\"hljs-property\">friends</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance.<span class=\"hljs-property\">colors</span>);\n\n<span class=\"hljs-keyword\">const</span> instance2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SubType</span>(<span class=\"hljs-string\">&#x27;jerry&#x27;</span>, <span class=\"hljs-number\">21</span>, [], []);\ninstance2.<span class=\"hljs-property\">friends</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;tom&#x27;</span>);\ninstance2.<span class=\"hljs-property\">colors</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;black&#x27;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance2.<span class=\"hljs-property\">friends</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(instance2.<span class=\"hljs-property\">colors</span>);\n<span class=\"hljs-comment\">// tom</span>\n<span class=\"hljs-comment\">// 21</span>\n<span class=\"hljs-comment\">// [ &#x27;jerry&#x27; ]</span>\n<span class=\"hljs-comment\">// [ &#x27;pink&#x27; ]</span>\n<span class=\"hljs-comment\">// [ &#x27;tom&#x27; ]</span>\n<span class=\"hljs-comment\">// [ &#x27;black&#x27; ]</span>\n</code></pre>\n"},{"title":"JavaScript复习-迭代器","tags":["JavaScript","迭代器","Iterator"],"categories":"2021复习","description":"在软件开发领域，迭代的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件\n\n任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的API。迭代器无需了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。\n\n## 可迭代协议\n\n数据结构必须暴露一个属性作为","createDate":"2021-05-12 14:32:07","updateDate":"2021-06-10 11:06:19","body":"<p>在软件开发领域，迭代的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件</p>\n<p>任何实现Iterable接口的数据结构都可以被实现Iterator接口的结构消费。迭代器是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的API。迭代器无需了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">可迭代协议</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>数据结构必须暴露一个属性作为<strong>默认迭代器</strong>，而且这个属性必须使用特殊的<code>Symbol.iterator</code>作为键，以一个迭代器工厂函数作为值（调用其会返回一个一个新迭代器）</p>\n<p>可迭代对象可使用的语言特性包括：</p>\n<ul>\n<li><code>for-of</code>循环</li>\n<li>数组解构</li>\n<li>扩展操作符</li>\n<li><code>Array.from()</code></li>\n<li>创建集合</li>\n<li>创建映射</li>\n<li><code>Promise.all()</code>接收由<code>Promise</code>组成的可迭代对象</li>\n<li><code>Promise.race()</code>接收由<code>Promise</code>组成的可迭代对象</li>\n<li><code>yield* </code>操作符，在生成器中使用</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">迭代器协议</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>迭代器是一次性使用的对象</li>\n<li>迭代器API使用next()方法在可迭代对象中遍历数据。每次成功调用next()，都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。</li>\n<li>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有关系，只会独立地遍历可迭代对象</li>\n<li>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来标记遍历可迭代对象的历程。如果可迭代对象在遍历期间被修改了，那么迭代器也会反应相应地变化</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> iterable = {\n  [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]: <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) {\n        count += <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">if</span> (count &lt;= <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">value</span>: count };\n        <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span> };\n      },\n      <span class=\"hljs-keyword\">return</span>() {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;exiting early&#x27;</span>);\n        <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span> };\n      },\n    };\n  },\n};\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">提前终止迭代器：</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><code>for-of</code>循环通过<code>break</code>、<code>continue</code>、<code>return</code>、<code>throw</code>提前退出</li>\n<li>解构操作并未消费的值</li>\n</ul>\n<p>并非所有迭代器都是可关闭的，比如数组</p>\n"},{"title":"JavaScript复习-执行机制","tags":["JavaScript","执行机制","EventLoop"],"categories":"2021复习","description":"众所周知，JavaScript是一门**单线程**、**异步执行**的语言。虽然在HTML5中提出了`web worker`（可以理解为**浏览器**为JavaScript开的*外挂*），但JavaScript是单线程运行的这一核心仍未改变，所有多线程都是通过单线程**模拟**出来的\n\n## JavaScript的执行与运行\n\n执行与运行不太一样，在不同环境下，比如Node.js、浏览器下，J","createDate":"2021-05-13 10:25:45","updateDate":"2021-06-10 11:03:31","body":"<p>众所周知，JavaScript是一门<strong>单线程</strong>、<strong>异步执行</strong>的语言。虽然在HTML5中提出了<code>web worker</code>（可以理解为<strong>浏览器</strong>为JavaScript开的<em>外挂</em>），但JavaScript是单线程运行的这一核心仍未改变，所有多线程都是通过单线程<strong>模拟</strong>出来的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript的执行与运行</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>执行与运行不太一样，在不同环境下，比如Node.js、浏览器下，JavaScript的执行结果是不一样的；而运行大多是指基于JavaScript引擎，如V8，结果是一致的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript中的异步</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>JavaScript中的异步主要通过event loop进行模拟，当我们执行JavaScript代码的时候其实就是往执行栈里放入函数，那么遇到异步代码怎么办？其实当遇到异步代码时，会被挂起并在需要执行的时候加入到<strong>task</strong>（有多种task）队列中。一旦执行栈为空，event loop就会从task中拿到需要执行的代码并放入执行栈中执行，所以本质上说JavaScript的异步还是同步行为</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器中的event loop</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>来自不同的<strong>任务源</strong>的任务会被分配到不同的task队列中，任务源可以分为<strong>微任务(micro task)</strong> 和 <strong>宏任务(macro task)<strong>。在ES6规范中，微任务被称为</strong>jobs</strong>，宏任务被称为<strong>task</strong></p>\n<p>微任务包括：<code>precess.nextTick</code>、<code>Promise</code>、<code>Mutation Observer</code></p>\n<p>宏任务包括：<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code>、<code>UI Rendering</code></p>\n<p><strong>宏任务中包含了 <code>script</code> ，因此浏览器会先执行一个宏任务，接下来由异步代码的话才会先执行微任务</strong></p>\n<p><strong>Promise的构造函数是同步执⾏，<code>then()</code>是异步执行</strong></p>\n<p>event loop 执行顺序</p>\n<ol>\n<li>先执行宏任务</li>\n<li>当执行完后<strong>执行栈为空</strong>，查询是否有异步代码需要执行</li>\n<li><strong>执行所有微任务</strong></li>\n<li>当执行完所有微任务，如有需要会渲染页面</li>\n<li>然后开始下一轮循环</li>\n</ol>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_event_loop.png\" alt=\"event loop\"></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">3</span>);\n  });\n});\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">5</span>);\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n});\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">6</span>);\n});\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">7</span>);\n\n<span class=\"hljs-comment\">// 1 4 7 5 2 3 6</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Node.js中的event loop</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>v11之后和浏览器保持一致</strong></p>\n<p>Node.js中的event loop分为6个阶段，它们会按照循序反复运行。每当进入到某一个阶段的时候都会从对应的回调队列中取出函数去执行，当<strong>队列为空</strong>或者<strong>执行的回调函数数量达到系统设定的阈值</strong>，就会进入到下一阶段</p>\n<p>Node.js的event loop中，执行宏队列的回调任务有6个阶段：</p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_event_loop.png\" alt=\"event loop\"></p>\n<ol>\n<li><p>timers</p>\n<p> <strong>timers</strong>阶段会执行<code>setTimeout</code>、<code>setInterval</code>回调，并且是由<strong>pool</strong>阶段控制的。</p>\n</li>\n<li><p>I/O</p>\n<p> <strong>I/O</strong>阶段会处理一些上一轮循环中少许未执行的I/O回调</p>\n</li>\n<li><p>idle, prepare</p>\n</li>\n<li><p>poll</p>\n<p> 计算应该阻塞并轮询I / O的时间，然后处理轮询队列中的事件</p>\n<ul>\n<li>如果poll队列不为空，遍历队列并同步执行回调，直到队列为空或达到系统限制</li>\n<li>如果poll队列为空，<ol>\n<li>如果有setImmediate回调需要执行，poll阶段会停止并进入<strong>check阶段</strong></li>\n<li>如果没有，会等待回调被加入队列中并立即执行回调，这里同样有个超时时间防止一直等待下去</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>check</p>\n<p> 执行<code>setImmediate</code>回调</p>\n</li>\n<li><p>colse callbacks</p>\n<p> 执行close事件</p>\n<p> 当发生以下任一情况时会触发 &#39;close&#39; 事件：</p>\n<ul>\n<li>调用 <code>rl.close()</code> 方法，且 <code>readline.Interface</code> 实例放弃对 <code>input</code> 流和 <code>output</code> 流的控制；</li>\n<li><code>input</code> 流接收到其 <code>end</code> 事件；</li>\n<li><code>input</code> 流接收到 <code>&lt;ctrl&gt;-D</code> 以发信号传输结束<code>（EOT）</code>；</li>\n<li><code>input</code> 流接收到 <code>&lt;ctrl&gt;-C</code> 以发信号 <code>SIGINT</code>，并且 <code>readline.Interface</code> 实例上没有注册 &#39;SIGINT&#39; 事件监听器。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"算法复习-栈","tags":["算法"],"categories":"2021复习","description":"## 最小栈\n\n[leetcode-最小栈](https://leetcode-cn.com/problems/min-stack/)\n\n``` js\nfunction MinStack() {\n  this.storage = [];\n  this.min = null;\n}\nMinStack.prototype.push = function (val) {\n  let preMin =","createDate":"2021-06-08 15:03:02","updateDate":"2021-06-08 23:03:06","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">最小栈</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://leetcode-cn.com/problems/min-stack/\">leetcode-最小栈</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MinStack</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span> = [];\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span> = <span class=\"hljs-literal\">null</span>;\n}\n<span class=\"hljs-title class_\">MinStack</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">push</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) {\n  <span class=\"hljs-keyword\">let</span> preMin = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">if</span> (val &lt;= <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span> || <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span> === <span class=\"hljs-literal\">null</span>) {\n    preMin = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span> = val;\n  }\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">push</span>({ val, preMin });\n};\n<span class=\"hljs-title class_\">MinStack</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">pop</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { val, preMin } = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">pop</span>();\n  <span class=\"hljs-keyword\">if</span> (val &lt;= <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span>) <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span> = preMin;\n};\n<span class=\"hljs-title class_\">MinStack</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getMin</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">min</span>;\n};\n<span class=\"hljs-title class_\">MinStack</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">top</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> topNode = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">return</span> topNode ? topNode.<span class=\"hljs-property\">val</span> : <span class=\"hljs-literal\">undefined</span>;\n};\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">有效的括号</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">leetcode-有效的括号</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isValid</span>(<span class=\"hljs-params\">str</span>) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> str !== <span class=\"hljs-string\">&#x27;string&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">if</span> (str === <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">if</span> (str.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">const</span> stack = [];\n  <span class=\"hljs-keyword\">const</span> left = <span class=\"hljs-regexp\">/\\(|\\[|\\{/</span>;\n  <span class=\"hljs-keyword\">const</span> right = <span class=\"hljs-regexp\">/\\)|\\]|\\}/</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; str.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">if</span> (left.<span class=\"hljs-title function_\">test</span>(str[i])) stack.<span class=\"hljs-title function_\">push</span>(str[i]);\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (right.<span class=\"hljs-title function_\">test</span>(str[i])) {\n      <span class=\"hljs-keyword\">const</span> top = stack[stack.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>];\n      <span class=\"hljs-keyword\">if</span> (str[i] === <span class=\"hljs-string\">&#x27;)&#x27;</span> &amp;&amp; top === <span class=\"hljs-string\">&#x27;(&#x27;</span>) stack.<span class=\"hljs-title function_\">pop</span>();\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (str[i] === <span class=\"hljs-string\">&#x27;]&#x27;</span> &amp;&amp; top === <span class=\"hljs-string\">&#x27;[&#x27;</span>) stack.<span class=\"hljs-title function_\">pop</span>();\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (str[i] === <span class=\"hljs-string\">&#x27;}&#x27;</span> &amp;&amp; top === <span class=\"hljs-string\">&#x27;{&#x27;</span>) stack.<span class=\"hljs-title function_\">pop</span>();\n      <span class=\"hljs-keyword\">else</span> stack.<span class=\"hljs-title function_\">push</span>(stack[i]);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">删除字符串中的所有相邻重复项</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/\">leetcode-删除字符串中的所有相邻重复项</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">removeDuplicates</span>(<span class=\"hljs-params\">str</span>) {\n  <span class=\"hljs-keyword\">if</span> (str === <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">if</span> (str.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> str;\n  <span class=\"hljs-keyword\">const</span> stack = [str[<span class=\"hljs-number\">0</span>]];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; str.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">const</span> prev = stack.<span class=\"hljs-title function_\">pop</span>();\n    <span class=\"hljs-keyword\">if</span> (prev !== str[i]) {\n      stack.<span class=\"hljs-title function_\">push</span>(prev);\n      stack.<span class=\"hljs-title function_\">push</span>(str[i]);\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">删除字符串中的所有相邻重复项II</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii/\">lletcode-删除字符串中的所有相邻重复项II</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">removeNDuplicates</span>(<span class=\"hljs-params\">s, k</span>) {\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">popN</span>(<span class=\"hljs-params\">stack, n</span>) {\n    <span class=\"hljs-keyword\">let</span> i = n;\n    <span class=\"hljs-keyword\">while</span> (i &gt; <span class=\"hljs-number\">0</span>) {\n      stack.<span class=\"hljs-title function_\">pop</span>();\n      i -= <span class=\"hljs-number\">1</span>;\n    }\n  }\n  <span class=\"hljs-keyword\">const</span> stack = [];\n  <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; s.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">if</span> (stack[stack.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>] === s[i]) {\n      n += <span class=\"hljs-number\">1</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n      n = <span class=\"hljs-number\">0</span>;\n    }\n    stack.<span class=\"hljs-title function_\">push</span>(s[i]);\n    <span class=\"hljs-keyword\">if</span> (n === k - <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-title function_\">popN</span>(stack, k);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">removeNDuplicates</span>(stack.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>) + s.<span class=\"hljs-title function_\">slice</span>(i + <span class=\"hljs-number\">1</span>), k);\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">removeNDuplicatesPerform</span>(<span class=\"hljs-params\">s, k</span>) {\n  <span class=\"hljs-keyword\">const</span> stack = [];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; s.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">const</span> pre = stack.<span class=\"hljs-title function_\">pop</span>();\n    <span class=\"hljs-keyword\">if</span> (!pre || pre[<span class=\"hljs-number\">0</span>] !== s[i]) {\n      stack.<span class=\"hljs-title function_\">push</span>(pre);\n      stack.<span class=\"hljs-title function_\">push</span>(s[i]);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pre.<span class=\"hljs-property\">length</span> &lt; k - <span class=\"hljs-number\">1</span>) {\n      stack.<span class=\"hljs-title function_\">push</span>(pre + s[i]);\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">翻转字符串里的单词</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://leetcode-cn.com/problems/reverse-words-in-a-string/\">leetcode-翻转字符串里的单词</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverseWords</span>(<span class=\"hljs-params\">s</span>) {\n  <span class=\"hljs-keyword\">if</span> (s === <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">const</span> str = s.<span class=\"hljs-title function_\">trim</span>();\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-regexp\">/ /</span>.<span class=\"hljs-title function_\">test</span>(str)) <span class=\"hljs-keyword\">return</span> str;\n  <span class=\"hljs-keyword\">const</span> tmp = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item !== <span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-title function_\">reverse</span>();\n  <span class=\"hljs-keyword\">return</span> tmp.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);\n}\n</code></pre>\n"},{"title":"算法复习-队列","tags":["算法"],"categories":"2021复习","description":"## ⽆重复字符的最⻓⼦串\n\n``` js\nfunction lengthOfLongestSubstring(s) {\n  if (s === '') return 0;\n  if (s.length === 1) return 1;\n  let longestStr = '';\n  const queue = new Map();\n  for (let i = 0; i < s.lengt","createDate":"2021-06-08 14:56:29","updateDate":"2021-06-08 22:56:34","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">⽆重复字符的最⻓⼦串</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">lengthOfLongestSubstring</span>(<span class=\"hljs-params\">s</span>) {\n  <span class=\"hljs-keyword\">if</span> (s === <span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">if</span> (s.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> longestStr = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">const</span> queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; s.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">if</span> (queue.<span class=\"hljs-title function_\">has</span>(s[i])) {\n      <span class=\"hljs-keyword\">const</span> newStr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(queue.<span class=\"hljs-title function_\">keys</span>()).<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n      longestStr = newStr.<span class=\"hljs-property\">length</span> &gt; longestStr.<span class=\"hljs-property\">length</span> ? newStr : longestStr;\n      i = queue.<span class=\"hljs-title function_\">get</span>(s[i]) + <span class=\"hljs-number\">1</span>;\n      queue.<span class=\"hljs-title function_\">clear</span>();\n    }\n    queue.<span class=\"hljs-title function_\">set</span>(s[i], i);\n  }\n\n  <span class=\"hljs-keyword\">const</span> newStr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(queue.<span class=\"hljs-title function_\">keys</span>()).<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(newStr.<span class=\"hljs-property\">length</span>, longestStr.<span class=\"hljs-property\">length</span>);\n}\n</code></pre>\n"},{"title":"算法复习-树","tags":["算法","树"],"categories":"2021复习","description":"## BST\n\n二叉搜索树\n\n在⼆叉树的基础上，增加了对⼆叉树上节点存储位置的限制：\n\n- 左子节点值小于父节点的值\n- 右节点的值大于父节点的值\n\n![BST](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/bst.png)\n\n在理想情况下，⼆叉树每多⼀层，可以存储的元素都增加⼀倍。也就是说 n 个元素的⼆叉搜索树，对应的树⾼为 O(logn)。","createDate":"2021-06-13 15:12:50","updateDate":"6/8/2021, 2:52:43 PM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">BST</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>二叉搜索树</p>\n<p>在⼆叉树的基础上，增加了对⼆叉树上节点存储位置的限制：</p>\n<ul>\n<li>左子节点值小于父节点的值</li>\n<li>右节点的值大于父节点的值</li>\n</ul>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/bst.png\" alt=\"BST\"></p>\n<p>在理想情况下，⼆叉树每多⼀层，可以存储的元素都增加⼀倍。也就是说 n 个元素的⼆叉搜索树，对应的树⾼为 O(logn)。所以我们查找元素、插⼊元素的时间也为 O(logn)。当然这是理想情况下，但在实际应⽤中，并不是那么理想，例如⼀直递增或递减的给⼀个⼆叉查找树插⼊数据，那么所有插⼊的元素就会⼀直出现在⼀个树的左节点上，数型结构就会退化为链表结构，时间复杂度就会趋于 O(n)，这是不好的。</p>\n<p>AVL树用来解决这个问题</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AVL</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>平衡搜索二叉树</p>\n<p>在二叉搜索树的基础上满⾜左右⼦树⾼度不⼤于1</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avl.png\" alt=\"AVL\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">红黑树</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>红黑树也是一种特殊的二叉搜索树</p>\n<p>在二叉搜索树的基础上添加以下限制：</p>\n<ul>\n<li>节点是红⾊或⿊⾊</li>\n<li>根节点必须是⿊⾊节点</li>\n<li>所有的叶⼦节点都必须是值为<code>NULL</code>的⿊节点</li>\n<li>如果⼀个节点是红⾊的，则它两个⼦节点都是⿊⾊的</li>\n<li>从任⼀节点到达它的每个叶⼦节点的所有的路径，都有相同数⽬的⿊⾊节点</li>\n</ul>\n"},{"title":"算法复习-链表","tags":["算法"],"categories":"2021复习","description":"一些公用数据结构/函数\n\n``` js\nclass ListNode {\n  constructor(value, next) {\n    this.value = value;\n    this.next = next;\n  }\n}\nfunction list2array(list) {\n  const array = [];\n  let pointer = list;\n  while (p","createDate":"2021-06-06 05:09:34","updateDate":"2021-06-07 13:09:37","body":"<p>一些公用数据结构/函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ListNode</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">value, next</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">next</span> = next;\n  }\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">list2array</span>(<span class=\"hljs-params\">list</span>) {\n  <span class=\"hljs-keyword\">const</span> array = [];\n  <span class=\"hljs-keyword\">let</span> pointer = list;\n  <span class=\"hljs-keyword\">while</span> (pointer !== <span class=\"hljs-literal\">null</span>) {\n    array.<span class=\"hljs-title function_\">push</span>(pointer.<span class=\"hljs-property\">value</span>);\n    pointer = pointer.<span class=\"hljs-property\">next</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> array;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">array2list</span>(<span class=\"hljs-params\">array</span>) {\n  <span class=\"hljs-keyword\">if</span> (array.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">const</span> list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ListNode</span>(array[<span class=\"hljs-number\">0</span>], <span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-keyword\">let</span> pointer = list;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; array.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    pointer.<span class=\"hljs-property\">next</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ListNode</span>(array[i], <span class=\"hljs-literal\">null</span>);\n    pointer = pointer.<span class=\"hljs-property\">next</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> list;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">skipNNodes</span>(<span class=\"hljs-params\">head, n</span>) {\n  <span class=\"hljs-keyword\">let</span> m = n;\n  <span class=\"hljs-keyword\">let</span> pointer = head;\n  <span class=\"hljs-keyword\">while</span> (m &gt; <span class=\"hljs-number\">0</span> &amp;&amp; pointer) {\n    m -= <span class=\"hljs-number\">1</span>;\n    pointer = pointer.<span class=\"hljs-property\">next</span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> pointer;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">合并两个有序链表</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mergeTwoLists</span>(<span class=\"hljs-params\">l1, l2</span>) {\n  <span class=\"hljs-keyword\">const</span> arr1 = <span class=\"hljs-title function_\">list2array</span>(l1);\n  <span class=\"hljs-keyword\">const</span> arr2 = <span class=\"hljs-title function_\">list2array</span>(l2);\n  <span class=\"hljs-keyword\">const</span> res = arr1.<span class=\"hljs-title function_\">concat</span>(arr2).<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a - b);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">array2list</span>(res);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">判断链表是否有环</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hasCycle</span>(<span class=\"hljs-params\">list</span>) {\n  <span class=\"hljs-keyword\">const</span> nodeMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n  <span class=\"hljs-keyword\">let</span> pointer = list;\n  <span class=\"hljs-keyword\">let</span> pos = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">if</span> (pointer === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">if</span> (pointer.<span class=\"hljs-property\">next</span> === <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">while</span> (pointer) {\n    <span class=\"hljs-keyword\">if</span> (nodeMap.<span class=\"hljs-title function_\">has</span>(pointer) &amp;&amp; nodeMap.<span class=\"hljs-title function_\">get</span>(pointer) &lt; pos) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    nodeMap.<span class=\"hljs-title function_\">set</span>(pointer, pos);\n    pointer = pointer.<span class=\"hljs-property\">next</span>;\n    pos += <span class=\"hljs-number\">1</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">反转链表</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverseList</span>(<span class=\"hljs-params\">list</span>) {\n  <span class=\"hljs-keyword\">const</span> arr = <span class=\"hljs-title function_\">list2array</span>(list);\n  <span class=\"hljs-keyword\">const</span> reverseArr = arr.<span class=\"hljs-title function_\">reverse</span>();\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title function_\">array2list</span>(reverseArr);\n  <span class=\"hljs-keyword\">return</span> res;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取链表中间节点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getMiddle</span>(<span class=\"hljs-params\">list</span>) {\n  <span class=\"hljs-keyword\">let</span> pointer2 = list;\n  <span class=\"hljs-keyword\">let</span> pointer1 = list;\n\n  <span class=\"hljs-keyword\">while</span> (pointer2.<span class=\"hljs-property\">next</span> !== <span class=\"hljs-literal\">null</span> &amp;&amp; pointer2.<span class=\"hljs-property\">next</span>.<span class=\"hljs-property\">next</span> !== <span class=\"hljs-literal\">null</span>) {\n    pointer1 = pointer1.<span class=\"hljs-property\">next</span>;\n    pointer2 = pointer2.<span class=\"hljs-property\">next</span>.<span class=\"hljs-property\">next</span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> pointer2.<span class=\"hljs-property\">next</span> &amp;&amp; pointer2.<span class=\"hljs-property\">next</span>.<span class=\"hljs-property\">next</span> === <span class=\"hljs-literal\">null</span> ? pointer1.<span class=\"hljs-property\">next</span> : pointer1;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">移除倒数第n个节点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">removeNthFromEnd</span>(<span class=\"hljs-params\">head, n</span>) {\n  <span class=\"hljs-keyword\">const</span> arr = [];\n  <span class=\"hljs-keyword\">let</span> pointer = head;\n  <span class=\"hljs-keyword\">while</span> (pointer) {\n    arr.<span class=\"hljs-title function_\">push</span>(pointer);\n    pointer = pointer.<span class=\"hljs-property\">next</span>;\n  }\n  <span class=\"hljs-keyword\">const</span> index = arr.<span class=\"hljs-property\">length</span> - n;\n  <span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) {\n    arr[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">next</span> = <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">return</span> arr[<span class=\"hljs-number\">1</span>] || [];\n  }\n  arr[index - <span class=\"hljs-number\">1</span>].<span class=\"hljs-property\">next</span> = arr[index].<span class=\"hljs-property\">next</span>;\n  arr[index].<span class=\"hljs-property\">next</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-keyword\">return</span> head;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">removeNthFromEndPreform</span>(<span class=\"hljs-params\">head, n</span>) {\n  <span class=\"hljs-keyword\">const</span> preHead = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ListNode</span>(<span class=\"hljs-number\">0</span>);\n  preHead.<span class=\"hljs-property\">next</span> = head;\n  <span class=\"hljs-keyword\">let</span> pointer1 = preHead;\n  <span class=\"hljs-keyword\">let</span> pointer2 = <span class=\"hljs-title function_\">skipNNodes</span>(head, n - <span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-keyword\">while</span> (pointer2 &amp;&amp; pointer2.<span class=\"hljs-property\">next</span>) {\n    pointer2 = pointer2.<span class=\"hljs-property\">next</span>;\n    pointer1 = pointer1.<span class=\"hljs-property\">next</span>;\n  }\n  pointer1.<span class=\"hljs-property\">next</span> = pointer1.<span class=\"hljs-property\">next</span>.<span class=\"hljs-property\">next</span>;\n  <span class=\"hljs-keyword\">return</span> preHead.<span class=\"hljs-property\">next</span>;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取两个链表开始相交的节点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getIntersectionNode</span>(<span class=\"hljs-params\">headA, headB</span>) {\n  <span class=\"hljs-keyword\">let</span> pointerA = headA;\n  <span class=\"hljs-keyword\">let</span> pointerB = headB;\n  <span class=\"hljs-keyword\">while</span> (pointerA || pointerB) {\n    <span class=\"hljs-keyword\">if</span> (pointerA === pointerB) <span class=\"hljs-keyword\">return</span> pointerA;\n    pointerA = pointerA === <span class=\"hljs-literal\">null</span> ? headB : pointerA.<span class=\"hljs-property\">next</span>;\n    pointerB = pointerB === <span class=\"hljs-literal\">null</span> ? headA : pointerB.<span class=\"hljs-property\">next</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n}\n</code></pre>\n"},{"title":"算法复习-常见算法","tags":["算法"],"categories":"2021复习","description":"## LRU\n\n``` js\nclass LRUCache {\n  constructor(max) {\n    this.max = max;\n    this.storage = new Map();\n  }\n\n  get(key) {\n    if (!this.storage.has(key)) return -1;\n    const tmp = this.storage.get(k","createDate":"2021-06-05 10:37:45","updateDate":"2021-06-05 18:37:53","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">LRU</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LRUCache</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">max</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">max</span> = max;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n  }\n\n  <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">key</span>) {\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">has</span>(key)) <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">const</span> tmp = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">get</span>(key);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">delete</span>(key);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">set</span>(key, tmp);\n    <span class=\"hljs-keyword\">return</span> tmp;\n  }\n\n  <span class=\"hljs-title function_\">put</span>(<span class=\"hljs-params\">key, value</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">has</span>(key)) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">delete</span>(key);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">size</span> &gt;= <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">max</span>) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">keys</span>().<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);\n    }\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-title function_\">set</span>(key, value);\n  }\n}\n</code></pre>\n"},{"title":"算法复习-数组","tags":["算法"],"categories":"2021复习","description":"## 合并两数组\n\n``` js\nconst first = (arr) => arr[0];\nconst last = (arr) => arr[arr.length - 1];\n\nfunction combineOrderedArrays(arr1, arr2) {\n  if (!Array.isArray(arr1) || !Array.isArray(arr2)) throw new","createDate":"2021-06-05 10:37:05","updateDate":"2021-06-05 18:37:49","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">合并两数组</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">first</span> = (<span class=\"hljs-params\">arr</span>) =&gt; arr[<span class=\"hljs-number\">0</span>];\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">last</span> = (<span class=\"hljs-params\">arr</span>) =&gt; arr[arr.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>];\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">combineOrderedArrays</span>(<span class=\"hljs-params\">arr1, arr2</span>) {\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr1) || !<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr2)) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;parameter must be an array&#x27;</span>);\n  <span class=\"hljs-keyword\">if</span> (arr1.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> arr2;\n  <span class=\"hljs-keyword\">if</span> (arr2.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> arr1;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">first</span>(arr1) &gt;= <span class=\"hljs-title function_\">last</span>(arr2)) <span class=\"hljs-keyword\">return</span> arr1.<span class=\"hljs-title function_\">concat</span>(arr2);\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">first</span>(arr2) &gt;= <span class=\"hljs-title function_\">last</span>(arr1)) <span class=\"hljs-keyword\">return</span> arr2.<span class=\"hljs-title function_\">concat</span>(arr1);\n\n  <span class=\"hljs-keyword\">let</span> index1 = arr1.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> index2 = arr2.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> index = arr1.<span class=\"hljs-property\">length</span> + arr2.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">const</span> res = [...arr1];\n  <span class=\"hljs-keyword\">while</span> (index2 &gt;= <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">if</span> (index1 &lt; <span class=\"hljs-number\">0</span>) {\n      res[index] = arr2[index2];\n      index -= <span class=\"hljs-number\">1</span>;\n      index2 -= <span class=\"hljs-number\">1</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (arr2[index2] &gt; arr1[index1]) {\n        res[index] = arr2[index2];\n        index2 -= <span class=\"hljs-number\">1</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        res[index] = arr1[index1];\n        index1 -= <span class=\"hljs-number\">1</span>;\n      }\n      index -= <span class=\"hljs-number\">1</span>;\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> res;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数组两数之和</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sumOfTwoNumbers</span>(<span class=\"hljs-params\">src, target</span>) {\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(src)) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;src must be an Array&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; src.<span class=\"hljs-property\">length</span>; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">const</span> abs = target - src[i];\n    <span class=\"hljs-keyword\">if</span> (tmp.<span class=\"hljs-title function_\">has</span>(abs)) <span class=\"hljs-keyword\">return</span> [tmp.<span class=\"hljs-title function_\">get</span>(abs), i];\n    tmp.<span class=\"hljs-title function_\">set</span>(src[i], i);\n  }\n  <span class=\"hljs-keyword\">return</span> [];\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数组交集</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">intersection</span>(<span class=\"hljs-params\">arr1, arr2</span>) {\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr1) || !<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(arr2)) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;parameters must be both of Arrays&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr1);\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();\n  arr2.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (tmp.<span class=\"hljs-title function_\">has</span>(item)) res.<span class=\"hljs-title function_\">add</span>(item);\n  });\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(res);\n}\n</code></pre>\n"},{"title":"webpack复习-构建原理","tags":["webpack"],"categories":"2021复习","description":"## 初始化\n\n从配置文件、配置对象、命令行参数、默认配置中计算得到最终的参数，创建`Compiler`初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化`RuleSet`等\n\n## 确定入口\n\n根据配置中的`entry`找到所有入口文件，调用`compilition.addEntry`将入口文件转化为`dependence`对象\n\n## 构建\n\n根据`entry`对应的`depend","createDate":"2021-06-04 06:58:05","updateDate":"2021-06-04 18:07:22","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">初始化</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>从配置文件、配置对象、命令行参数、默认配置中计算得到最终的参数，创建<code>Compiler</code>初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化<code>RuleSet</code>等</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">确定入口</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>根据配置中的<code>entry</code>找到所有入口文件，调用<code>compilition.addEntry</code>将入口文件转化为<code>dependence</code>对象</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">构建</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>根据<code>entry</code>对应的<code>dependence</code>创建<code>module</code>对象，调用<code>loader</code>将模块转译为标准JavaScript内容，调用JavaScript解释器将内容转换为AST对象，从中找出该模块依赖的模块，再递归本步骤直到所有入口依赖文件都经过本步骤的处理。递归完成之后就得到了模块间的依赖关系图</p>\n<p>这个过程中数据流大致是<strong>module =&gt; ast =&gt; dependences =&gt; module</strong>，先转 AST 再从 AST 找依赖。这就要求<code>loaders</code>处理完的最后结果必须是可以被<code>acorn</code>处理的标准 JavaScript 语法，比如说对于图片，需要从图像二进制转换成类似于<code>export default &quot;data:image/png;base64,xxx&quot;</code>这类base64格式或者<code>export default &quot;http://xxx&quot;</code>这类url格式</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生成</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>构建阶段围绕<code>module</code>展开，生成阶段则围绕<code>Chunks</code>展开。经过构建阶段后，webpack已经得到足够的模块内容与模块关系信息，根据入口和模块之间的依赖关系，组装成一个个包含多个模块的<code>Chunk</code>，再把每个<code>Chunk</code>转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</p>\n<p>webpack内置的<code>chunk</code>封装规则：</p>\n<ul>\n<li>entry及entry能触及到的模块，组成一个<code>chunk</code></li>\n<li>使用动态引入语句的模块，各自组合成一个<code>chunk</code></li>\n<li>通过<code>optimization.splitChunks</code>来强制设定公用模块导出为一个<code>chunk</code></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">资源形态流转</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack-transform.png\" alt=\"webpack转换过程\"></p>\n<ul>\n<li><code>compiler.make</code>，将<code>entry</code>以<code>dependence</code>对象形式加入<code>compilation</code>的依赖列表，<code>dependence</code>对象记录有<code>entry</code>的类型、路径等信息。根据<code>dependence</code>调用对应的工厂函数创建<code>module</code>对象，之后读入<code>module</code>对应的文件内容，调用<code>loader-runner</code>对内容转化，转化结果若有其他依赖则继续读入依赖资源，重复此过程直到所有依赖均被转化为<code>module</code></li>\n<li><code>compilation.seal</code>，遍历<code>module</code>集合，根据<code>entry</code>配置及引入资源的方式，将<code>module</code>分配到不同的<code>chunk</code>，遍历<code>chunk</code>集合，调用<code>compilation.emitAsset</code>方法标记<code>chunk</code>的输出规则，即转化为<code>assets</code>集合</li>\n<li><code>compiler.emitAssets</code>，将<code>assets</code>写入文件系统</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://xie.infoq.cn/article/ddca4caa394241447fa0aa3c0\">[万字总结] 一文吃透 Webpack 核心原理</a></p>\n"},{"title":"React.js复习-0","tags":["React.js"],"categories":"2021复习","description":"## 事件合成\n\n### 什么事件合成\n\n在react中，我们绑定的事件`onClick`等，并不是原生事件，而是由原生事件合成的React事件，比如`click`事件合成为`onClick`事件。比如`blur`, `change`, `input`, `keydown`, `keyup`等 , 合成为`onChange`\n\n### 为什么要合成事件\n\n统一管理，消除浏览器差异性\n\n###","createDate":"2021-06-02 10:16:14","updateDate":"2021-06-04 14:26:03","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件合成</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么事件合成</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>在react中，我们绑定的事件<code>onClick</code>等，并不是原生事件，而是由原生事件合成的React事件，比如<code>click</code>事件合成为<code>onClick</code>事件。比如<code>blur</code>, <code>change</code>, <code>input</code>, <code>keydown</code>, <code>keyup</code>等 , 合成为<code>onChange</code></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么要合成事件</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>统一管理，消除浏览器差异性</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件触发流程</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ol>\n<li>执行<code>dispatchEvent</code></li>\n<li>创建事件对应的合成事件<code>SyntheticEvent</code></li>\n<li>收集捕获的回调函数和对应的节点实例</li>\n<li>收集冒泡的回调函数和对应的节点实例</li>\n<li>执行对应的回调函数，同时将<code>SyntheticEvent</code>作为参数传入</li>\n</ol>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注意</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>原生事件的执行先于合成事件</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">路由懒加载/代码分割</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>webpack遇到<code>import()</code>时会将引入的模块打包成独立的bundle （<code>import()</code>函数会返回一个Promise），需要时会异步加载这些bundle</p>\n"},{"title":"React.js复习-一些理念","tags":["React.js"],"categories":"2021复习","description":"## 整体架构\n\n- scheduler（调度器）\n    调度任务的优先级，高优任务优先进入reconciler\n- reconciler（协调器）\n    负责找出发生变化的组件\n- renderer（渲染器）\n    负责将变化的组件渲染到页面上\n    \n## Fiber\n\n具有三种不同的含义\n\n1. 一种架构\n    之前React15的reconciler采用递归的方式执行更新DO","createDate":"2021-05-30 14:41:42","updateDate":"2021-06-01 18:00:03","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">整体架构</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>scheduler（调度器）\n  调度任务的优先级，高优任务优先进入reconciler</li>\n<li>reconciler（协调器）\n  负责找出发生变化的组件</li>\n<li>renderer（渲染器）\n  负责将变化的组件渲染到页面上</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Fiber</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>具有三种不同的含义</p>\n<ol>\n<li>一种架构\n 之前React15的reconciler采用递归的方式执行更新DOM的操作，数据保存在递归调用栈中，所以被称为<strong>stack Reconciler</strong>。React16的reconciler基于Fiber节点实现，被称为<strong>Fiber Reconciler</strong></li>\n<li>一种数据结构\n 每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息</li>\n<li>一个执行任务（工作单元）\n 每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">FiberNode</span>(<span class=\"hljs-params\">\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: <span class=\"hljs-literal\">null</span> | string,\n  mode: TypeOfMode,\n</span>) {\n  <span class=\"hljs-comment\">// 作为静态数据结构的属性</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">tag</span> = tag;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span> = key;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">elementType</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">type</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stateNode</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-comment\">// 用于连接其他Fiber节点形成Fiber树</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">return</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">child</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sibling</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">index</span> = <span class=\"hljs-number\">0</span>;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-comment\">// 作为动态的工作单元的属性</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingProps</span> = pendingProps;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">memoizedProps</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">updateQueue</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">memoizedState</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">dependencies</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mode</span> = mode;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">effectTag</span> = <span class=\"hljs-title class_\">NoEffect</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">nextEffect</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstEffect</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastEffect</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-comment\">// 调度优先级相关</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lanes</span> = <span class=\"hljs-title class_\">NoLanes</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">childLanes</span> = <span class=\"hljs-title class_\">NoLanes</span>;\n\n  <span class=\"hljs-comment\">// 指向该fiber在另一次更新时对应的fiber</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">alternate</span> = <span class=\"hljs-literal\">null</span>;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Fiber Reconciler</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>分为两个阶段，<code>commit</code>和<code>render</code></p>\n<ul>\n<li><code>commit</code>\n  可中断，生成fiber树，收集effect</li>\n<li><code>render</code>\n  不可中断，根据收集到的effect更新DOM，执行一些生命周期函数和hooks（<code>useEffect</code>在渲染中之后执行）</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">jsx vs fiber</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>JSX是一种描述当前组件内容的数据结构，它不包含组件<code>schedule</code>、<code>reconcile</code>、<code>render</code>所需的相关信息。</p>\n<p>在组件<strong>mount</strong>时，<code>Reconciler</code>根据JSX描述的组件内容生成组件对应的<code>Fiber</code>节点。</p>\n<p>在<strong>update</strong>时，<code>Reconciler</code>将JSX与<code>Fiber</code>节点保存的数据对比，生成组件对应的<code>Fiber</code>节点，并根据对比结果为<code>Fiber</code>节点打上标记</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">初次渲染流程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">更新流程</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>调用数据更新的方法(<code>this.setState</code>/<code>useState返回的更新方法</code>)</li>\n<li>进入<strong>render</strong>阶段</li>\n<li>采用<strong>DFS</strong>创建fiber树</li>\n<li>采用<strong>reconcile算法</strong>标记变化</li>\n<li>进入<strong>commit</strong>阶段</li>\n<li>执行4中变化对应的视图操作</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://react.iamkasong.com/\">React技术揭秘</a></p>\n"},{"title":"JavaScript复习-JavaScript的执行过程","tags":["JavaScript的执行过程"],"categories":"2021复习","description":"JavaScript代码在执行时，首先创建一个**全局可执行上下文（`GlobalContext`）**，每当执行到一个函数调用时都会创建一个**可执行上下文（`ExecutionContext`）EC**。当然程序可能存在很多函数调用，那么就会创建很多EC，所以JavaScript引擎创建了**执行上下文栈（`ExecutionConetxtStack`）ECS**来管理执行上下文。当函数调","createDate":"2021-05-28 02:22:06","updateDate":"2021-05-28 16:36:52","body":"<p>JavaScript代码在执行时，首先创建一个<strong>全局可执行上下文（<code>GlobalContext</code>）</strong>，每当执行到一个函数调用时都会创建一个<strong>可执行上下文（<code>ExecutionContext</code>）EC</strong>。当然程序可能存在很多函数调用，那么就会创建很多EC，所以JavaScript引擎创建了<strong>执行上下文栈（<code>ExecutionConetxtStack</code>）ECS</strong>来管理执行上下文。当函数调用完成，JavaScript会退出这个执行环境并把这个环境销毁，回到上一个执行环境...。这个过程反复执行，直到执行栈中的代码全部执行完毕。</p>\n<p>执行上下文的创建阶段主要负责三件事：</p>\n<ol>\n<li><code>this</code></li>\n<li>Lexical Environment</li>\n<li>Variable Environment</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">词法环境</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>词法环境（Lexical Environment）：作用于词法分析阶段。包含两部分：</p>\n<ol>\n<li>Environment Record（环境记录）是一个以全部局部变量为属性的对象（以及其他如 this 值的信息）。</li>\n<li>对 outer lexical environment（外部词法环境）的引用，通常关联词法上的外面一层代码（花括号外一层）。</li>\n</ol>\n<p>词法环境是在代码定义的时候决定的，跟代码在哪⾥调⽤没有关系</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 全局执⾏上下⽂</span>\n<span class=\"hljs-title class_\">GlobalExectionContext</span> = {\n  <span class=\"hljs-comment\">// 词法环境</span>\n  <span class=\"hljs-title class_\">LexicalEnvironment</span>: {\n    <span class=\"hljs-comment\">// 环境记录</span>\n    <span class=\"hljs-title class_\">EnvironmentRecord</span>: {\n      <span class=\"hljs-title class_\">Type</span>: <span class=\"hljs-string\">&quot;Object&quot;</span>, <span class=\"hljs-comment\">// 全局环境</span>\n      <span class=\"hljs-comment\">// ... 标识符绑定在这⾥</span>\n      <span class=\"hljs-attr\">outer</span>: &lt;<span class=\"hljs-literal\">null</span>&gt;, <span class=\"hljs-comment\">// 对外部环境的引⽤</span>\n    }\n  }\n}\n<span class=\"hljs-comment\">// 函数执⾏上下⽂</span>\n<span class=\"hljs-title class_\">FunctionExectionContext</span> = {\n  <span class=\"hljs-title class_\">LexicalEnvironment</span>: {\n    <span class=\"hljs-title class_\">EnvironmentRecord</span>: {\n      <span class=\"hljs-title class_\">Type</span>: <span class=\"hljs-string\">&quot;Declarative&quot;</span>,<span class=\"hljs-comment\">// 函数环境</span>\n      <span class=\"hljs-comment\">// ... 标识符绑定在这⾥</span>\n      <span class=\"hljs-comment\">// 对全局环境或外部函数环境的引⽤</span>\n      <span class=\"hljs-attr\">outer</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Global</span> <span class=\"hljs-attr\">or</span> <span class=\"hljs-attr\">outer</span> <span class=\"hljs-attr\">function</span> <span class=\"hljs-attr\">environment</span> <span class=\"hljs-attr\">reference</span>&gt;</span>,\n    }\n  }\n}</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">词法环境与闭包</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） --MDN</p>\n</blockquote>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">变量环境</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>为了继续去适配早期JavaScript的<code>var</code>等，ES6增加了<strong>变量环境（Variable Environment）</strong>。变量环境也是一个词法环境，其环境记录器包含有变量声明语句</p>\n<p>在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量(<code>let</code>和<code>const</code>)绑定，而后者仅用于存储变量(<code>var</code>)绑定</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">20</span>;\n<span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-number\">30</span>;\n<span class=\"hljs-keyword\">var</span> c;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">multiply</span>(<span class=\"hljs-params\">e, f</span>){\n  <span class=\"hljs-keyword\">var</span> g = <span class=\"hljs-number\">20</span>;\n  <span class=\"hljs-keyword\">return</span> e*f*g;\n}\nc = <span class=\"hljs-title function_\">multiply</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>);\n</code></pre>\n<p>词法构成</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 全局执⾏上下⽂</span>\n<span class=\"hljs-title class_\">GlobalExectionContext</span> = {\n  <span class=\"hljs-title class_\">ThisBinding</span>: &lt; <span class=\"hljs-title class_\">Global</span> <span class=\"hljs-title class_\">Object</span> &gt; ,\n  <span class=\"hljs-comment\">// 词法环境</span>\n  <span class=\"hljs-title class_\">LexicalEnvironment</span>: {\n    <span class=\"hljs-title class_\">EnvironmentRecord</span>: {\n      <span class=\"hljs-title class_\">Type</span>: <span class=\"hljs-string\">&quot;Object&quot;</span>,\n      <span class=\"hljs-comment\">// 标识符绑定，let、const、函数声明</span>\n      <span class=\"hljs-attr\">a</span>: &lt; uninitialized &gt; ,\n      <span class=\"hljs-attr\">b</span>: &lt; uninitialized &gt; ,\n      <span class=\"hljs-attr\">multiply</span>: &lt; func &gt;\n    }\n    <span class=\"hljs-attr\">outer</span>: &lt; <span class=\"hljs-literal\">null</span> &gt;\n  },\n  <span class=\"hljs-comment\">// 变量环境</span>\n  <span class=\"hljs-title class_\">VariableEnvironment</span>: {\n    <span class=\"hljs-title class_\">EnvironmentRecord</span>: {\n      <span class=\"hljs-title class_\">Type</span>: <span class=\"hljs-string\">&quot;Object&quot;</span>,\n      <span class=\"hljs-comment\">// 标识符绑定，var 声明</span>\n      <span class=\"hljs-attr\">c</span>: <span class=\"hljs-literal\">undefined</span>,\n    }\n    <span class=\"hljs-attr\">outer</span>: &lt; <span class=\"hljs-literal\">null</span> &gt;\n  }\n}\n\n<span class=\"hljs-comment\">// 函数执⾏上下⽂</span>\n<span class=\"hljs-title class_\">FunctionExectionContext</span> = {\n  <span class=\"hljs-title class_\">ThisBinding</span>: &lt; <span class=\"hljs-title class_\">Global</span> <span class=\"hljs-title class_\">Object</span> &gt; ,\n  <span class=\"hljs-title class_\">LexicalEnvironment</span>: {\n    <span class=\"hljs-title class_\">EnvironmentRecord</span>: {\n      <span class=\"hljs-title class_\">Type</span>: <span class=\"hljs-string\">&quot;Declarative&quot;</span>,\n      <span class=\"hljs-comment\">// 标识符绑定</span>\n      <span class=\"hljs-title class_\">Arguments</span>: {\n        <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">20</span>,\n        <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">30</span>,\n        <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">2</span>\n      },\n    },\n    <span class=\"hljs-attr\">outer</span>: &lt; <span class=\"hljs-title class_\">GlobalLexicalEnvironment</span> &gt;\n  },\n  <span class=\"hljs-title class_\">VariableEnvironment</span>: {\n    <span class=\"hljs-title class_\">EnvironmentRecord</span>: {\n      <span class=\"hljs-title class_\">Type</span>: <span class=\"hljs-string\">&quot;Declarative&quot;</span>,\n      <span class=\"hljs-comment\">// 在这⾥绑定标识符</span>\n      <span class=\"hljs-attr\">g</span>: <span class=\"hljs-literal\">undefined</span>\n    },\n    <span class=\"hljs-attr\">outer</span>: &lt; <span class=\"hljs-title class_\">GlobalLexicalEnvironment</span> &gt;\n  }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\">MDN-闭包</a></p>\n<p><a href=\"https://hondrytravis.github.io/docs/typescript/javascript_workflow/\">JS | 执行调度过程</a></p>\n"},{"title":"前端架构&软实力复习-图片预加载&懒加载","tags":["预加载","懒加载"],"categories":"2021复习","description":"## 预加载\n\n`new`一个新的`Image`，给`Image`的`src`赋值为真正的`src`；该`Image`在加载完毕后相应的图片资源就会在本地缓存\n\n## 懒加载\n\n首先设置一个把`src`设置为临时的`data-src`属性，`src`设置为一个loading图，待当前元素出现在视口后用`data-src`替换`src`\n\n可供实现的方案：\n\n- `window.onscroll","createDate":"2021-05-27 10:17:46","updateDate":"2021-05-27 18:42:04","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">预加载</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>new</code>一个新的<code>Image</code>，给<code>Image</code>的<code>src</code>赋值为真正的<code>src</code>；该<code>Image</code>在加载完毕后相应的图片资源就会在本地缓存</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">懒加载</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>首先设置一个把<code>src</code>设置为临时的<code>data-src</code>属性，<code>src</code>设置为一个loading图，待当前元素出现在视口后用<code>data-src</code>替换<code>src</code></p>\n<p>可供实现的方案：</p>\n<ul>\n<li><p><code>window.onscroll（节流）</code> + <code>clientTop</code> + <code>offsetTop</code> + <code>clientHieght</code> + <code>scrollTop</code></p>\n<p>  不容易判断元素位置</p>\n</li>\n<li><p><code>widnow.onscroll（节流）</code> + <code>Element.getBoundingClientRect()</code></p>\n<p>  <code>getBoundingClientRect()</code>会触发回流</p>\n</li>\n<li><p><code>IntersectionObserver</code> + <a href=\"https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/IntersectionObserver/polyfill.js\">polyfill</a></p>\n</li>\n<li><p><code>img</code>的<code>lazy</code>属性</p>\n<p>  兼容性差</p>\n</li>\n</ul>\n<p>以<code>IntersectionObserver</code>为实现方案：</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;height: 100vh;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;img&quot;</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avatar.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">srcset</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IntersectionObserver</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">changes</span>) =&gt;</span> {\n      changes.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">change</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (change.<span class=\"hljs-property\">isIntersecting</span>) {\n          <span class=\"hljs-keyword\">const</span> img = change.<span class=\"hljs-property\">target</span>;\n          img.<span class=\"hljs-property\">src</span> = img.<span class=\"hljs-property\">dataset</span>.<span class=\"hljs-property\">src</span>;\n          <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(img.<span class=\"hljs-property\">dataset</span>, <span class=\"hljs-string\">&#x27;src&#x27;</span>);\n          observer.<span class=\"hljs-title function_\">unobserve</span>(img);\n        }\n      })\n    });\n    observer.<span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#img&#x27;</span>));\n  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n      <span class=\"hljs-comment\">// todo 添加节流</span>\n     <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;scroll&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> innerHeight = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">innerHeight</span> || <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">documentElement</span>.<span class=\"hljs-property\">clientHeight</span> || <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">clientHeight</span>;\n      <span class=\"hljs-keyword\">const</span> img = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#img&quot;</span>);\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(img.<span class=\"hljs-property\">dataset</span>.<span class=\"hljs-property\">src</span>);\n      <span class=\"hljs-keyword\">const</span> { left, right, top, bottom } = img.<span class=\"hljs-title function_\">getBoundingClientRect</span>();\n      <span class=\"hljs-keyword\">if</span> (innerHeight &gt; top &amp;&amp; bottom &gt; -<span class=\"hljs-number\">30</span>) {\n        img.<span class=\"hljs-property\">src</span> = img.<span class=\"hljs-property\">dataset</span>.<span class=\"hljs-property\">src</span>;\n        <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(img.<span class=\"hljs-property\">dataset</span>, <span class=\"hljs-string\">&#x27;src&#x27;</span>);\n      }\n    })\n  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n"},{"title":"CSS复习-盒模型","tags":["CSS"],"categories":"2021复习","description":"> 可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）","createDate":"2021-05-25 02:33:01","updateDate":"2021-05-25 11:09:13","body":"<blockquote>\n<p>可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。</p>\n</blockquote>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/box-model.png\" alt=\"盒模型\"></p>\n<p>盒模型的各个部分</p>\n<ul>\n<li>Context，用来显示内容，可通过<code>width</code>和<code>height</code>来设置大小</li>\n<li>Padding，包围在内容区域外部的空白区域，可通过<code>padding</code>来设置大小</li>\n<li>Border，包裹<code>Content</code>和<code>padding</code>，可通过<code>border</code>来设置</li>\n<li>Margin，最外面的区域，是盒子和其他元素之间的空白区域，通过<code>margin</code>来设置</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">标准盒模型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在标准盒模型中，如果你给盒设置<code>width</code>和<code>height</code>，实际上设置的是<code>Content</code>的大小。<code>padding</code>+<code>border</code>+<code>margin</code>再加上设置的<code>width</code>和<code>height</code>才是盒子的大小</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/box-model-1.png\" alt=\"标准盒模型\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">替代（IE）盒模型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的! 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/box-model-2.png\" alt=\"标准盒模型\"></p>\n<p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 <code>box-sizing: border-box</code> 来实现。</p>\n<p>如果你希望所有元素都使用替代模式，而且确实很常用，设置 box-sizing 在<code>&lt;html&gt;</code>元素上，然后设置所有元素继承该属性</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">html</span> {\n  <span class=\"hljs-attribute\">box-sizing</span>: border-box;\n}\n*, *<span class=\"hljs-selector-pseudo\">::before</span>, *<span class=\"hljs-selector-pseudo\">::after</span> {\n  <span class=\"hljs-attribute\">box-sizing</span>: inherit;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">外边框折叠</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model\">盒模型</a></p>\n<p><a href=\"https://juejin.cn/post/6844903505983963143\">CSS盒模型详解</a></p>\n"},{"title":"浏览器复习-架构","tags":["浏览器架构"],"categories":"2021复习","description":"## 浏览器是多进程的\n\n浏览器主要包含以下进程：\n\n- `browser`进程，浏览器的主进程，负责协调各进程；有且只有一个\n    - 负责浏览器界面的显示，与用户交互（前进/后退等）\n    - 负责各个页面的管理，创建和销毁其他进程\n    - 将`render`进程得到的内存中的位图绘制到用户界面上\n    - 网络资源的下载与管理等\n- 第三方插件进程，每种类型的插件对应一个进程，","createDate":"2021-05-24 04:58:32","updateDate":"2021-05-24 22:02:57","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器是多进程的</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>浏览器主要包含以下进程：</p>\n<ul>\n<li><code>browser</code>进程，浏览器的主进程，负责协调各进程；有且只有一个<ul>\n<li>负责浏览器界面的显示，与用户交互（前进/后退等）</li>\n<li>负责各个页面的管理，创建和销毁其他进程</li>\n<li>将<code>render</code>进程得到的内存中的位图绘制到用户界面上</li>\n<li>网络资源的下载与管理等</li>\n</ul>\n</li>\n<li>第三方插件进程，每种类型的插件对应一个进程，仅当使用该插件时创建</li>\n<li>GUI进程，最多只有一个，用户3D图形的绘制</li>\n<li><code>render</code>进程（浏览器内核），默认为一个tab页一个进程，互不影响<ul>\n<li>页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器使用多线程的优势</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>避免单个page crash后影响到整个浏览器</li>\n<li>避免第三方插件crash后影响到整个浏览器</li>\n<li>多进程充分利用多核cpu优势</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器内核（render进程）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>浏览器核心，页面渲染、JavaScript执行等都在这个进程内执行，主要包含以下线程：</p>\n<ul>\n<li>渲染线程\n  负责渲染页面。解析html构建dom树，解析css构建cssom树，合并成为render树，布局，绘制，合成等。与JavaScript引擎互斥</li>\n<li>JavaScript引擎线程\n  负责解释执行事件循环队列中的JavaScript代码。与渲染线程互斥</li>\n<li>事件触发线程\n  专注于处理event-loop</li>\n<li>定时器触发线程\n  <code>setTimeout</code>与<code>setInteval</code></li>\n<li>异步http请求线程\n  发送<code>http</code>请求</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一些问题</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>渲染线程与JavaScript引擎线程互斥？</p>\n<p>  为了防止在渲染线程工作时JavaScript修改DOM造成显示出错的问题</p>\n</li>\n<li><p>CSS加载不会阻塞DOM树构建，会阻塞render树构建</p>\n</li>\n<li></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://juejin.cn/post/6844903553795014663\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>\n"},{"title":"网络复习-https","tags":["https"],"categories":"2021复习","description":"> HTTPS （安全的HTTP）是 HTTP 协议的加密版本。它通常使用 SSL 者 TLS 来加密客户端和服务器之间所有的通信 。这安全的链接允许客户端与服务器安全地交换敏感的数据，例如网上银行或者在线商城等涉及金钱的操作。\n\n![https](http://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-5.png)\n\n## https和http的","createDate":"2021-05-24 06:39:38","updateDate":"2021-05-24 15:29:28","body":"<blockquote>\n<p>HTTPS （安全的HTTP）是 HTTP 协议的加密版本。它通常使用 SSL 者 TLS 来加密客户端和服务器之间所有的通信 。这安全的链接允许客户端与服务器安全地交换敏感的数据，例如网上银行或者在线商城等涉及金钱的操作。</p>\n</blockquote>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-5.png\" alt=\"https\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">https和http的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>http是明文传输，https使用ssl/tsl加密传输</li>\n<li>http的端口是80，https的端口是443</li>\n<li>https需要ca证书</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么需要https</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>安全</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">https的原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单来讲https的发展过程是：http -&gt; 对称加密 -&gt; 非对称加密 -&gt; 混合加密 -&gt; CA证书</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对称加密</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>http的通信是明文的，相当于在网络上裸奔，任何人或组织都可以监听、窥探数据，安全性较差，此时对称加密出现了：每次传输之前，发送方用一个加密算法加密，然后再发送；接收方使用加密算法对应的密钥进行解密。因为加密/解密使用的是同一个密钥，因此称为对称加密</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-0.png\" alt=\"对称加密\"></p>\n<p>弊端：<strong>密钥容易被截取</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">非对称加密</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用非对称加密的双方都有一对密钥：私钥（保密）、公钥（公开）。使用公钥加密的数据只有对应的私钥才能解密；</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-1.png\" alt=\"非对称加密\"></p>\n<p>弊端：<strong>速度较慢，相较于对称加密算法，非对称加密算法的速度要慢上百倍</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">混合加密（非对称加密+对称加密）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用非对称密钥加密对称密钥的密钥，然后使用对称加密通信</p>\n<p>弊端：还是不能确保接收人的身份，容易受到<strong>中间人攻击</strong></p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-2.png\" alt=\"中间人攻击\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CA证书</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>解决中间人攻击。相当于一个公证处，所有服务器均需要在机构注册备案，然后机构会派发一个CA证书来表示该服务器是安全的</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-4.png\" alt=\"https传输流程\"></p>\n<p>在第三步浏览器校验证书时：浏览器会根据自身保存的CA公钥来验证服务器的身份</p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/https-ca.png\" alt=\"ca证书验证流程\"></p>\n"},{"title":"前端架构&软实力复习-移动端适配","tags":["移动端适配"],"categories":"2021复习","description":"## 移动端适配的具体含义\n\n为了在移动端让页面获得更好的显示效果，我们必须让**布局视口(宽度)=视觉视口(宽度)=理想视口(宽度)**。但一般情况下它们并不一致，因此我们需要一种方案 ~~(rem+vw)~~ 来让设计稿得到更完美的适配。\n\n## 三个视口\n\n### 布局视口\n\n![布局视口](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/la","createDate":"2021-05-18 14:06:04","updateDate":"2021-05-18 23:21:35","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">移动端适配的具体含义</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>为了在移动端让页面获得更好的显示效果，我们必须让**布局视口(宽度)=视觉视口(宽度)=理想视口(宽度)**。但一般情况下它们并不一致，因此我们需要一种方案 <del>(rem+vw)</del> 来让设计稿得到更完美的适配。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">三个视口</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">布局视口</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/layout_viewport.png\" alt=\"布局视口\"></p>\n<p>布局视口(<code>layout viewport</code>):当我们以百分比来之当一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。</p>\n<p>所以，布局视口是网页布局的基准窗口，在PC浏览器上，布局视口就等于当前浏览器的窗口大小（不包含滚动条、标签栏等）</p>\n<p>在移动端，布局视口被赋予一个默认值，大部分是<strong>980px</strong>，这保证PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大</p>\n<p>我们可以使用<code>document.documentElement.clientWidth/clientWidth</code>来获取布局视口的大小</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">视觉视口</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/visual_viewport.png\" alt=\"视觉视口\"></p>\n<p>视觉视口(<code>visual viewport</code>): 用户通过屏幕真是看到的区域</p>\n<p>视觉视口默认等于当前浏览器的窗口大小（包括滚动条等）</p>\n<p>当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是<strong>缩放会改变视觉视口的大小</strong></p>\n<p>例如：用户将浏览器窗口放大了200%，这时浏览器窗口中的CSS像素会随着视觉视口的放大而放大，这时一个CSS像素会跨域更多的物理像素</p>\n<p>所以，布局视口会限制你的CSS布局，而视觉视口决定着用户具体能看到什么</p>\n<p>我们可以使用<code>window.innerWidth/innerHeight</code>来获取视觉视口的大小</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">理想视口</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(<code>ideal viewport</code>)就诞生了：网页在移动端展示的理想大小=设备独立像素</p>\n<p>当页面缩放比例为100%时，<strong>CSS像素=设备独立像素，理想视口=视觉视口</strong></p>\n<p>我们可以通过调用<code>screen.width/height</code>来获得理想视口的大小</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">meta viewport</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>meta</code>元素可提供相关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p>\n<p>我们可以借助<code>meta</code>元素的<code>viewport</code>来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;with=device-width; initial-scale=1; maxomum-scale=1; minmum-scale=1; user-scale=no;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">meta</span>&gt;</span>\n</code></pre>\n<p><code>device-width</code>就是理想视口的宽度，<code>with=device-width</code>就相当于让布局视口等于理想视口</p>\n<p>由于<code>initial-scale = 理想视口宽度  / 视觉视口宽度</code>，所以设置<code>initial-scale=1</code>就相当于让视觉视口等于理想视口</p>\n<p>这时，1个CSS像素就等于一个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><del>rem + vw适配</del></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>突然写不下去了，不同屏幕下应该显示不同的内容，<strong>屏幕大应该是显示更多的ui而不是更大的ui</strong>。等看到牛逼的文章再回来补充</p>\n"},{"title":"浏览器相关-安全","tags":["安全"],"categories":"浏览器","description":"## XSS\n\nXSS(cross-site scripting)，跨站脚本攻击（缩写和CSS重叠，所以称之为XSS）。XSS指的是通过存在安全漏洞的web网站注册用户的**浏览器**内**自动运行非法的HTML标签或JavaScript**进行的一种攻击\n\n如果 Web 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读","createDate":"2020-04-08 23:15:51","updateDate":"2021-05-16 22:46:58","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">XSS</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>XSS(cross-site scripting)，跨站脚本攻击（缩写和CSS重叠，所以称之为XSS）。XSS指的是通过存在安全漏洞的web网站注册用户的<strong>浏览器</strong>内<strong>自动运行非法的HTML标签或JavaScript</strong>进行的一种攻击</p>\n<p>如果 Web 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取 cookie，session tokens，或者其它敏感的网站信息，或者让恶意脚本重写<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/HTML\">HTML</a>内容。</p>\n<p>XSS可能会造成以下影响：</p>\n<ul>\n<li>利用虚假表单骗取用户个人信息</li>\n<li>利用脚本窃取用户的cookie值，被害者在不知情的情况下帮助攻击者发送恶意请求</li>\n<li>显示伪造的文章或图片</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">存储型XSS</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>注入型脚本永久<strong>存储在目标服务器上</strong>。当浏览器请求数据时，脚本从服务器上传回并执行。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">反射性XSS</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>当<strong>用户点击</strong>一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自&quot;可信任&quot;的服务器，所以会执行这段脚本。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何防御</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p>CSP</p>\n<p>建立白名单，明确告诉浏览器那些外部资源可以进行加载和执行。</p>\n<ol>\n<li><p>设置<code>HTTP Header</code>中的<code>Content-Security-Policy</code></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- 只允许加载本站资源 --&gt;</span>\nContent-Security-Policy: default-src &#x27;self&#x27;\n\n<span class=\"hljs-comment\">&lt;!-- 只允许加载HTTPS图片 --&gt;</span>\nContent-Security-Policy: img-src https://*\n</code></pre>\n</li>\n<li><p>设置<code>meta</code>标签</p>\n</li>\n</ol>\n</li>\n<li><p>转义字符</p>\n<p>对引号、尖括号、斜杠进行转义</p>\n</li>\n<li><p>httponly cookie</p>\n<p>这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CSRF</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/csrf.png\" alt=\"CSRF原理\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何防御</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>防范 CSRF 攻击可以遵循以下几种规则：</p>\n<ul>\n<li>Get 请求不对数据进行修改</li>\n<li>不让第三方网站访问到用户 Cookie</li>\n<li>阻止第三方网站请求接口</li>\n<li>请求时附带验证信息，比如验证码或者 Token</li>\n</ul>\n<ol>\n<li><p>samesite</p>\n<p>可以对 Cookie 设置 SameSite 属性。该属性表示 <strong>Cookie 不随着跨域请求发送</strong>，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>\n</li>\n<li><p>referer check</p>\n<p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以<strong>通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击</strong>。</p>\n<p>但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。</p>\n</li>\n<li><p>anti CSRF token</p>\n<p>目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>\n<p><strong>这种方法相比Referer检查要安全很多</strong>，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。</p>\n</li>\n<li><p>验证码</p>\n<p>在关键业务点设置验证码</p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">点击劫持</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <strong>iframe</strong> 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何防御</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p>X-FRAME-OPTIONS</p>\n<p><code>X-FRAME-OPTIONS</code>是一个 HTTP 响应头，三个值可选，分别是</p>\n<ul>\n<li>DENY，表示页面不允许通过 iframe 的方式展示</li>\n<li>SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示</li>\n<li>ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示</li>\n</ul>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">URL跳转漏洞</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">SQL注入</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>\n<p>SQL注入必备条件：</p>\n<ol>\n<li>可以控制输入的数据</li>\n<li>服务器要执行的代码拼接了控制的数据</li>\n</ol>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何防御</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p><strong>严格限制Web应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>\n</li>\n<li><p><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>\n</li>\n<li><p><strong>对进入数据库的特殊字符（&#39;，&quot;，\\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换</strong>。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。</p>\n</li>\n<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。</p>\n</li>\n</ul>\n"},{"title":"浏览器相关-缓存","tags":["缓存"],"categories":"浏览器","description":"对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据\n\n缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在","createDate":"2019-06-30 15:29:59","updateDate":"2021-05-16 15:24:15","body":"<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据</p>\n<p>缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">缓存位置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>Service Worker</p>\n<p>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>\n<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p>\n</li>\n<li><p>Memory Cache</p>\n<p>Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>\n<p>当访问过页面以后，再次刷新页面，可 以发现很多数据都来自于内存缓存</p>\n</li>\n<li><p>Disk Cache</p>\n<p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p>\n<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p>\n</li>\n<li><p>Push Cache</p>\n<p>Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">缓存策略</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>\n<ol>\n<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果及缓存标识</li>\n<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>\n</ol>\n<ul>\n<li>浏览器在加载资源时，先根据这个资源的一些http  header判断它是否命中强缓存，强缓存如果命中，浏览器会直接从自己的缓存中读取资源，不会发送请求到浏览器</li>\n<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器依据资源的另外一些http      header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</li>\n<li>强缓存与协商缓存的共同点时：如果命中都是从客户端缓存中加载资源，而不是从服务器加载资源数据，区别是：强缓存不发送请求到服务器，协商缓存会发送请求到服务器</li>\n<li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据</li>\n</ul>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_cache.png\" alt=\"cache流程\"></p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>强缓存</strong></span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>强缓存可以通过设置两种 HTTP Header 实现：<strong>Expires</strong> <strong>和</strong> <strong>Cache-Control</strong> 。强缓存表示在缓存期间不需要请求，state code 为 200</p>\n<ul>\n<li><p>Expires</p>\n<p>Expires: Wed, 22 Oct 2018 08:41:00 GMT</p>\n<p>Expires 是 HTTP/1 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n</li>\n<li><p>Cache-control</p>\n<p>Cache-control: max-age=30</p>\n<p>Cache-Control 出现于 HTTP/1.1，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求。</p>\n<p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/cache_1.png\" alt=\"cache header字段\"></p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>协商缓存</strong></span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段而不关心服务端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那么此时就需要协商缓存来确定服务端内容是否发生更新。</p>\n<p>协商缓存就是在强缓存失效后，浏览器携带标识向服务器发起请求，由服务器根据缓存不碍事决定是否使用缓存的过过程。协商缓存可通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p>\n<ul>\n<li><p>Last-Modified 和 If-Modified-Since</p>\n<p>Last-Modified 会随着第一次访问资源时返回（该资源在浏览器上最后的修改日期）。浏览器再次请求该资源时，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码-即命中缓存</p>\n<p>弊端：</p>\n<ol>\n<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li>\n<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>\n</ol>\n</li>\n<li><p>ETag 和 If-None-Match</p>\n<p>ETag 类似于文件指纹，，会随着第一次访问资源时返回（浏览器生成）。浏览器再次请求该资源时，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">实际使用场景</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>频繁变动的资源</p>\n<p>对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>\n</li>\n<li><p>代码文件</p>\n<p>一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。</p>\n</li>\n</ul>\n"},{"title":"about","tags":["about"],"categories":"other","description":"## 技术栈\n\n- 前端向：基础、React.js、微信小程序、TypeScript、Docker、webpack\n\n- 后端向：基础、Node.js\n\n## Email\n\nmrrs878@foxmail.com\n\n## Github\n\n[https://github.com/mrrs878](https://github.com/mrrs878)","createDate":"2020-11-27 06:52:03","updateDate":"2021-05-15 12:21:35","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">技术栈</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>前端向：基础、React.js、微信小程序、TypeScript、Docker、webpack</p>\n</li>\n<li><p>后端向：基础、Node.js</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Email</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"mailto:&#109;&#114;&#114;&#115;&#x38;&#55;&#56;&#64;&#102;&#111;&#x78;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;\">&#109;&#114;&#114;&#115;&#x38;&#55;&#56;&#64;&#102;&#111;&#x78;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Github</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://github.com/mrrs878\">https://github.com/mrrs878</a></p>\n"},{"title":"JavaScript相关-2","tags":["Javascript","基础"],"categories":"JavaScript","description":"## Promise\n\n**WHAT**\n\n**Promise** 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.\n\n异步编程的一种解决方案\n\n`Promise`可能处于以下三个状态之一：`fulfilled`、`rejected`、`pending`。用户可以对`Promise`添加回调函数来处理操作成功的结果或失败的原因\n\n**WHY**\n\n传统的异步编程缺点难以忍受:","createDate":"2020-02-12 22:53:13","updateDate":"2021-05-13 17:47:54","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong></p>\n<p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.</p>\n<p>异步编程的一种解决方案</p>\n<p><code>Promise</code>可能处于以下三个状态之一：<code>fulfilled</code>、<code>rejected</code>、<code>pending</code>。用户可以对<code>Promise</code>添加回调函数来处理操作成功的结果或失败的原因</p>\n<p><strong>WHY</strong></p>\n<p>传统的异步编程缺点难以忍受:</p>\n<ul>\n<li>代码臃肿</li>\n<li>可读性差</li>\n<li>耦合度过高，可维护性差</li>\n<li>代码复用性差</li>\n<li>只能在回调里处理异常</li>\n</ul>\n<pre><code class=\"hljs language-javascript\">请求<span class=\"hljs-number\">1</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">请求结果<span class=\"hljs-number\">1</span></span>){\n    请求<span class=\"hljs-number\">2</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">请求结果<span class=\"hljs-number\">2</span></span>){\n        请求<span class=\"hljs-number\">3</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">请求结果<span class=\"hljs-number\">3</span></span>){\n            请求<span class=\"hljs-number\">4</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">请求结果<span class=\"hljs-number\">4</span></span>){\n                请求<span class=\"hljs-number\">5</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">请求结果<span class=\"hljs-number\">5</span></span>){\n                    请求<span class=\"hljs-number\">6</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">请求结果<span class=\"hljs-number\">6</span></span>){\n                        ...\n                    })\n                })\n            })\n        })\n    })\n})\n\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(请求<span class=\"hljs-number\">1</span>)\n    .<span class=\"hljs-title function_\">then</span>(请求<span class=\"hljs-number\">2</span>(请求结果<span class=\"hljs-number\">1</span>))\n    .<span class=\"hljs-title function_\">then</span>(请求<span class=\"hljs-number\">3</span>(请求结果<span class=\"hljs-number\">2</span>))\n    .<span class=\"hljs-title function_\">then</span>(请求<span class=\"hljs-number\">4</span>(请求结果<span class=\"hljs-number\">3</span>))\n    .<span class=\"hljs-title function_\">then</span>(请求<span class=\"hljs-number\">5</span>(请求结果<span class=\"hljs-number\">4</span>))\n    .<span class=\"hljs-title function_\">catch</span>(处理异常(异常信息))\n</code></pre>\n<p><strong>HOW</strong></p>\n<p>常用API：</p>\n<ul>\n<li><p><code>Promise.resolve(value)</code></p>\n<p>返回一个状态由给定的<code>value</code>决定的<code>Promise</code>对象。如果该值时<code>theable</code>（即带有then方法的对象），返回的<code>Promise</code>对象的最终状态是由<code>then</code>方法决定；否则（该<code>value</code>为空、基本类型或不带<code>then</code>方法的对象）返回的<code>Promise</code>对象状态为<code>fulfilled</code>，并且将该<code>value    </code>传递给对应的<code>then</code>方法。通常，如果不知道一个值是否是<code>Promise</code>对象，可以使用<code>Promsie.resolve(value)</code>来返回一个<code>Promise</code>对象，这样就能将该<code>value</code>以<code>Promise</code>对象形式使用</p>\n</li>\n<li><p><code>Promise.reject(value)</code></p>\n<p>返回一个状态为失败的<code>Promise</code>对象，并将给定的失败信息传递给对应的出处理方法</p>\n</li>\n<li><p><code>Promise.race(interable)</code></p>\n<p>当<code>interable</code>参数里的任意一个子<code>promise</code>被执行失败或成功后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promsie</code>绑定的相应句柄并返回该<code>promsie</code>对象</p>\n</li>\n<li><p><code>Promise.all(interable)</code></p>\n<p>这个方法返回的是一个新的<code>promise</code>对象，该<code>promise</code>对象在<code>interable</code>参数对象里所有的<code>promise</code>对象都成功的时候才会触发成功，一旦有任何一个<code>interable</code>里的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败。这个新的<code>promise</code>对象在触发成功状态以后，会把一个包含<code>interable</code>里所有<code>promise</code>返回值的数组作为成功回调的返回值，顺序跟<code>interable</code>的顺序保持一致；如果这个新的<code>promise</code>对象出发了失败状态，它会把<code>interable</code>里第一个触发失败的<code>promise</code>对象的错误信息作为它的失败错误信息。<code>Promise.all</code>方法常用于处理多个<code>promise</code>对象的状态集合</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>)\n\nfs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./index.html&quot;</span>, { <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">&quot;utf8&quot;</span> }, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err, data);\n})\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_readFile</span>(<span class=\"hljs-params\">path, options</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    fs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">&quot;./index.html&quot;</span>, options, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span>(err)\n        <span class=\"hljs-title function_\">reject</span>(err)\n      <span class=\"hljs-keyword\">else</span>\n        <span class=\"hljs-title function_\">resolve</span>(data)\n    })\n  })\n}\n\n(<span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">_readFile</span>(<span class=\"hljs-string\">&quot;./index.html&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>)\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);\n  }\n})()\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">遍历对象的属性和数组元素的方法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对象：</p>\n<ul>\n<li><p><code>for</code>循环 👎</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> property <span class=\"hljs-keyword\">in</span> obj)\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(property)\n</code></pre>\n<p>缺点：会遍历到它的继承属性，在使用之前需要加入<code>obj.hasOwnProperty(property)</code></p>\n</li>\n<li><p><code>Object.keys(obj).forEach()</code> 👍</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">property</span> =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(property)\n})\n</code></pre>\n<p><code>Object.keys</code>返回一个有给定对象的自身可枚举属性组成的数组</p>\n</li>\n<li><p><code>Object.getOwnPropertyNames(obj).forEach</code> 👍</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyNames</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">property</span> =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(property)\n})\n</code></pre>\n<p><code>Object.getOwnPropertyNames</code>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括<code>Symbol</code>值作为名称的属性）组成的数组</p>\n</li>\n<li><p><code>Reflect.ownKeys(target)</code> 👍</p>\n<p>基本等同于<code>Object.getOwnPeopertyNames</code> + <code>Object.getOwnPropertySymbols</code></p>\n</li>\n</ul>\n<p>数组：<strong>各取所需</strong></p>\n<ul>\n<li><p><code>for</code>循环</p>\n<p>普通遍历方法，较常用</p>\n</li>\n<li><p><code>arr.forEach</code></p>\n<p>相较于<code>for</code>，<code>forEach</code>不可提前结束循环</p>\n</li>\n<li><p><code>arr.map/reduce</code></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">可变对象和不可变对象</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>可变对象</strong>在创建之后是可以被改变的</p>\n<p><strong>不可变对象</strong>在创建之后是不可以被改变的</p>\n<ol>\n<li>在<code>JavaScript</code>中，<code>string</code>和<code>number</code>从设计之初就是不可变的（immediate）</li>\n<li>不可变对象是保持一个对象状态不变，这样的好处是是的开发更加简单、可回溯、测试友好，减少了任何可能的副作用。但是，每当想添加点东西到一个不可变对象里时，它一定是先拷贝已存在的值到新实例里，然后再给新实例添加内容，最后返回新实例。相比可变对象，这势必会有更多内存、计算量消耗</li>\n</ol>\n<p>创建一个纯函数（pure function）</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> student = {\n    <span class=\"hljs-attr\">school</span>: <span class=\"hljs-string\">&quot;baidu&quot;</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateStudent</span>(<span class=\"hljs-params\">student, name, age</span>) {\n    <span class=\"hljs-keyword\">return</span> {\n        ...student,\n        name,\n        age\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">同步函数和异步函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>同步函数阻塞，异步函数不阻塞。在同步函数中，语句完成后下一句才执行，在这种情况下，程序可以按照语句的顺序进行精确评估，如果其中一个语句需要很长时间，那么程序的执行会停滞很长时间</p>\n<p>异步函数通常接受回调作为参数，在调用异步函数后立即继续执行下一行。回调函数仅在异步操作完成且调用堆栈为空时调用，诸如从web服务器加载数据或查询数据库等重负载操作应该异步完成，以便主线程可以继续执行其他操作而不会出现一直阻塞</p>\n<p>在JavaScript中异步函数的解决方案通常有callback、Promise、async/await</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript执行机制</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><strong>JavaScript的执行与运行</strong></p>\n<p>执行和与运行不太相同，在不同环境下，比如Node、浏览器下，JavaScript的执行结果是不一样的；而运行大多是指基于JavaScript引擎，如V8，结果是一致的 </p>\n</li>\n<li><p><strong>关于JavaScript</strong></p>\n<p>众所周知，JavaScript是一门<strong>单线程</strong>、<strong>异步执行</strong>的语言，虽然在HTML5中提出了<strong>web workers</strong>（可以理解为<strong>浏览器</strong>为JavaScript开的“外挂”），但JavaScript是单线程运行的这一核心仍未改变，所有多线程都是通过单线程<strong>模拟</strong>出来的</p>\n</li>\n<li><p><strong>JavaScript中的异步</strong> <strong>event-loop</strong></p>\n<p>JavaScript中的异步主要通过<strong>event loop</strong>进行模拟当我们执行JavaScript代码的时候其实就是往执行栈中放入函数，那么遇到异步代码怎么办？其实当遇到异步代码时，会被挂起并在需要执行的时候加入到<strong>Task</strong>（有多种Task）队列中。一旦执行栈为空，<strong>event loop</strong>就会从<strong>Task</strong>中拿出需要执行的代码并放入执行栈中执行，所以本质上说JavaScript中的异步还是同步行为</p>\n</li>\n<li><p><strong>浏览器中的event loop</strong></p>\n<p>来自不同的<strong>任务源</strong>的任务会被分配到不同的Task队列中，任务源可以分为<strong>微任务（micro task）</strong>和<strong>宏任务（macro task）</strong>。在ES6规范中，微任务被称为jobs，宏任务被称为task</p>\n<p>微任务包括：<code>precess.nextTick</code>、<code>promise</code>、<code>Mutation Observer</code></p>\n<p>宏任务包括：<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>I/O</code>、UI Rendering</p>\n<p><strong>宏任务中包含了<code>script</code>，因此浏览器会先执行一个宏任务，接下来由异步代码的话才会先执行微任务</strong></p>\n<p><strong>event loop执行顺序</strong>：</p>\n<ol>\n<li>先执行同步代码，这属于宏任务</li>\n<li>当<strong>执行完所有同步代码</strong>后执行栈为空，查询是否有异步代码需要执行</li>\n<li><strong>执行所有微任务</strong></li>\n<li>当执行完所有微任务，如有必要会渲染页面</li>\n<li>然后开始下一轮<code>event loop</code>，执行宏任务中的异步代码也就是<code>setTimeout</code>（宏任务）中的回调函数</li>\n</ol>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_event_loop.png\" alt=\"浏览器中的event loop\"></p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_event_loop2.png\" alt=\"浏览器中的event loop\"></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">3</span>);\n  });\n});\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">5</span>);\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n});\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">6</span>);\n});\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">7</span>);\n\n<span class=\"hljs-comment\">// 1 4 7 5 2 3 6</span>\n</code></pre>\n</li>\n<li><p><strong>Node.js中的event loop</strong></p>\n<p>Node.js中的<code>event loop</code>分为6个阶段，他们会按照顺序反复运行。每当进入某一个阶段的时候都会从对应的回调队列中取出函数去执行。当<strong>队列为空</strong>或者<strong>执行的回调函数数量到达系统设定的阈值</strong>，就会进入下一阶段</p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_event_loop.png\" alt=\"Node.js中的event loop\"></p>\n<ol>\n<li><p><strong>timers</strong></p>\n<p><strong>timers</strong>阶段会执行<code>setTimeout</code>和<code>setinterval</code>回调，并且是由<strong>poll</strong>阶段控制的。同样在<code>Node.js</code>中定时器指定的事件也不是准确时间，只是尽快执行</p>\n</li>\n<li><p><strong>I/O</strong></p>\n<p><strong>I/O</strong>阶段会处理一些上一轮循环中少许未执行的<strong>I/O</strong>回调</p>\n</li>\n<li><p><strong>idle,prepare</strong></p>\n</li>\n<li><p><strong>poll</strong></p>\n<p><strong>poll</strong>是一个至关重要的阶段，在这一阶段中，系统会做两件事情</p>\n<ol>\n<li><p>回到<strong>timer</strong>阶段执行回调</p>\n</li>\n<li><p>执行<strong>I/O</strong>回调，并且在进入该阶段时如果没有设定了<strong>timer</strong>的话，会发生以下两件事情</p>\n</li>\n</ol>\n<ul>\n<li>如果<strong>poll</strong>队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>\n<li>如果<strong>poll</strong>队列为空<ul>\n<li>如果有<code>setImmediate</code>回调需要执行，<strong>poll</strong>阶段会停止并且<strong>进入到check阶段</strong>执行回调</li>\n<li>如果没有，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间防止一直等待下去</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>check</strong></p>\n<p>执行<code>setImmediate</code></p>\n</li>\n<li><p><strong>close callbacks</strong></p>\n<p>执行close事件</p>\n</li>\n</ol>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_event_loop2.png\" alt=\"Node.js中的event loop\"></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ES6的类和ES6的构造函数的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在普通使用中没有区别：</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name\n    }\n}\n</code></pre>\n<p>主要区别在于类继承上：</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Student</span>(<span class=\"hljs-params\">name, id</span>) {\n    <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name)\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span> = id\n}\n<span class=\"hljs-title class_\">Student</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)\n<span class=\"hljs-title class_\">Student</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Student</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Person</span> {\n    <span class=\"hljs-title function_\">consreuctor</span>(<span class=\"hljs-params\">name, id</span>) {\n        <span class=\"hljs-variable language_\">super</span>(name)\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span> = id\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">扩展运算符和剩余参数语句的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在函数泛型编码时，ES6的扩展运算符非常有用吗，因为我们可以轻松创建数组和对象的拷贝，而无需使用<code>Object.create</code>、<code>slice</code>或其他函数库。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">arr</span>) {\n    <span class=\"hljs-keyword\">return</span> [ ...arr, <span class=\"hljs-string\">&quot;test&quot;</span> ]\n}\n\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">test</span>([<span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;world&quot;</span>])\n<span class=\"hljs-comment\">// [&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;]</span>\n\n<span class=\"hljs-keyword\">const</span> person = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>\n}\n<span class=\"hljs-keyword\">const</span> copyPerson = { ...person }\n</code></pre>\n<p>ES6的剩余参数语句提供了一个简写，允许我们将不定数量的参数表示为一个<strong>数组</strong>，它就像扩展运算符语法的反面，将数据收集到数组中而不是解构数组。剩余参数语句在函数参数、数组和对象的解构赋值中有很大作用</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">...numbers</span>) {\n    <span class=\"hljs-keyword\">return</span> numbers.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x + <span class=\"hljs-number\">5</span>)\n}\n\n<span class=\"hljs-keyword\">const</span> result1 = <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\n<span class=\"hljs-comment\">// [6, 7, 8, 9]</span>\n<span class=\"hljs-keyword\">const</span> result2 = <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>)\n<span class=\"hljs-comment\">// [10, 11, 12, 13, 14]</span>\n\n<span class=\"hljs-keyword\">const</span> [ a, b, ...rest ] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\n<span class=\"hljs-comment\">// 1 2 [ 3, 4 ]</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">内置类型</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>JavaScript中分为<strong>七种</strong>内置类型，其中内置类型又分为两大类型：<strong>基本类型</strong>和<strong>引用类型</strong>（对象 Object）</p>\n<p>基本类型：<code>null</code>、<code>undefined</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></p>\n<p>其中JavaScript的数字类型是浮点类型的，没有整形。并且浮点类型基于 IEEE 754 标准实现，在使用中会遇到某些 <a href=\"#2\">Bug </a><code>NaN</code>也属于<code>number</code>类型并且<code>NaN</code>并不等于自身</p>\n<p>对于基本类型来说，如果使用字面量的方式，那个这个变量只是个字面量，只有在必要的时候才会转换成对应的类型</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">111</span> <span class=\"hljs-comment\">// 这只是字面量，不是number类型</span>\na.<span class=\"hljs-title function_\">toString</span>() <span class=\"hljs-comment\">// 使用的时候才会转换为对象类型</span>\n</code></pre>\n<p>引用类型在使用过程中会遇到深拷贝和浅拷贝问题</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Typeof</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>typeof</code>对于基本类型，除了<code>null</code>都可以显示正确的类型</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// number</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&#x27;1&#x27;</span> <span class=\"hljs-comment\">// string</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span> <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// boolean</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Symbol</span>() <span class=\"hljs-comment\">// symbol</span>\n</code></pre>\n<p><code>typeof</code>对于对象，除了函数都会显示<code>object</code></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">typeof</span> [] <span class=\"hljs-comment\">// object</span>\n<span class=\"hljs-keyword\">typeof</span> {} <span class=\"hljs-comment\">// object</span>\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span> <span class=\"hljs-comment\">// function</span>\n\n<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// object</span>\n</code></pre>\n<p>关于为什么<code>typeof null == object</code>：在JavaScript的最初版本中，使用的是32为系统，为了性能考虑使用低位存储了变量的类型信息。<code>000</code>开头的代表是对象，然而<code>null</code>表示为全零，所以将它错误的判断为<code>object</code></p>\n<p>如果想得到一个正确的数据类型，使用<code>Object.prototype.toString.call(xxx)</code></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>])\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">instanceof</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>instance</code>可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能正确的找到类型的<code>prototype</code></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">instanceof</span>(<span class=\"hljs-params\">left, right</span>) {\n    <span class=\"hljs-keyword\">let</span> prototype = right.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>\n    left = left.<span class=\"hljs-property\">__proto__</span>\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">if</span> (left === <span class=\"hljs-literal\">null</span>)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        <span class=\"hljs-keyword\">if</span> (prototypr === left)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        left = left.<span class=\"hljs-property\">__proto__</span>\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">new</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在调用<code>new</code>的过程中会发生以下四件事情</p>\n<ol>\n<li>新生成了一个对象</li>\n<li>绑定到原型</li>\n<li>绑定<code>this</code></li>\n<li>返回新对象</li>\n</ol>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>()\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Con</span> = [].<span class=\"hljs-property\">shift</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>)\n    obj.<span class=\"hljs-property\">__proto__</span> = <span class=\"hljs-title class_\">Con</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>\n    <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title class_\">Con</span>.<span class=\"hljs-title function_\">apply</span>(obj, <span class=\"hljs-variable language_\">arguments</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">&#x27;object&#x27;</span> ? result : obj\n}\n</code></pre>\n"},{"title":"JavaScript-模块化机制","tags":["JavaScript模块化机制"],"categories":"JavaScript","description":"# AMD\n\n## 简介\n\n全称是Asynchronous Module Definition（异步模块加载机制）。后来由该草案的作者以RequireJS实现了该规范，所以一般说AMD也是指RequireJS。适用于**浏览器环境**\n\n## 用法\n\n```js\n// a.js\ndefine(function () {\n\treturn 1\n})\n\n// b.js\nrequire(['a'],","createDate":"2020-04-24 22:55:14","updateDate":"2021-05-13 14:16:51","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AMD</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">简介</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>全称是Asynchronous Module Definition（异步模块加载机制）。后来由该草案的作者以RequireJS实现了该规范，所以一般说AMD也是指RequireJS。适用于<strong>浏览器环境</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">用法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n})\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a)\n})\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">特点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对于依赖的模块，AMD推崇<strong>依赖前置，提前执行</strong>。也就是说在<code>define</code>方法里传入的依赖模块（数组）会在一来是就下载并执行</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CommonJS</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">简介</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>由CommonJS小组所提出，目的是弥补JavaScript在服务端缺少模块化机制。<strong>Node.js、webpack</strong>都是基于该规范实现</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">用法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;i am a function&quot;</span>)\n}\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./a.js&quot;</span>)\n<span class=\"hljs-title function_\">a</span>()\n<span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">num</span> = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">obj</span> = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;zhangsan&#x27;</span> }\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./a.js&quot;</span>)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a) <span class=\"hljs-comment\">// { num: 1, obj: { name: &#x27;zhangsan&#x27; } }</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">特点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>所有代码都运行在模块作用域，不会污染全局环境</li>\n<li>模块是同步加载的，即只有加载完成次啊能执行后面的操作</li>\n<li>模块在首次执行后就会<strong>缓存</strong>，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>\n<li>CommonJS <strong>输出的是值的拷贝</strong></li>\n<li><code>this</code>指向当前模块</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ESM</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">简介</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>ES6定义的模块化规范</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基本用法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;zhangsan&quot;</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> age = <span class=\"hljs-number\">23</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">&quot;shanghai&quot;</span>\n}\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-keyword\">import</span> address, { name, age } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./a.js&quot;</span>\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(address, name, age) <span class=\"hljs-comment\">// &quot;shanghai&quot; &quot;zhangsan&quot; 23</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">特点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>编译时输出接口</li>\n<li>可以单独加载模块某个接口</li>\n<li>输出的是引用</li>\n<li><code>this</code>指向<code>undefined</code></li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ESM VS CommonJS</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <table>\n<thead>\n<tr>\n<th></th>\n<th>CommonJS</th>\n<th>ESM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>加载时间</td>\n<td>运行时加载</td>\n<td>编译时输出接口</td>\n</tr>\n<tr>\n<td>加载方式</td>\n<td>加载整个模块</td>\n<td>按需加载</td>\n</tr>\n<tr>\n<td>输出方式</td>\n<td>值的拷贝</td>\n<td>值的引用</td>\n</tr>\n<tr>\n<td><code>this</code></td>\n<td>指向当前模块</td>\n<td><code>undefined</code></td>\n</tr>\n</tbody></table>\n"},{"title":"网络复习-WebSocket","tags":["WebSocket"],"categories":"2021复习","description":"## WebSocket是什么\n\nHTML5开始提供的一种浏览器与服务器进行**全双工通讯**的网络技术，属于**应用层协议**、基于**TCP**、**复用HTTP的握手通道**\n\n## 和长轮训的区别\n\n长轮训就是客户端发起一个请求，服务器收到客户端发送的请求后，服务端不会直接进行响应，而是先将这个请求挂起，然后判断请求的数据是否有更新，如果有更新，则进行更新，如果一直没有数据，则等待一定","createDate":"2021-05-10 05:04:10","updateDate":"2021-05-10 18:53:03","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WebSocket是什么</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>HTML5开始提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于<strong>应用层协议</strong>、基于<strong>TCP</strong>、<strong>复用HTTP的握手通道</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">和长轮训的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>长轮训就是客户端发起一个请求，服务器收到客户端发送的请求后，服务端不会直接进行响应，而是先将这个请求挂起，然后判断请求的数据是否有更新，如果有更新，则进行更新，如果一直没有数据，则等待一定的时间后返回</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何建立连接</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>WebSocket</code>复用了<code>HTTP</code>的握手通道。客户端通过<code>HTTP</code>请求与<code>WebSocket</code>服务器协商<strong>升级协议</strong>，协议升级完成后，后续的数据交换则按照<code>WebSocket</code>的协议。</p>\n<p>首先，客户端发起协议升级请求</p>\n<pre><code class=\"hljs language-http\"><span class=\"hljs-keyword\">GET</span> <span class=\"hljs-string\">ws://localhost:8080/</span> <span class=\"hljs-meta\">HTTP/1.1</span>\n<span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>Upgrade\n<span class=\"hljs-attribute\">Host</span><span class=\"hljs-punctuation\">: </span>localhost:8080\n<span class=\"hljs-attribute\">Origin</span><span class=\"hljs-punctuation\">: </span>http://localhost:3000\n<span class=\"hljs-attribute\">Sec-WebSocket-Extensions</span><span class=\"hljs-punctuation\">: </span>permessage-deflate; client_max_window_bits\n<span class=\"hljs-attribute\">Sec-WebSocket-Key</span><span class=\"hljs-punctuation\">: </span>wXE7gVKUV5flJWEnJLr8pw==\n<span class=\"hljs-attribute\">Sec-WebSocket-Version</span><span class=\"hljs-punctuation\">: </span>13\n<span class=\"hljs-attribute\">Upgrade</span><span class=\"hljs-punctuation\">: </span>websocket\n</code></pre>\n<p>然后服务端响应协议升级</p>\n<pre><code class=\"hljs language-http\"><span class=\"hljs-meta\">HTTP/1.1</span> <span class=\"hljs-number\">101</span> Switching Protocols\n<span class=\"hljs-attribute\">Upgrade</span><span class=\"hljs-punctuation\">: </span>websocket\n<span class=\"hljs-attribute\">Connection</span><span class=\"hljs-punctuation\">: </span>Upgrade\n<span class=\"hljs-attribute\">Sec-WebSocket-Accept</span><span class=\"hljs-punctuation\">: </span>DeY5PvpKJhTquRvvA7TPBcinVBk=\n</code></pre>\n<p>代码演示：</p>\n<p>服务端(使用<code>ws</code>库)：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;express&quot;</span>);\n<span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;ws&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n<span class=\"hljs-keyword\">const</span> wsServer = <span class=\"hljs-keyword\">new</span> ws.<span class=\"hljs-title class_\">Server</span>({ <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">8080</span> });\n\nwsServer.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;connection&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">ws</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;server: connected to a client&quot;</span>);\n  ws.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">msg</span>) =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`server: message receive from client--<span class=\"hljs-subst\">${msg}</span>`</span>);\n  });\n  ws.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&quot;hello client&quot;</span>);\n  ws.<span class=\"hljs-title function_\">ping</span>(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-function\">() =&gt;</span> {});\n});\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n  res.<span class=\"hljs-title function_\">sendFile</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${__dirname}</span>/index.html`</span>);\n})\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);\n</code></pre>\n<p>客户端：</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;IE=edge&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;sendMessage()&quot;</span>&gt;</span>sendMessage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">const</span> wsClient = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&quot;ws://localhost:8080&quot;</span>);\n    wsClient.<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;client: connected to server&quot;</span>);\n    }\n    wsClient.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">msg</span>) =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`client: receive from server--<span class=\"hljs-subst\">${msg.data}</span>`</span>);\n    }\n\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sendMessage</span>(<span class=\"hljs-params\"></span>) {\n      wsClient.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&quot;hello server&quot;</span>);\n    }\n  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>运行结果：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">客户端</span>\nclient: connected to server\nclient: receive from server--hello client\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">服务端</span>\nserver: connected to a client\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数据交换</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一旦<code>WebSocket</code>客户端、服务端建立连接后，后续的操作都是基于<strong>数据帧</strong>的传递</p>\n<p><code>WebSocket</code>根据<code>opcode</code>来区分操作的类型。比如<code>0x8</code>表示断开连接，<code>0x0-0x2</code>表示数据交互</p>\n<p>数据分片：</p>\n<p><code>WebSocket</code>的每条消息可能被切分成多个数据帧。当<code>WebSocket</code>的接收方接收到一个数据帧时，会根据FIN的值进行判断，是否已经收到消息的最后一个数据帧</p>\n<pre><code class=\"hljs language-http\"># 一个完整的消息(FIN=1且opcode != 0x0)\n<span class=\"hljs-attribute\">Client</span><span class=\"hljs-punctuation\">: </span>FIN=1, opcode=0x1, msg=&quot;hello&quot;\n<span class=\"hljs-attribute\">Server</span><span class=\"hljs-punctuation\">: </span>(process complete message immediately) Hi.\n\n# 文本消息且消息还没发送完成\n<span class=\"hljs-attribute\">Client</span><span class=\"hljs-punctuation\">: </span>FIN=0, opcode=0x1, msg=&quot;and a&quot;\n<span class=\"hljs-attribute\">Server</span><span class=\"hljs-punctuation\">: </span>(listening, new message containing text started)\n# 延续帧\n<span class=\"hljs-attribute\">Client</span><span class=\"hljs-punctuation\">: </span>FIN=0, opcode=0x0, msg=&quot;happy new&quot;\n<span class=\"hljs-attribute\">Server</span><span class=\"hljs-punctuation\">: </span>(listening, payload concatenated to previous message)\n# 最终帧\n<span class=\"hljs-attribute\">Client</span><span class=\"hljs-punctuation\">: </span>FIN=1, opcode=0x0, msg=&quot;year!&quot;\n<span class=\"hljs-attribute\">Server</span><span class=\"hljs-punctuation\">: </span>(process complete message) Happy new year to you too!\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">心跳</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在Websocket中定义了<strong>心跳ping(0x9)</strong> 和 <strong>心跳pong(0xA)</strong> 的控制帧</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://juejin.cn/post/6844903544978407431\">WebSocket：5分钟从入门到精通\n</a></p>\n"},{"title":"前端架构&软实力-前端拾遗","tags":["前端拾遗"],"categories":"前端架构&软实力","description":"## dom事件机制\n\n事件触发后有三个阶段\n\n1. 事件捕获阶段\n2. 命中目标（触发入口）\n3. 事件冒泡阶段\n\n![dom 事件机制](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/20160928221704676.png)\n\n## flex每行两个元素\n\n``` css\n.container {\n\tdisplay: flex;\n  \tfl","createDate":"2021-01-04 14:58:02","updateDate":"2021-05-09 10:51:11","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">dom事件机制</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>事件触发后有三个阶段</p>\n<ol>\n<li>事件捕获阶段</li>\n<li>命中目标（触发入口）</li>\n<li>事件冒泡阶段</li>\n</ol>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/20160928221704676.png\" alt=\"dom 事件机制\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">flex每行两个元素</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.container</span> {\n    <span class=\"hljs-attribute\">display</span>: flex;\n      <span class=\"hljs-attribute\">flex-wrap</span>: wrap;\n}\n\n<span class=\"hljs-selector-class\">.item</span> {\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">50%</span>;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">event对象中 target和currentTarget 属性的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>event.target返回触发事件的元素</li>\n<li>event.currentTarget返回绑定事件的元素</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">clearTimeout</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>clearTimeout(tid)</code>只是将<code>tid</code>指向的定时器关闭，并不会将<code>tid</code>置为<code>null</code></p>\n<p>如果不在适当的时机清除定时器，每次事件触发都会多一个延时器，延时器之间互相干扰，造成紊乱。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JSON.stringify()</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>基本用法：</p>\n<ul>\n<li><p>默认情况下JSON.stringify()会输出不包含空格或缩进的JSON字符串</p>\n</li>\n<li><p>在序列化JavaScript对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为<code>undefined</code>和<code>Symbol</code>的任何属性也会被跳过。最终得到的就是所有实例属性均为有效JSON数据类型的表示。正则则会变为空对象</p>\n</li>\n<li><p>一共能接受3个参数，第二个参数是过滤器，可以是数组或函数；第三个参数是用于缩进结果JSON字符串的选项</p>\n</li>\n</ul>\n<p>第二个参数：</p>\n<ul>\n<li><p>如果第二个参数是一个数组，那么<code>JSON.stringify()</code>返回的结果中只包含该数组中列出的对象属性：</p>\n</li>\n<li><p>如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个key决定要对相应属性执行什么操作</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userInfo = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span>,\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">&quot;Shanghai&quot;</span>\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(userInfo, [<span class=\"hljs-string\">&quot;name&quot;</span>]));\n<span class=\"hljs-comment\">// {&quot;name&quot;:&quot;tom&quot;}</span>\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(userInfo, <span class=\"hljs-function\">(<span class=\"hljs-params\">key, value</span>) =&gt;</span> key === <span class=\"hljs-string\">&quot;name&quot;</span> ? value.<span class=\"hljs-title function_\">toUpperCase</span>() : value))\n<span class=\"hljs-comment\">// {&quot;name&quot;:&quot;TOM&quot;,&quot;age&quot;:23,&quot;address&quot;:&quot;Shanghai&quot;}</span>\n</code></pre>\n<p>第三个参数：</p>\n<p>控制缩进和空格</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> userInfo = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span>,\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">&quot;Shanghai&quot;</span>\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(userInfo, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">4</span>))\n<span class=\"hljs-comment\">/*\n{\n    &quot;name&quot;: &quot;tom&quot;,\n    &quot;age&quot;: 23,\n    &quot;address&quot;: &quot;Shanghai&quot;\n}\n*/</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">git 撤销修改</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>git checkout .</code>撤销所有未<code>git add</code>的修改</p>\n<p><code>git reset --soft HEAD^</code>撤销所有<code>git commit</code></p>\n<p><code>git reset --hard HEAD^</code>撤销所有<code>git commit + git add</code></p>\n"},{"title":"重学前端(winter)阅读笔记-0-JavaScript","tags":["重学前端","阅读笔记"],"categories":"阅读笔记","description":"## JavaScript知识架构\n\n![JavaScript架构](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/JavaScript%E6%9E%B6%E6%9E%84.png)\n\n用一定的**词法**和**语法**表达一定的**语义**，从而操作**运行时**\n\n## html替换型标签\n\n替换型标签：引入声音、图片、视频等外部元素替换自身的","createDate":"2021-04-20 02:17:40","updateDate":"2021-05-07 23:10:37","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript知识架构</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/JavaScript%E6%9E%B6%E6%9E%84.png\" alt=\"JavaScript架构\"></p>\n<p>用一定的<strong>词法</strong>和<strong>语法</strong>表达一定的<strong>语义</strong>，从而操作<strong>运行时</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">html替换型标签</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数据属性/访问器属性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>表示<em>属性</em>的<em>属性</em>，用于描述属性的行为特征</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">new Number() 和 Number() 的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>Number()</code>执行类型转换，好于<code>parseInt/parseFloat</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">装箱转换/拆箱转换</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>装箱转换：把基本类型转换为对应的对象\n拆箱转换：对象类型到基本类型</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript对象</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>JavaScript运行时是一个<em>属性</em>的集合，属性以字符串或<code>Symbol</code>为<code>key</code>，以数据属性特征值或访问器属性特征值为<code>value</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">函数对象/构造器对象</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>函数对象：具有<code>[[call]]</code>私有字段的对象</li>\n<li>构造器对象：具有<code>[[constructor]]</code>私有字段的对象</li>\n</ul>\n<p>任何对象只要实现<code>[[call]]</code>，它就是一个函数对象，可以作为函数被调用。而如果它实现了<code>[[contructor]]</code>，它就是一个构造器对象，可以使用<code>new</code>调用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">宏任务/微任务</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>宿主(程序猿)发起的任务称为<em>宏任务</em>。JavaScript引擎发起的任务称为<em>微任务</em></p>\n<p><code>Promise</code>永远在队列尾部添加微任务(引擎)\n<code>setTimeout</code>宿主API则会添加宏任务</p>\n<p>如果在微任务执行期间微任务加入了新的微任务，会将新的微任务加到队列尾部，之后也会被执行</p>\n<p>会将<code>await</code>后的放入微任务队列</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">闭包</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>闭包指的是那些引用了另一个函数作用域中变量的<strong>函数</strong>。通常是在嵌套函数中实现</p>\n<p>外部函数的<strong>活动对象</strong>是内部函数<strong>作用域链</strong>上的第二个对象</p>\n<p>闭包只是在定义嵌套函数时的外在表现，闭包的本质是包含函数的活动对象加上了其作用域链</p>\n<p>每个函数在被调用时都会自动创建两个特殊变量<strong>this</strong>和<strong>arguments</strong>。内部函数永远不可能<strong>直接访问</strong>外部函数的这两个变量</p>\n"},{"title":"网络-websocket","tags":["websocket"],"categories":"网络","description":"## 什么是websocket\n\n- HTML5提出的一种应用层网络协议\n\n- 全双工通信\n\n## 如何建立连接\n\nwebsocket服用了http的握手通道：客户端通过http请求与websocket服务端协商升级协议，协议升级完成后，后续的数据交换则遵照websocket协议\n\n1. 客户端发送协议升级请求\n\n首先，客户端发起协议升级`GET`请求\n\n``` http\nGET / HTTP","createDate":"2021-05-06 14:12:47","updateDate":"2021-05-07 10:49:52","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是websocket</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>HTML5提出的一种应用层网络协议</p>\n</li>\n<li><p>全双工通信</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何建立连接</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>websocket服用了http的握手通道：客户端通过http请求与websocket服务端协商升级协议，协议升级完成后，后续的数据交换则遵照websocket协议</p>\n<ol>\n<li>客户端发送协议升级请求</li>\n</ol>\n<p>首先，客户端发起协议升级<code>GET</code>请求</p>\n<pre><code class=\"hljs language-http\"><span class=\"hljs-keyword\">GET</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-meta\">HTTP/1.1</span>\n<span class=\"hljs-attribute\">Host</span><span class=\"hljs-punctuation\">: </span>localhost:8080\n</code></pre>\n<ol start=\"2\">\n<li>服务端响应协议升级</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数据帧格式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何维持连接</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    "},{"title":"React.js学习-合成事件","tags":["React.js","合成事件"],"categories":"React.js","description":"## 什么是合成事件\n\n如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——**SyntheticEvent**\n\n## 为什么使用合成事件\n\n1. 兼容浏览器\n2. 性能。避免大量节点绑定事件占用内存，将事件委托到`document`上，等事件**冒泡**到`doc","createDate":"2021-05-06 08:29:57","updateDate":"2021-05-06 16:30:04","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是合成事件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——<strong>SyntheticEvent</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么使用合成事件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>兼容浏览器</li>\n<li>性能。避免大量节点绑定事件占用内存，将事件委托到<code>document</code>上，等事件<strong>冒泡</strong>到<code>document</code>上时，React将事件内容封装交给中间层<code>SyntheticEvent</code>（负责所有事件合成）</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">和原生事件的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li><p>React的所有事件都通过<code>document</code>进行统一分发。当真实Dom触发事件后冒泡到<code>document</code>后才会对React事件进行处理</p>\n</li>\n<li><p>原生事件先执行</p>\n</li>\n<li><p>不要混用，如果在原生事件中执行<code>stopPropagation</code>会导致React事件失效</p>\n</li>\n</ol>\n"},{"title":"JavaScript相关-骚操作","tags":["JavaScript","骚操作"],"categories":"JavaScript","description":"## 自定义事件\n\n```js\nconst event = new Event('build');\n// Listen for the event.\nelem.addEventListener('build', function (e) { ... }, false);\n// Dispatch the event.\nelem.dispatchEvent(event);\n```\n\n## slee","createDate":"2020-12-02 15:08:45","updateDate":"2021-05-06 16:08:46","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">自定义事件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> event = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Event</span>(<span class=\"hljs-string\">&#x27;build&#x27;</span>);\n<span class=\"hljs-comment\">// Listen for the event.</span>\nelem.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;build&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) { ... }, <span class=\"hljs-literal\">false</span>);\n<span class=\"hljs-comment\">// Dispatch the event.</span>\nelem.<span class=\"hljs-title function_\">dispatchEvent</span>(event);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">sleep函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sleep</span> = (<span class=\"hljs-params\">time</span>) =&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(resolve, time));\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">5000</span>);        <span class=\"hljs-comment\">// sleep 5s</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">判断事件触发源</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用<code>HTMLElement.contains</code>函数，判断所给元素和指定元素是不是父子关系</p>\n<p>事件代理中非常有用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">const关键字定义的常量对象不够&#39;常量&#39;的解决办法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用<code>Object.freeze()</code>，这样虽然再给属性负值时不回报错，但会静默失败</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">取cookie</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getCookie</span> = (<span class=\"hljs-params\">name</span>) =&gt;<span class=\"hljs-string\">`; <span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">document</span>.cookie}</span>`</span>.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">`; <span class=\"hljs-subst\">${name}</span>=`</span>).<span class=\"hljs-title function_\">pop</span>().<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;;&#x27;</span>).<span class=\"hljs-title function_\">shift</span>();\n</code></pre>\n"},{"title":"React.js学习-骚操作","tags":["React.js骚操作"],"categories":"React.js","description":"## 获取target\n\n``` ts\nexport type BasicTarget<T = HTMLElement> =\n  | (() => T | null)\n  | T\n  | null\n  | MutableRefObject<T | null | undefined>;\n\ntype TargetElement = HTMLElement | Element | Document","createDate":"2021-01-04 15:21:23","updateDate":"2021-04-26 16:54:30","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取target</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">BasicTarget</span>&lt;T = <span class=\"hljs-title class_\">HTMLElement</span>&gt; =\n  | (<span class=\"hljs-function\">() =&gt;</span> T | <span class=\"hljs-literal\">null</span>)\n  | T\n  | <span class=\"hljs-literal\">null</span>\n  | <span class=\"hljs-title class_\">MutableRefObject</span>&lt;T | <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span>&gt;;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">TargetElement</span> = <span class=\"hljs-title class_\">HTMLElement</span> | <span class=\"hljs-title class_\">Element</span> | <span class=\"hljs-title class_\">Document</span> | <span class=\"hljs-title class_\">Window</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getTargetElement</span>(<span class=\"hljs-params\">\n  target?: BasicTarget&lt;TargetElement&gt;,\n  defaultElement?: TargetElement,\n</span>): <span class=\"hljs-title class_\">TargetElement</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-literal\">null</span> {\n  <span class=\"hljs-keyword\">if</span> (!target) <span class=\"hljs-keyword\">return</span> defaultElement;\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">targetElement</span>: <span class=\"hljs-title class_\">TargetElement</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> target === <span class=\"hljs-string\">&#x27;function&#x27;</span>) {\n    targetElement = <span class=\"hljs-title function_\">target</span>();\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&#x27;current&#x27;</span> <span class=\"hljs-keyword\">in</span> target) {\n    targetElement = target.<span class=\"hljs-property\">current</span>;\n  } <span class=\"hljs-keyword\">else</span> {\n    targetElement = target;\n  }\n\n  <span class=\"hljs-keyword\">return</span> targetElement;\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">父子组件通信</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>父组件要获取子组件的值：通过<code>props</code>传递回调函数</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">react-router-dom重定向</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Redirect</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;\n\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Redirect</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/auth/login&quot;</span> /&gt;</span></span>\n</code></pre>\n"},{"title":"VSCode插件开发-0-初始化","tags":["VSCode插件"],"categories":"VSCode插件","description":"由于晚上下班坐公交方便点，虽然移动端有不少app供查看，但懒得打开手机，而且自己大多数时间都在使用vscode，因此打算开发一个实时公交插件。\n\n[GitHub地址](https://github.com/mrrs878/real_time_bus_arrival)\n[插件市场地址](https://marketplace.visualstudio.com/items?itemName=Rea","createDate":"2021-03-22 15:26:01","updateDate":"2021-03-26 12:26:14","body":"<p>由于晚上下班坐公交方便点，虽然移动端有不少app供查看，但懒得打开手机，而且自己大多数时间都在使用vscode，因此打算开发一个实时公交插件。</p>\n<p><a href=\"https://github.com/mrrs878/real_time_bus_arrival\">GitHub地址</a>\n<a href=\"https://marketplace.visualstudio.com/items?itemName=Real-timeBusArrival.real-time-bus-arrival\">插件市场地址</a></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">项目搭建</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>安装官方类似于脚手架的工具</li>\n</ol>\n<p><code>npm install -g yo generator-code</code></p>\n<ol start=\"2\">\n<li>使用 <code>yo code</code> 初始化一个项目模板</li>\n</ol>\n<p>选择 <code>New Extension (TypeScript)</code> 和 <code>webpack</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">项目简单运行</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>VSCode打开项目并F5，会在一个新的VSCode窗口中运行插件</p>\n<p>在新窗口的命令面板（Ctrl+Shift+P） 运行<code>Hello World</code>命令。右下角会弹出<code>Hello World</code>通知信息</p>\n<p>注：</p>\n<p>默认项目的激活事件设置的是执行<code>helloWorld</code>指令：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-attr\">&quot;activationEvents&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-string\">&quot;onCommand:extension-template.helloWorld&quot;</span>\n<span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;contributes&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;commands&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n        <span class=\"hljs-punctuation\">{</span>\n            <span class=\"hljs-attr\">&quot;command&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;extension-template.helloWorld&quot;</span><span class=\"hljs-punctuation\">,</span>\n            <span class=\"hljs-attr\">&quot;title&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span>\n        <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">]</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>因此在执行<code>Hello World</code>命令时会激活插件。而且<code>extension.ts</code>中注册了<code>helloWorld</code>命令回调，因此会显示通知信息</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">activate</span>(<span class=\"hljs-params\">context: vscode.ExtensionContext</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Congratulations, your extension &quot;extension-template&quot; is now active!&#x27;</span>);\n    <span class=\"hljs-keyword\">let</span> disposable = vscode.<span class=\"hljs-property\">commands</span>.<span class=\"hljs-title function_\">registerCommand</span>(<span class=\"hljs-string\">&#x27;extension-template.helloWorld&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n        vscode.<span class=\"hljs-property\">window</span>.<span class=\"hljs-title function_\">showInformationMessage</span>(<span class=\"hljs-string\">&#x27;Hello World from extension_template!&#x27;</span>);\n    });\n    context.<span class=\"hljs-property\">subscriptions</span>.<span class=\"hljs-title function_\">push</span>(disposable);\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">目录结构</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vscodeExtensionDir.png\" alt=\"vscode插件目录结构\"></p>\n"},{"title":"VSCode插件开发-1-界面配置","tags":["VSCode插件"],"categories":"VSCode插件","description":"## 简介\n\nVSCode插件界面与package.json中的字段对应如图\n\n![插件界面与package.json中的字段对应](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vscodeExtensionView.png)\n\n其中：\n\n- activityBar是左侧边栏中的插件图标\n\n- '公交线路'(sidebar)相当于一级菜单，可通过","createDate":"2021-03-23 15:34:17","updateDate":"2021-03-26 11:28:12","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">简介</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>VSCode插件界面与package.json中的字段对应如图</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vscodeExtensionView.png\" alt=\"插件界面与package.json中的字段对应\"></p>\n<p>其中：</p>\n<ul>\n<li><p>activityBar是左侧边栏中的插件图标</p>\n</li>\n<li><p>&#39;公交线路&#39;(sidebar)相当于一级菜单，可通过packa.json中的<code>views.sidebar</code>配置</p>\n</li>\n<li><p>&#39;浦东25路/1117路&#39;相当于二级菜单，通过代码创建</p>\n<pre><code class=\"hljs language-js\">vscode.<span class=\"hljs-property\">window</span>.<span class=\"hljs-title function_\">registerTreeDataProvider</span>(<span class=\"hljs-string\">&#x27;sidebar_id&#x27;</span>, <span class=\"hljs-title class_\">TreeDataProvider</span>);\n</code></pre>\n</li>\n<li><p>菜单项中的图标在<code>commands</code>和<code>menus</code>中配置，<code>view/title</code>对应的是一级菜单；<code>view/item/context</code>对应的是二级菜单</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 1. 先添加command</span>\n<span class=\"hljs-string\">&quot;commands&quot;</span>: [\n    {\n        <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;realTimeBus.refreshLines&quot;</span>,\n        <span class=\"hljs-string\">&quot;icon&quot;</span>: <span class=\"hljs-string\">&quot;$(refresh)&quot;</span>,\n        <span class=\"hljs-string\">&quot;title&quot;</span>: <span class=\"hljs-string\">&quot;刷新线路&quot;</span>\n    },\n    {\n        <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;realTimeBus.addLine&quot;</span>,\n        <span class=\"hljs-string\">&quot;icon&quot;</span>: <span class=\"hljs-string\">&quot;$(add)&quot;</span>,\n        <span class=\"hljs-string\">&quot;title&quot;</span>: <span class=\"hljs-string\">&quot;添加线路&quot;</span>\n    },\n    {\n        <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;realTimeBus.removeLine&quot;</span>,\n        <span class=\"hljs-string\">&quot;icon&quot;</span>: <span class=\"hljs-string\">&quot;$(remove)&quot;</span>,\n        <span class=\"hljs-string\">&quot;title&quot;</span>: <span class=\"hljs-string\">&quot;删除线路&quot;</span>\n    },\n]\n\n<span class=\"hljs-comment\">// 2. 设置图标位置</span>\n<span class=\"hljs-string\">&quot;menus&quot;</span>: {\n  <span class=\"hljs-string\">&quot;view/title&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;realTimeBus.refreshLines&quot;</span>,\n      <span class=\"hljs-string\">&quot;group&quot;</span>: <span class=\"hljs-string\">&quot;navigation&quot;</span>,  <span class=\"hljs-comment\">// 和文字一行显示</span>\n      <span class=\"hljs-string\">&quot;when&quot;</span>: <span class=\"hljs-string\">&quot;view == realTimeBusLine&quot;</span>\n    }\n  ],\n  <span class=\"hljs-string\">&quot;view/item/context&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;realTimeBus.revertLine&quot;</span>,\n      <span class=\"hljs-string\">&quot;group&quot;</span>: <span class=\"hljs-string\">&quot;inline&quot;</span>,  <span class=\"hljs-comment\">// 和文字一行显示</span>\n      <span class=\"hljs-string\">&quot;when&quot;</span>: <span class=\"hljs-string\">&quot;view == realTimeBusLine &amp;&amp; viewItem == BusLineItem&quot;</span>\n    }\n  ]\n}\n\n<span class=\"hljs-comment\">// 配置viewItem == BusLineItem后command回调函数可以接收到被点击的菜单项</span>\ncommands.<span class=\"hljs-title function_\">registerCommand</span>(<span class=\"hljs-string\">&#x27;realTimeBus.revertLine&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">params</span>) =&gt;</span> {\n<span class=\"hljs-title class_\">BusLineProvider</span>.<span class=\"hljs-title function_\">revertLine</span>(params);\n});\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">treeView</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一级菜单可在<code>package.json</code>中配置，二级菜单需要使用<code>TreeDataProvider</code></p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BusLineProvider</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">TreeDataProvider</span>&lt;<span class=\"hljs-title class_\">BusLineTreeItem</span>|<span class=\"hljs-title class_\">BusStopTreeItem</span>&gt;{\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-attr\">instance</span>: <span class=\"hljs-title class_\">BusLineProvider</span>;\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">_onDidChangeTreeData</span>: <span class=\"hljs-title class_\">EventEmitter</span>&lt;<span class=\"hljs-title class_\">BusLineTreeItem</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-built_in\">void</span>&gt; \n    = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventEmitter</span>&lt;<span class=\"hljs-title class_\">BusLineTreeItem</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-built_in\">void</span>&gt;();\n    <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">onDidChangeTreeData</span>: <span class=\"hljs-title class_\">Event</span>&lt;<span class=\"hljs-title class_\">BusLineTreeItem</span> | <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-built_in\">void</span>&gt;\n    = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_onDidChangeTreeData</span>.<span class=\"hljs-property\">event</span>;\n  \n  <span class=\"hljs-title function_\">getTreeItem</span>(<span class=\"hljs-params\">element: BusLineTreeItem</span>) {\n    <span class=\"hljs-keyword\">return</span> element;\n  }\n\n  <span class=\"hljs-comment\">// 核心方法</span>\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getChildren</span>(<span class=\"hljs-params\">item: BusLineTreeItem|BusStopTreeItem</span>) {\n    <span class=\"hljs-keyword\">return</span> [];\n  }\n  \n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">getInstance</span>(): <span class=\"hljs-title class_\">BusLineProvider</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span> || (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BusLineProvider</span>());\n  }\n  \n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">refreshLines</span>(<span class=\"hljs-params\">action: () =&gt; <span class=\"hljs-built_in\">void</span> = () =&gt; {}</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span>.<span class=\"hljs-property\">_onDidChangeTreeData</span>.<span class=\"hljs-title function_\">fire</span>();\n  }\n}\n</code></pre>\n<p>创建后注册即可<code>vscode.window.registerTreeDataProvider(&#39;realTimeBusLine&#39;, BusLineProvider.getInstance());</code></p>\n<p>关键在于<code>getChildren</code>方法</p>\n<p><code>getChildren</code>会在以下情形调用:</p>\n<ol>\n<li><p>调用<code>vscode.window.registerTreeDataProvider</code>注册TreeDataProvider时</p>\n</li>\n<li><p>调用<code>this.instance._onDidChangeTreeData.fire()</code>时</p>\n</li>\n<li><p>点击可折叠<code>TreeItem</code></p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">可折叠菜单</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>设置<code>TreeItem</code>的<code>collapse</code>属性为<code>TreeItemCollapsibleState.Collapsed</code></p>\n<p>点击该菜单时会调用<code>getChildren</code>，该菜单也回作为参数传递给<code>getChildren</code></p>\n"},{"title":"Babel7学习-0","tags":["Babel"],"categories":"Babel","description":"## WHAT\n\n一个JS库，转化JS**高级语法**，处理浏览器间的兼容性。\n\n默认是**只会去转化js语法**的，**不会去转换新的API**，比如像Promise、Generator、Symbol这种全局API对象，babel是不会去编译的。\n\n共有三个必备库：\n\n- `@babel/core`，对代码进行转换的核心方法\n- `@babel/cli`，babel带有的内置cli，可以用来","createDate":"2021-01-25 15:00:40","updateDate":"2021-03-24 22:06:07","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一个JS库，转化JS<strong>高级语法</strong>，处理浏览器间的兼容性。</p>\n<p>默认是<strong>只会去转化js语法</strong>的，<strong>不会去转换新的API</strong>，比如像Promise、Generator、Symbol这种全局API对象，babel是不会去编译的。</p>\n<p>共有三个必备库：</p>\n<ul>\n<li><code>@babel/core</code>，对代码进行转换的核心方法</li>\n<li><code>@babel/cli</code>，babel带有的内置cli，可以用来让我们从命令行来编译我们的文件</li>\n<li><code>@babel/plugin*</code>/<code>@babel/preset-env</code>，需要工作的babel插件</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>兼容性</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>安装必备库：</li>\n</ul>\n<p><code>yarn add @babel/core @babel/cli @babel/preser-env -D</code></p>\n<p><code>yarn add </code></p>\n<ul>\n<li>根目录创建<code>babel.config.js</code></li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">presets</span>: [\n    [\n      <span class=\"hljs-string\">&quot;@babel/preset-env&quot;</span>,\n    ]\n  ],\n  <span class=\"hljs-string\">&quot;plugins&quot;</span>: [\n    [\n      <span class=\"hljs-string\">&quot;@babel/plugin-transform-runtime&quot;</span>,\n      {\n        <span class=\"hljs-string\">&quot;corejs&quot;</span>: <span class=\"hljs-number\">3</span>\n      }\n    ],\n  ]\n};\n</code></pre>\n<ul>\n<li>入口文件引入</li>\n</ul>\n"},{"title":"typescript学习-Utility Types","tags":["typescript","UtilityTypes"],"categories":"typescript","description":"## Partial<Type>\n\n返回一个所有 property 都可选的 type\n  \n``` ts\ntype Partial<T> = {\n    [P in keyof T]?: T[P]\n}\n// 使用\ninterface Todo {\n  title: string;\n  description: string;\n}\nconst newTodo: Partial<Todo> =","createDate":"2021-02-25 15:22:38","updateDate":"2021-02-25 23:22:43","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Partial<Type></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>返回一个所有 property 都可选的 type</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Partial</span>&lt;T&gt; = {\n    [P <span class=\"hljs-keyword\">in</span> keyof T]?: T[P]\n}\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Todo</span> {\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">description</span>: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">newTodo</span>: <span class=\"hljs-title class_\">Partial</span>&lt;<span class=\"hljs-title class_\">Todo</span>&gt; = {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;title&#x27;</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Required&lt; Type &gt;</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使 Type 中所有属性必选。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Pick&lt;Type, Keys&gt;</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>从 Type 中挑选出 Keys 中指定 key 在 Type 中存在的类型，组成一个新类型</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Pick</span>&lt;T, K <span class=\"hljs-keyword\">extends</span> keyof T&gt; = {\n    [P <span class=\"hljs-keyword\">in</span> K]: T[P]\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Omit&lt;Type, Keys&gt;</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>从排除 Type 的 property 中排除 keys 中指定的 property。Type 中剩下的 properties 形成一个新类型。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Extract&lt;Type, Union&gt;</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>取两个联合类型的交集</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Parameters&lt; Type &gt;</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>返回一个函数类型的参数的类型，值为元祖类型</p>\n"},{"title":"python-urllib库的使用","tags":["python","urllib"],"categories":"Python","description":"# Python urllib库的介绍及使用\n\n@(python)[urllib]\n\n**urllib**库，是 Python 内置的 HTTP 请求库 ，也就是说不需要额外安装即可使用。它包含如下 4 个模块：\n- **request** ：最基本的 HTTP 请求模块，可以用来模拟发送请求 。 就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个","createDate":"2018-11-13 12:14:43","updateDate":"2021-02-20 17:21:39","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Python urllib库的介绍及使用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>@(python)[urllib]</p>\n<p><strong>urllib</strong>库，是 Python 内置的 HTTP 请求库 ，也就是说不需要额外安装即可使用。它包含如下 4 个模块：</p>\n<ul>\n<li><strong>request</strong> ：最基本的 HTTP 请求模块，可以用来模拟发送请求 。 就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个过程；</li>\n<li><strong>error</strong> ：异常处理模块，如果出现请求错误 ， 我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止；</li>\n<li><strong>parse</strong> ：一个工具模块，提供了许多 URL 处理方法，比如拆分、解析 、 合并等。</li>\n<li><strong>robotparse</strong>：主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少；</li>\n</ul>\n<p>接下来主要介绍前三个模块：<strong>request</strong>/<strong>error</strong>/<strong>parse</strong></p>\n"},{"title":"Python-正则表达式","tags":["Python","正则表达式"],"categories":"Python","description":"# 正则表达式\n\n- 正则表达式匹配，就是按照一定的规则将特定的文本提取出来。\n  ![enter image description here](https://t1.picb.cc/uploads/2018/11/15/JXfxNi.jpg)\n\n## match\n\n- match(0)法会尝试从字符串的**起始位置**匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回 fa","createDate":"2018-11-15 19:55:58","updateDate":"2021-02-20 17:21:17","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">正则表达式</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>正则表达式匹配，就是按照一定的规则将特定的文本提取出来。\n<img src=\"https://t1.picb.cc/uploads/2018/11/15/JXfxNi.jpg\" alt=\"enter image description here\"></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">match</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>match(0)法会尝试从字符串的<strong>起始位置</strong>匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回 false。</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">match 示例</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">匹配目标</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>可以使用&quot;（）&quot;将想提取的子字符串括起来，&quot;（）&quot;实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用 group()法传入分组的索引即可获取提取的结果。</li>\n</ul>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\ncontent = <span class=\"hljs-string\">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span>\nresult0 = re.match(<span class=\"hljs-string\">&#x27;^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}&#x27;</span>, content)\nresult1 = re.match(<span class=\"hljs-string\">&#x27;^Hello\\s(\\d+)\\s(\\d+)\\sWorld&#x27;</span>, content)\n<span class=\"hljs-built_in\">print</span>(result0)\n<span class=\"hljs-built_in\">print</span>(result1)\n<span class=\"hljs-built_in\">print</span>(result1.group(<span class=\"hljs-number\">1</span>), result1.group(<span class=\"hljs-number\">2</span>))\n\n\n<span class=\"hljs-comment\"># 输出</span>\n&lt;re.Match <span class=\"hljs-built_in\">object</span>; span=(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">25</span>), match=<span class=\"hljs-string\">&#x27;Hello 123 4567 World_This&#x27;</span>&gt;\n&lt;re.Match <span class=\"hljs-built_in\">object</span>; span=(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">20</span>), match=<span class=\"hljs-string\">&#x27;Hello 123 4567 World&#x27;</span>&gt;\n<span class=\"hljs-number\">123</span> <span class=\"hljs-number\">4567</span>\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">通用匹配</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li>”.*“可以匹配任意长度字符串(换行符除外)。</li>\n<li>”.“可以匹配任意字符(换行符除外)</li>\n<li>”*“代表匹配前面的字符无限次</li>\n</ul>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\ncontent = <span class=\"hljs-string\">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span>\nresult = re.match(<span class=\"hljs-string\">&#x27;^Hello\\s(\\d+)\\s(\\d+)\\s(.*?)Demo$&#x27;</span>, content)\n<span class=\"hljs-built_in\">print</span>(result)\n<span class=\"hljs-built_in\">print</span>(result.group(<span class=\"hljs-number\">3</span>))\n\n\n<span class=\"hljs-comment\"># 输出</span>\n&lt;re.Match <span class=\"hljs-built_in\">object</span>; span=(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">41</span>), match=<span class=\"hljs-string\">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span>&gt;\nWorld_This <span class=\"hljs-keyword\">is</span> a Regex\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">贪婪匹配</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>使用”.*“通用匹配时，可能会得不到想要的结果：</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\ncontent = <span class=\"hljs-string\">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span>\n\nresult = re.match(<span class=\"hljs-string\">&#x27;^He.*(\\d+).*Demo$&#x27;</span>, content)\n<span class=\"hljs-built_in\">print</span>(result.group(<span class=\"hljs-number\">1</span>))\n\n\n<span class=\"hljs-comment\"># 输出</span>\n<span class=\"hljs-number\">7</span>\n</code></pre>\n<p>想要的结果是 123，却输出了 7。这就涉及到贪婪与非贪婪匹配了。</p>\n<ul>\n<li>在贪婪匹配下， &quot;._&quot;会匹配尽可能多的字符。\n所以在上面的正则表达式中，”._“直接匹配到了&#39;Hello 123 456&#39;，&#39;\\d&#39;匹配到了&#39;7&#39;。</li>\n<li>在非贪婪匹配下， &quot;.<em>&quot;会匹配尽可能少的字符。非贪婪匹配的写法是&quot;.</em>?&quot;。</li>\n</ul>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\ncontent = <span class=\"hljs-string\">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span>\nresult = re.match(<span class=\"hljs-string\">&#x27;^He.*?(\\d+).*Demo$&#x27;</span>, content)\n<span class=\"hljs-built_in\">print</span>(result.group(<span class=\"hljs-number\">1</span>))\n\n\n<span class=\"hljs-comment\"># 输出</span>\n<span class=\"hljs-number\">123</span>\n</code></pre>\n<p>在做匹配的时候，字符串<strong>中间尽量使用非贪婪匹配</strong>，但需要注意，如果匹配的结果在字符串结尾，&quot;.*?&quot;就有可能匹配不到任何内容了。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">修饰符</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>正则表达式可以包含一些<strong>可选标志修饰符来控制匹配的模式</strong> 。\n<img src=\"https://t1.picb.cc/uploads/2018/11/15/JX62zc.png\" alt=\"enter image description here\"></p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\ncontent = <span class=\"hljs-string\">&#x27;&#x27;&#x27;Hello 123 4567 World_This\n          is a Regex Demo&#x27;&#x27;&#x27;</span>\nresult_none = re.match(<span class=\"hljs-string\">&#x27;^He.*?(\\d+).*Demo$&#x27;</span>, content)\n<span class=\"hljs-built_in\">print</span>(result_none)\n\nresult = re.match(<span class=\"hljs-string\">&#x27;^He.*?(\\d+).*Demo$&#x27;</span>, content, re.S)\n<span class=\"hljs-built_in\">print</span>(result)\n\n\n<span class=\"hljs-comment\"># 输出</span>\n<span class=\"hljs-literal\">None</span>\n&lt;re.Match <span class=\"hljs-built_in\">object</span>; span=(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">52</span>), match=<span class=\"hljs-string\">&#x27;Hello 123 4567 World_This \\n          is a Regex &gt;</span>\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">转义匹配</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可 。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">search</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>search ()，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果 。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">search 示例</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\nhtml = <span class=\"hljs-string\">&#x27;&#x27;&#x27;&lt;div id=&quot;songs-list&quot;&gt;\n    &lt;h2 class=&quot;title&quot;&gt;经典老歌&lt;/h2&gt;\n    &lt;p class=&quot;introduction&quot;&gt;\n        经典老歌列表\n    &lt;/p&gt;\n    &lt;ul id=&quot;list&quot; class=&quot;list-group&quot;&gt;\n        &lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt;\n        &lt;li data-view=&quot;7&quot;&gt;\n            &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一声笑&lt;/a&gt;\n        &lt;/li&gt;\n        &lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt;\n            &lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt;\n        &lt;/li&gt;\n        &lt;li data-view=&quot;6&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;\n        &lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈慧琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;&#x27;&#x27;&#x27;</span>\n\nresult = re.search(<span class=\"hljs-string\">&#x27;&lt;li.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#x27;</span>, html, re.S)\n<span class=\"hljs-built_in\">print</span>(result.group(<span class=\"hljs-number\">1</span>), result.group(<span class=\"hljs-number\">2</span>))\nresult = re.search(<span class=\"hljs-string\">&#x27;&lt;li.*?href=&quot;(.*?)&quot;\\ssinger=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#x27;</span>, html, re.S)\n<span class=\"hljs-comment\">#print(result)</span>\n<span class=\"hljs-built_in\">print</span>(result.group(<span class=\"hljs-number\">1</span>), result.group(<span class=\"hljs-number\">2</span>), result.group(<span class=\"hljs-number\">3</span>))\n\n\n<span class=\"hljs-comment\"># 输出</span>\n任贤齐 沧海一声笑\n/<span class=\"hljs-number\">2.</span>mp3 任贤齐 沧海一声笑\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">findall</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>findall()方法会搜索整个字符串然后返回匹配正则表达式的所有内容。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">findall 示例</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\">...\n...\nresult = re.search(<span class=\"hljs-string\">&#x27;&lt;li.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#x27;</span>, html, re.S)\n<span class=\"hljs-built_in\">print</span>(result.group(<span class=\"hljs-number\">1</span>), result.group(<span class=\"hljs-number\">2</span>))\nresult = re.search(<span class=\"hljs-string\">&#x27;&lt;li.*?href=&quot;(.*?)&quot;\\ssinger=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#x27;</span>, html, re.S)\n\n\n<span class=\"hljs-comment\"># 输出</span>\n任贤齐 沧海一声笑\n/<span class=\"hljs-number\">2.</span>mp3 任贤齐 沧海一声笑\n/<span class=\"hljs-number\">2.</span>mp3 任贤齐 沧海一声笑\n/<span class=\"hljs-number\">3.</span>mp3 齐秦 往事随风\n/<span class=\"hljs-number\">4.</span>mp3 beyond 光辉岁月\n/<span class=\"hljs-number\">5.</span>mp3 陈慧琳 记事本\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">sub</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>用来修改/替换文本</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">sub 使用示例</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\n<span class=\"hljs-keyword\">import</span> re\n\ncontent = <span class=\"hljs-string\">&#x27;54ak54yr50ir54ix5L2g&#x27;</span>\ncontent = re.sub(<span class=\"hljs-string\">&#x27;\\d&#x27;</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>, content)\n<span class=\"hljs-built_in\">print</span>(content)\n\n\n<span class=\"hljs-comment\"># 输出</span>\nakyririxLg\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">compile</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>compile()可以将正则字符串编译成正则表达式对象，以便在以后的匹配中复用(也可以传入修饰符)。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\n\ncontent0 = <span class=\"hljs-string\">&#x27;2016-12-15 12:00&#x27;</span>\ncontent1 = <span class=\"hljs-string\">&#x27;2016-12-17 12:55&#x27;</span>\ncontent2 = <span class=\"hljs-string\">&#x27;2016-12-22 13:21&#x27;</span>\n\npattern = re.<span class=\"hljs-built_in\">compile</span>(<span class=\"hljs-string\">&#x27;\\d{2}:\\d{2}&#x27;</span>)\nresult0 = re.sub(pattern, <span class=\"hljs-string\">&#x27;&#x27;</span>, content1)\nresult1 = re.sub(pattern, <span class=\"hljs-string\">&#x27;&#x27;</span>, content1)\nresult2 = re.sub(pattern, <span class=\"hljs-string\">&#x27;&#x27;</span>, content2)\n\n<span class=\"hljs-built_in\">print</span>(result0, result1, result2)\n\n\n<span class=\"hljs-comment\"># 输出</span>\n<span class=\"hljs-number\">2016</span>-<span class=\"hljs-number\">12</span>-<span class=\"hljs-number\">17</span>  <span class=\"hljs-number\">2016</span>-<span class=\"hljs-number\">12</span>-<span class=\"hljs-number\">17</span>  <span class=\"hljs-number\">2016</span>-<span class=\"hljs-number\">12</span>-<span class=\"hljs-number\">22</span>\n</code></pre>\n"},{"title":"Python-BeautifulSoup","tags":["Python","BeautifulSoup"],"categories":"Python","description":"# Python-BeautifulSoup的使用\nBeautiSoup，是借助网页的结构和属性等特性来解析网页的工具，有了它我们不用再去写一些复杂的正则，只需要简单的几条语句就可以完成网页中某个元素的提取。\n## BeautifulSoup简介\n官方解释如下：\nBeautifulSoup提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户","createDate":"2018-11-16 14:50:41","updateDate":"2021-02-20 17:20:24","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Python-BeautifulSoup的使用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>BeautiSoup，是借助网页的结构和属性等特性来解析网页的工具，有了它我们不用再去写一些复杂的正则，只需要简单的几条语句就可以完成网页中某个元素的提取。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">BeautifulSoup简介</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>官方解释如下：\nBeautifulSoup提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 BeautifulSoup 自动将输入文档转换为 Unicode 编码，输出文档转换为 utf-8 编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。 BeautifulSoup 已成为和 lxml、html6lib 一样出色的 Python 解释器，为用户灵活地提供不同的解析策略或强劲的速度。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">解析器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>BeautifulSoup 在解析的时候实际上是依赖于解析器的，它除了支持 Python 标准库中的 HTML 解析器，还支持一些第三方的解析器比如 LXML，下面我们对 BeautifulSoup 支持的解析器及它们的一些优缺点做一个简单的对比。\n<img src=\"https://t1.picb.cc/uploads/2018/11/16/JXuhZc.png\" alt=\"enter image description here\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基本使用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> bs4 <span class=\"hljs-keyword\">import</span> BeautifulSoup\n\nhtml = <span class=\"hljs-string\">&#x27;&#x27;&#x27;\n&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;\n&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were\n&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,\n&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and\n&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;\nand they lived at the bottom of a well.&lt;/p&gt;\n&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;\n&#x27;&#x27;&#x27;</span>\n\nsoup = BeautifulSoup(html, <span class=\"hljs-string\">&#x27;lxml&#x27;</span>) \n<span class=\"hljs-built_in\">print</span>(soup.prettify())  <span class=\"hljs-comment\"># 把要解析的字符串以标准的缩进格式输出(自动更正格式)</span>\n<span class=\"hljs-built_in\">print</span>(soup.title.string)\n\n\n<span class=\"hljs-comment\"># 输出</span>\n&lt;html&gt;\n &lt;head&gt;\n  &lt;title&gt;\n   The Dormouse<span class=\"hljs-string\">&#x27;s story\n  &lt;/title&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;\n   &lt;b&gt;\n    The Dormouse&#x27;</span>s story\n   &lt;/b&gt;\n  &lt;/p&gt;\n  &lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;\n   Once upon a time there were three little sisters; <span class=\"hljs-keyword\">and</span> their names were\n   &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/elsie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link1&quot;</span>&gt;\n    &lt;!-- Elsie --&gt;\n   &lt;/a&gt;\n   ,\n   &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;\n    Lacie\n   &lt;/a&gt;\n   <span class=\"hljs-keyword\">and</span>\n   &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;\n    Tillie\n   &lt;/a&gt;\n   ;\n<span class=\"hljs-keyword\">and</span> they lived at the bottom of a well.\n  &lt;/p&gt;\n  &lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;\n   ...\n  &lt;/p&gt;\n &lt;/body&gt;\n&lt;/html&gt;\nThe Dormouse<span class=\"hljs-string\">&#x27;s story</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">节点选择器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">选择元素</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\">soup = BeautifulSoup(html, <span class=\"hljs-string\">&#x27;lxml&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(soup.title)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">type</span>(soup.title.string))\n<span class=\"hljs-built_in\">print</span>(soup.title.string)\n<span class=\"hljs-built_in\">print</span>(soup.head)\n<span class=\"hljs-built_in\">print</span>(soup.p)  <span class=\"hljs-comment\"># 只选择第一个出现的p标签</span>\n\n\n<span class=\"hljs-comment\"># 输出</span>\n&lt;title&gt;The Dormouse<span class=\"hljs-string\">&#x27;s story&lt;/title&gt;\n&lt;class &#x27;</span>bs4.element.NavigableString<span class=\"hljs-string\">&#x27;&gt;\nThe Dormouse&#x27;</span>s story\n&lt;head&gt;&lt;title&gt;The Dormouse<span class=\"hljs-string\">&#x27;s story&lt;/title&gt;&lt;/head&gt;\n&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;</span>s story&lt;/b&gt;&lt;/p&gt;\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">提取信息</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取名称</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>可以利用 name 属性来获取节点的名称。还是以上面的文本为例，我们选取 title 节点，然后调用 name 属性就可以得到节点名称。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(soup.title.name)\n\n<span class=\"hljs-comment\"># 输出</span>\ntitle\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取属性</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>每个节点可能有多个属性，比如 id，class 等等，我们选择到这个节点元素之后，可以调用 attrs 获取所有属性。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(soup.p.attrs)\n<span class=\"hljs-built_in\">print</span>(soup.p.attrs[<span class=\"hljs-string\">&#x27;name&#x27;</span>])\n<span class=\"hljs-comment\">#更加简便的写法</span>\n<span class=\"hljs-built_in\">print</span>(soup.p[<span class=\"hljs-string\">&#x27;name&#x27;</span>])\n<span class=\"hljs-built_in\">print</span>(soup.p[<span class=\"hljs-string\">&#x27;class&#x27;</span>])\n\n<span class=\"hljs-comment\"># 输出</span>\n{<span class=\"hljs-string\">&#x27;class&#x27;</span>: [<span class=\"hljs-string\">&#x27;title&#x27;</span>], <span class=\"hljs-string\">&#x27;name&#x27;</span>: <span class=\"hljs-string\">&#x27;dromouse&#x27;</span>}\ndromouse\ndromouse\n[<span class=\"hljs-string\">&#x27;title&#x27;</span>]\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取内容</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>可以利用 string 属性获取节点元素包含的文本内容。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(soup.p.string)\n\n<span class=\"hljs-comment\"># 输出</span>\nThe Dormouse<span class=\"hljs-string\">&#x27;s story</span>\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">嵌套选择</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>在上面的例子中我们知道每一个返回结果都是 bs4.element.Tag 类型，它同样可以继续调用节点进行下一步的选择，比如我们获取了 head 节点元素，我们可以继续调用 head 来选取其内部的 head 节点元素。</p>\n<pre><code class=\"hljs language-python\">html = <span class=\"hljs-string\">&quot;&quot;&quot;\n&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&quot;&quot;&quot;</span>\n\n<span class=\"hljs-keyword\">from</span> bs4 <span class=\"hljs-keyword\">import</span> BeautifulSoup\nsoup = BeautifulSoup(html, <span class=\"hljs-string\">&#x27;lxml&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(soup.head.title)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">type</span>(soup.head.title))\n<span class=\"hljs-built_in\">print</span>(soup.head.title.string)\n\n\n<span class=\"hljs-comment\"># 输出</span>\n&lt;title&gt;The Dormouse<span class=\"hljs-string\">&#x27;s story&lt;/title&gt;\n&lt;class &#x27;</span>bs4.element.Tag<span class=\"hljs-string\">&#x27;&gt;\nThe Dormouse&#x27;</span>s story\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">关联选择</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>我们在做选择的时候有时候不能做到一步就可以选择到想要的节点元素，有时候在选择的时候需要先选中某一个节点元素，然后以它为基准再选择它的子节点、父节点、兄弟节点等等。</p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">子节点和子孙节点</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>选取到了一个节点元素之后，如果想要获取它的<strong>直接子节点</strong>可以调用 contents 属性。 contents 返回的是列表类型， children 返回的是生成器类型。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(soup.p.contents)\n<span class=\"hljs-built_in\">print</span>(soup.p.children)\n<span class=\"hljs-built_in\">print</span>(soup.p.contents)\n\n<span class=\"hljs-built_in\">print</span>(soup.p.children)\n<span class=\"hljs-keyword\">for</span> i, child <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(soup.p.children):\n    <span class=\"hljs-built_in\">print</span>(i, child)\n\n\n<span class=\"hljs-comment\"># 输出</span>\n[<span class=\"hljs-string\">&#x27;Once upon a time there were three little sisters; and their names were\\n&#x27;</span>, &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/elsie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, <span class=\"hljs-string\">&#x27;,\\n&#x27;</span>, &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt;, <span class=\"hljs-string\">&#x27; and\\n&#x27;</span>, &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;, <span class=\"hljs-string\">&#x27;;\\nand they lived at the bottom of a well.&#x27;</span>]\n\n<span class=\"hljs-number\">0</span> Once upon a time there were three little sisters; <span class=\"hljs-keyword\">and</span> their names were\n\n<span class=\"hljs-number\">1</span> &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/elsie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;\n<span class=\"hljs-number\">2</span> ,\n\n<span class=\"hljs-number\">3</span> &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt;\n<span class=\"hljs-number\">4</span>  <span class=\"hljs-keyword\">and</span>\n\n<span class=\"hljs-number\">5</span> &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;\n<span class=\"hljs-number\">6</span> ;\n<span class=\"hljs-keyword\">and</span> they lived at the bottom of a well.\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">父节点和祖先节点</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>如果要获取某个节点元素的直接父节点，可以调用 parent 属性，要想获取所有的祖先节点，可以调用 parents 。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(soup.a.parent)\n<span class=\"hljs-built_in\">print</span>(soup.a.parents)\n\n<span class=\"hljs-comment\"># 输出</span>\n&lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;Once upon a time there were three little sisters; <span class=\"hljs-keyword\">and</span> their names were\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/elsie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt; <span class=\"hljs-keyword\">and</span>\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;;\n<span class=\"hljs-keyword\">and</span> they lived at the bottom of a well.&lt;/p&gt;\n\n[(<span class=\"hljs-number\">0</span>, &lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;Once upon a time there were three little sisters; <span class=\"hljs-keyword\">and</span> their names were\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/elsie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt; <span class=\"hljs-keyword\">and</span>\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;;\n<span class=\"hljs-keyword\">and</span> they lived at the bottom of a well.&lt;/p&gt;), (<span class=\"hljs-number\">1</span>, &lt;body&gt;\n&lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;Once upon a time there were three little sisters; <span class=\"hljs-keyword\">and</span> their names were\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/elsie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt; <span class=\"hljs-keyword\">and</span>\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;;\n<span class=\"hljs-keyword\">and</span> they lived at the bottom of a well.&lt;/p&gt;\n&lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;...&lt;/p&gt;\n&lt;/body&gt;), (<span class=\"hljs-number\">2</span>, &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse<span class=\"hljs-string\">&#x27;s story&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were\n&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,\n&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and\n&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;\nand they lived at the bottom of a well.&lt;/p&gt;\n&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;\n&lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;</span>s story&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;Once upon a time there were three little sisters; <span class=\"hljs-keyword\">and</span> their names were\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/elsie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link1&quot;</span>&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt; <span class=\"hljs-keyword\">and</span>\n&lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;;\n<span class=\"hljs-keyword\">and</span> they lived at the bottom of a well.&lt;/p&gt;\n&lt;p <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;story&quot;</span>&gt;...&lt;/p&gt;\n&lt;/body&gt;&lt;/html&gt;)]\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">兄弟节点</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> bs4 <span class=\"hljs-keyword\">import</span> BeautifulSoup\nhtml = <span class=\"hljs-string\">&quot;&quot;&quot;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;p class=&quot;story&quot;&gt;\n            Once upon a time there were three little sisters; and their names were\n            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;\n                &lt;span&gt;Elsie&lt;/span&gt;\n            &lt;/a&gt;\n            Hello\n            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; \n            and\n            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;\n            and they lived at the bottom of a well.\n        &lt;/p&gt;\n&quot;&quot;&quot;</span>\nsoup = BeautifulSoup(html, <span class=\"hljs-string\">&#x27;lxml&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;next_sibling&#x27;</span>, soup.a.next_sibling)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;prev_sibling&#x27;</span>, soup.a.previous_sibling)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;next_siblings&#x27;</span>, <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">enumerate</span>(soup.a.next_sibling)))\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;prev_siblings&#x27;</span>, <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">enumerate</span>(soup.a.previous_sibling)))\n\n\n<span class=\"hljs-comment\"># 输出</span>\nnext_sibling \n            Hello\n            \nprev_sibling \n            Once upon a time there were three little sisters; <span class=\"hljs-keyword\">and</span> their names were\n            \nnext_siblings [(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;\\n            Hello\\n            &#x27;</span>), (<span class=\"hljs-number\">1</span>, &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/lacie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link2&quot;</span>&gt;Lacie&lt;/a&gt;), (<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27; \\n            and\\n            &#x27;</span>), (<span class=\"hljs-number\">3</span>, &lt;a <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;sister&quot;</span> href=<span class=\"hljs-string\">&quot;http://example.com/tillie&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;link3&quot;</span>&gt;Tillie&lt;/a&gt;), (<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;\\n            and they lived at the bottom of a well.\\n        &#x27;</span>)]\nprev_siblings [(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;\\n            Once upon a time there were three little sisters; and their names were\\n            &#x27;</span>)]\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">方法选择器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>前面讲的选择方法都是通过属性来选择元素的，这种选择方法非常快，但是如果要进行比较复杂的选择的话则会比较繁琐，不够灵活。所以 BeautifulSoup 还提供了一些查询的方法，比如 find_all()、find() 等方法，我们可以调用方法然后传入相应等参数就可以灵活地进行查询。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">find_all--查找所有符合条件的元素</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> bs4 <span class=\"hljs-keyword\">import</span> BeautifulSoup\nhtml=<span class=\"hljs-string\">&#x27;&#x27;&#x27;\n&lt;div class=&quot;panel&quot;&gt;\n    &lt;div class=&quot;panel-heading&quot;&gt;\n        &lt;h4&gt;Hello&lt;/h4&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;panel-body&quot;&gt;\n        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;\n            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;\n            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;\n            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;\n            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;\n            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&#x27;&#x27;&#x27;</span>\nsoup = BeautifulSoup(html, <span class=\"hljs-string\">&#x27;lxml&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(soup.find_all(name = <span class=\"hljs-string\">&#x27;ul&#x27;</span>))\n<span class=\"hljs-keyword\">for</span> ul <span class=\"hljs-keyword\">in</span> soup.find_all(name = <span class=\"hljs-string\">&#x27;ul&#x27;</span>):\n    <span class=\"hljs-built_in\">print</span>(ul.find_all(name = <span class=\"hljs-string\">&#x27;li&#x27;</span>))\n    <span class=\"hljs-keyword\">for</span> li <span class=\"hljs-keyword\">in</span> ul.find_all(name = <span class=\"hljs-string\">&#x27;li&#x27;</span>):\n        <span class=\"hljs-built_in\">print</span>(li.string)\n\n<span class=\"hljs-comment\"># 输出</span>\n[&lt;ul <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;list&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;list-1&quot;</span>&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Jay&lt;/li&gt;\n&lt;/ul&gt;, &lt;ul <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;list list-small&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;list-2&quot;</span>&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;\n&lt;/ul&gt;]\n[&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Jay&lt;/li&gt;]\nFoo\nBar\nJay\n[&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;]\nFoo\nBar\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">attrs</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>根据属性进行查询</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(soup.find_all(attrs = {<span class=\"hljs-string\">&#x27;id&#x27;</span>: <span class=\"hljs-string\">&#x27;list-1&#x27;</span>}))\n\n<span class=\"hljs-comment\"># 输出</span>\n[&lt;ul <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;list&quot;</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;list-1&quot;</span>&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;\n&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Jay&lt;/li&gt;\n&lt;/ul&gt;]\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">text</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>text 参数可以用来匹配节点的文本，传入的形式可以是字符串，可以是正则表达式对象。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> re\nhtml=<span class=\"hljs-string\">&#x27;&#x27;&#x27;\n&lt;div class=&quot;panel&quot;&gt;\n    &lt;div class=&quot;panel-body&quot;&gt;\n        &lt;a&gt;Hello, this is a link&lt;/a&gt;\n        &lt;a&gt;Hello, this is a link, too&lt;/a&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&#x27;&#x27;&#x27;</span>\n<span class=\"hljs-keyword\">from</span> bs4 <span class=\"hljs-keyword\">import</span> BeautifulSoup\nsoup = BeautifulSoup(html, <span class=\"hljs-string\">&#x27;lxml&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(soup.find_all(text=re.<span class=\"hljs-built_in\">compile</span>(<span class=\"hljs-string\">&#x27;link&#x27;</span>)))\n\n<span class=\"hljs-comment\"># 输出</span>\n[<span class=\"hljs-string\">&#x27;Hello, this is a link&#x27;</span>, <span class=\"hljs-string\">&#x27;Hello, this is a link, too&#x27;</span>]\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">find()</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>find方法和find_all类似，只是返回的是第一个匹配的元素</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">othres API</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p>find_parents() find_parent()\nfind_parents() 返回所有祖先节点，find_parent() 返回直接父节点。</p>\n</li>\n<li><p>find_next_siblings() find_next_sibling()\nfind_next_siblings() 返回后面所有兄弟节点，find_next_sibling() 返回后面第一个兄弟节点。</p>\n</li>\n<li><p>find_previous_siblings() find_previous_sibling()\nfind_previous_siblings() 返回前面所有兄弟节点，find_previous_sibling() 返回前面第一个兄弟节点。</p>\n</li>\n<li><p>find_all_next() find_next()\nfind_all_next() 返回节点后所有符合条件的节点, find_next() 返回第一个符合条件的节点。</p>\n</li>\n<li><p>find_all_previous() 和 find_previous()\nfind_all_previous() 返回节点后所有符合条件的节点, find_previous() 返回第一个符合条件的节点</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CSS选择器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>BeautifulSoup 还提供了另外一种选择器，那就是 CSS 选择器。使用 CSS 选择器，只需要调用 select() 方法，传入相应的 CSS 选择器即可。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> bs4 <span class=\"hljs-keyword\">import</span> BeautifulSoup\nhtml=<span class=\"hljs-string\">&#x27;&#x27;&#x27;\n&lt;div class=&quot;panel&quot;&gt;\n    &lt;div class=&quot;panel-heading&quot;&gt;\n        &lt;h4&gt;Hello&lt;/h4&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;panel-body&quot;&gt;\n        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;\n            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;\n            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;\n            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;\n            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;\n            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&#x27;&#x27;&#x27;</span>\nsoup = BeautifulSoup(html, <span class=\"hljs-string\">&#x27;lxml&#x27;</span>)\n<span class=\"hljs-built_in\">print</span>(soup.select(<span class=\"hljs-string\">&#x27;.panel .panel-heading&#x27;</span>))\n<span class=\"hljs-built_in\">print</span>(soup.select(<span class=\"hljs-string\">&#x27;ul li&#x27;</span>))\n<span class=\"hljs-built_in\">print</span>(soup.select(<span class=\"hljs-string\">&#x27;#list-2 .element&#x27;</span>))\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">type</span>(soup.select(<span class=\"hljs-string\">&#x27;ul&#x27;</span>)[<span class=\"hljs-number\">0</span>]))\n\n\n<span class=\"hljs-comment\"># 输出</span>\n[&lt;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;panel-heading&quot;</span>&gt;\n&lt;h4&gt;Hello&lt;/h4&gt;\n&lt;/div&gt;]\n[&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Jay&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;]\n[&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;]\n&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-string\">&#x27;bs4.element.Tag&#x27;</span>&gt;\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">嵌套选择</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>select() 方法同样支持嵌套选择，例如我们先选择所有 ul 节点，再遍历每个 ul 节点选择其 li 节点。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">for</span> ul <span class=\"hljs-keyword\">in</span> soup.select(<span class=\"hljs-string\">&#x27;ul&#x27;</span>):\n    <span class=\"hljs-built_in\">print</span>(ul.select(<span class=\"hljs-string\">&#x27;li&#x27;</span>))\n\n<span class=\"hljs-comment\"># 输出</span>\n[&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Jay&lt;/li&gt;]\n[&lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Foo&lt;/li&gt;, &lt;li <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;element&quot;</span>&gt;Bar&lt;/li&gt;]\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取属性</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">for</span> ul <span class=\"hljs-keyword\">in</span> soup.select(<span class=\"hljs-string\">&#x27;ul&#x27;</span>):\n    <span class=\"hljs-built_in\">print</span>(ul[<span class=\"hljs-string\">&#x27;id&#x27;</span>])\n    <span class=\"hljs-built_in\">print</span>(ul.attrs[<span class=\"hljs-string\">&#x27;id&#x27;</span>])\n\n<span class=\"hljs-comment\"># 输出</span>\n<span class=\"hljs-built_in\">list</span>-<span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">list</span>-<span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">list</span>-<span class=\"hljs-number\">2</span>\n<span class=\"hljs-built_in\">list</span>-<span class=\"hljs-number\">2</span>\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">获取文本</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>获取文本可以用前面所讲的 string 属性，还有一个方法那就是 get_text()。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">for</span> li <span class=\"hljs-keyword\">in</span> soup.select(<span class=\"hljs-string\">&#x27;li&#x27;</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;Get Text:&#x27;</span>, li.get_text())\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;String:&#x27;</span>, li.string)\n\n<span class=\"hljs-comment\"># 输出</span>\nGet Text: Foo\nString: Foo\nGet Text: Bar\nString: Bar\nGet Text: Jay\nString: Jay\nGet Text: Foo\nString: Foo\nGet Text: Bar\nString: Bar\n</code></pre>\n"},{"title":"前端架构&软实力-移动端适配","tags":["移动端适配"],"categories":"前端架构&软实力","description":"# 移动端适配具体含义\n\n为了在移动端让页面获得更好的显示效果，我们必须让**布局视口、视觉视口都尽可能等于理想视口**，但这并不能保证它们显示完全一致，我们需要一种方案（rem + vw适配）来让设计稿得到更完美的适配。\n\n# 三个视口\n\n1. 布局视口\n\n   ![布局视口](https://user-gold-cdn.xitu.io/2019/5/17/16ac3a666e96ff01?","createDate":"2020-04-21 22:33:00","updateDate":"2021-02-20 17:16:39","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">移动端适配具体含义</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>为了在移动端让页面获得更好的显示效果，我们必须让<strong>布局视口、视觉视口都尽可能等于理想视口</strong>，但这并不能保证它们显示完全一致，我们需要一种方案（rem + vw适配）来让设计稿得到更完美的适配。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">三个视口</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li><p>布局视口</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/17/16ac3a666e96ff01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"布局视口\">\n布局视口(<code>layout viewport</code>)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。</p>\n<p>所以，布局视口是网页布局的基准窗口，在<code>PC</code>浏览器上，布局视口就等于当前浏览器的窗口大小（不包括<code>borders</code> 、<code>margins</code>、滚动条）。</p>\n<p>在移动端，布局视口被赋予一个默认值，大部分为<code>980px</code>，这保证<code>PC</code>的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p>\n<p>我们可以通过调用<code>document.documentElement.clientWidth / clientHeight</code>来获取布局视口大小。</p>\n</li>\n<li><p>视觉视口</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/5/17/16ac3a66924ef751?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"视觉视口\">\n视觉视口(<code>visual viewport</code>)：用户通过屏幕真实看到的区域。</p>\n<p>视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。</p>\n<p>当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是<strong>缩放会改变视觉视口</strong>的大小。</p>\n<p>例如：用户将浏览器窗口放大了<code>200%</code>，这时浏览器窗口中的<code>CSS像素</code>会随着视觉视口的放大而放大，这时一个<code>CSS</code>像素会跨越更多的物理像素。</p>\n<p>所以，布局视口会限制你的<code>CSS</code>布局，而视觉视口决定用户具体能看到什么。</p>\n<p>我们可以通过调用<code>window.innerWidth / innerHeight</code>来获取视觉视口大小。</p>\n</li>\n<li><p>理想视口</p>\n<p>布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(<code>ideal viewport</code>)就诞生了：网站页面在移动端展示的理想大小 === 设备独立像素</p>\n<p>当页面缩放比例为<code>100%</code>时，<code>CSS像素 = 设备独立像素</code>，<code>理想视口 = 视觉视口</code>。</p>\n<p>我们可以通过调用<code>screen.width / height</code>来获取理想视口大小。</p>\n</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Meta viewport</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <meta> 元素表示那些不能由其它HTML元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面\n\n<p>我们可以借助``元素的<code>viewport</code>来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span>  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span>  <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;</span>&gt;</span>\n</code></pre>\n<p><code>device-width</code>就等于理想视口的宽度，所以设置<code>width=device-width</code>就相当于让布局视口等于理想视口。</p>\n<p>由于<code>initial-scale = 理想视口宽度 / 视觉视口宽度</code>，所以我们设置<code>initial-scale=1;</code>就相当于让视觉视口等于理想视口。</p>\n<p>这时，1个<code>CSS</code>像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">rem + vw适配</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>rem是相对于根元素的字体大小的单位，也就是html的font-size大小，浏览器默认的字体大小是16px，所以默认的1rem=16px，我们可以根据设备宽度动态设置根元素的font-size，使得以rem为单位的元素在不同终端上以相对一致的视觉效果呈现。</p>\n</li>\n<li><p><code>vh、vw</code>分别对应于视觉视口宽度 <code>window.innerHeight</code>和视觉视口高度 <code>window.innerWidth</code></p>\n<p><code>100vh === window.innerHeight</code>，<code>100vw === window.innerWidth</code></p>\n</li>\n</ul>\n<ol>\n<li><p>设置meta标签</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span>  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span>  <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;</span>&gt;</span>\n</code></pre>\n</li>\n<li><p>设置根<code>font-size</code>（对应于750px设计稿）</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">html</span> {\n    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">13.3333vw</span>\n}\n\n<span class=\"hljs-comment\">/*\n750px = 100vw\n1px = 0.13333vw\n\n假定1rem = 100px\n则1rem = 13.333vw\n*/</span>\n</code></pre>\n</li>\n</ol>\n"},{"title":"前端架构&软实力-预加载&懒加载","tags":["预加载&懒加载"],"categories":"前端架构&软实力","description":"# 预加载\n\n## 实现思路\n\n`new`一个新的`Imgnode`，给`Imgnode`的`src`赋值为真正的`src`；该`Imgnode`在加载完毕后相应的图片资源就会在本地缓存。\n\n```js\nfunction  preLoad (...src) {\n\tsrc.forEach(item  => {\n\t\tconst  imgNode = new Image()\n\t\timgNode.sr","createDate":"2020-04-24 21:17:04","updateDate":"2021-02-20 17:16:23","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">预加载</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">实现思路</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>new</code>一个新的<code>Imgnode</code>，给<code>Imgnode</code>的<code>src</code>赋值为真正的<code>src</code>；该<code>Imgnode</code>在加载完毕后相应的图片资源就会在本地缓存。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span>  <span class=\"hljs-title function_\">preLoad</span> (...src) {\n    src.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span>  =&gt;</span> {\n        <span class=\"hljs-keyword\">const</span>  imgNode = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Image</span>()\n        imgNode.<span class=\"hljs-property\">src</span> = realSrc\n    })\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">懒加载</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">实现思路</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>首先设置一个临时属性 <code>data-src</code>，当前元素是否出现在视口时使用 <code>src</code> 代替 <code>data-src</code>。</p>\n<ol>\n<li><p><code>window.onscroll</code> + <code>clientTop</code>，<code>offsetTop</code>，<code>clientHeight</code> <code>scrollTop</code> + 节流 👎</p>\n<p>不容易判断元素的位置</p>\n</li>\n<li><p><code>window.onscroll</code> + <code>Element.getBoundingClientRect()</code> + 节流👎</p>\n<p><code>getBoundingClientRect</code>会触发回流</p>\n</li>\n<li><p><code>IntersectionObserver</code>👍</p>\n<pre><code class=\"hljs language-js\">&lt;img  style=<span class=\"hljs-string\">&quot;width: 200px;&quot;</span>  id=<span class=\"hljs-string\">&quot;img&quot;</span>  data-src=<span class=\"hljs-string\">&quot;./assets/yoda.jpg&quot;</span>  alt=<span class=\"hljs-string\">&quot;&quot;</span>  srcset=<span class=\"hljs-string\">&quot;&quot;</span>&gt;\n\n<span class=\"hljs-keyword\">const</span>  observer = <span class=\"hljs-keyword\">new</span>  <span class=\"hljs-title class_\">IntersectionObserver</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">changes</span>=&gt;</span> {\n    changes.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">change</span>  =&gt;</span> {\n        <span class=\"hljs-comment\">// change.isIntersecting 判断当前元素是否出现在视口中</span>\n        <span class=\"hljs-keyword\">if</span> (change.<span class=\"hljs-property\">isIntersecting</span>) {\n            <span class=\"hljs-keyword\">const</span>  img = change.<span class=\"hljs-property\">target</span>\n            img.<span class=\"hljs-property\">src</span> = img.<span class=\"hljs-property\">dataset</span>.<span class=\"hljs-property\">src</span>\n            <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(img.<span class=\"hljs-property\">dataset</span>, <span class=\"hljs-string\">&quot;src&quot;</span>)\n            observer.<span class=\"hljs-title function_\">unobserve</span>(img)\n        }\n    })\n})\nobserver.<span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#img&quot;</span>))\n</code></pre>\n</li>\n<li><p><code>img</code>的<code>lazy</code>属性 👎</p>\n<p>兼容性差，<a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/%5D(https://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/)\">具体实践</a></p>\n<p><code>&lt;img loading=&quot;lazy&quot; src=&quot;http://blog.p18c.top/imgs/avatar.png&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt;</code></p>\n</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">预加载 VS 懒加载</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>|      | 预加载                             | 懒加载                                      |\n| </p>\n"},{"title":"前端架构&软实力-JSBridge原理","tags":["JSBridge"],"categories":"前端架构&软实力","description":"# 什么是JSBridge\n\nJSBridge是一种JavaScript实现的Bridge，连接着桥两端的native和H5。它在APP里方便地让native调用JavaScript，JavaScript调用native，是双向通信的通道。\n\n# JSBridge双向通信原理\n\n## JavaScript调用native\n\nJavaScript调用native的实现方式较多，主要有：\n\n- 拦","createDate":"2020-04-25 23:01:48","updateDate":"2021-02-20 17:16:05","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是JSBridge</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>JSBridge是一种JavaScript实现的Bridge，连接着桥两端的native和H5。它在APP里方便地让native调用JavaScript，JavaScript调用native，是双向通信的通道。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JSBridge双向通信原理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript调用native</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>JavaScript调用native的实现方式较多，主要有：</p>\n<ul>\n<li>拦截<code>URL Scheme</code></li>\n<li>重写<code>prompt</code></li>\n<li>注入API</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">拦截<code>URL Scheme</code></span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Android和iOS都可以通过拦截<code>URL Scheme</code>并解析<code>Scheme</code>来决定是否进行对应的native代码逻辑处理。</p>\n<p>Android 的话，<code>Webview</code> 提供了 <code>shouldOverrideUrlLoading</code> 方法来提供给 Native 拦截 H5 发送的 <code>URL Scheme</code> 请求。</p>\n<p>iOS 的 <code>WKWebview</code> 可以根据拦截到的 <code>URL Scheme</code> 和对应的参数执行相关的操作。</p>\n<p>这种方法的优点是不存在漏洞问题、使用灵活，可以实现 H5 和 Native 页面的无缝切换。例如在某一页面需要快速上线的情况下，先开发出 H5 页面。某一链接填写的是 H5 链接，在对应的 Native 页面开发完成前先跳转至 H5 页面，待 Native 页面开发完后再进行拦截，跳转至 Native 页面，此时 H5 的链接无需进行修改。但是使用 iframe.src 来发送 <code>URL Scheme</code> 需要对 URL 的长度作控制，使用复杂，速度较慢。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">重写 prompt 等原生 JS 方法</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Android 4.2 之前注入对象的接口是 <code>addJavascriptInterface</code> ，但是由于安全原因慢慢不被使用。一般会通过修改浏览器的部分 <code>Window</code> 对象的方法来完成操作。主要是拦截 <code>alert</code>、<code>confirm</code>、<code>prompt</code>、<code>console.log</code> 四个方法，分别被 <code>Webview</code> 的 <code>onJsAlert</code>、<code>onJsConfirm</code>、<code>onConsoleMessage</code>、<code>onJsPrompt</code> 监听。</p>\n<p>iOS 由于安全机制，<code>WKWebView</code> 对 <code>alert</code>、<code>confirm</code>、<code>prompt</code> 等方法做了拦截，如果通过此方式进行 Native 与 JS 交互，需要实现 <code>WKWebView</code> 的三个 <code>WKUIDelegate</code> 代理方法。</p>\n<p>使用该方式时，可以与 Android 和 iOS 约定好使用传参的格式，这样 H5 可以无需识别客户端，传入不同参数直接调用 Native 即可。剩下的交给客户端自己去拦截相同的方法，识别相同的参数，进行自己的处理逻辑即可实现多端表现一致。另外，如果能与 Native 确定好方法名、传参等调用的协议规范，这样其它格式的 <code>prompt</code> 等方法是不会被识别的，能起到隔离的作用。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注入API</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>基于 <code>Webview</code> 提供的能力，可以向 <code>Window</code> 上注入对象或方法。JavaScript 通过这个对象或方法进行调用时，执行对应的逻辑操作，可以直接调用 Native 的方法。使用该方式时，JavaScript 需要等到 Native 执行完对应的逻辑后才能进行回调里面的操作。</p>\n<p>Android 的 <code>Webview</code> 提供了 <code>addJavascriptInterface</code> 方法，支持 Android 4.2 及以上系统。</p>\n<p>iOS 的 <code>UIWebview</code> 提供了 <code>JavaScriptScore</code> 方法，支持 iOS 7.0 及以上系统。<code>WKWebview</code> 提供了 <code>window.webkit.messageHandlers</code> 方法，支持 iOS 8.0 及以上系统。<code>UIWebview</code> 在几年前常用，目前已不常见。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">native调用JavaScript</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>native调用JavaScript只需H5将JavaScript方法暴露在<code>window</code>上给native调用即可</p>\n<p>Android中主要有两种方式实现。在4.4之前，通过loadUrl方法，执行一段JavaScript代码来实现。在4.4之后，可以使用<code>evaluateJavascript</code>方法实现。loadUrl方法使用起来方便简洁，但是效率低无法获得返回结果且调用的时候会刷新webview。evaluateJavascript方法效率高且获取返回值方便，调用时不刷新<code>webview</code>，支持4.4+</p>\n<p>iOS在<code>WKWebview</code>中可以通过<code>evaluateJavascript:javascriptString</code>来实现，支持8.0+</p>\n"},{"title":"前端架构&软实力-性能优化","tags":["性能优化"],"categories":"前端架构&软实力","description":"# 从问题出发\n\n从输入URL到页面加载完成，发生了什么？\n\n1. DNS解析\n2. TCP连接\n3. 发送HTTP请求\n4. 服务端处理请求，返回HTTP响应\n5. 浏览器拿到数据，解析响应内容，把解析的结果展示给用户\n\n前端可以做的：\n\n1. 发送HTTP请求阶段\n2. 渲染服务端响应阶段\n\n# 网络层面-优化HTTP请求\n\n## 减少请求次数\n\n- 精灵图\n- 懒加载\n\n## 减少单次请","createDate":"2020-04-28 21:21:05","updateDate":"2021-02-20 17:15:50","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">从问题出发</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>从输入URL到页面加载完成，发生了什么？</p>\n<ol>\n<li>DNS解析</li>\n<li>TCP连接</li>\n<li>发送HTTP请求</li>\n<li>服务端处理请求，返回HTTP响应</li>\n<li>浏览器拿到数据，解析响应内容，把解析的结果展示给用户</li>\n</ol>\n<p>前端可以做的：</p>\n<ol>\n<li>发送HTTP请求阶段</li>\n<li>渲染服务端响应阶段</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">网络层面-优化HTTP请求</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">减少请求次数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>精灵图</li>\n<li>懒加载</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">减少单次请求所花费的时间</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>按需加载</li>\n<li>gzip压缩</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">选用正确的图片格式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>JPEG，有损压缩、体积小、加载快、不支持透明</p>\n<p>适用于呈现色彩丰富的图片，JPG通常作为大的背景图、轮播图或banner图</p>\n</li>\n<li><p>PNG，无损压缩、质量高、体积大、支持透明</p>\n<p>小的logo、颜色简单且对比强烈的图片</p>\n</li>\n<li><p>SVG，文本文件、体积小、不失真、兼容性好</p>\n<p>图标</p>\n</li>\n<li><p>webP，全能型选手，兼容性差</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"http://blog.p18c.top/2019/06/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3-%E7%BC%93%E5%AD%98/\">合理使用缓存</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">渲染阶段</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注意<code>script</code>标签放置的位置</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用<code>link</code>的<code>rel</code>属性</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>preload</code></p>\n<p>告诉浏览器下载资源，因为在当前导航期间稍后将需要该资源。</p>\n</li>\n<li><p><code>prefetch</code></p>\n<p>提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">扁平化CSS选择器，避免嵌套过深</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">减少重绘与回流</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>使用<code>transform</code>代替<code>top</code></li>\n<li>使用<code>visiblity</code>代替<code>display:none</code></li>\n<li>直接改变<code>clsaaName</code>（把要修改的样式集中到一个<code>class</code>内统一修改）</li>\n<li>避免使用table布局（尽量不要使用table布局。如果没有定宽，表格一列的宽度则由最宽的一列决定，那个很可能在最后一行的宽度超出之前的列宽，引起整体回流造成table可能需要多次计算才能确定好其在渲染树中节点的属性）</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件委托</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">避免操作频繁DOM</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">异步更新DOM （包装成 micro 任务）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>结束<code>script</code>脚本的执行 👉 处理micro队列 👉 render</p>\n"},{"title":"前端架构&软实力-React.js对比Vue.js","tags":["React.js对比Vue.js"],"categories":"前端架构&软实力","description":"# 设计思想\n\n## Vue.js\n\n渐进式框架，采用自底向上增量开发的模式。\n\n所谓渐进式就是把框架分层。\n\n最核心的部分是视图层渲染，然后往外是组件系统，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。\n\n![渐进式](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-5.png)\n\n所谓分层，就是说既可以只用最核心的视图层渲","createDate":"2020-04-28 23:09:43","updateDate":"2021-02-20 17:15:36","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">设计思想</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>渐进式框架，采用自底向上增量开发的模式。</p>\n<p>所谓渐进式就是把框架分层。</p>\n<p>最核心的部分是视图层渲染，然后往外是组件系统，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-5.png\" alt=\"渐进式\"></p>\n<p>所谓分层，就是说既可以只用最核心的视图层渲染功能快速开发一些需求，也可以使用一整套全家桶来开发大型应用。Vue.js由足够的灵活性来适应不同的需求，所以开发者可以根据自己的需求选择不同的层级。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React.js</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>声明式、组件化</p>\n<p>React.js使创建交互式UI变得轻而易举。为应用的每一个状态设计简介地试图，当数据改变时React.js可以有效地更新并渲染组件。此外，React.js可以创建拥有各自状态的组件，再由这些组件构成更加复杂的 UI</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组件间数据交互</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">父子组件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Vue.js中父组件通过<code>props</code>传递数据给子组件，子组件使用<code>$emit</code>触发自定义事件，父组件中监听子组件的自定义事件获取子组件传递来的数据。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React.js</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>React.js中父组件使用<code>props</code>传递数据和回调函数给子组件，子组件通过<code>props</code>传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">跨级组件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>Vue.js中通过<code>provide / inject</code>在祖先组件向所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React.js</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>React.js的<code>Context</code> 提供了一个无需为每层组件手动添加 <code>props</code>就能在组件树间进行数据传递的方法。在父组件创建一个<code>Context</code>对象，通过<code>Context.provider</code>的<code>value</code>属性向消费组件传值。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">响应式原理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Vue.js采用数据劫持&amp;发布-订阅模式来实现响应式，Vue.js在创建<code>vm</code>的时候，会将数据配置在实例当中，然后通过<code>Object.defineProperty</code>对数据进行操作，为数据动态添加了<code>getter</code>与<code>setter</code>方法，当获取数据的时候会触发对应的<code>getter</code>方法，当设置数据的时候会触发对应的<code>setter</code>方法，从而进一步触发<code>vm</code>的<code>watcher</code>方法，然后数据更改，<code>vm</code>则会进一步触发视图更新操作。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React.js</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>React.js中组件不允许通过<code>this.state</code>这种方式直接更改组件的状态。自身设置的状态，可以通过<code>setState</code>来进行更改。在<code>setState</code>中，传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须向上面方式一样的一个对象函数可以接受<code>prevState</code>和<code>props</code>。React.js在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactSetData.png\" alt=\"React更新过程\"></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Diff算法</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>同级比较，再比较子节点</li>\n<li>先判断一方有子节点而另一方没有子节点的情况</li>\n<li>比较双方都有子节点的情况（<a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttp://blog.p18c.top/2020/03/04/Vue.js%E7%A0%94%E8%AF%BB-%E8%99%9A%E6%8B%9FDOM/%5D(http://blog.p18c.top/2020/03/04/Vue.js%E7%A0%94%E8%AF%BB-%E8%99%9A%E6%8B%9FDOM/)\">核心diff算法</a>）</li>\n<li>递归比较子节点</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React.js（<a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://zhuanlan.zhihu.com/p/20346379%5D(https://zhuanlan.zhihu.com/p/20346379)\">Diff详解</a>）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactDomDiff.png\" alt=\"React.js DOM Diff\"></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生命周期</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Vue.js</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>beforeCreate</li>\n</ol>\n<p><code>new Vue()</code>后触发的第一个钩子，在当前阶段<code>data</code>、<code>methods</code>、<code>computed</code>以及<code>watch</code>上的数据和方法均不能被访问</p>\n<ol>\n<li>created</li>\n</ol>\n<p>在实例创建完成之后触发，当前阶段已完成了数据观测，也就是可以使用数据，更改数据，这时更新不会触发<code>updated</code>钩子。可以<strong>做一些初始数据的获取</strong>，在当前阶段<strong>无法访问DOM</strong>（可使用vm.$nextTick）</p>\n<ol>\n<li>beforeMount</li>\n</ol>\n<p>发生在挂载之前，在这之前template已导入渲染函数编译，而且当前阶段虚拟DOM已创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发<code>updated</code></p>\n<ol>\n<li>mounted</li>\n</ol>\n<p>在挂载之后被触发。在当前阶段，真实的DOM被挂载完毕，数据完成双向绑定，可以访问到DOM，可以使用<code>$ref</code>属性对DOM进行操作</p>\n<ol>\n<li>beforeUpdate</li>\n</ol>\n<p>在界面发生更新之前被触发。也就是响应式数据发生改变之前、虚拟DOM重新渲染之前被触发，可以在此阶段对数据进行修改，不会造成重渲染</p>\n<ol>\n<li>updated</li>\n</ol>\n<p>早发生更新之前被触发。当前阶段DOM已完成更新。要注意的是避免在此期间更新数据，因为这样可能会造成无限循环的更新</p>\n<ol>\n<li>beforeDestory</li>\n</ol>\n<p>在实例销毁之前触发。在当前阶段实例完全可以被使用，可以在此阶段做些善后工作，如清除定时器</p>\n<ol>\n<li>destoryed</li>\n</ol>\n<p>在实例销毁之后触发。这时候只剩下DOM，组件已被拆解、数据绑定被卸载、监听被移除、子实例也统统被销毁</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">React.js（<a href=\"https://www.jianguoyun.com/static/stackedit/%5Bhttps://www.jianshu.com/p/b331d0e4b398%5D(https://www.jianshu.com/p/b331d0e4b398)\">生命周期详解</a>）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactLifeCycle.png\" alt=\"React.js生命周期\"></p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/reactLifeCycle-1.png\" alt=\"React.js生命周期1\"></p>\n"},{"title":"前端架构&软实力-前端埋点","tags":["埋点"],"categories":"前端架构&软实力","description":"# WHAT\n\n在线上项目中，需要统计产品中用户行为和使用情况，从而可以从用户和产品的角度去了解用户群体，从而升级和迭代产品，使其更加贴近用户。用户行为数据可以通过前端**数据监控**的方式获得，除此之外，前端还需要实现**性能监控**和**异常监控**。\n\n**实现前端监控**有三个步骤：**前端埋点**和上报、数据处理和数据分析。\n\n## 数据监控\n\n数据监控就是监听用户信息和行为，常见的","createDate":"2020-06-04 22:35:12","updateDate":"2021-02-20 17:15:22","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>在线上项目中，需要统计产品中用户行为和使用情况，从而可以从用户和产品的角度去了解用户群体，从而升级和迭代产品，使其更加贴近用户。用户行为数据可以通过前端<strong>数据监控</strong>的方式获得，除此之外，前端还需要实现<strong>性能监控</strong>和<strong>异常监控</strong>。</p>\n<p><strong>实现前端监控</strong>有三个步骤：<strong>前端埋点</strong>和上报、数据处理和数据分析。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">数据监控</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>数据监控就是监听用户信息和行为，常见的监控项有：</p>\n<ul>\n<li>PV（page view，页面访问量）</li>\n<li>UV（unique view，独立访客）</li>\n<li>用户在每一个页面停留的时间</li>\n<li>用户通过什么入口访问该页面</li>\n<li>用户在相应页面触发的行为</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">性能监控</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>性能监控指监听前端的性能，主要包括监听网页或者产品在用户端的体验。常见的性能监控项包括：</p>\n<ul>\n<li>不同用户、不同机型和不同系统下的首屏加载时间</li>\n<li>http等请求的响应时间</li>\n<li>静态资源整体下载时间</li>\n<li>页面渲染时间</li>\n<li>页面交互动画完成时间</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">异常监控</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>由于产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 try catch 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>\n<ul>\n<li>Javascript 的异常监控</li>\n<li>样式丢失的异常监控</li>\n<li>服务器请求的异常监控</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>获取用户基本信息、行为以及跟踪产品在客户端的使用情况，并以监控数据为基础，指明产品优化的方向。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">手动埋点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>也称代码埋点，即纯手动写代码，调用埋点SDK的函数，在需要埋点的业务逻辑功能位置调用接口上报埋点数据，像<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fwww.umeng.com%2F\">友盟</a>、<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Ftongji.baidu.com%2Fweb%2Fwelcome%2Flogin\">百度统计</a>等第三方数据统计服务商大都采用这种方案。</p>\n<p>优势：</p>\n<ul>\n<li>可自定义属性，自定义事件</li>\n<li>可以细化需求</li>\n<li>相比其他埋点方式减少服务器压力</li>\n</ul>\n<p>劣势：</p>\n<ul>\n<li>工程量大的话，手动埋点会出翔漏洞，不方便审查</li>\n<li>需求变更需重新埋点，成本高</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">可视化埋点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>通过可视化交互的手段，代替上述的代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。缺点就是可以埋点的控件有限，不能手动定制。</p>\n<p>可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。比如国外比较早做可视化的是 <a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fmixpanel.com%2F\">Mixpanel</a>，国内较早支持可视化埋点的有<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fwww.talkingdata.com%2F\">TalkingData</a>、<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fzhugeio.com%2F\">诸葛 IO</a>，2017年腾讯的 <a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fmta.qq.com%2F\">MTA</a> 也宣布支持可视化埋点；相比于手动埋点更新困难，埋点成本高的问题，可视化埋点优化了移动运营中数据采集的流程，能够支持产品运营随时调整埋点，无需再走发版流程，直接把配置结果推入到前端，数据采集流程更简化，也更方便产品的迭代。</p>\n<p>可视化埋点中多数基于Xpath的方案，XPath 是一门在 XML 文档中查找信息的语言，XPath 可用来在 XML 文档中对元素和属性进行遍历。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">无埋点</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>\n<p>优点:</p>\n<ol>\n<li>前端只要一次加载埋点脚本</li>\n</ol>\n<p>缺点:</p>\n<ol>\n<li>服务器性能压力山大</li>\n</ol>\n<p>采用无埋点技术的有主流的 <a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fwww.growingio.com%2F\">GrowingIO</a>、<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fwww.sensorsdata.cn%2F\">神策</a>。</p>\n<p>参考：</p>\n<p><a href=\"https://segmentfault.com/a/1190000015864670\">前端监控和前端埋点方案设计</a></p>\n<p><a href=\"https://www.jianshu.com/p/645a26619508\">小谈前端埋点</a></p>\n"},{"title":"前端架构&软实力-异常监控","tags":["异常监控"],"categories":"前端架构&软实力","description":"# JavaScript中的异常处理方式\n\n对于JavaScript而言，我们面对的仅仅只是异常，异常的出现并不会直接导致JavaScript引擎崩溃，最多只会使当前执行的任务终止\n\n1. 当前代码块将作为一个任务压入任务队列中，JavaScript引擎线程会不断地从任务队列中提取任务执行\n2. 当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务地","createDate":"2020-06-08 22:33:01","updateDate":"2021-02-20 17:15:07","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript中的异常处理方式</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>对于JavaScript而言，我们面对的仅仅只是异常，异常的出现并不会直接导致JavaScript引擎崩溃，最多只会使当前执行的任务终止</p>\n<ol>\n<li>当前代码块将作为一个任务压入任务队列中，JavaScript引擎线程会不断地从任务队列中提取任务执行</li>\n<li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务地执行</li>\n<li>JavaScript引擎线程继续从任务队列中取出下一个任务继续执行</li>\n</ol>\n<p>异常主要分为两大中：<strong>运行时错误</strong>和语<strong>法错误</strong>。语法错误在编写代码期间很容易被发现，运行时错误主要由取值/赋值异常、函数执行出错等</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何捕获异常</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">捕获普通JavaScript异常</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>对于普通的JavaScript异常，常见的做法是使用<code>try-catch</code>进行包裹，当<code>try</code>中的代码块执行出错后，<code>catch</code>将能捕捉到异常，代码也可以继续执行下去</p>\n<p>但<code>try-catch</code>处理异常的能力有限，<strong>只能捕捉到运行时非异步错误</strong>，对于语法错误和异步错误就显得无能为力，捕捉不到</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">捕获异步JavaScript异常</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>window.onerror</code>捕获异常能力比<code>try-catch</code>稍微强点，无论是异步还是非异步运行时错误，<code>onerror</code>都能捕获到</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg, url, row, col, error</span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;我知道错误了&#x27;</span>);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>({\n    msg,  url,  row, col, error\n  })\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n};\n</code></pre>\n<p>使用注意：</p>\n<ul>\n<li>在实际的使用过程中，<code>windows.onerror</code> 主要是来捕获预料之外的错误，而 <code>try-catch</code> 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</li>\n<li><code>window.onerror</code> 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示</li>\n<li><code>window.onerror</code>无法捕获到网络异常的错误</li>\n<li>无法捕获<code>Promise</code>异常</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">捕获<strong>Promise</strong> 异常</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>通过 <code>Promise</code> 可以帮助我们解决异步回调地狱的问题，但是一旦 ~实例抛出异常而你没有用 <code>catch</code> 去捕获的话，<code>onerror</code> 或 <code>try-catch</code> 也无能为力，无法捕捉到错误</p>\n<p>对此可以添加一个 <strong><code>Promise</code> 全局异常捕获事件</strong> <code>unhandledrejection</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;unhandledrejection&quot;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){\n  e.<span class=\"hljs-title function_\">preventDefault</span>()\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;我知道 promise 的错误了&#x27;</span>);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e.<span class=\"hljs-property\">reason</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n});\n</code></pre>\n<p>|                    | 同步方法 | 异步方法 | 资源加载 | Promise | async/await |\n| </p>\n"},{"title":"异常监控-工程化","tags":["异常监控"],"categories":"前端架构&软实力","description":"// todo","createDate":"2020-07-28 11:15:28","updateDate":"2021-02-20 17:14:53","body":"<p>// todo</p>\n"},{"title":"异常监控-异常上报","tags":["异常监控"],"categories":"前端架构&软实力","description":"# 上报数据结构设计\n\n## 公共信息\n\n```js\ninterface BaseinfoI {\n  title: string;        // 页面名称\n  location: string;     // 页面url\n  message: string;      // 报错信息\n  kind: string;         // 报错大类\n  type: string;","createDate":"2020-07-28 11:15:28","updateDate":"2021-02-20 17:14:37","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">上报数据结构设计</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">公共信息</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">title</span>: string;        <span class=\"hljs-comment\">// 页面名称</span>\n  <span class=\"hljs-attr\">location</span>: string;     <span class=\"hljs-comment\">// 页面url</span>\n  <span class=\"hljs-attr\">message</span>: string;      <span class=\"hljs-comment\">// 报错信息</span>\n  <span class=\"hljs-attr\">kind</span>: string;         <span class=\"hljs-comment\">// 报错大类</span>\n  <span class=\"hljs-attr\">type</span>: string;         <span class=\"hljs-comment\">// 报错小类</span>\n  <span class=\"hljs-attr\">errorType</span>: string;    <span class=\"hljs-comment\">// 报错类型</span>\n  <span class=\"hljs-attr\">userAgent</span>: string;    <span class=\"hljs-comment\">// 浏览器信息</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JS错误</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">JSRunTimeErrorEventI</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">filename</span>: string;     <span class=\"hljs-comment\">// 报错js文件名</span>\n  <span class=\"hljs-attr\">position</span>: string;     <span class=\"hljs-comment\">// 报错位置(行号:列号)</span>\n  <span class=\"hljs-attr\">stack</span>: string;        <span class=\"hljs-comment\">// 堆栈信息</span>\n  <span class=\"hljs-attr\">selector</span>: string;     <span class=\"hljs-comment\">// 触发错误的DOM</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">静态资源加载错误</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">AssetsErrorI</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">url</span>: string;          <span class=\"hljs-comment\">// 报错资源url</span>\n  <span class=\"hljs-attr\">nodeName</span>: string;     <span class=\"hljs-comment\">// 资源类型</span>\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Promise错误</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ajax错误</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">AjaxErrorEventI</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">response</span>: string;     <span class=\"hljs-comment\">// 后端响应</span>\n  <span class=\"hljs-attr\">status</span>: number;       <span class=\"hljs-comment\">// 请求状态码</span>\n  <span class=\"hljs-attr\">method</span>: string;       <span class=\"hljs-comment\">// 请求方法</span>\n  <span class=\"hljs-attr\">url</span>: string;          <span class=\"hljs-comment\">// 请求地址</span>\n  <span class=\"hljs-attr\">params</span>: string;       <span class=\"hljs-comment\">// 请求参数</span>\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">上报方式</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">img</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Img</span>(<span class=\"hljs-string\">`http://xxx/report?info=<span class=\"hljs-subst\">${xxx}</span>`</span>)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">navigator.sendBeacon</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>MDN:<code>navigator.sendBeacon()</code>方法可用于通过HTTP将少量数据异步传输到Web服务器。使用<code>sendBeacon()</code>方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单许多！</p>\n<pre><code class=\"hljs language-js\">navigator.<span class=\"hljs-title function_\">sendBeacon</span>(<span class=\"hljs-string\">&quot;/log&quot;</span>, analyticsData)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">请求接口</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">后端处理</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>// todo</p>\n"},{"title":"异常监控-异常捕获","tags":["异常监控"],"categories":"前端架构&软实力","description":"## 异常分类\n\n- 编译时异常/运行时异常\n\n**着重处理运行时异常**\n\n## 要处理的异常\n\n- js运行时异常\n- 静态资源加载异常\n- Promise异常\n- ajax请求异常\n- 崩溃和卡顿\n\n## 捕获异常\n\n### 普通前端项目\n\n```js\n// monitor.ts\n\ninterface ConfigI {\n  reportUrl: string;\n}\n\ninterface","createDate":"2020-07-28 11:15:28","updateDate":"2021-02-20 17:14:19","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">异常分类</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>编译时异常/运行时异常</li>\n</ul>\n<p><strong>着重处理运行时异常</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">要处理的异常</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>js运行时异常</li>\n<li>静态资源加载异常</li>\n<li>Promise异常</li>\n<li>ajax请求异常</li>\n<li>崩溃和卡顿</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">捕获异常</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">普通前端项目</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// monitor.ts</span>\n\ninterface <span class=\"hljs-title class_\">ConfigI</span> {\n  <span class=\"hljs-attr\">reportUrl</span>: string;\n}\n\ninterface <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">title</span>: string;\n  <span class=\"hljs-attr\">location</span>: string;\n  <span class=\"hljs-attr\">message</span>: string;\n  <span class=\"hljs-attr\">kind</span>: string;\n  <span class=\"hljs-attr\">type</span>: string;\n  <span class=\"hljs-attr\">errorType</span>: string;\n}\n\ninterface <span class=\"hljs-title class_\">JSRunTimeErrorEventI</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">filename</span>: string;\n  <span class=\"hljs-attr\">position</span>: string;\n  <span class=\"hljs-attr\">stack</span>: string;\n  <span class=\"hljs-attr\">selector</span>: string;\n}\n\ninterface <span class=\"hljs-title class_\">AssetsErrorI</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">url</span>: string;\n  <span class=\"hljs-attr\">nodeName</span>: string;\n}\n\ninterface <span class=\"hljs-title class_\">AjaxErrorEventI</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">response</span>: string;\n  <span class=\"hljs-attr\">status</span>: number;\n  <span class=\"hljs-attr\">method</span>: string;\n  <span class=\"hljs-attr\">url</span>: string;\n}\n\ninterface <span class=\"hljs-title class_\">PromiseErrorI</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseinfoI</span> {\n  <span class=\"hljs-attr\">message</span>: string;\n  <span class=\"hljs-attr\">stack</span>: string;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">config</span>: <span class=\"hljs-title class_\">ConfigI</span> = { <span class=\"hljs-attr\">reportUrl</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span> };\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getLastEvent</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-literal\">undefined</span> | <span class=\"hljs-title class_\">Event</span> {\n  <span class=\"hljs-keyword\">let</span> lastEvent;\n  [<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-string\">&#x27;touchstart&#x27;</span>, <span class=\"hljs-string\">&#x27;mousedown&#x27;</span>, <span class=\"hljs-string\">&#x27;keydown&#x27;</span>, <span class=\"hljs-string\">&#x27;mouseover&#x27;</span>].<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">eventType</span>) =&gt;</span> <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(eventType, <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> {\n    lastEvent = event;\n  }, {\n    <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span>,\n  }));\n  <span class=\"hljs-keyword\">return</span> lastEvent;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getSelector</span>(<span class=\"hljs-params\">path: <span class=\"hljs-built_in\">Array</span>&lt;EventTarget&gt;</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&#x27;</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> report&lt;T&gt;(<span class=\"hljs-attr\">data</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;JSRunTimeErrorI&#x27;</span> | <span class=\"hljs-string\">&#x27;PromiseErrorT&#x27;</span> | <span class=\"hljs-string\">&#x27;AssetsErrorI&#x27;</span> | <span class=\"hljs-string\">&#x27;AjaxErrorEventI&#x27;</span>; <span class=\"hljs-attr\">info</span>: T }) {\n  <span class=\"hljs-keyword\">const</span> image = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Image</span>();\n  image.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${config.reportUrl}</span>?error=<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.stringify(data.info)}</span>`</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getCommonInfoFromEvent</span>(<span class=\"hljs-params\">event?: Event</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span>.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/&amp;/</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>),\n    <span class=\"hljs-attr\">location</span>: <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">location</span>.<span class=\"hljs-property\">href</span>.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/&amp;/</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>),\n    <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;stability&#x27;</span>,\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;error&#x27;</span>,\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getLines</span>(<span class=\"hljs-params\">stack: string | <span class=\"hljs-literal\">undefined</span></span>) {\n  <span class=\"hljs-keyword\">return</span> stack?.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>).<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/^\\s+at\\s+/g</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>)).<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>) || <span class=\"hljs-string\">&#x27;&#x27;</span>;\n}\n\n<span class=\"hljs-comment\">// Promise异常</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">promiseError</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;unhandledrejection&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event: PromiseRejectionEvent</span>) =&gt;</span> {\n    event.<span class=\"hljs-title function_\">preventDefault</span>();\n    <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n    <span class=\"hljs-keyword\">let</span> stack = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n    message = event.<span class=\"hljs-property\">reason</span>;\n    <span class=\"hljs-keyword\">const</span> { reason } = event;\n    <span class=\"hljs-keyword\">if</span> (reason <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Error</span>) {\n      message = reason.<span class=\"hljs-property\">message</span>;\n      stack = <span class=\"hljs-title function_\">getLines</span>(reason.<span class=\"hljs-property\">stack</span>);\n    }\n\n    report&lt;<span class=\"hljs-title class_\">PromiseErrorI</span>&gt;({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;PromiseErrorT&#x27;</span>, <span class=\"hljs-attr\">info</span>: { <span class=\"hljs-attr\">errorType</span>: event.<span class=\"hljs-property\">type</span>, message, stack, ...<span class=\"hljs-title function_\">getCommonInfoFromEvent</span>() } });\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  }, <span class=\"hljs-literal\">true</span>);\n}\n\n<span class=\"hljs-comment\">// 静态资源加载异常&amp;JSRuntime异常</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">assetsError</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;error&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event: ErrorEvent</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { target } = event;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(event);\n    <span class=\"hljs-keyword\">const</span> isElementTarget = target <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HTMLScriptElement</span> || target <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HTMLLinkElement</span> || target <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HTMLImageElement</span>;\n    <span class=\"hljs-keyword\">if</span> (!isElementTarget) {\n      <span class=\"hljs-keyword\">const</span> { message, filename, lineno, colno, error, type } = event;\n      <span class=\"hljs-keyword\">const</span> position = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${lineno}</span>:<span class=\"hljs-subst\">${colno}</span>`</span>;\n      <span class=\"hljs-keyword\">const</span> stack = <span class=\"hljs-title function_\">getLines</span>(error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Error</span> ? error.<span class=\"hljs-property\">stack</span> : <span class=\"hljs-string\">&#x27;&#x27;</span>);\n      <span class=\"hljs-keyword\">const</span> lastEvent = <span class=\"hljs-title function_\">getLastEvent</span>();\n      <span class=\"hljs-keyword\">const</span> selector = lastEvent ? <span class=\"hljs-title function_\">getSelector</span>(lastEvent.<span class=\"hljs-title function_\">composedPath</span>()) : <span class=\"hljs-string\">&#x27;&#x27;</span>;\n      report&lt;<span class=\"hljs-title class_\">JSRunTimeErrorEventI</span>&gt;({\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;JSRunTimeErrorI&#x27;</span>,\n        <span class=\"hljs-attr\">info</span>: { ...<span class=\"hljs-title function_\">getCommonInfoFromEvent</span>(), message, <span class=\"hljs-attr\">errorType</span>: type, filename, position, stack, selector },\n      });\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">let</span> url = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n      <span class=\"hljs-keyword\">let</span> nodeName = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n      <span class=\"hljs-keyword\">if</span> (target <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HTMLImageElement</span> || target <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HTMLScriptElement</span>) {\n        url = target.<span class=\"hljs-property\">src</span>;\n        nodeName = target.<span class=\"hljs-property\">nodeName</span>;\n      }\n      <span class=\"hljs-keyword\">if</span> (target <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HTMLLinkElement</span>) {\n        url = target.<span class=\"hljs-property\">href</span>;\n        nodeName = target.<span class=\"hljs-property\">nodeName</span>;\n      }\n\n      report&lt;<span class=\"hljs-title class_\">AssetsErrorI</span>&gt;({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;AssetsErrorI&#x27;</span>,\n        <span class=\"hljs-attr\">info</span>: {\n          url,\n          <span class=\"hljs-attr\">errorType</span>: event.<span class=\"hljs-property\">type</span>,\n          nodeName,\n          <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n          ...<span class=\"hljs-title function_\">getCommonInfoFromEvent</span>() } });\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  }, <span class=\"hljs-literal\">true</span>);\n}\n\n<span class=\"hljs-comment\">// ajax请求异常</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ajaxError</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { protocol } = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">location</span>;\n  <span class=\"hljs-keyword\">if</span> (protocol === <span class=\"hljs-string\">&#x27;file:&#x27;</span>) <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">XMLHttpRequest</span>) <span class=\"hljs-keyword\">return</span>;\n  <span class=\"hljs-keyword\">const</span> xmlReq = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">XMLHttpRequest</span>;\n  <span class=\"hljs-keyword\">const</span> oldSend = xmlReq.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">send</span>;\n  <span class=\"hljs-keyword\">const</span> oldOpen = xmlReq.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">open</span>;\n  <span class=\"hljs-keyword\">const</span> oldArgs = { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;&#x27;</span> };\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleEvent</span>(<span class=\"hljs-params\">event: any</span>) {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">if</span> (event &amp;&amp; event.<span class=\"hljs-property\">currentTarget</span> &amp;&amp; event.<span class=\"hljs-property\">currentTarget</span>.<span class=\"hljs-property\">status</span> !== <span class=\"hljs-number\">200</span>) {\n        <span class=\"hljs-keyword\">const</span> { response, status, statusText } = event.<span class=\"hljs-property\">currentTarget</span>;\n        <span class=\"hljs-keyword\">const</span> { method, url } = oldArgs;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(event);\n\n        report&lt;<span class=\"hljs-title class_\">AjaxErrorEventI</span>&gt;({\n          <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;AjaxErrorEventI&#x27;</span>,\n          <span class=\"hljs-attr\">info</span>: {\n            <span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(response),\n            status,\n            method,\n            url,\n            <span class=\"hljs-attr\">message</span>: statusText,\n            <span class=\"hljs-attr\">errorType</span>: event.<span class=\"hljs-property\">type</span>,\n            ...<span class=\"hljs-title function_\">getCommonInfoFromEvent</span>(),\n          },\n        });\n      }\n    } <span class=\"hljs-keyword\">catch</span> (e) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Tool&#x27;s error: <span class=\"hljs-subst\">${e}</span>`</span>);\n    }\n  }\n  xmlReq.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">send</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;error&#x27;</span>, handleEvent);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;load&#x27;</span>, handleEvent);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;abort&#x27;</span>, handleEvent);\n    <span class=\"hljs-keyword\">return</span> oldSend.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n  };\n  xmlReq.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">open</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args: any</span>) {\n    <span class=\"hljs-keyword\">const</span> [method, url] = args;\n    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(oldArgs, { method, url });\n    oldOpen.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">_config: ConfigI</span>) {\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(config, _config);\n  <span class=\"hljs-title function_\">promiseError</span>();\n  <span class=\"hljs-title function_\">assetsError</span>();\n  <span class=\"hljs-title function_\">ajaxError</span>();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> init;\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基于Vue.js的项目</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>针对于Vue.js项目，虽然官方提供有<code>Vue.config.errorHandler</code>来拦截内部错误(生命周期、事件绑定等)。但处理能力有限，无法处理js运行时异步异常(如setTimeout)和资源加载异常等，因此需要使用<code>mointor.js</code> + <code>Vue.config.errorHandler</code>来共同处理</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">基于React.js的项目</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ol>\n<li><p>引入<code>monitor.ts</code></p>\n</li>\n<li><p>添加<code>MErrorBoundary</code>组件用户出现异常后优雅降级显示和收集出错组件</p>\n</li>\n</ol>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MErrorBoundary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span>&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>&gt; {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props: <span class=\"hljs-built_in\">any</span></span>) {\n    <span class=\"hljs-variable language_\">super</span>(props);\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = { <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span> };\n  }\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">getDerivedStateFromError</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;MErrorBoundary&#x27;</span>);\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">true</span> };\n  }\n\n  <span class=\"hljs-title function_\">componentDidCatch</span>(<span class=\"hljs-params\">error: <span class=\"hljs-built_in\">any</span>, errorInfo: <span class=\"hljs-built_in\">any</span></span>) {\n    <span class=\"hljs-comment\">// logErrorToMyService(error, errorInfo);</span>\n  }\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">hasError</span>) {\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Something went wrong.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n      );\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">MErrorBoundary</span>;\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">白屏和卡顿</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>// todo</p>\n"},{"title":"前端架构&软实力-发布自己的npm包","tags":["npm"],"categories":"前端架构&软实力","description":"# 发布前准备\n\n- 安装npm\n\n- 注册npm账号\n\n- package.json相关配置\n\n```json\n{\n    \"name\": \"@mrrs878/blog\",\n    \"version\": \"0.0.1\",\n    \"private\": false,\n    \"repository\": \"https://github.com/mrrs878/blog\"\n}\n```\n\n- 更改仓","createDate":"2020-08-23 22:24:12","updateDate":"2021-02-20 17:13:58","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">发布前准备</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>安装npm</p>\n</li>\n<li><p>注册npm账号</p>\n</li>\n<li><p>package.json相关配置</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;@mrrs878/blog&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;0.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;private&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">false</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;repository&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;https://github.com/mrrs878/blog&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<ul>\n<li>更改仓库地址(之前更改过为淘宝镜像)</li>\n</ul>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">查看</span>\nnpm config get registry\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">设置</span>\nnpm config set registry https://registry.npmjs.org\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">发布</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-shell\">\nnpm login\n\nnpm publish --access publish\n</code></pre>\n<p>可能遇到的错误：</p>\n<pre><code class=\"hljs language-shell\">npm ERR! path c:\\Temp\\npm-20936-b98f84c8\\tmp\\fromDir-02dd5394\\package.tgz\nnpm ERR! code EPERM\nnpm ERR! errno -4048\nnpm ERR! syscall unlink\nnpm ERR! Error: EPERM: operation not permitted, unlink &#x27;c:\\Temp\\npm-20936-b98f84c8\\tmp\\fromDir-02dd5394\\package.tgz&#x27;\nnpm ERR!     at Error (native)\nnpm ERR!  { Error: EPERM: operation not permitted, unlink &#x27;c:\\Temp\\npm-20936-b98f84c8\\tmp\\fromDir-02dd5394\\package.tgz&#x27;\nnpm ERR!     at Error (native)\nnpm ERR!   cause:\nnpm ERR!    { Error: EPERM: operation not permitted, unlink &#x27;c:\\Temp\\npm-20936-b98f84c8\\tmp\\fromDir-02dd5394\\package.tgz&#x27;\nnpm ERR!        at Error (native)\nnpm ERR!      errno: -4048,\nnpm ERR!      code: &#x27;EPERM&#x27;,\nnpm ERR!      syscall: &#x27;unlink&#x27;,\nnpm ERR!      path: &#x27;c:\\\\Temp\\\\npm-20936-b98f84c8\\\\tmp\\\\fromDir-02dd5394\\\\package.tgz&#x27; },\nnpm ERR!   isOperational: true,\nnpm ERR!   stack: &#x27;Error: EPERM: operation not permitted, unlink \\&#x27;c:\\\\Temp\\\\npm-20936-b98f84c8\\\\tmp\\\\fromDir-02dd5394\\\\package.tgz\\&#x27;\\n    at Error (native)&#x27;,\nnpm ERR!   errno: -4048,\nnpm ERR!   code: &#x27;EPERM&#x27;,\nnpm ERR!   syscall: &#x27;unlink&#x27;,\nnpm ERR!   path: &#x27;c:\\\\Temp\\\\npm-20936-b98f84c8\\\\tmp\\\\fromDir-02dd5394\\\\package.tgz&#x27; }\nnpm ERR!\nnpm ERR! Please try running this command again as root/Administrator.\n</code></pre>\n<p>或：</p>\n<p><img src=\"https://img-blog.csdn.net/20180112190805599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3ZwZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"npm报错\"></p>\n<p><strong>重新登录npm</strong></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">更新</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>更改<code>package.json</code>中的<code>version</code>，重新运行<code>npm publish --access public</code></p>\n"},{"title":"JavaScript-执行机制","tags":["JavaScript","执行机制","EventLoop"],"categories":"JavaScript","description":"# **JavaScript 执行与运行**\n\n执行和运行不太相同，在不同环境下，比如 Node、浏览器下，JavaScript 的执行结果是不一样的；而运行大多指的是基于 JavaScript 引擎，如 V8，结果是一致的\n\n# **关于 JavaScript**\n\n众所周知，JavaScript 是一门**单线程**、**异步执行**的语言，虽然在 HTML5 中提出了 **web wor","createDate":"2019-06-30 11:15:28","updateDate":"2021-02-05 10:30:04","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>JavaScript 执行与运行</strong></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>执行和运行不太相同，在不同环境下，比如 Node、浏览器下，JavaScript 的执行结果是不一样的；而运行大多指的是基于 JavaScript 引擎，如 V8，结果是一致的</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><strong>关于 JavaScript</strong></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>众所周知，JavaScript 是一门<strong>单线程</strong>、<strong>异步执行</strong>的语言，虽然在 HTML5 中提出了 <strong>web workers</strong>(可以理解为<strong>浏览器</strong>为 JavaScript 开的“外挂”，下一篇会谈)，但 JavaScript 是单线程运行的这一核心仍未改变，所有<strong>多线程</strong>都是通过单线程模拟出来的，都是“纸老虎”</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript 中的异步--event loop</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>JavaScript 中的异步主要通过 event loop 进行模拟，那么什么是 event loop 呢？当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">浏览器中的 event loop</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_event_loop.png\" alt=\"浏览器中的event loop\"></p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/browser_event_loop2.png\" alt=\"浏览器中的event loop\">\n不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。\n微任务包括 process.nextTick ，promise ，MutationObserver。\n宏任务包括 script ，setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。</p>\n<p><strong>宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。</strong></p>\n<p>Event Loop 执行顺序如下所示：</p>\n<ul>\n<li>首先执行同步代码，这属于宏任务</li>\n<li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>\n<li>执行所有微任务</li>\n<li>当执行完所有微任务后，如有必要会渲染页面</li>\n<li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout(宏任务) 中的回调函数</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">3</span>);\n  });\n});\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">5</span>);\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n});\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">6</span>);\n});\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">7</span>);\n\n<span class=\"hljs-comment\">// 执行结果：1 4 7 5 2 3 6</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Node.js 中的 event loop</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当<strong>队列为空</strong>或者<strong>执行的回调函数数量到达系统设定的阈值</strong>，就会进入下一阶段。\n<img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_event_loop.png\" alt=\"Node.js中的event loop\"></p>\n<ul>\n<li>timer\ntimers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 <strong>poll</strong> 阶段控制的。\n同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</li>\n<li>I/O\nI/O 阶段会处理一些上一轮循环中的少数未执行的 I/O 回调</li>\n<li>idle, prepare\nidle, prepare 阶段内部实现，这里就忽略不讲了。</li>\n<li>poll\npoll 是一个至关重要的阶段，这一阶段中，系统会做两件事情<ul>\n<li>回到 timer 阶段执行回调</li>\n<li>执行 I/O 回调\n并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</li>\n<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>\n<li>如果 poll 队列为空时，会有两件事发生<ul>\n<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>\n<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去\n当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>check\ncheck 阶段执行 setImmediate</li>\n<li>close callbacks\nclose callbacks 阶段执行 close 事件\n对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask\n<img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_event_loop2.png\" alt=\"Node中的event loop\"></li>\n</ul>\n"},{"title":"webpack学习-2","tags":["webpack优化"],"categories":"webpack","description":"# 优化\n\n## 提取公共的js文件-splitChunks.cacheGroups.commons\n\n```js\nconst path = require(\"path\")\n\nmodule.exports = {\n    entry: \"./src/app.js\",\n    output: {\n        path: path.resolve(__dirname, \"dist\"),","createDate":"2020-04-14 23:04:37","updateDate":"2021-01-19 09:48:05","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">优化</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">提取公共的js文件-splitChunks.cacheGroups.commons</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&quot;./src/app.js&quot;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist&quot;</span>),\n        <span class=\"hljs-attr\">filname</span>: <span class=\"hljs-string\">&quot;bundle.[hash:6].js&quot;</span>\n    },\n    <span class=\"hljs-attr\">optimization</span>: {\n        <span class=\"hljs-attr\">splitChunks</span>: {\n            <span class=\"hljs-attr\">cacheGroups</span>: {\n                <span class=\"hljs-attr\">commons</span>: {\n                    <span class=\"hljs-attr\">chunks</span>: <span class=\"hljs-string\">&quot;initial&quot;</span>,\n                    <span class=\"hljs-attr\">minChunks</span>: <span class=\"hljs-number\">2</span>,\n                    <span class=\"hljs-attr\">maxInitialRequests</span>: <span class=\"hljs-number\">5</span>,\n                    <span class=\"hljs-attr\">minSize</span>: <span class=\"hljs-number\">2</span>,\n                    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;common.[hash:6]&quot;</span>\n                }\n            }\n        }\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">压缩图片-image-webpack-loader</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://www.webpackjs.com/loaders/url-loader/\">url-loader</a>来处理图片文件解析，可以再使用 <a href=\"https://github.com/tcoopman/image-webpack-loader\">image-webpack-loader</a>来压缩图片</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">enter</span>: <span class=\"hljs-string\">&quot;./src/app.js&quot;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist&quot;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;bundle.[hash:6].js&quot;</span>\n    },\n    <span class=\"hljs-attr\">modules</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.*\\.(gif|png|jpe?g|svg|webp)$/i</span>,\n                <span class=\"hljs-attr\">use</span>: [\n                    {\n                        <span class=\"hljs-attr\">laoder</span>: <span class=\"hljs-string\">&quot;url-loader&quot;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">8192</span>\n                        }\n                    }\n                    {\n                        <span class=\"hljs-attr\">laoder</span>: <span class=\"hljs-string\">&quot;image-webpack-loader&quot;</span>,\n                        <span class=\"hljs-attr\">options</span>: {\n                            <span class=\"hljs-attr\">mozjpeg</span>: {\n                                <span class=\"hljs-attr\">progress</span>: <span class=\"hljs-literal\">true</span>,\n                                <span class=\"hljs-attr\">quality</span>: <span class=\"hljs-number\">65</span>\n                            },\n                            <span class=\"hljs-attr\">optipng</span>: {\n                                <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">false</span>\n                            },\n                            <span class=\"hljs-attr\">pngquant</span>: {\n                                <span class=\"hljs-attr\">quality</span>: <span class=\"hljs-string\">&#x27;65-90&#x27;</span>,\n                                <span class=\"hljs-attr\">speed</span>: <span class=\"hljs-number\">4</span>\n                            },\n                            <span class=\"hljs-attr\">gifsicle</span>: {\n                                <span class=\"hljs-attr\">interlaced</span>: <span class=\"hljs-literal\">false</span>\n                            },\n                            <span class=\"hljs-attr\">webp</span>: { <span class=\"hljs-comment\">// 开启webp会把jpg、png压缩为webp格式</span>\n                                <span class=\"hljs-attr\">quality</span>: <span class=\"hljs-number\">65</span>\n                            }\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">多线程打包-happypack</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在webpack运行在node中打包时是单线程去一件一件事情做，<a href=\"https://github.com/amireh/happypack#readme\">happypack</a>可以开启多个子进程去并发执行，子进程处理完成之后把结果交给主进程</p>\n<pre><code class=\"hljs language-js\">yarn add happypack -D\n\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HappyPack</span> = <span class=\"hljs-title function_\">reruire</span>(<span class=\"hljs-string\">&quot;happypack&quot;</span>)\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&quot;./src/app.js&quot;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">reaolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist&quot;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;bundle_[hash:6].js&quot;</span>\n    },\n    <span class=\"hljs-attr\">module</span>: {\n        <span class=\"hljs-attr\">rules</span>: [\n            {\n                <span class=\"hljs-attr\">text</span>: <span class=\"hljs-regexp\">/\\.jsx?$/</span>,\n                <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>,\n                <span class=\"hljs-attr\">use</span>: <span class=\"hljs-string\">&quot;happypack/loader?id=babel&quot;</span>\n            }\n        ]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HappyPack</span>({\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;babel&quot;</span>,\n            <span class=\"hljs-attr\">threads</span>: <span class=\"hljs-number\">4</span>,\n            <span class=\"hljs-attr\">loaders</span>: [<span class=\"hljs-string\">&quot;babel-loader&quot;</span>]\n        })\n    ]\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">作用域提升-ModuleConcatenationPlugin</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果项目里使用的是ES6的语法，并且webpack3+，那么建议启用这一插件，把所有的模块放到一个函数里：</p>\n<ul>\n<li>减少了函数声明</li>\n<li>文件体积变小</li>\n<li>函数作用域变少</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n<span class=\"hljs-keyword\">const</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack&quot;</span>)\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&quot;./src/app.js&quot;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist&quot;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;bundle_[hash:6].js&quot;</span>\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-keyword\">new</span> webpack.<span class=\"hljs-property\">optimize</span>.<span class=\"hljs-title class_\">ModuleConcatenationPlugin</span>()\n    ]\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">提取第三方库-enter.vendor</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>方便长期缓存第三方的库，新建一个入口，将第三方库作为一个<code>chunk</code>，生成<code>vendor.js</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">entry</span>: {\n        <span class=\"hljs-attr\">main</span>: <span class=\"hljs-string\">&quot;./src/app.js&quot;</span>,\n        <span class=\"hljs-attr\">vendor</span>: [<span class=\"hljs-string\">&#x27;react&#x27;</span>, <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>]\n    }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">DLL动态链接-webpack.DllPlugin</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果第三方库不是经常更新，打包的时候希望分开打包来提升打包速度。打包dll需要新建一个webpack配置文件，在打包dll的时候，webpack做一个索引，现在manifest文件中。然后打包项目的时候只需要读取manifest文件</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.vendor.js</span>\n\n<span class=\"hljs-keyword\">const</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack&quot;</span>)\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">entry</span>: {\n        <span class=\"hljs-attr\">vendor</span>: [<span class=\"hljs-string\">&quot;react&quot;</span>, <span class=\"hljs-string\">&quot;react-dom&quot;</span>]\n    },\n    <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">reaolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist&quot;</span>),\n        <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;dll/[name]_dll.js&quot;</span>,\n        <span class=\"hljs-attr\">library</span>: <span class=\"hljs-string\">&quot;_dll_[name]&quot;</span>\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-keyword\">new</span> webpack.<span class=\"hljs-title class_\">DllPlugin</span>({\n            <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist/sll&quot;</span>, <span class=\"hljs-string\">&quot;manifest.json&quot;</span>),\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;_dll_[name]&quot;</span>\n        })\n    ]\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.config.js</span>\n\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">enter</span>: {\n        <span class=\"hljs-attr\">main</span>: <span class=\"hljs-string\">&quot;./src/app.js&quot;</span>,\n        <span class=\"hljs-attr\">vendor</span>: [<span class=\"hljs-string\">&quot;react&quot;</span>, <span class=\"hljs-string\">&quot;react-dom&quot;</span>]\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-keyword\">new</span> webpack.<span class=\"hljs-title class_\">DllReferencePlugin</span>({\n            <span class=\"hljs-attr\">manifest</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist/dll&quot;</span>, <span class=\"hljs-string\">&quot;manifest.json&quot;</span>)\n        })\n    ]\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">多环境配置</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>创建多个配置文件：</p>\n<ul>\n<li><code>webpack.base.js</code>，共同的个配置</li>\n<li><code>webpack.dev.js</code>，在开发环境下的配置</li>\n<li><code>webpack.prod.js</code>，在生产环境下的配置</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">开发环境</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>配置测试服务器相关、HMR</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// webpack.dev.js</span>\n\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n<span class=\"hljs-keyword\">const</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack&quot;</span>)\n<span class=\"hljs-keyword\">const</span> merge = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack-merge&quot;</span>)\n<span class=\"hljs-keyword\">const</span> abse = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./webpack.base.js&quot;</span>)\n\n<span class=\"hljs-keyword\">const</span> dev = {\n    <span class=\"hljs-attr\">devServer</span>: {\n        <span class=\"hljs-attr\">contentNase</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;dist&quot;</span>),\n        <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">8080</span>,\n        <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&quot;localhost&quot;</span>,\n        <span class=\"hljs-attr\">overlay</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">compress</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">open</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">hot</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">inline</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">progress</span>: <span class=\"hljs-literal\">true</span>\n    },\n    <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">&quot;inline-source-map&quot;</span>,\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-keyword\">new</span> webpack.<span class=\"hljs-title class_\">HotModuleReplacementPlugin</span>(),\n        <span class=\"hljs-keyword\">new</span> webpack.<span class=\"hljs-title class_\">NamedModulesPlugin</span>()\n    ]\n}\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">merge</span>(base, dev)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">生产环境</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>生产环境最重要的是开启代码压缩、混淆</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//webpack.prod.js</span>\n\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)\n<span class=\"hljs-keyword\">const</span> merge = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack-merge&quot;</span>)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">WebpackParallUglifyPlugin</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;webpack-parallel-uglify-plugin&quot;</span>)\n<span class=\"hljs-keyword\">const</span> base = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./webpack.base.js&quot;</span>)\n\n<span class=\"hljs-keyword\">const</span> prod = {\n    <span class=\"hljs-attr\">plugins</span>: [\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebpackParallUglifyPlugin</span>({\n            <span class=\"hljs-attr\">uglifyJS</span>: {\n                <span class=\"hljs-attr\">mangle</span>: <span class=\"hljs-literal\">true</span>,\n                <span class=\"hljs-attr\">output</span>: {\n                    <span class=\"hljs-attr\">beautify</span>: <span class=\"hljs-literal\">false</span>,\n                    <span class=\"hljs-attr\">comments</span>: <span class=\"hljs-literal\">false</span>\n                },\n                <span class=\"hljs-attr\">compress</span>: {\n                    <span class=\"hljs-attr\">warnings</span>: <span class=\"hljs-literal\">false</span>,\n                    <span class=\"hljs-attr\">drop_console</span>: <span class=\"hljs-literal\">true</span>,\n                    <span class=\"hljs-attr\">collpase_vars</span>: <span class=\"hljs-literal\">true</span>,\n                    <span class=\"hljs-attr\">reduce_vars</span>: <span class=\"hljs-literal\">true</span>\n                }\n            }\n        })\n    ]\n}\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">marge</span>(base, prod)\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用环境变量</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>安装依赖: <code>yarn add dotenv-cli -D</code></p>\n</li>\n<li><p><code>webpack.config.js</code>添加配置：</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">DefinePlugin</span> } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;webpack&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-variable constant_\">MODE</span> } = process.<span class=\"hljs-property\">env</span>;\n\n<span class=\"hljs-attr\">plugins</span>: [\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefinePlugin</span>({\n        <span class=\"hljs-string\">&#x27;process.env&#x27;</span>: {\n            <span class=\"hljs-attr\">MODE</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">strinfy</span>(<span class=\"hljs-variable constant_\">MODE</span>)\n        }\n    })\n]\n</code></pre>\n<ul>\n<li>根目录创建<code>.env.development</code></li>\n</ul>\n<pre><code class=\"hljs language-shell\">MODE=&#x27;development&#x27;\n</code></pre>\n<ul>\n<li>修改<code>package.json</code></li>\n</ul>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;start:dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;dotenv -e .env.development webpack-dev-server&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n"},{"title":"CSS相关-骚操作","tags":["CSS","骚操作"],"categories":"CSS","description":"## 给第一个字加上特殊样式\n\n使用CSS伪选择器`::first-letter`，**行内元素无法使用**\n\n## 给table的td/tr加样border\n\n先设置`table`的`border-collapse: collapse`，然后设置`td/tr`的`border`","createDate":"2020-12-12 07:35:21","updateDate":"2021-01-06 15:37:00","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">给第一个字加上特殊样式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>使用CSS伪选择器<code>::first-letter</code>，<strong>行内元素无法使用</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">给table的td/tr加样border</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>先设置<code>table</code>的<code>border-collapse: collapse</code>，然后设置<code>td/tr</code>的<code>border</code></p>\n"},{"title":"rollup.js学习-基础","tags":["打包","rollup.js"],"categories":"rollup.js","description":"## WHAT\n\n一款打包工具\n\n## WHY\n\n- 轻量，适合打包库\n\n- 支持输出esm\n\n## HOW\n\n> 打包 typescript，单入口，多输出格式\n\n###  安装\n\n- `rollup`\n\n- `rollup-plugin-typescript2`\n\n- `@rollup/plugin-node-resolve`\n\n- `@rollup/plugin-commonjs`\n\n-","createDate":"2020-12-11 03:43:07","updateDate":"2020-12-11 11:02:22","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一款打包工具</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>轻量，适合打包库</p>\n</li>\n<li><p>支持输出esm</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>打包 typescript，单入口，多输出格式</p>\n</blockquote>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p><code>rollup</code></p>\n</li>\n<li><p><code>rollup-plugin-typescript2</code></p>\n</li>\n<li><p><code>@rollup/plugin-node-resolve</code></p>\n</li>\n<li><p><code>@rollup/plugin-commonjs</code></p>\n</li>\n<li><p><code>rollup-plugin-cleaner</code></p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">配置</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> resolve <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@rollup/plugin-node-resolve&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> commonjs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@rollup/plugin-commonjs&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> path <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;path&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ts <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rollup-plugin-typescript2&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> cleaner <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rollup-plugin-cleaner&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> extensions = [<span class=\"hljs-string\">&#x27;.ts&#x27;</span>, <span class=\"hljs-string\">&#x27;.tsx&#x27;</span>, <span class=\"hljs-string\">&#x27;.js&#x27;</span>, <span class=\"hljs-string\">&#x27;.jsx&#x27;</span>];\n<span class=\"hljs-keyword\">const</span> tsconfig = path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;tsconfig.json&#x27;</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> [\n  {\n    <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;./src/index.ts&#x27;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n      <span class=\"hljs-attr\">dir</span>: <span class=\"hljs-string\">&#x27;dist/esm&#x27;</span>,\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">&#x27;esm&#x27;</span>,\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n      <span class=\"hljs-title function_\">cleaner</span>({ <span class=\"hljs-attr\">targets</span>: [<span class=\"hljs-string\">&#x27;./dist/&#x27;</span>] }),\n      <span class=\"hljs-title function_\">resolve</span>({ extensions }),\n      <span class=\"hljs-title function_\">commonjs</span>(),\n      <span class=\"hljs-title function_\">ts</span>({ tsconfig }),\n    ],\n    <span class=\"hljs-attr\">external</span>: [<span class=\"hljs-string\">&#x27;react&#x27;</span>]\n  },\n  {\n    <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">&#x27;./src/index.ts&#x27;</span>,\n    <span class=\"hljs-attr\">output</span>: {\n      <span class=\"hljs-attr\">dir</span>: <span class=\"hljs-string\">&#x27;dist/umd&#x27;</span>,\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">&#x27;umd&#x27;</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;MJSLibrary&#x27;</span>,\n      <span class=\"hljs-attr\">globals</span>: {\n        <span class=\"hljs-attr\">react</span>: <span class=\"hljs-string\">&#x27;React&#x27;</span>\n      }\n    },\n    <span class=\"hljs-attr\">plugins</span>: [\n      <span class=\"hljs-title function_\">resolve</span>({ \n        extensions\n      }),\n      <span class=\"hljs-title function_\">commonjs</span>(),\n      <span class=\"hljs-title function_\">ts</span>({ \n        <span class=\"hljs-attr\">tsconfigOverride</span>: { <span class=\"hljs-attr\">compilerOptions</span>: { <span class=\"hljs-attr\">declaration</span>: <span class=\"hljs-literal\">false</span> } }, \n        tsconfig\n      }),\n    ],\n    <span class=\"hljs-attr\">external</span>: [<span class=\"hljs-string\">&#x27;react&#x27;</span>]\n  }\n]\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">打包</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;rollup -c&quot;</span>\n    <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n"},{"title":"React.js学习-基础","tags":["React.js"],"categories":"React.js","description":"## react和react-dom\n\n- react\n\n 专门用来创建`React`组件、组件生命周期等\n\n- react-dom\n\n 封装了`DOM`操作相关的函数，比如`render`","createDate":"2020-12-02 10:41:44","updateDate":"2020-12-02 10:41:51","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">react和react-dom</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>react</li>\n</ul>\n<p> 专门用来创建<code>React</code>组件、组件生命周期等</p>\n<ul>\n<li>react-dom</li>\n</ul>\n<p> 封装了<code>DOM</code>操作相关的函数，比如<code>render</code></p>\n"},{"title":"Docker-基于GitHub Actions搭建CI&CD","tags":["GithubActions","CI/CD"],"categories":"Docker","description":"# todo","createDate":"2020-10-22 16:35:23","updateDate":"2020-11-29 03:57:27","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">todo</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    "},{"title":"(翻译)创建你自己的React","tags":["React.js"],"categories":"React.js","description":"> 原文链接:https://pomb.us/build-your-own-react/\n\n# Build your own React\n\n我们将从头开始重写React。 一步步。 遵循真实的React代码中的架构，但没有所有的优化和非必要的功能。\n\n如果您阅读过[我以前的任何“构建自己的React”文章](https://engineering.hexacta.com/didact-lear","createDate":"2020-11-02 14:25:18","updateDate":"2020-11-11 15:00:53","body":"<blockquote>\n<p>原文链接:<a href=\"https://pomb.us/build-your-own-react/\">https://pomb.us/build-your-own-react/</a></p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Build your own React</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>我们将从头开始重写React。 一步步。 遵循真实的React代码中的架构，但没有所有的优化和非必要的功能。</p>\n<p>如果您阅读过<a href=\"https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5\">我以前的任何“构建自己的React”文章</a>，不同之处在于该文章基于React 16.8，因此我们现在可以使用<code>hook</code>并删除所有与<code>class</code>相关的代码。</p>\n<p>您可以在旧博客文章中找到历史记录，并在<a href=\"https://github.com/pomber/didact\">Didact仓库</a>中找到代码。 还有一个演讲涉及相同的内容。</p>\n<p>以下这些都是我们将一一添加到我们的React版本中的内容：</p>\n<ul>\n<li>第一步: <code>createElement</code> 函数</li>\n<li>第二步: <code>render</code> 函数</li>\n<li>第三步: Concurrent Mode</li>\n<li>第四步: Fibers</li>\n<li>第五步: Render and Commit Phases</li>\n<li>第六步: Reconciliation</li>\n<li>第七步: 函数式组件</li>\n<li>第八步: Hooks</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第零步</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果您已经对React，JSX和DOM节点的工作方式有了很好的了解，则可以跳过此步骤。首先让我们回顾一些基本概念，我们将使用只有三行代码的React应用程序：第一个定义一个React节点，下一个从DOM获取一个节点，最后一个将React节点渲染到容器中。然后，我们会删除所有特定于React的代码将其替换为原始JavaScript。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>)\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(element, container)\n</code></pre>\n<p>在第一行中，我们使用JSX定义了节点。 它不是有效的JavaScript，因此要用原生JS取代它。通过Babel等构建工具，JSX转换为JS。 转换通常很简单：使用对<code>createElement</code>的调用来替换标签内的代码，并将标签<code>type</code>、<code>props</code>、<code>children</code>作为参数传递。<code>React.createElement</code>根据其参数创建一个对象，除了一些验证之外，这就是全部。 因此，我们可以安全地将函数调用替换为其输出。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n\n👇\n\n<span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createElement</span>(\n  <span class=\"hljs-string\">&quot;h1&quot;</span>,\n  { <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;foo&quot;</span> },\n  <span class=\"hljs-string\">&quot;Hello&quot;</span>\n)\n</code></pre>\n<p>这就是一个节点，一个具有两个属性的对象：<code>type</code>和<code>props</code>（嗯，<a href=\"https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111\">它有更多的属性</a>，但是我们只关心这两个属性）。<code>type</code>是一个字符串，用于指定我们要创建的DOM节点的类型，它是您要创建HTML节点时传递给<code>document.createElement</code>的<code>tagName</code>。 它也可以是一个函数，但我们将其留给步骤VII。<code>props</code>是另一个对象，它具有JSX属性中的所有键和值。 它还有一个特殊的属性：<code>children</code>。在这种情况下，<code>children</code>是字符串，但通常是包含更多节点的数组（这就是为什么节点也是树的原因）。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;h1&quot;</span>,\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;foo&quot;</span>,\n    <span class=\"hljs-attr\">children</span>: <span class=\"hljs-string\">&quot;Hello&quot;</span>,\n  },\n}\n</code></pre>\n<p>我们需要替换的另一部分React代码是对<code>ReactDOM.render</code>的调用。<code>render</code>是React更新DOM的地方，现在用我们自己的代码进行操作。</p>\n<p>首先，我们使用节点<code>type</code>（在本例中为<code>h1</code>）创建一个<code>node*</code>。然后，我们将所有节点属性分配给该节点。 这里只有一个<code>title</code>。*为避免混淆，我将使用<code>element</code>来指代React节点，并使用<code>node</code>来指代DOM节点。</p>\n<p>然后，我们为<code>children</code>创建节点。 我们只有一个字符串作为<code>children</code>，因此我们创建了一个文本节点。使用<code>textNode</code>而不是设置<code>innerText</code>将允许我们以后以相同的方式对待所有节点。另请注意，我们像设置<code>h1</code>标题一样设置<code>nodeValue</code>，就像字符串中带有<code>props: {nodeValue: &quot;hello&quot;}</code>。最后，我们将<code>textNode</code>添加到<code>h1</code>并将<code>h1</code>添加到<code>container</code>。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> element = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;h1&quot;</span>,\n  <span class=\"hljs-attr\">props</span>: {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;foo&quot;</span>,\n    <span class=\"hljs-attr\">children</span>: <span class=\"hljs-string\">&quot;Hello&quot;</span>,\n  },\n}\n\n<span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>)\n\n<span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(element.<span class=\"hljs-property\">type</span>)\nnode[<span class=\"hljs-string\">&quot;title&quot;</span>] = element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">title</span>\n\n<span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\ntext[<span class=\"hljs-string\">&quot;nodeValue&quot;</span>] = element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>\n\nnode.<span class=\"hljs-title function_\">appendChild</span>(text)\ncontainer.<span class=\"hljs-title function_\">appendChild</span>(node)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第一步: createElement 函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>现在，让我们切换到另一个App：自己实现的简易React。</p>\n<p>首先，从编写<code>createElement</code>开始，将JSX转换为JS。正如在上一步中看到的，<code>element</code>是具有类型和属性的对象。<code>createElement</code>唯一需要做的就是创建该对象。</p>\n<p>因为<code>children</code>也可以包含原始数据类型，比如字符串或数字，所以对不是<code>object</code>的<code>child</code>创建特殊节点类型：<code>TEXT_ELEMENT</code>。这样做是因为可以简化代码。对于我们的库，我更喜欢简单而不是高性能代码。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createTextElement</span>(<span class=\"hljs-params\">text</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>,\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">nodeValue</span>: text,\n      <span class=\"hljs-attr\">children</span>: [],\n    },\n  }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-params\">type, props, ...children</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    type,\n    <span class=\"hljs-attr\">props</span>: {\n      ...props,\n      <span class=\"hljs-attr\">children</span>: children.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-keyword\">typeof</span> child === <span class=\"hljs-string\">&quot;object&quot;</span>\n        ? child\n        : <span class=\"hljs-title function_\">createTextElement</span>(child)\n      ),\n    },\n  }\n}\n</code></pre>\n<p>目前Babel仍然使用<code>React.createElement</code>，为了替换它，让我们给自己的库起个名字。我们需要一个听起来像React的名字，但也暗示了它的教学目的，我们叫它<code>Didact</code>。</p>\n<p>让我们使用<code>/** @jsx Didact.createElement */</code>来告诉Babel使用我们自己的<code>createElement</code>来转换jsx代码：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@jsx</span> Didact.createElement */</span>\n<span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span>bar<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n)\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第二步：redner 函数</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>首先使用element的<code>type</code>创建DOM节点，然后将新element添加到<code>container</code>中。然后对每个<code>child</code>递归调用<code>render</code>：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-keyword\">const</span> dom = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(element.<span class=\"hljs-property\">type</span>);\n\n  element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-title function_\">render</span>(child, dom))\n\n  container.<span class=\"hljs-title function_\">appendChild</span>(dom);\n}\n</code></pre>\n<p>其次，我们还需要处理文本节点，如果element类型为<code>TEXT_ELEMENT</code>，我们将创建文本节点而不是普通节点：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> dom = element.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>\n    ? <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n    : <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElmenet</span>(element.<span class=\"hljs-property\">type</span>);\n  <span class=\"hljs-comment\">//...</span>\n}\n</code></pre>\n<p>最后，将<code>props</code>分配给element：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = key =&gt; key === <span class=\"hljs-string\">&quot;children&quot;</span>;\n  <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownkeys</span>(element.<span class=\"hljs-property\">props</span>)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> dom[name] = element.<span class=\"hljs-property\">props</span>[name]);\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>这样的话，我们就有了一个可以将JSX呈现到DOM的库：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createTextElement</span>(<span class=\"hljs-params\">text</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>,\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">nodeValue</span>: text,\n      <span class=\"hljs-attr\">children</span>: []\n    }\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-params\">type, props, ...children</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    type,\n    <span class=\"hljs-attr\">props</span>: {\n      ...props,\n      <span class=\"hljs-attr\">children</span>: children.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span>\n        <span class=\"hljs-keyword\">typeof</span> child === <span class=\"hljs-string\">&quot;object&quot;</span> ? child : <span class=\"hljs-title function_\">createTextElement</span>(child)\n      )\n    }\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  <span class=\"hljs-keyword\">const</span> dom =\n    element.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>\n      ? <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n      : <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(element.<span class=\"hljs-property\">type</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = (<span class=\"hljs-params\">key</span>) =&gt; key !== <span class=\"hljs-string\">&quot;children&quot;</span>;\n  <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(element.<span class=\"hljs-property\">props</span>)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> (dom[name] = element.<span class=\"hljs-property\">props</span>[name]));\n\n  element.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">child</span>) =&gt;</span> <span class=\"hljs-title function_\">render</span>(child, dom));\n\n  container.<span class=\"hljs-title function_\">appendChild</span>(dom);\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Didact</span> = {\n  createElement,\n  render\n};\n\n<span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@jsx</span> Didact.createElement */</span>\n<span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello STEP1-STEP2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n);\n\n<span class=\"hljs-keyword\">const</span> container = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#step1&quot;</span>);\n\n<span class=\"hljs-title class_\">Didact</span>.<span class=\"hljs-title function_\">render</span>(element, container);\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第三步Concurrent Mode</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在开始添加更多代码之前，我们需要重构。</p>\n<p>上面的递归调用存在问题。开始渲染后，直到渲染完完整的element树，我们才会停止。 如果element树很大，则可能会阻塞主线程太长时间。 那么如果浏览器需要执行高优先级的操作（例如处理用户输入或保持动画流畅），则它必须等到渲染完成为止。因此，我们将工作分成几个小部分，在完成每个单元后，如果需要执行其他任何操作，我们将让浏览器中断渲染。</p>\n<p>我们使用<code>requestIdleCallback</code>进行循环。 您可以将<code>requestIdleCallback</code>看作<code>setTimeout</code>，但是浏览器将在主线程空闲时运行回调，而不是告诉它何时运行。React不再使用<code>requestIdleCallback</code>，现在它使用scheduler package。 但是对于此用例，它在概念上是相同的。<code>requestIdleCallback</code>还为我们提供了<code>deadline</code>参数。 我们可以使用它来检查浏览器需要再次控制之前有多少时间。</p>\n<p>要开始使用循环，我们需要设置第一个工作单元，然后编写一个<code>performUnitOfWork</code>函数，该函数不仅执行工作，还返回下一个工作单元。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">第四步Fiber</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>要组织工作单元，我们需要一个数据结构--Fiber树。我们将为每个元素分配一根Fiber，并且每个Fiber将成为一个工作单元。</p>\n<p>假如我们要渲染如下的element树，那么Fiber树就如下所示：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Didact</span>.<span class=\"hljs-title function_\">render</span>(\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>,\n  container\n)\n</code></pre>\n<p><img src=\"https://pomb.us/static/a88a3ec01855349c14302f6da28e2b0c/ac667/fiber1.png\" alt=\"\"></p>\n<p>在render函数中，我们将创建root Fiber并将其设置为<code>nextUnitOfWork</code>。 剩下的工作将在<code>performUnitOfWork</code>函数上进行，我们将为每个Fiber做三件事：</p>\n<ol>\n<li>将element添加到DOM</li>\n<li>为element的子代创建Filber</li>\n<li>选择下一个工作单元</li>\n</ol>\n<p>该数据结构的目标之一是使查找下一个工作单元变得容易。 这就是为什么每个Fiber都链接到其第一个子节点、下一个兄弟节点和父节点。</p>\n<ul>\n<li>当我们完成对当前Fiber的工作时，如果有child，那么该child对应的Fiber将是下一个工作单元。在我们的示例中，当我们完成div Fiber的工作时，下一个工作单元将是h1 Fiber。</li>\n<li>如果当前Fiber没有child，我们将其sibling作为下一个工作单元。例如，p Fiber没有child，因此我们在完成当前之后下一个工作单元将是h1。</li>\n<li>如果当前Fiber既没有child也没有sibling，那么我们去“uncle”：父母的兄弟节点。 就像示例中的a和h2 Fiber一样。</li>\n<li>如果parent没有sibling，我们会不断检查parent，直到找到有sibling的parent，或者直到找到root。 如果到达root，则意味着我们已经完成了此渲染的所有工作。</li>\n</ul>\n<p>现在，让我们开始写代码。</p>\n<p>首先，更改<code>render</code>函数并创建<code>createDom</code>函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">element, container</span>) {\n  nextUnitOfWork = {\n    <span class=\"hljs-attr\">dom</span>: container,\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">children</span>: [element],\n    },\n  }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDom</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">const</span> dom =\n    fiber.<span class=\"hljs-property\">type</span> == <span class=\"hljs-string\">&quot;TEXT_ELEMENT&quot;</span>\n      ? <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-string\">&quot;&quot;</span>)\n      : <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(fiber.<span class=\"hljs-property\">type</span>)\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = key =&gt; key !== <span class=\"hljs-string\">&quot;children&quot;</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(fiber.<span class=\"hljs-property\">props</span>)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      dom[name] = fiber.<span class=\"hljs-property\">props</span>[name]\n    })\n  <span class=\"hljs-keyword\">return</span> dom\n}\n</code></pre>\n<p>然后，当浏览器准备就绪时，它将调用我们的<code>workLoop</code>，我们将从<code>root</code>开始执行渲染。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">workLoop</span>(<span class=\"hljs-params\">deadline</span>) {\n  <span class=\"hljs-keyword\">let</span> shouldYield = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) {\n    nextUnitOfWork = <span class=\"hljs-title function_\">performUnitOfWork</span>(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.<span class=\"hljs-title function_\">timeRemaining</span>() &lt; <span class=\"hljs-number\">1</span>\n  }\n  <span class=\"hljs-title function_\">requestIdleCallback</span>(workLoop)\n}\n</code></pre>\n<p>首先，我们创建一个新node并将其添加到DOM。我们在<code>fibre.dom</code>属性中跟踪DOM节点。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">if</span> (!fiber.<span class=\"hljs-property\">dom</span>) {\n    fiber.<span class=\"hljs-property\">dom</span> = <span class=\"hljs-title function_\">createDom</span>(fiber)\n  }\n  <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">parent</span>) {\n    fiber.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">dom</span>.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  }\n  <span class=\"hljs-comment\">// TODO create new fibers</span>\n  <span class=\"hljs-comment\">// TODO return next unit of work</span>\n}\n</code></pre>\n<p>然后对每个<code>child</code>创建Fiber</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> elements = fiber.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>\n  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span>\n  <span class=\"hljs-keyword\">while</span> (index &lt; elements.<span class=\"hljs-property\">length</span>) {\n    <span class=\"hljs-keyword\">const</span> element = elements[index]\n    <span class=\"hljs-keyword\">const</span> newFiber = {\n      <span class=\"hljs-attr\">type</span>: element.<span class=\"hljs-property\">type</span>,\n      <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n      <span class=\"hljs-attr\">parent</span>: fiber,\n      <span class=\"hljs-attr\">dom</span>: <span class=\"hljs-literal\">null</span>,\n    }\n  }\n</code></pre>\n<p>然后将其添加到Fiber树中，将其设置为<code>child</code>还是<code>sibing</code>，具体取决于它是否是第一个child。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) {\n      fiber.<span class=\"hljs-property\">child</span> = newFiber\n    } <span class=\"hljs-keyword\">else</span> {\n      prevSibling.<span class=\"hljs-property\">sibling</span> = newFiber\n    }\n}\nprevSibling = newFiber\nindex++\n</code></pre>\n<p>最后，我们按照child ☞ sibling ☞ uncle来选择下一工作单元。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">child</span>) {\n  <span class=\"hljs-keyword\">return</span> fiber.<span class=\"hljs-property\">child</span>\n}\n<span class=\"hljs-keyword\">let</span> nextFiber = fiber\n<span class=\"hljs-keyword\">while</span> (nextFiber) {\n  <span class=\"hljs-keyword\">if</span> (nextFiber.<span class=\"hljs-property\">sibling</span>) {\n    <span class=\"hljs-keyword\">return</span> nextFiber.<span class=\"hljs-property\">sibling</span>\n  }\n  nextFiber = nextFiber.<span class=\"hljs-property\">parent</span>\n}\n</code></pre>\n<p>完整的代码如下所示：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">performUnitOfWork</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">if</span> (!fiber.<span class=\"hljs-property\">dom</span>) {\n    fiber.<span class=\"hljs-property\">dom</span> = <span class=\"hljs-title function_\">createDom</span>(fiber)\n  }\n\n  <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">parent</span>) {\n    fiber.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">dom</span>.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  }\n\n  <span class=\"hljs-keyword\">const</span> elements = fiber.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">children</span>\n  <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> prevSibling = <span class=\"hljs-literal\">null</span>\n\n  <span class=\"hljs-keyword\">while</span> (index &lt; elements.<span class=\"hljs-property\">length</span>) {\n    <span class=\"hljs-keyword\">const</span> element = elements[index]\n\n    <span class=\"hljs-keyword\">const</span> newFiber = {\n      <span class=\"hljs-attr\">type</span>: element.<span class=\"hljs-property\">type</span>,\n      <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n      <span class=\"hljs-attr\">parent</span>: fiber,\n      <span class=\"hljs-attr\">dom</span>: <span class=\"hljs-literal\">null</span>,\n    }\n\n    <span class=\"hljs-keyword\">if</span> (index === <span class=\"hljs-number\">0</span>) {\n      fiber.<span class=\"hljs-property\">child</span> = newFiber\n    } <span class=\"hljs-keyword\">else</span> {\n      prevSibling.<span class=\"hljs-property\">sibling</span> = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">child</span>) {\n    <span class=\"hljs-keyword\">return</span> fiber.<span class=\"hljs-property\">child</span>\n  }\n  <span class=\"hljs-keyword\">let</span> nextFiber = fiber\n  <span class=\"hljs-keyword\">while</span> (nextFiber) {\n    <span class=\"hljs-keyword\">if</span> (nextFiber.<span class=\"hljs-property\">sibling</span>) {\n      <span class=\"hljs-keyword\">return</span> nextFiber.<span class=\"hljs-property\">sibling</span>\n    }\n    nextFiber = nextFiber.<span class=\"hljs-property\">parent</span>\n  }\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">提交更改</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>我们还有一个问题。每次处理一个元素时，我们都会向DOM添加一个新节点。而且，请记住，浏览器可能会在我们完成整个树的渲染之前中断我们的工作。在这种情况下，用户将看到一个不完整的UI。我们不想这样。</p>\n<p>因此，我们需要从<code>performUnitOfWork</code>里删除改变DOM的部分。相反，我们将跟踪Fiber tree。我们称它为<code>wipRoot</code>。一旦我们完成了所有的工作(我们知道它是因为没有下一个工作单元)，我们就将整个Fiber tree提交给DOM。我们在<code>commitRoot</code>函数中完成。在这里，我们递归地将所有节点追加到dom。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Reconciliation</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>到目前为止，我们只向DOM添加了一些东西，那么更新或删除节点呢? </p>\n<p>这就是我们现在要做的，我们需要将<code>render</code>函数接收到的元素与提交给DOM的最后一个Fiber tree进行比较。因此，在完成<code>commit</code>之后，我们需要保存对<strong>最后一个提交到DOM的Fiber tree</strong>的引用。我们称之为<code>currentRoot</code>。我们还在每Fiber中加入了<code>alternate</code>, 此属性是到旧Fiber的链接，即我们在上一个提交阶段提交给DOM的Fiber。</p>\n<p>现在让我们从创建新Fiber的<code>performUnitOfWork</code>函数中提取代码到<code>reconcileChildren</code> 。在这里，我们将<code>reconcile</code>旧的fibers和新元素。我们同时遍历旧Fiber tree(<code>wipFiber.alternate</code>)的子元素和我们想要reconciliation的元素数组。如果我们忽略同时遍历数组和链表所需的所有样板文件，那么我们只剩下while中最重要的部分:oldFiber和element。元素是我们想要渲染到DOM的东西，而oldFiber是我们上次渲染的东西。我们需要比较它们，看看是否需要对DOM进行更改。</p>\n<p>为了比较它们，我们使用类型:</p>\n<ul>\n<li>如果旧的Fiber和新元素具有相同的类型，我们可以保留DOM节点，并使用新的道具更新它</li>\n<li>如果类型不同，并且有一个新元素，这意味着我们需要创建一个新的DOM节点</li>\n<li>如果类型不同，并且有一个旧的光纤，我们需要删除旧的节点</li>\n</ul>\n<p>这里React也使用key，这样可以更好的<code>reconcile</code>。例如，它检测子元素在元素数组中的位置发生了变化。</p>\n<p>当旧Fiber和元素具有相同的类型时，我们创建一个新Fiber，使DOM节点与旧Fiber保持一致，使props与element保持一致。我们还向Fiber 添加了一个新属性:<code>effectTag</code>。我们将在稍后的<code>commit</code>阶段使用此属性。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> sameType =\n      oldFiber &amp;&amp;\n      element &amp;&amp;\n      element.<span class=\"hljs-property\">type</span> == oldFiber.<span class=\"hljs-property\">type</span>\n<span class=\"hljs-keyword\">if</span> (sameType) {\n  newFiber = {\n    <span class=\"hljs-attr\">type</span>: oldFiber.<span class=\"hljs-property\">type</span>,\n    <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n    <span class=\"hljs-attr\">dom</span>: oldFiber.<span class=\"hljs-property\">dom</span>,\n    <span class=\"hljs-attr\">parent</span>: wipFiber,\n    <span class=\"hljs-attr\">alternate</span>: oldFiber,\n    <span class=\"hljs-attr\">effectTag</span>: <span class=\"hljs-string\">&quot;UPDATE&quot;</span>,\n  }\n}\n</code></pre>\n<p>对于element需要一个新DOM节点的情况，我们用<code>PLACEMENT</code>标记标记新Fiber。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (element &amp;&amp; !sameType) {\n  newFiber = {\n    <span class=\"hljs-attr\">type</span>: element.<span class=\"hljs-property\">type</span>,\n    <span class=\"hljs-attr\">props</span>: element.<span class=\"hljs-property\">props</span>,\n    <span class=\"hljs-attr\">dom</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">parent</span>: wipFiber,\n    <span class=\"hljs-attr\">alternate</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">effectTag</span>: <span class=\"hljs-string\">&quot;PLACEMENT&quot;</span>,\n  }\n}\n</code></pre>\n<p>对于需要删除节点的情况，我们没有新的Fiber，所以我们在旧Fiber上添加effect标签。但是当我们将Fiber树提交到DOM时，我们从正在进行的根目录执行，它没有旧的Fiber 。所以我们需要一个数组来跟踪要删除的节点。然后，当我们将更改提交到DOM时，我们还使用了来自该数组的Fiber。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> (oldFiber &amp;&amp; !sameType) {\n  oldFiber.<span class=\"hljs-property\">effectTag</span> = <span class=\"hljs-string\">&quot;DELETION&quot;</span>\n  deletions.<span class=\"hljs-title function_\">push</span>(oldFiber)\n}\n</code></pre>\n<p>现在，让我们修改<code>commitWork</code>函数来处理新的<code>effectTags</code>。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">commitWork</span>(<span class=\"hljs-params\">fiber</span>) {\n  <span class=\"hljs-keyword\">if</span> (!fiber) {\n    <span class=\"hljs-keyword\">return</span>\n  }\n  <span class=\"hljs-keyword\">if</span> (\n    fiber.<span class=\"hljs-property\">effectTag</span> === <span class=\"hljs-string\">&quot;PLACEMENT&quot;</span> &amp;&amp;\n    fiber.<span class=\"hljs-property\">dom</span> != <span class=\"hljs-literal\">null</span>\n  ) {\n    domParent.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (\n      fiber.<span class=\"hljs-property\">effectTag</span> === <span class=\"hljs-string\">&quot;UPDATE&quot;</span> &amp;&amp;\n      fiber.<span class=\"hljs-property\">dom</span> != <span class=\"hljs-literal\">null</span>\n    ) {\n      <span class=\"hljs-title function_\">updateDom</span>(\n        fiber.<span class=\"hljs-property\">dom</span>,\n        fiber.<span class=\"hljs-property\">alternate</span>.<span class=\"hljs-property\">props</span>,\n        fiber.<span class=\"hljs-property\">props</span>\n      )\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (fiber.<span class=\"hljs-property\">effectTag</span> === <span class=\"hljs-string\">&quot;DELETION&quot;</span>) {\n      domParent.<span class=\"hljs-title function_\">removeChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  }\n  <span class=\"hljs-keyword\">const</span> domParent = fiber.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">dom</span>\n  domParent.<span class=\"hljs-title function_\">appendChild</span>(fiber.<span class=\"hljs-property\">dom</span>)\n  <span class=\"hljs-title function_\">commitWork</span>(fiber.<span class=\"hljs-property\">child</span>)\n  <span class=\"hljs-title function_\">commitWork</span>(fiber.<span class=\"hljs-property\">sibling</span>)\n}\n</code></pre>\n<ul>\n<li><p>如果Fiber有一个<code>PLACEMENT</code>标签，从父Fiber将DOM节点附加到节点。</p>\n</li>\n<li><p>如果是<code>DELETION</code>，则做相反的操作，删除子元素。</p>\n</li>\n<li><p>如果是<code>UPDATE</code>，则需要使用更改后的props更新现有DOM节点。我们将在这个<code>updateDom</code>函数中完成这些操作。将旧Fiber中的props与新Fiber中的props进行比较，去掉不存在的prop，设置新的或更换的prop。需要注意的是，如果prop以<code>on</code>前缀开头，我们将以不同的方式处理它：如果event handler发生了更改，我们将其从节点中删除，然后再添加新的handler。</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isEvent</span> = key =&gt; key.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&quot;on&quot;</span>)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isProperty</span> = key =&gt;\n      key !== <span class=\"hljs-string\">&quot;children&quot;</span> &amp;&amp; !<span class=\"hljs-title function_\">isEvent</span>(key)\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isNew</span> = (<span class=\"hljs-params\">prev, next</span>) =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span>\n    prev[key] !== next[key]\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isGone</span> = (<span class=\"hljs-params\">prev, next</span>) =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> !(key <span class=\"hljs-keyword\">in</span> next)\n  \n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateDom</span>(<span class=\"hljs-params\">dom, prevProps, nextProps</span>) {\n  <span class=\"hljs-comment\">// Remove old properties</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(prevProps)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title function_\">isGone</span>(prevProps, nextProps))\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      dom[name] = <span class=\"hljs-string\">&quot;&quot;</span>\n  })\n\n  <span class=\"hljs-comment\">// Set new or changed properties</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(nextProps)\n    .<span class=\"hljs-title function_\">filter</span>(isProperty)\n    .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title function_\">isNew</span>(prevProps, nextProps))\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      dom[name] = nextProps[name]\n  })\n  \n  <span class=\"hljs-comment\">// Add event listeners</span>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(nextProps)\n    .<span class=\"hljs-title function_\">filter</span>(isEvent)\n    .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-title function_\">isNew</span>(prevProps, nextProps))\n    .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> eventType = name\n        .<span class=\"hljs-title function_\">toLowerCase</span>()\n        .<span class=\"hljs-title function_\">substring</span>(<span class=\"hljs-number\">2</span>)\n      dom.<span class=\"hljs-title function_\">addEventListener</span>(\n        eventType,\n        nextProps[name]\n      )\n  })\n}\n</code></pre>\n"},{"title":"React.js学习-useEffect完整指南","tags":["React.js","Hooks"],"categories":"React.js","description":"> 原文链接：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\n\n# 每一次渲染都有它自己的...\n\n``` jsx\nconst Counter = () => {\n\tconst [count, setCount] = useState(0)\n    \n    return (\n    \t<button onClick=","createDate":"2020-10-27 15:21:38","updateDate":"2020-10-30 18:03:54","body":"<blockquote>\n<p>原文链接：<a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">每一次渲染都有它自己的...</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Counter</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)\n    \n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setCount(count+1)}&gt;click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>${ count }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>\n        <span class=\"hljs-comment\">// 没做任何特殊事件绑定，只是在渲染时拿取独立的count状态</span>\n    )\n}\n</code></pre>\n<ul>\n<li>每一次渲染都有它自己的<code>data</code>和<code>props</code></li>\n<li>每一次渲染都有它自己的事件处理函数</li>\n<li>每一次渲染都有它自己的Effects</li>\n<li>每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的<code>props</code>和<code>state</code></li>\n<li>当更新状态时，React会重新渲染组件。每一次渲染都能拿到独立的<code>count</code>状态，这个状态值是函数中的一个常量</li>\n<li>在单次渲染的范围内，<code>props</code>和<code>state</code>始终保持不变</li>\n</ul>\n<blockquote>\n<p>如果<code>props</code>和<code>state</code>在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的<code>count</code>值。</p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组件不要将接收到的参数本地化，或者说使组件完全受控</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>如果需要对 props 进行加工，可以利用 useMemo 对加工过程进行缓存，仅当依赖变化时才重新执行</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> textColor = <span class=\"hljs-title function_\">useMemo</span>(\n  <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">slowlyCalculateTextColor</span>(color),\n  [color] <span class=\"hljs-comment\">// ✅ Don’t recalculate until `color` changes</span>\n);\n</code></pre>\n"},{"title":"React.js学习-自定义hook-1","tags":["React.js学习","hook"],"categories":"React.js","description":"# 自定义hook的好处\n\n可以把组件逻辑抽到**可复用**的方法里\n\n# useRequest\n\n```ts\nfunction useRequest<P, T>(api: (params: P) => Promise<T>, params?: P, visiable = true)\n  :[boolean, T|undefined, (params?: P) => void, () => v","createDate":"2020-09-03 09:23:54","updateDate":"2020-10-20 16:48:58","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">自定义hook的好处</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>可以把组件逻辑抽到<strong>可复用</strong>的方法里</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useRequest</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">function</span> useRequest&lt;P, T&gt;(<span class=\"hljs-attr\">api</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">params: P</span>) =&gt;</span> <span class=\"hljs-title class_\">Promise</span>&lt;T&gt;, params?: P, visiable = <span class=\"hljs-literal\">true</span>)\n  :[<span class=\"hljs-built_in\">boolean</span>, T|<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">params?: P</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">void</span>] {\n  <span class=\"hljs-keyword\">const</span> [res, setRes] = useState&lt;T&gt;();\n  <span class=\"hljs-keyword\">const</span> [loading, setLoading] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> [newParams, setNewParams] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-function\">() =&gt;</span> params);\n  <span class=\"hljs-keyword\">const</span> [autoFetch, setAutoFetch] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-function\">() =&gt;</span> visiable);\n\n  <span class=\"hljs-keyword\">const</span> fetch = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-keyword\">if</span> (!newParams &amp;&amp; autoFetch === <span class=\"hljs-literal\">false</span>) <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-keyword\">if</span> (autoFetch) {\n      <span class=\"hljs-keyword\">const</span> _params = (newParams || {}) <span class=\"hljs-keyword\">as</span> P;\n      <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">true</span>);\n      <span class=\"hljs-keyword\">const</span> tmp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">api</span>(_params);\n      <span class=\"hljs-title function_\">setRes</span>(tmp);\n      <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">false</span>);\n    }\n  }, [api, autoFetch, newParams]);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">fetch</span>();\n  }, [fetch]);\n\n  <span class=\"hljs-keyword\">const</span> doFetch = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">rest = <span class=\"hljs-literal\">null</span></span>) =&gt;</span> {\n    <span class=\"hljs-title function_\">setNewParams</span>(rest);\n    <span class=\"hljs-title function_\">setAutoFetch</span>(<span class=\"hljs-literal\">true</span>);\n  }, []);\n\n  <span class=\"hljs-keyword\">return</span> [loading, res, doFetch, fetch];\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">useSlider</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>如果使用传统方式开发，UI界面与逻辑强耦合在一起，若要开发一个横向和一个竖向则代码过于冗余。于是可以使用自定义<code>hook-useSlider</code>将滑动逻辑复用</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 传统方式开发</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useRef, useEffect, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Slider</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> drag = <span class=\"hljs-title function_\">useRef</span>()\n    <span class=\"hljs-keyword\">const</span> [percent, setPercent] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)\n\n    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        drag.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">left</span> = percent * <span class=\"hljs-number\">300</span> - <span class=\"hljs-number\">12</span> + <span class=\"hljs-string\">&#x27;px&#x27;</span>\n    }, [percent])\n\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseDown</span>(<span class=\"hljs-params\">e</span>) {\n        e.<span class=\"hljs-title function_\">persist</span>()\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;mousemove&#x27;</span>, onMouseMove)\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;mouseup&#x27;</span>, onMouseUp)\n    }\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseMove</span>(<span class=\"hljs-params\">e</span>) {\n        <span class=\"hljs-keyword\">if</span> (e.<span class=\"hljs-property\">pageX</span> &lt; <span class=\"hljs-number\">0</span> || e.<span class=\"hljs-property\">pageX</span> &gt; <span class=\"hljs-number\">300</span>) <span class=\"hljs-keyword\">return</span>\n        <span class=\"hljs-title function_\">setPercent</span>((e.<span class=\"hljs-property\">pageX</span> / <span class=\"hljs-number\">300</span>))\n        drag.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">left</span> = e.<span class=\"hljs-property\">pageX</span> - <span class=\"hljs-number\">12</span> + <span class=\"hljs-string\">&#x27;px&#x27;</span>\n    }\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseUp</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;mousemove&#x27;</span>, onMouseMove)\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;mouseup&#x27;</span>, onMouseUp)\n    }\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercent(0)}&gt;0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercent(0.5)}&gt;0.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercent(1)}&gt;1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span> \n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{ percent }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">relative</span>&#x27; }}&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">height:</span> &#x27;<span class=\"hljs-attr\">15px</span>&#x27;, <span class=\"hljs-attr\">width:</span> &#x27;<span class=\"hljs-attr\">300px</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">ccc</span>&#x27; }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{drag}</span> <span class=\"hljs-attr\">onMouseDown</span>=<span class=\"hljs-string\">{</span> <span class=\"hljs-attr\">onMouseDown</span> } <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">width:</span> &#x27;<span class=\"hljs-attr\">35px</span>&#x27;, <span class=\"hljs-attr\">height:</span> &#x27;<span class=\"hljs-attr\">35px</span>&#x27;, <span class=\"hljs-attr\">borderRadius:</span> &#x27;<span class=\"hljs-attr\">50</span>%&#x27;, <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">absolute</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">aaa</span>&#x27;, <span class=\"hljs-attr\">top:</span> &#x27;<span class=\"hljs-attr\">-10px</span>&#x27;, <span class=\"hljs-attr\">left:</span> <span class=\"hljs-attr\">0</span> }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    )\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Slider</span>\n</code></pre>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// 使用自定义hook开发</span>\n\n<span class=\"hljs-comment\">// slider2.0.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useRef, useEffect, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">useSlider</span> = (<span class=\"hljs-params\">{ dragWidth, slideWidth, direction =<span class=\"hljs-string\">&#x27;horizontal&#x27;</span> }</span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> drag = <span class=\"hljs-title function_\">useRef</span>()\n    <span class=\"hljs-keyword\">const</span> [percent, setPercent] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)\n    <span class=\"hljs-keyword\">const</span> [originPosition, setOriginPosition] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span> ,<span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span> }))\n\n    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (direction === <span class=\"hljs-string\">&#x27;horizontal&#x27;</span>) drag.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">left</span> = percent * slideWidth - (dragWidth&gt;&gt;<span class=\"hljs-number\">1</span>) + <span class=\"hljs-string\">&#x27;px&#x27;</span>\n        <span class=\"hljs-keyword\">else</span> drag.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">top</span> = percent * slideWidth - (dragWidth&gt;&gt;<span class=\"hljs-number\">1</span>) + <span class=\"hljs-string\">&#x27;px&#x27;</span>\n    }, [percent])\n\n    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-keyword\">const</span> { left, top } = drag.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">getBoundingClientRect</span>()\n        <span class=\"hljs-title function_\">setOriginPosition</span>({ <span class=\"hljs-attr\">x</span>: left, <span class=\"hljs-attr\">y</span>: top })\n        <span class=\"hljs-keyword\">return</span> onMouseUp\n    }, [drag])\n    \n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseDown</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;mousemove&#x27;</span>, onMouseMove)\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;mouseup&#x27;</span>, onMouseUp)\n    }\n\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseMove</span>(<span class=\"hljs-params\">e</span>) {\n        <span class=\"hljs-keyword\">if</span> (direction === <span class=\"hljs-string\">&#x27;horizontal&#x27;</span>) {\n            <span class=\"hljs-keyword\">const</span> pos = e.<span class=\"hljs-property\">pageX</span> - originPosition.<span class=\"hljs-property\">x</span> - (dragWidth&gt;&gt;<span class=\"hljs-number\">1</span>)\n            <span class=\"hljs-keyword\">if</span> (pos &lt; <span class=\"hljs-number\">0</span> || pos &gt; slideWidth) <span class=\"hljs-keyword\">return</span>\n            <span class=\"hljs-title function_\">setPercent</span>(pos / slideWidth)\n            drag.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">left</span> = pos - (dragWidth&gt;&gt;<span class=\"hljs-number\">1</span>) + <span class=\"hljs-string\">&#x27;px&#x27;</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">const</span> pos = e.<span class=\"hljs-property\">pageY</span> - originPosition.<span class=\"hljs-property\">y</span> - (dragWidth&gt;&gt;<span class=\"hljs-number\">1</span>)\n            <span class=\"hljs-keyword\">if</span> (pos &lt; <span class=\"hljs-number\">0</span> || pos &gt; slideWidth) <span class=\"hljs-keyword\">return</span>\n            <span class=\"hljs-title function_\">setPercent</span>(pos / slideWidth)\n            drag.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">top</span> = pos - (dragWidth&gt;&gt;<span class=\"hljs-number\">1</span>) + <span class=\"hljs-string\">&#x27;px&#x27;</span>\n        }\n    }\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onMouseUp</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;mousemove&#x27;</span>, onMouseMove)\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;mouseup&#x27;</span>, onMouseUp)\n    }\n\n    <span class=\"hljs-keyword\">return</span> [\n        drag,\n        percent,\n        onMouseDown,\n        setPercent\n    ]\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Slider</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> [ dragH, percentH, onDragMouseDownH, setPercentH ] = <span class=\"hljs-title function_\">useSlider</span>({ <span class=\"hljs-attr\">dragWidth</span>: <span class=\"hljs-number\">35</span>, <span class=\"hljs-attr\">slideWidth</span>: <span class=\"hljs-number\">300</span> })\n    <span class=\"hljs-keyword\">const</span> [ dragV, percentV, onDragMouseDownV, setPercentV ] = <span class=\"hljs-title function_\">useSlider</span>({ <span class=\"hljs-attr\">dragWidth</span>: <span class=\"hljs-number\">35</span>, <span class=\"hljs-attr\">slideWidth</span>: <span class=\"hljs-number\">300</span>, <span class=\"hljs-attr\">direction</span>: <span class=\"hljs-string\">&#x27;vertical&#x27;</span> })\n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        {/* 可以分别创建一个SliderV.js和SliderH.js */}\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">marginLeft:</span> &#x27;<span class=\"hljs-attr\">20px</span>&#x27; }}&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>横向<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>            \n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercentH(0)}&gt;0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercentH(0.5)}&gt;0.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercentH(1)}&gt;1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span> \n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{ percentH }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">relative</span>&#x27; }}&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">height:</span> &#x27;<span class=\"hljs-attr\">15px</span>&#x27;, <span class=\"hljs-attr\">width:</span> &#x27;<span class=\"hljs-attr\">300px</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">ccc</span>&#x27; }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">width:</span> `${<span class=\"hljs-attr\">percentH</span> * <span class=\"hljs-attr\">300</span>}<span class=\"hljs-attr\">px</span>`, <span class=\"hljs-attr\">height:</span> &#x27;<span class=\"hljs-attr\">15px</span>&#x27;, <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">absolute</span>&#x27;, <span class=\"hljs-attr\">top:</span> &#x27;<span class=\"hljs-attr\">0</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">f00</span>&#x27; }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{dragH}</span> <span class=\"hljs-attr\">onMouseDown</span>=<span class=\"hljs-string\">{onDragMouseDownH}</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">width:</span> &#x27;<span class=\"hljs-attr\">35px</span>&#x27;, <span class=\"hljs-attr\">height:</span> &#x27;<span class=\"hljs-attr\">35px</span>&#x27;, <span class=\"hljs-attr\">borderRadius:</span> &#x27;<span class=\"hljs-attr\">50</span>%&#x27;, <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">absolute</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">aaa</span>&#x27;, <span class=\"hljs-attr\">left:</span> <span class=\"hljs-attr\">0</span>, <span class=\"hljs-attr\">top:</span> &#x27;<span class=\"hljs-attr\">-10px</span>&#x27; }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">marginLeft:</span> &#x27;<span class=\"hljs-attr\">20px</span>&#x27; }}&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>竖向<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>            \n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercentV(0)}&gt;0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercentV(0.5)}&gt;0.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setPercentV(1)}&gt;1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span> \n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{ percentV }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">relative</span>&#x27; }}&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">height:</span> &#x27;<span class=\"hljs-attr\">300px</span>&#x27;, <span class=\"hljs-attr\">width:</span> &#x27;<span class=\"hljs-attr\">15px</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">ccc</span>&#x27; }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">height:</span> `${<span class=\"hljs-attr\">percentV</span> * <span class=\"hljs-attr\">300</span>}<span class=\"hljs-attr\">px</span>`, <span class=\"hljs-attr\">width:</span> &#x27;<span class=\"hljs-attr\">15px</span>&#x27;, <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">absolute</span>&#x27;, <span class=\"hljs-attr\">left:</span> &#x27;<span class=\"hljs-attr\">0</span>&#x27;, <span class=\"hljs-attr\">top:</span> &#x27;<span class=\"hljs-attr\">0</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">f00</span>&#x27; }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{dragV}</span> <span class=\"hljs-attr\">onMouseDown</span>=<span class=\"hljs-string\">{onDragMouseDownV}</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">width:</span> &#x27;<span class=\"hljs-attr\">35px</span>&#x27;, <span class=\"hljs-attr\">height:</span> &#x27;<span class=\"hljs-attr\">35px</span>&#x27;, <span class=\"hljs-attr\">borderRadius:</span> &#x27;<span class=\"hljs-attr\">50</span>%&#x27;, <span class=\"hljs-attr\">position:</span> &#x27;<span class=\"hljs-attr\">absolute</span>&#x27;, <span class=\"hljs-attr\">backgroundColor:</span> &#x27;#<span class=\"hljs-attr\">aaa</span>&#x27;, <span class=\"hljs-attr\">top:</span> <span class=\"hljs-attr\">0</span>, <span class=\"hljs-attr\">left:</span> &#x27;<span class=\"hljs-attr\">-10px</span>&#x27; }}&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    )\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Slider</span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ref:</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><a href=\"https://juejin.im/post/6844904021984018439\">React Hook 系列（二）：自定义hook的一些实践</a></p>\n"},{"title":"React.js学习-自定义hook-2","tags":["React.js学习","hook"],"categories":"React.js","description":"# DOM 副作用修改 / 监听\n\n## 修改页面 title\n\n在组件里调用`useDocumentTitle`即可设置页面标题，且切换页面时，页面标题重置为默认标题 “React.js学习”\n\n```js\nconst useDocumentTitle = (newTitle: string) => {\n\tuseEffect(() => {\n  \tdocument.title = title","createDate":"2020-10-19 15:11:13","updateDate":"2020-10-20 03:22:35","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">DOM 副作用修改 / 监听</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">修改页面 title</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在组件里调用<code>useDocumentTitle</code>即可设置页面标题，且切换页面时，页面标题重置为默认标题 “React.js学习”</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">useDocumentTitle</span> = (<span class=\"hljs-params\">newTitle: string</span>) =&gt; {\n    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span> = title\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span> = <span class=\"hljs-string\">&quot;React.js学习&quot;</span>\n    }\n  }, [newTitle])\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">监听页面大小发生改变（网络状况发生改变），重新渲染界面</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getSize</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { innerWidth, innerHeight, outerHeight, outerWidth } = <span class=\"hljs-variable language_\">window</span>\n  <span class=\"hljs-keyword\">return</span> {\n    innerWidth,\n    innerHeight,\n    outerHeight,\n    outerWidth\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useWindowSizeChange</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [windowSize, setWindowSize] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-title function_\">getSize</span>());\n\n  <span class=\"hljs-keyword\">const</span> onWindowSizeChange = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">setWindowSize</span>(<span class=\"hljs-title function_\">getSize</span>());\n  }, [])\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;resize&#x27;</span>, onWindowSizeChange);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;resize&#x27;</span>, onWindowSizeChange);\n    }\n  }, [onWindowSizeChange])\n\n  <span class=\"hljs-keyword\">return</span> windowSize;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getInternetState</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> { onLine } = navigator\n  <span class=\"hljs-keyword\">return</span> onLine ? <span class=\"hljs-string\">&#x27;online&#x27;</span> : <span class=\"hljs-string\">&#x27;offline&#x27;</span>\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useInternetStateChange</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [internetState, setInternetState] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-title function_\">getInternetState</span>())\n\n  <span class=\"hljs-keyword\">const</span> onInternetStateChange = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">setInternetState</span>(<span class=\"hljs-title function_\">getInternetState</span>())\n  }, [])\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;online&quot;</span>, onInternetStateChange)\n    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;offline&quot;</span>, onInternetStateChange)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;online&quot;</span>, onInternetStateChange)\n      <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;offline&quot;</span>, onInternetStateChange)\n    }\n  }, [onInternetStateChange])\n\n  <span class=\"hljs-keyword\">return</span> internetState\n}\n</code></pre>\n"},{"title":"Vue.js学习-$nextTick","tags":["$nextTick"],"categories":"Vue.js","description":"# [异步更新]([https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97](https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%","createDate":"2020-05-07 23:20:25","updateDate":"2020-10-16 17:33:23","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"%5Bhttps://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97%5D(https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97)\">异步更新</a></span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p>\n<p>这样做主要是为了提升性能，因为如果在主线程中更新DOM，循环100次就要更新100次DOM；但是如果等待事件循环完成之后再更新DOM，只需要更新一次。为了在数据更新操作之后操作DOM，我们可以在数据变化之后立即使用<code>Vue.nextTick(callback)</code>；这样回调函数会在DOM更新完成后被调用，就可以拿到最新的DOM元素了。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><code>$nextTick</code>源码分析</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// /src/core/util/next-tick.js</span>\n<span class=\"hljs-keyword\">const</span> callbacks = []\n<span class=\"hljs-keyword\">let</span> pending = <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-keyword\">let</span> timerFunc\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">nextTick</span> (cb?: <span class=\"hljs-title class_\">Function</span>, ctx?: <span class=\"hljs-title class_\">Object</span>) {\n  <span class=\"hljs-keyword\">let</span> _resolve\n  callbacks.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (cb) {\n      <span class=\"hljs-keyword\">try</span> {\n        cb.<span class=\"hljs-title function_\">call</span>(ctx)\n      } <span class=\"hljs-keyword\">catch</span> (e) {\n        <span class=\"hljs-title function_\">handleError</span>(e, ctx, <span class=\"hljs-string\">&#x27;nextTick&#x27;</span>)\n      }\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (_resolve) {\n      <span class=\"hljs-title function_\">_resolve</span>(ctx)\n    }\n  })\n  <span class=\"hljs-keyword\">if</span> (!pending) {\n    pending = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-title function_\">timerFunc</span>()\n  }\n  <span class=\"hljs-comment\">// $flow-disable-line</span>\n  <span class=\"hljs-keyword\">if</span> (!cb &amp;&amp; <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Promise</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> {\n      _resolve = resolve\n    })\n  }\n}\n</code></pre>\n<p>每次调用$nextTick就是在向callbacks新增回调函数.callbacks新增回调函数后又执行了timerFunc函数，<code>pending</code>用来标识同一个时间只能执行一次。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> isUsingMicroTask = <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Promise</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-title function_\">isNative</span>(<span class=\"hljs-title class_\">Promise</span>)) {\n  <span class=\"hljs-comment\">//判断1：是否原生支持Promise</span>\n  <span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>()\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> {\n    p.<span class=\"hljs-title function_\">then</span>(flushCallbacks)\n    <span class=\"hljs-keyword\">if</span> (isIOS) <span class=\"hljs-built_in\">setTimeout</span>(noop)\n  }\n  isUsingMicroTask = <span class=\"hljs-literal\">true</span>\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!isIE &amp;&amp; <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">MutationObserver</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; (\n  <span class=\"hljs-title function_\">isNative</span>(<span class=\"hljs-title class_\">MutationObserver</span>) ||\n  <span class=\"hljs-title class_\">MutationObserver</span>.<span class=\"hljs-title function_\">toString</span>() === <span class=\"hljs-string\">&#x27;[object MutationObserverConstructor]&#x27;</span>\n)) {\n  <span class=\"hljs-comment\">//判断2：是否原生支持MutationObserver</span>\n  <span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MutationObserver</span>(flushCallbacks)\n  <span class=\"hljs-keyword\">const</span> textNode = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createTextNode</span>(<span class=\"hljs-title class_\">String</span>(counter))\n  observer.<span class=\"hljs-title function_\">observe</span>(textNode, {\n    <span class=\"hljs-attr\">characterData</span>: <span class=\"hljs-literal\">true</span>\n  })\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> {\n    counter = (counter + <span class=\"hljs-number\">1</span>) % <span class=\"hljs-number\">2</span>\n    textNode.<span class=\"hljs-property\">data</span> = <span class=\"hljs-title class_\">String</span>(counter)\n  }\n  isUsingMicroTask = <span class=\"hljs-literal\">true</span>\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> setImmediate !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-title function_\">isNative</span>(setImmediate)) {\n  <span class=\"hljs-comment\">//判断3：是否原生支持setImmediate</span>\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-title function_\">setImmediate</span>(flushCallbacks)\n  }\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-comment\">//判断4：上面都不行，直接用setTimeout</span>\n  timerFunc = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(flushCallbacks, <span class=\"hljs-number\">0</span>)\n  }\n}\n</code></pre>\n<p><code>timerFunc</code>做了四个判断，对当前环境进行不断的降级处理，尝试使用原生的<code>Promise.then</code>、<code>MutationObserver</code>和<code>setImmediate</code>，上述三个都不支持最后使用setTimeout；降级处理的目的都是将<code>flushCallbacks</code>函数放入微任务(判断1和判断2)或者宏任务(判断3和判断4)，等待下一次事件循环时来执行。<code>MutationObserver</code>是Html5的一个新特性，用来监听目标DOM结构是否改变，也就是代码中新建的textNode；如果改变了就执行<code>MutationObserver</code>构造函数中的回调函数，不过是它是在微任务中执行的。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">flushCallbacks</span> () {\n  pending = <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-keyword\">const</span> copies = callbacks.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>)\n  callbacks.<span class=\"hljs-property\">length</span> = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; copies.<span class=\"hljs-property\">length</span>; i++) {\n    copies[i]()\n  }\n}\n</code></pre>\n<p><code>flushCallbacks</code>把<code>callbacks</code>数组复制一份，然后把<code>callbacks</code>置为空，最后把复制出来的数组中的每个函数依次执行一遍；所以它的作用仅仅是用来执行<code>callbacks中</code>的回调函数。</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>$nextTick</code>的总体流程大致是：</p>\n<ol>\n<li>把回调函数放入<code>callbacks</code>中执行，<code>callpacks.push</code></li>\n<li>将执行函数放到微任务会宏任务中，<code>timerFunc</code></li>\n<li>事件循环到了微任务或宏任务，执行函数依次执行<code>callbacks</code>中的回调，<code>flushCallbacks</code></li>\n</ol>\n"},{"title":"React.js学习-图片懒加载（高阶组件实现）","tags":["React.js学习","HOC"],"categories":"React.js","description":"# 懒加载实现方式\n\nHTML5新API：`new IntersectionObserver(callback)`\n\n观察一个元素后，当元素出现在视口内，会触发回调\n\n[其他实现方式]([http://blog.p18c.top/2020/04/24/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84&%E8%BD%AF%E5%AE%9E%E5%8A%9B-%E9%A2%","createDate":"2020-05-12 23:03:54","updateDate":"2020-10-16 17:33:00","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">懒加载实现方式</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>HTML5新API：<code>new IntersectionObserver(callback)</code></p>\n<p>观察一个元素后，当元素出现在视口内，会触发回调</p>\n<p><a href=\"%5Bhttp://blog.p18c.top/2020/04/24/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84&amp;%E8%BD%AF%E5%AE%9E%E5%8A%9B-%E9%A2%84%E5%8A%A0%E8%BD%BD&amp;%E6%87%92%E5%8A%A0%E8%BD%BD/%5D(http://blog.p18c.top/2020/04/24/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84&amp;%E8%BD%AF%E5%AE%9E%E5%8A%9B-%E9%A2%84%E5%8A%A0%E8%BD%BD&amp;%E6%87%92%E5%8A%A0%E8%BD%BD/)\">其他实现方式</a></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">代码实现</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// MLazyLoad.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useEffect, useRef, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { clone } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;ramda&#x27;</span>;\n\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">PropsI</span> {\n  <span class=\"hljs-attr\">element</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable constant_\">JSX</span>.<span class=\"hljs-property\">Element</span>,\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">LazyLoad</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&lt;<span class=\"hljs-title class_\">PropsI</span>&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">props: PropsI</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> [<span class=\"hljs-title class_\">Element</span>, setElement] = useState&lt;<span class=\"hljs-variable constant_\">JSX</span>.<span class=\"hljs-property\">Element</span>&gt;(props.<span class=\"hljs-title function_\">element</span>());\n  <span class=\"hljs-keyword\">const</span> elementRef = useRef&lt;<span class=\"hljs-title class_\">HTMLDivElement</span>&gt;(<span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    (<span class=\"hljs-keyword\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">if</span> (!elementRef || !elementRef.<span class=\"hljs-property\">current</span>) <span class=\"hljs-keyword\">return</span>;\n      <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IntersectionObserver</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">changes</span>) =&gt;</span> {\n        changes.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">change</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">if</span> (change.<span class=\"hljs-property\">isIntersecting</span>) {\n            <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Com</span> = <span class=\"hljs-title function_\">clone</span>(<span class=\"hljs-title class_\">Element</span>);\n            <span class=\"hljs-title class_\">Com</span>.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">src</span> = <span class=\"hljs-title class_\">Com</span>.<span class=\"hljs-property\">props</span>[<span class=\"hljs-string\">&#x27;data-src&#x27;</span>];\n            <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(<span class=\"hljs-title class_\">Com</span>.<span class=\"hljs-property\">props</span>, <span class=\"hljs-string\">&#x27;data-src&#x27;</span>);\n            <span class=\"hljs-title function_\">setElement</span>(<span class=\"hljs-title class_\">Com</span>);\n            observer.<span class=\"hljs-title function_\">unobserve</span>(change.<span class=\"hljs-property\">target</span>);\n          }\n        });\n      });\n      observer.<span class=\"hljs-title function_\">observe</span>(elementRef.<span class=\"hljs-property\">current</span>);\n    })();\n  }, []);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{elementRef}</span>&gt;</span>\n      {\n        Element\n      }\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element: () =&gt; JSX.Element</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LazyLoad</span> <span class=\"hljs-attr\">element</span>=<span class=\"hljs-string\">{element}</span> /&gt;</span></span>\n  );\n}\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用方式</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ImageNode</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{style.itemImg}</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;xxx&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> /&gt;</span></span>;\n\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    {\n        lazyLoad(ImageNode)\n    }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">效果</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/lazyload.gif\" alt=\"lazyload\"></p>\n"},{"title":"服务端渲染-简介","tags":["SSR"],"categories":"服务端渲染","description":"# 什么是SSR\r\n\r\n`SSR`(server side rendering)，服务端渲染。当后端/服务器接收到网络请求后，生成(渲染)`HTML`字符串，将它们直接发送到浏览器\r\n\r\n与之对立的则是`CSR`(client side rendering)，客户端渲染。后端不提供完整的`html`页面，而是提供一些`api`使得前端可以获取`json`数据，然后前端拿到`json`数据之","createDate":"2020-07-28 11:15:28","updateDate":"2020-10-16 17:32:50","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是SSR</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>SSR</code>(server side rendering)，服务端渲染。当后端/服务器接收到网络请求后，生成(渲染)<code>HTML</code>字符串，将它们直接发送到浏览器</p>\n<p>与之对立的则是<code>CSR</code>(client side rendering)，客户端渲染。后端不提供完整的<code>html</code>页面，而是提供一些<code>api</code>使得前端可以获取<code>json</code>数据，然后前端拿到<code>json</code>数据之后再在前端进行<code>html</code>页面拼接，然后展示在浏览器上。这种是客户端渲染。这样前端就可以专注<code>UI</code>的开发，后端专注逻辑开发。典型的应用是<code>SPA</code></p>\n<p><code>CSR</code>和<code>SSR</code>最大的区别在于前者的页面渲染是<code>JS</code>负责进行的，而后者是服务器端直接返回HTML让浏览器直接渲染</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么要有SSR</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>传统CSR的弊端不容小觑：</p>\n<ul>\n<li>首屏加载缓慢</li>\n<li>对于SEO无能为力</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">怎么做SSR</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">原理(基于React.js)</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li><p>编写一个简单的<code>React</code>组件</p>\n</li>\n<li><p>使用<code>react-dom/server</code>中的<code>renderToString</code>编译虚拟<code>DOM</code></p>\n</li>\n<li><p>将转换后的<code>DOM</code>插入<code>html</code>中返回给前端</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// containers/Home.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>This is sanyuan<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>\n\n<span class=\"hljs-comment\">// server/index.js</span>\n<span class=\"hljs-keyword\">import</span> express <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;express&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { renderToString } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom/server&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./containers/Home&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n<span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-title function_\">renderToString</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>);\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;/&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res</span>) {\n  res.<span class=\"hljs-title function_\">send</span>(\n  <span class=\"hljs-string\">`\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;ssr&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;div id=&quot;root&quot;&gt;<span class=\"hljs-subst\">${content}</span>&lt;/div&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  `</span>\n  );\n})\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3001</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;listen:3001&#x27;</span>)\n})\n</code></pre>\n</li>\n</ol>\n<p>此时已实现一个简单的SSR，但对于一些常见的场景如事件绑定无效，这时就需要进行了同构。所谓同构，通俗的讲，就是一套<code>React</code>代码在服务器上运行一遍，到达浏览器又运行一遍。<strong>服务端渲染完成页面结构，浏览器端渲染完成事件绑定</strong>。这样的话就需要浏览器去拉取额外的JS文件，由JS来完成一些复杂的事情</p>\n<ol start=\"4\">\n<li><p>使用<code>react-dom</code>关联<code>DOM</code>与<code>JS</code></p>\n</li>\n<li><p>使用<code>webpack</code>打包<code>JS</code></p>\n</li>\n<li><p>开启<code>express</code>的静态服务</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// client/index. js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDom</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../containers/Home&#x27;</span>;\n\n<span class=\"hljs-title class_\">ReactDom</span>.<span class=\"hljs-title function_\">hydrate</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>, <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;root&#x27;</span>))\n\n<span class=\"hljs-comment\">// webpack.client.js</span>\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> merge = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;webpack-merge&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> config = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./webpack.base&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> clientConfig = {\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&#x27;development&#x27;</span>,\n  <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&#x27;./src/client/index.js&#x27;</span>,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&#x27;index.js&#x27;</span>,\n    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&#x27;public&#x27;</span>)\n  },\n}\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-title function_\">merge</span>(config, clientConfig);\n\n<span class=\"hljs-comment\">//webpack.base.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">module</span>: {\n    <span class=\"hljs-attr\">rules</span>: [{\n      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.js$/</span>,\n      <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&#x27;babel-loader&#x27;</span>,\n      <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/node_modules/</span>,\n      <span class=\"hljs-attr\">options</span>: {\n        <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&#x27;@babel/preset-react&#x27;</span>,  [<span class=\"hljs-string\">&#x27;@babel/preset-env&#x27;</span>, {\n          <span class=\"hljs-attr\">targets</span>: {\n            <span class=\"hljs-attr\">browsers</span>: [<span class=\"hljs-string\">&#x27;last 2 versions&#x27;</span>]\n          }\n        }]]\n      }\n    }]\n  }\n}\n\n<span class=\"hljs-comment\">// package.json</span>\n<span class=\"hljs-string\">&quot;scripts&quot;</span>: {\n  <span class=\"hljs-string\">&quot;dev&quot;</span>: <span class=\"hljs-string\">&quot;npm-run-all --parallel dev:**&quot;</span>,\n  <span class=\"hljs-string\">&quot;dev:start&quot;</span>: <span class=\"hljs-string\">&quot;nodemon --watch build --exec node \\&quot;./build/bundle.js\\&quot;&quot;</span>,\n  <span class=\"hljs-string\">&quot;dev:build:server&quot;</span>: <span class=\"hljs-string\">&quot;webpack --config webpack.server.js --watch&quot;</span>,\n  <span class=\"hljs-string\">&quot;dev:build:client&quot;</span>: <span class=\"hljs-string\">&quot;webpack --config webpack.client.js --watch&quot;</span>\n}\n\n<span class=\"hljs-comment\">// server/index.js</span>\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">static</span>(<span class=\"hljs-string\">&#x27;public&#x27;</span>));\n</code></pre>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">三方框架</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><a href=\"https://nuxtjs.org/\">Nuxt.js</a>(基于<a href=\"https://cn.vuejs.org/index.html\">Vue.js</a>)</p>\n</li>\n<li><p><a href=\"https://nextjs.frontendx.cn/\">Next.js</a>(基于<a href=\"https://react.docschina.org\">React.js</a>)</p>\n</li>\n</ul>\n<p>Ref:</p>\n<p><a href=\"https://segmentfault.com/a/1190000020029159?utm_source=tag-newest\">从头开始，彻底理解服务端渲染原理(8千字汇总长文)</a></p>\n"},{"title":"Nest.js学习-基本概念","tags":["Nest.js"],"categories":"Nest.js","description":"# 核心架构\n\n## 模块\n\n模块是按业务逻辑化分基本单元，包含控制器和服务。控制器是处理请求和响应数据的条件，服务是处理实际业务逻辑的部件\n\n## 中间件\n\n中间件是路由处理handler前的数据处理层，只能在模块或者全局注册，可以做**日志处理中间件**；中间件可以访问整个`request`、`response`的上下文，模块作用域可以依赖注入服务。全局注册只能是一个纯函数或者一个高阶函数","createDate":"2020-09-22 22:35:38","updateDate":"2020-10-16 17:22:32","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">核心架构</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模块</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>模块是按业务逻辑化分基本单元，包含控制器和服务。控制器是处理请求和响应数据的条件，服务是处理实际业务逻辑的部件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">中间件</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>中间件是路由处理handler前的数据处理层，只能在模块或者全局注册，可以做<strong>日志处理中间件</strong>；中间件可以访问整个<code>request</code>、<code>response</code>的上下文，模块作用域可以依赖注入服务。全局注册只能是一个纯函数或者一个高阶函数</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">管道</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>管道是数据流处理，在中间件后路由处理前做数据处理，可以在控制器中的类、方法、方法参数及全局注册使用，只能是一个纯函数。可以做<strong>数据验证，数据转换</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">守卫</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>守卫决定请求是否可以到达对应的路由处理器，能够知道当前路由的执行上下文，可以在控制器中的类、方法及全局注册使用。可以做<code>RABC</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">异常过滤器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>内置的异常层负责处理整个应用程序中所有抛出的异常。当捕获到未处理的异常时，最终用户将收到友好的响应。可以做<strong>异常处理</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">拦截器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>拦截器是进入控制器之前和之后处理相关逻辑，能够知道当前路由的执行上下文，可以控制器中的类、方法、全局注册使用。可以做<strong>接口响应记录</strong></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模块划分</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>AppModule应用根模块</p>\n<ul>\n<li>CoreModule 核心模块（注册中间件、过滤器、管道、守卫、拦截器、装饰器等）</li>\n<li>SharedModule 共享模块（注册服务，如DB、redis等）</li>\n<li>ConfigureModule 配置模块（系统配置）</li>\n<li>FeatureModule 特性模块（业务模块）</li>\n</ul>\n"},{"title":"Docker-入门","tags":["Docker入门"],"categories":"Docker","description":"# 什么是Docker\n\n## 简介\n\n[百科](https://baike.baidu.com/item/docker/13344470)：Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\n\n## 核心概念\n\n- 镜像","createDate":"2020-08-10 22:16:00","updateDate":"2020-10-16 15:19:50","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">什么是Docker</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">简介</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://baike.baidu.com/item/docker/13344470\">百科</a>：Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">核心概念</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>镜像</li>\n</ul>\n<p>镜像是一个文件，它是用来创建容器的。Docker镜就好比“Win7纯净版.iso”文件</p>\n<ul>\n<li>容器</li>\n</ul>\n<p>像一个虚拟机，容器中运行着一个完整的操作系统。可以在容器中装Nodejs，可以执行<code>npm install</code>，可以做一切你当前操作系统能做的事情</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Docker能用来做什么</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>快速部署应用（DevOps），较虚拟机系统性能消耗低、应用启停高效</p>\n<p><a href=\"/article/Docker-%E5%AE%9E%E6%88%98%E4%B9%8B%E5%9F%BA%E4%BA%8ETravis%E3%80%81Github%E6%90%AD%E5%BB%BACI&amp;CD%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2\">Docker-实战之基于Travis、Github搭建CI/CD自动化部署</a></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">怎么使用Docker</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li><a href=\"https://www.cnblogs.com/sky-k/p/11507441.html\">安装docker(CentOS)</a></li>\n<li>拉取/打包镜像</li>\n</ol>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">拉取镜像</span>\ndocker pull mrrs878/blog:latest\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">打包镜像</span>\ndocker build -t mrrs878/blog:latest .\n</code></pre>\n<ol start=\"3\">\n<li>根据镜像创建容器</li>\n</ol>\n<pre><code class=\"hljs language-shell\">docker container create --name blog -p 8081:80 mrrs878/blog:latest\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">container <span class=\"hljs-built_in\">id</span></span>\n</code></pre>\n<ol start=\"4\">\n<li>启动容器</li>\n</ol>\n<pre><code class=\"hljs language-shell\">docker container start xxx(container id)\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">docker-compose</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">service name和container name的关系</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如果<code>container_name</code>没有定义，运行<code>docker-cmpose up -d</code>后，docker-compose自动给container分配了一个名字，其格式为：<code>&lt;当前工作路径名&gt;/&lt;servicename&gt;_&lt;sequencenumber&gt;</code></p>\n"},{"title":"服务端渲染-Nuxt.js","tags":["SSR"],"categories":"服务端渲染","description":"> Nuxt.js@2.13.6\n\n# 安装\n\n推荐使用官方脚手架\n\n`yarn create nuxt-app <project name>`\n\n# 使用\n\n## 如何引入三方UI库/框架\n\n[vant](https://youzan.github.io/vant/#/zh-CN/) 为例\n\n1. `~/plugins/`下新建`vant-ui.js`\n\n    ```js\n    // ~","createDate":"2020-07-28 11:15:28","updateDate":"2020-10-16 15:18:28","body":"<blockquote>\n<p><a href=\"mailto:&#78;&#x75;&#x78;&#x74;&#46;&#106;&#x73;&#x40;&#x32;&#x2e;&#x31;&#51;&#46;&#54;\">&#78;&#x75;&#x78;&#x74;&#46;&#106;&#x73;&#x40;&#x32;&#x2e;&#x31;&#51;&#46;&#54;</a></p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>推荐使用官方脚手架</p>\n<p><code>yarn create nuxt-app &lt;project name&gt;</code></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">使用</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何引入三方UI库/框架</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://youzan.github.io/vant/#/zh-CN/\">vant</a> 为例</p>\n<ol>\n<li><p><code>~/plugins/</code>下新建<code>vant-ui.js</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ~/plugins/vant-ui.js</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Vue</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span>\n<span class=\"hljs-keyword\">import</span> { xxx } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vant&#x27;</span>\n\n<span class=\"hljs-comment\">// 只能全局注册组件，局部注册会丢失样式！！！</span>\n<span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">use</span>(xxx)\n</code></pre>\n</li>\n<li><p>安装<code>vant、less、less-loader</code></p>\n<pre><code class=\"hljs language-shell\">yarn add vant -S\nyarn add less less-loader -D\n</code></pre>\n</li>\n<li><p>配置<code>nuxt.config.js</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// nuxt.config.js</span>\n{\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-attr\">build</span>: {\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-attr\">transpile</span>: [<span class=\"hljs-regexp\">/vant.*?less/</span>],\n        <span class=\"hljs-attr\">babel</span>: {\n          <span class=\"hljs-attr\">plugins</span>: [\n            [<span class=\"hljs-string\">&#x27;import&#x27;</span>, {\n              <span class=\"hljs-attr\">libraryName</span>: <span class=\"hljs-string\">&#x27;vant&#x27;</span>,\n              <span class=\"hljs-attr\">style</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>/style/less`</span>\n            }, <span class=\"hljs-string\">&#x27;vant&#x27;</span>]\n          ]\n        },\n        <span class=\"hljs-attr\">loaders</span>: {\n          <span class=\"hljs-comment\">// 修改默认样式</span>\n          <span class=\"hljs-attr\">less</span>: {\n            <span class=\"hljs-attr\">javascriptEnabled</span>: <span class=\"hljs-literal\">true</span>,\n            <span class=\"hljs-attr\">modifyVars</span>: {\n              <span class=\"hljs-string\">&#x27;button-primary-background-color&#x27;</span>: <span class=\"hljs-string\">&#x27;#ff6008&#x27;</span>,\n              <span class=\"hljs-string\">&#x27;button-primary-border-color&#x27;</span>: <span class=\"hljs-string\">&#x27;#ff6008&#x27;</span>,\n              <span class=\"hljs-string\">&#x27;nav-bar-text-color&#x27;</span>: <span class=\"hljs-string\">&#x27;#ff6008&#x27;</span>,\n              <span class=\"hljs-string\">&#x27;nav-bar-icon-color&#x27;</span>: <span class=\"hljs-string\">&#x27;#ff6008&#x27;</span>,\n            }\n          }\n        }\n    },\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">如何配置axios拦截器</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>~/plugins/</code>下新建<code>axios.js</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ~/plugins/axios.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">{ $axios }</span>) {\n  $axios.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-property\">request</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">config</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// todo</span>\n    <span class=\"hljs-keyword\">return</span> config\n  })\n  $axios.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-property\">response</span>.<span class=\"hljs-title function_\">use</span>(\n    <span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> response.<span class=\"hljs-property\">data</span>,\n    <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err)\n    }\n  )\n}\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">添加Node.js中间件（以日志中间件为例）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li><p>根目录下新建<code>serverMiddleware</code>文件夹</p>\n</li>\n<li><p>安装相关依赖<code>log4js</code>等</p>\n</li>\n<li><p>新建<code>logger.js</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> { join } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> { configure, getLogger, connectLogger } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;log4js&#x27;</span>)\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">LOG_PATH</span> = <span class=\"hljs-string\">&#x27;/opt/logs/gmm-node-h5ssrrelease/&#x27;</span>\n<span class=\"hljs-title function_\">configure</span>({\n  <span class=\"hljs-attr\">appenders</span>: {\n    <span class=\"hljs-attr\">ajaxError</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;dateFile&#x27;</span>,\n      <span class=\"hljs-attr\">pattern</span>: <span class=\"hljs-string\">&#x27;yyyy-MM-dd.log&#x27;</span>,\n      <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-title function_\">join</span>(<span class=\"hljs-variable constant_\">LOG_PATH</span>, <span class=\"hljs-string\">&#x27;ajaxError&#x27;</span>),\n      <span class=\"hljs-attr\">maxLogSize</span>: <span class=\"hljs-number\">10</span> * <span class=\"hljs-number\">1000</span> * <span class=\"hljs-number\">1000</span>,\n      <span class=\"hljs-attr\">numBackups</span>: <span class=\"hljs-number\">3</span>,\n      <span class=\"hljs-attr\">alwaysIncludePattern</span>: <span class=\"hljs-literal\">true</span>\n    },\n    <span class=\"hljs-comment\">// ...</span>\n  },\n  <span class=\"hljs-attr\">categories</span>: {\n    <span class=\"hljs-attr\">default</span>: { <span class=\"hljs-attr\">appenders</span>: [<span class=\"hljs-string\">&#x27;console&#x27;</span>], <span class=\"hljs-attr\">level</span>: <span class=\"hljs-string\">&#x27;info&#x27;</span> },\n    <span class=\"hljs-comment\">// ...</span>\n  }\n})\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">connectLogger</span>(<span class=\"hljs-title function_\">getLogger</span>(<span class=\"hljs-string\">&#x27;application&#x27;</span>), { <span class=\"hljs-attr\">level</span>: <span class=\"hljs-string\">&#x27;info&#x27;</span> })\n</code></pre>\n</li>\n<li><p>修改<code>nuxt.config.js</code>配置</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">serverMiddleware</span>: [\n    <span class=\"hljs-string\">&#x27;~/serverMiddleware/bodyParser&#x27;</span>,\n    <span class=\"hljs-comment\">// ...</span>\n  ],\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">注意点</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li>服务端只渲染需要做SEO的部分来加快访问速度</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">性能优化</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li><p>如果网关已启用gzip则关闭框架自带压缩</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// nuxt.config.js</span>\n<span class=\"hljs-attr\">render</span>: {\n  <span class=\"hljs-attr\">compressor</span>: <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n</li>\n<li><p>缓存页面(<code>lru-cache</code>)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// serverMiddleware/pageCache.js</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">LRU</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;lru-cache&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> cachePage = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">LRU</span>({\n  <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">100</span>,\n  <span class=\"hljs-attr\">maxAge</span>: <span class=\"hljs-number\">1000</span> * <span class=\"hljs-number\">60</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">req, res, next</span>) {\n  <span class=\"hljs-keyword\">const</span> url = req.<span class=\"hljs-property\">_parsedOriginalUrl</span>\n  <span class=\"hljs-keyword\">const</span> pathname = url.<span class=\"hljs-property\">pathname</span>\n  <span class=\"hljs-keyword\">if</span> ([<span class=\"hljs-string\">&#x27;/selectGame/1&#x27;</span>].<span class=\"hljs-title function_\">includes</span>(pathname)) {\n    <span class=\"hljs-keyword\">const</span> existsHtml = cachePage.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;selectGameData&#x27;</span>)\n    <span class=\"hljs-keyword\">if</span> (existsHtml) {\n      <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">end</span>(existsHtml.<span class=\"hljs-property\">html</span>, <span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n      res.<span class=\"hljs-property\">original_end</span> = res.<span class=\"hljs-property\">end</span>\n      res.<span class=\"hljs-property\">end</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) {\n        <span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-property\">statusCode</span> === <span class=\"hljs-number\">200</span>) {\n          cachePage.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;selectGameData&#x27;</span>, { <span class=\"hljs-attr\">html</span>: data })\n        }\n        res.<span class=\"hljs-title function_\">original_end</span>(data, <span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n      }\n    }\n  }\n  <span class=\"hljs-title function_\">next</span>()\n}\n</code></pre>\n</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">坑</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">同一域名如何部署多个Nuxt.js服务</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在<code>https://gmmsj.com/h5ssr</code>下部署Nuxt.js项目步骤：</p>\n<ol>\n<li><p>复制<code>nuxt_dist/serverMiddleware/static/nuxt.config.js/package.json</code>目录/文件至部署机</p>\n</li>\n<li><p>nuxt.config.js添加router配置</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// nuxt.config.js</span>\n{\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">router</span>: {\n    <span class=\"hljs-attr\">base</span>: <span class=\"hljs-string\">&#x27;/h5ssr/&#x27;</span>\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n</li>\n<li><p>Nginx添加配置</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">nginx.conf</span>\nlocation /h5ssr {\n  proxy_pass http://127.0.0.1:8005/h5ssr ;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-For $remote_addr;  \n}\n</code></pre>\n</li>\n</ol>\n"},{"title":"Docker-基于Travis、Github搭建CI&CD自动化部署之自动构建","tags":["Docker实战","自动构建"],"categories":"Docker","description":"> CentOS@7.5\n\n# 流程\n\n1. `git push`到仓库\n2. CI检测到GitHub代码有更新，自动打包出一个docker镜像更新至docker hub\n3. CI编译完成后登录服务器，删掉原有容器，拉取新镜像并创建一个新容器\n\n# 初始化项目\n\n1. 创建仓库\n2. 创建[Travis](https://www.travis-ci.org)账号并关联仓库\n3. 到[dock","createDate":"2020-08-10 22:32:00","updateDate":"2020-10-16 15:07:18","body":"<blockquote>\n<p><a href=\"mailto:&#67;&#101;&#110;&#x74;&#79;&#x53;&#64;&#x37;&#x2e;&#x35;\">&#67;&#101;&#110;&#x74;&#79;&#x53;&#64;&#x37;&#x2e;&#x35;</a></p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">流程</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li><code>git push</code>到仓库</li>\n<li>CI检测到GitHub代码有更新，自动打包出一个docker镜像更新至docker hub</li>\n<li>CI编译完成后登录服务器，删掉原有容器，拉取新镜像并创建一个新容器</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">初始化项目</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li>创建仓库</li>\n<li>创建<a href=\"https://www.travis-ci.org\">Travis</a>账号并关联仓库</li>\n<li>到<a href=\"https://hub.docker.com\">docker hub</a>注册账号并创建镜像仓库</li>\n<li>Travis个人中心添加环境变量<code>DOCKER_USERNAME</code>和<code>DOCKER_PASSWORD</code>方便更新镜像\n<img src=\"https://user-gold-cdn.xitu.io/2019/9/20/16d4c9d76dc4f557?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"添加环境变量\"></li>\n<li>在项目根目录创建<code>.travis.yml</code>\n```yaml\nlanguage: node_js\nnode_js:</li>\n</ol>\n<ul>\n<li>&quot;12&quot;\nservices:</li>\n<li>docker</li>\n</ul>\n<p>before_install:</p>\n<ul>\n<li>npm install</li>\n</ul>\n<p>script:</p>\n<ul>\n<li>npm run build</li>\n<li>echo &quot;$DOCKER_PASSWORD&quot; | docker login -u &quot;$DOCKER_USERNAME&quot; --password-stdin</li>\n<li>docker build -t mrrs878/blog:latest .</li>\n<li>docker push mrrs878/blog:latest\n```</li>\n</ul>\n<ol start=\"6\">\n<li>在项目根目录创建<code>nginx.conf</code>\n```shell script\nserver {\n listen       80;\n server_name  localhost;\n\n location / {\n     try_files $uri $uri/ /index.html;\n     root /usr/share/nginx/html;\n     index  index.html index.htm;\n }</li>\n</ol>\n<p>}</p>\n<pre><code>7. 在项目根目录创建`Dockerfile`\n```shell script\nFROM nginx\n\nCOPY ./build/ /usr/share/nginx/html/\n\nRUN rm /etc/nginx/conf.d/default.conf\n\nADD nginx.conf /etc/nginx/conf.d/\n\nEXPOSE 80\n</code></pre>\n<ol start=\"8\">\n<li>在项目根目录创建<code>.dockerignore</code>加快打包速度\n```shell script\n/.idea\n/node_modules\n/.pnp\n.pnp.js</li>\n</ol>\n<p>/coverage</p>\n<p>.DS_Store\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local</p>\n<p>npm-debug.log*\nyarn-debug.log*\nyarn-error.log*</p>\n<pre><code>\n# 编写代码push到仓库，Travis自动编译，等待编译完成\n\n# 到[docker hub](https://hub.docker.com)查看镜像状态\n\n# 服务器配置\n\n1. `nginx`添加反向代理\n\n```shell script\nserver {\n        listen       80;\n        server_name  blog.p18c.top;\n\n        location / {\n                proxy_pass   http://127.0.0.1:8081;\n        }\n}\n</code></pre>\n<ol start=\"2\">\n<li>更新镜像并创建容器</li>\n</ol>\n<pre><code class=\"hljs language-shell\">docker pull mrrs878/blog:latest\ndocker container stop blog\ndocker container rm blog\ndocker container create --name blog -p 8081:80 mrrs878/blog:latest\ndocker container start blog\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ref</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><a href=\"https://juejin.im/post/6844903946234904583\">写给前端的Docker实战教程</a></p>\n"},{"title":"Docker-基于Travis、Github搭建CI&CD自动化部署之自动部署","tags":["Docker实战","自动部署"],"categories":"Docker","description":"> CentOS@7.5\n\n# 创建travis用户，配置免密登录\n\n```shell script\nuseradd travis\n\npasswd travis\n\nvim /etc/sudoers\n# 找到#Allow root to run any commands anywhere这一段注释，在下面新增一行：\ntravis  ALL=(ALL)   ALL\n\nsu travis\n\ncd ~","createDate":"2020-08-11 10:32:00","updateDate":"2020-10-16 15:07:00","body":"<blockquote>\n<p><a href=\"mailto:&#67;&#x65;&#x6e;&#x74;&#x4f;&#83;&#x40;&#x37;&#46;&#53;\">&#67;&#x65;&#x6e;&#x74;&#x4f;&#83;&#x40;&#x37;&#46;&#53;</a></p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">创建travis用户，配置免密登录</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-shell\">useradd travis\n\npasswd travis\n\nvim /etc/sudoers\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">找到<span class=\"hljs-comment\">#Allow root to run any commands anywhere这一段注释，在下面新增一行：</span></span>\ntravis  ALL=(ALL)   ALL\n\nsu travis\n\ncd ~\n\nssh-keygen -t rsa\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">passphase一定要为空</span>\n\nchmod 700 ~/.ssh/\nchmod 600 ~/.ssh/*\n\ncd .ssh/\ncat id_rsa.pub &gt;&gt; authorized_keys\ncat authorized_keys\n</code></pre>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装Ruby</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-shell\">yum install gcc-c++ patch readline readline-devel zlib zlib-devel \\\n   libyaml-devel libffi-devel openssl-devel make \\\n   bzip2 autoconf automake libtool bison iconv-devel sqlite-devel\n\ncurl -sSL https://rvm.io/mpapis.asc | gpg --import -\ncurl -L get.rvm.io | bash -s stable\n\nsource /etc/profile.d/rvm.sh\nrvm reload\n\nrvm install 2.4.4\n\nrvm use 2.4.2 --default\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装Travis</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-shell\">gem install travis\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">添加加密的私钥至代码仓库</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>切换至travis用户，在~目录下拉取代码</strong></p>\n<pre><code class=\"hljs language-shell\">su travis\n\ntravis login\n\ntravis encrypt-file ~/.ssh/id_rsa --add\n</code></pre>\n<p>此时<code>.travis.yml</code>会添加配置项</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">before_install:</span>\n\n<span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">openssl</span> <span class=\"hljs-string\">aes-256-cbc</span> <span class=\"hljs-string\">-K</span> <span class=\"hljs-string\">$encrypted_f91baf41390f_key</span> <span class=\"hljs-string\">-iv</span> <span class=\"hljs-string\">$encrypted_f91baf41390f_iv</span>\n\n  <span class=\"hljs-string\">-in</span> <span class=\"hljs-string\">id_ras_deploy.enc</span> <span class=\"hljs-string\">-out</span> <span class=\"hljs-string\">~/.ssh/id_ras_deploy</span> <span class=\"hljs-string\">-d</span>\n</code></pre>\n<p>*<em>注意<del>/.ssh有可能为</del>/.ssh需要去掉\\*</em></p>\n<p>解释下解密命令中<code>-in</code>和<code>-out</code>参数:</p>\n<ul>\n<li>in 参数指定待解密的文件，位于仓库的根目录(Travis执行任务时会先把代码拉到Travis自己的服务器上，并进入仓库更目录)</li>\n<li>out 参数指定解密后的密钥存放在<strong>Travis服务器</strong>的~/.ssh/id_rsa</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">配置after_success钩子</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>项目根目录下创建<code>update.sh</code></p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">#</span><span class=\"language-bash\">!/bin/bash</span>\n\necho &quot;pulling image...&quot;\ndocker pull mrrs878/blog:latest\n\necho &quot;stopping old app&quot;\ndocker container stop blog\n\necho &quot;remove old container&quot;\ndocker container rm blog\n\necho &quot;crete new container&quot;\ndocker container create --name blog -p 8081:80 mrrs878/blog:latest\n\necho &quot;starting new app&quot;\ndocker container start blog\n\necho &quot;awesome, you succeeded!&quot;\n</code></pre>\n<p><code>.travis.yml</code>添加<code>after_success</code>配置项</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">after_success:</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">chmod</span> <span class=\"hljs-number\">600</span> <span class=\"hljs-string\">~/.ssh/id_rsa</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">ssh</span> <span class=\"hljs-string\">travis@服务器ip</span> <span class=\"hljs-string\">-o</span> <span class=\"hljs-string\">StrictHostKeyChecking=no</span> <span class=\"hljs-string\">&#x27;cd ~/blog &amp;&amp; sh ./update.sh&#x27;</span>\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">已存项目迁移</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ol>\n<li>docker hub新建仓库</li>\n<li>复制<code>.dockerignore/.travis.yml/Dockerfile/nginx.conf/update.sh</code>到项目根目录</li>\n<li>修改<code>.travis.yml</code>相关配置（项目名称）</li>\n<li>修改<code>update.sh</code>相关配置（项目目录）</li>\n<li>提交代码</li>\n<li>登录服务器，切换至Travis账户</li>\n<li>切换至<code>~</code>目录拉取项目代码</li>\n<li>使用<code>travis encrypt-file ~/.ssh/id_rsa --add</code>生成密钥。*<em>注意<del>/.ssh有可能为</del>/.ssh需要去掉\\*</em></li>\n<li>前往Travis控制台开启监控</li>\n<li>手动触发第一次构建</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ref</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><a href=\"https://blog.csdn.net/zzzcl112/article/details/80531792\">centos7 安装rvm及ruby</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000018687703\">手摸手教你搭建 Travis CI 持续集成和自动化部署</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_34088838/article/details/91367043\">Travis-CI自动化测试并部署至自己的CentOS服务器</a></p>\n"},{"title":"Docker-进阶","tags":["Docker优化"],"categories":"Docker","description":"# 打包优化\n\n- 缓存依赖\n\n  1. 先 `COPY` 该命令的依赖文件，而不是所有文件\n  2. 执行该命令\n\n  如：\n\n  ```shell\n  FROM node\n  \n  RUN rm -rf /app\n  RUN mkdir /app\n  WORKDIR /app\n  \n  # 1. 先 COPY 该命令的依赖文件，而不是所有文件\n  COPY package.json yar","createDate":"2020-08-17 14:16:00","updateDate":"2020-10-16 12:59:40","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">打包优化</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p>缓存依赖</p>\n<ol>\n<li>先 <code>COPY</code> 该命令的依赖文件，而不是所有文件</li>\n<li>执行该命令</li>\n</ol>\n<p>如：</p>\n<pre><code class=\"hljs language-shell\">FROM node\n\nRUN rm -rf /app\nRUN mkdir /app\nWORKDIR /app\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">1. 先 COPY 该命令的依赖文件，而不是所有文件</span>\nCOPY package.json yarn.lock ./\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">2. 执行该命令</span>\nRUN yarn install\n\nCOPY . .\nRUN yarn build\n\nEXPOSE 3000\n\nCMD [ &quot;node&quot;, &quot;dist/main&quot; ]\n</code></pre>\n<p>效果：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/docker_build_0.png\" alt=\"Docker build优化\"></p>\n</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">删除不用的镜像</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>删除悬空的镜像， <code>docker image prune -a -f</code></li>\n<li>删除悬空的容器，<code>docker container prune -f</code></li>\n</ul>\n"},{"title":"React.js学习-Fiber","tags":["React.js学习","Fiber"],"categories":"React.js","description":"# WHAT\n\n- 一种数据结构，它可以用一个纯 JS 对象来表示\n\n```js\nconst fiber = {\n    stateNode,  // 节点实例\n    child,      // 第一个子节点\n    sibling,    // 第一个兄弟节点\n    return,     // 父节点\n}\n```\n\n- 一种基于`requestIdleCallback`的调度算法","createDate":"2020-09-10 9:48:54","updateDate":"2020-09-22 23:15:01","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHAT</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>一种数据结构，它可以用一个纯 JS 对象来表示</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> fiber = {\n    stateNode,  <span class=\"hljs-comment\">// 节点实例</span>\n    child,      <span class=\"hljs-comment\">// 第一个子节点</span>\n    sibling,    <span class=\"hljs-comment\">// 第一个兄弟节点</span>\n    <span class=\"hljs-keyword\">return</span>,     <span class=\"hljs-comment\">// 父节点</span>\n}\n</code></pre>\n<ul>\n<li>一种基于<code>requestIdleCallback</code>的调度算法</li>\n</ul>\n<p>Fiber是一种将recocilation（递归diff）拆分成无数个小任务的算法；它随时能够停止、恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的事件允许计算</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">WHY</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>React15在页面元素很多，且需要频繁刷新的场景下会出现掉帧的现象：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/react15.gif\" alt=\"React15渲染很多组件会出现掉帧\"></p>\n<p>其根本原因就是大量的同步计算阻塞了浏览器的UI渲染。当我们调用<code>setState</code>更新页面的时候，React会遍历应用的所有节点计算出差异然后更新UI。整个过程是<strong>一气呵成，不能被打断</strong>。如果页面元素很多，整个过程占用的时间就可能超过16ms，就容易出现掉帧的现象</p>\n<p>针对这一问题，React团队从框架层面对web页面的渲染机制做了优化：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/react16.gif\" alt=\"React16优化后的效果\"></p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HOW</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><strong>递归改循环</strong></p>\n<p>旧版React通过递归的方式进行渲染，使用的是JS引擎自身的函数调用栈，它会一直执行到栈空为止。而Fiber实现了自己组件调用栈，它以<strong>链表</strong>的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现的方式是使用了浏览器的<code>requestIdleCallback</code></p>\n<blockquote>\n<p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间</p>\n</blockquote>\n<p>React内部运作可分为3层：</p>\n<ul>\n<li>virtual DOM，描述页面长什么样</li>\n<li>reconciler，负责调用组件生命周期方法，进行Diff运算</li>\n<li>render，根据不同的平台，渲染出相应的界面</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">reconciler</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>之前的<code>reconciler</code>被命名为<code>stack reconciler</code>，运行过程不能被打断：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/stackReconciler.png\" alt=\"stackReconciler\"></p>\n<p>而<code>fiber reconciler</code>每执行一段时间都会将执行权交回浏览器，可以分段执行：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberReconciler.png\" alt=\"fiberReconclier\"></p>\n<p><code>fiber reconciler</code>在执行过程中会分为两个阶段：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberReconcilerPhase.png\" alt=\"fiberReconcilerPhase\"></p>\n<ul>\n<li>阶段一，生成<code>fiber</code>树，得出需要更新的节点信息。<strong>可以被打断</strong></li>\n<li>阶段二，将需要更新的节点依次批量更新，<strong>这个过程不能被打断</strong></li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">fiber树</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>fiber reconciler</code>在阶段一进行<code>diff</code>计算的时候会生成一颗<code>fiber</code>树。这棵树是在<code>virtual DOM</code>树的基础上增加额外的信息来生成的，本质来说是一个链表</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberTree.png\" alt=\"fiberTree\"></p>\n<p><code>Fiber</code>树在首次渲染的时候会一次性生成。在后续需要<code>diff</code>的时候会根据已有树和最新<code>virtual DOM</code>的信息生成一颗新的树。这棵树每生成一个新的节点都会将控制权交回主线程，去检查有没有优先级更高的任务需要执行，如果没有则继续构建树的过程：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberBuild.png\" alt=\"fiberTreeBuild\"></p>\n<p>在构建过程中如果有优先级更高的任务需要执行，则<code>fiber reconciler</code>会将需要更新的节点信息保存在<code>effect list中</code>，在阶段二执行的时候会批量更新相应的节点</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ref</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000018250127\">React Fiber 原理介绍</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000015057505\">React 重温之 React Fiber</a></p>\n</li>\n</ul>\n"}]},"__N_SSG":true}