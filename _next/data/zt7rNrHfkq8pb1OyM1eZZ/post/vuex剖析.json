{"pageProps":{"post":{"title":"vuex剖析","tags":["Vue.js","vuex"],"categories":"Vue.js","description":"vuex是专门为Vue.js设计的**状态管理工具**，它采用**集中式存储**管理应用的所有状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n## vuex的构成\n\n- 引入`State`、`Getter`对状态进行定义\n\n- 使用`Mutation`、`Action`对状态进行修改\n\n- 使用`Module`对状态进行模块化分割\n\n- 引入插件对状态进行快照、记录、跟踪等\n\n-","createDate":"2020-03-10 20:50:56","updateDate":"10/1/2021, 3:34:43 AM","body":"<p>vuex是专门为Vue.js设计的<strong>状态管理工具</strong>，它采用<strong>集中式存储</strong>管理应用的所有状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex的构成</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>引入<code>State</code>、<code>Getter</code>对状态进行定义</p>\n</li>\n<li><p>使用<code>Mutation</code>、<code>Action</code>对状态进行修改</p>\n</li>\n<li><p>使用<code>Module</code>对状态进行模块化分割</p>\n</li>\n<li><p>引入插件对状态进行快照、记录、跟踪等</p>\n</li>\n<li><p>提供<code>mapState</code>、<code>mapGetters</code>、<code>mapActions</code>、<code>mapMutations</code>辅助函数方便开发者处理store</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-0.png\" alt=\"vuex组成\"></p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex原理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex的store是如何注入到组件中的</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <ul>\n<li><p>通过vue的<a href=\"https://cn.vuejs.org/v2/guide/mixins.html\">mixin</a>机制，在<code>install</code>函数中借助于vue的<code>beforeCreate</code>生命周期函数</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Vue</span>.<span class=\"hljs-title function_\">mixin</span>({ <span class=\"hljs-attr\">beforeCreate</span>: vuexInit })\n</code></pre>\n</li>\n<li><p>在<code>beforeCreate</code>中调用vuexInit将store挂载到当前实例上</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">vuexInit</span> () {\n    <span class=\"hljs-keyword\">const</span> options = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$options</span>\n    <span class=\"hljs-comment\">// store injection</span>\n    <span class=\"hljs-keyword\">if</span> (options.<span class=\"hljs-property\">store</span>) {\n        <span class=\"hljs-comment\">// 根组件通过options.store挂载</span>\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$store</span> = <span class=\"hljs-keyword\">typeof</span> options.<span class=\"hljs-property\">store</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n            ? options.<span class=\"hljs-title function_\">store</span>()\n            : options.<span class=\"hljs-property\">store</span>\n        <span class=\"hljs-comment\">// 其余组件通过父组件上的store挂载</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (options.<span class=\"hljs-property\">parent</span> &amp;&amp; options.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">$store</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$store</span> = options.<span class=\"hljs-property\">parent</span>.<span class=\"hljs-property\">$store</span>\n    }\n}\n</code></pre>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-1.jpg\" alt=\"store注入\"></p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">vuex的state和getter是如何映射到各个组件实例中自动更新的</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    \n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">state</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Store</span> {\n    construcor () {\n        <span class=\"hljs-title function_\">resetStoreVM</span>()\n    }\n    get state () {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_vm</span>.<span class=\"hljs-property\">_data</span>.<span class=\"hljs-property\">$$state</span>\n    }\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">resetStoreVM</span>(<span class=\"hljs-params\"></span>) {\n       store.<span class=\"hljs-property\">_vm</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>({\n           <span class=\"hljs-attr\">data</span>: {\n               <span class=\"hljs-attr\">$$state</span>: state\n           },\n          computed\n    })\n}\n</code></pre>\n<p>从源码得知，当使用<code>this.$store.state.xxx</code>时会被代理到<code>store._vm._data.$$state</code>上，而<code>store._vm</code>是一个Vue实例，由于示例中的data是响应式的，所以$$state也是响应式的，那么当更新state时，所有相关组件中的state也会自动更新</p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">getter</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">resetStoreVM</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">forEachValue</span>(wrappedGetters, <span class=\"hljs-function\">(<span class=\"hljs-params\">fn, key</span>) =&gt;</span> {\n        <span class=\"hljs-comment\">// use computed to leverage its lazy-caching mechanism</span>\n        <span class=\"hljs-comment\">// direct inline function use will lead to closure preserving oldVm.</span>\n        <span class=\"hljs-comment\">// using partial to return function with only arguments preserved in closure environment.</span>\n        computed[key] = <span class=\"hljs-title function_\">partial</span>(fn, store)\n        <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(store.<span class=\"hljs-property\">getters</span>, key, {\n            <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">() =&gt;</span> store.<span class=\"hljs-property\">_vm</span>[key],\n            <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// for local getters</span>\n        })\n    })\n}\n</code></pre>\n<p>从源码得知，当使用<code>this.$store.getter.xxx</code>时会被代理到<code>store._vm.xxx</code>，其中添加<code>computed</code>属性</p>\n<p>从上面可以看出，vuex中的<code>state</code>是借助于一个Vue.js实例，将<code>state</code>存入实例的<code>data</code>中；Vuex中的<code>getter</code>则是借助于实例的计算属性<code>computed</code>实现数据监听</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vuex-3.png\" alt=\"state、getter响应式\"></p>\n"}},"__N_SSG":true}