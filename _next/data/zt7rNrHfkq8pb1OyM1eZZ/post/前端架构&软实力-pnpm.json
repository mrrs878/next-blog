{"pageProps":{"post":{"title":"前端架构&软实力-pnpm","tags":["pnpm","npm"],"categories":"前端架构&软实力","description":"[pnpm](https://pnpm.io) 全称是 “Performant NPM”，即高性能的 npm。它结合软硬链接与新的依赖组织方式，大大提升了包管理的效率，也同时解决了 “幽灵依赖” 的问题，让包管理更加规范，降低潜在风险发生的可能性\n\n## 安装&使用\n\n```bash\nnpm i pnpm -g\n```\n\n## pnpm 在管理 package 时的区别\n\nnpm2(Node.j","createDate":"2022-08-15 19:11:45","updateDate":"2022-08-16 22:11:45","body":"<p><a href=\"https://pnpm.io\">pnpm</a> 全称是 “Performant NPM”，即高性能的 npm。它结合软硬链接与新的依赖组织方式，大大提升了包管理的效率，也同时解决了 “幽灵依赖” 的问题，让包管理更加规范，降低潜在风险发生的可能性</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装&amp;使用</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-bash\">npm i pnpm -g\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm 在管理 package 时的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>npm2(Node.js 0.11.14~4.9.1) 是通过<strong>嵌套</strong>的方式管理 <code>node_modules</code> 的</p>\n<p><img src=\"/img/npm2-node-modules-structure.png\" alt=\"npm2-node-modules-structure\"></p>\n<p>这样的处理方式层级结构非常明显，可以清楚的知道当前安装的包，但是这样也存在不小的问题：</p>\n<ol>\n<li><p>会有依赖下载多次的问题，无法复用</p>\n</li>\n<li><p>目录层级太深，路径过长，有些操作系统会报错（在 windows 系统中文件路径不能超过 280 个字符）</p>\n</li>\n</ol>\n<p><img src=\"/img/heaviest-objects-in-the-universe.png\" alt=\"heaviest-objects-in-the-universe\"></p>\n<p>npm3+(Node.js 5.0.0+) 是通过<strong>铺平的扁平化</strong>的方式来管理 <code>node_modules</code></p>\n<p><img src=\"/img/npm3-node-modules-structure.png\" alt=\"npm3-node-modules-structure\"></p>\n<p>安装时会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。该方式解决了 npm2 的部分问题，但也引入了其他的问题</p>\n<ol>\n<li><p><strong>幽灵依赖</strong></p>\n</li>\n<li><p>同名的包只会提升一个版本的，其余的版本依然会复制多次，而且该特性严重依赖包的<strong>安装顺序</strong></p>\n</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm 的优势</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单描述一下 pnpm 的优势：</p>\n<ul>\n<li><p>快。安装速度快。安装过的依赖会被精准缓存并拿来复用，基于内容寻址存储（CAS），包版本升级带来的变化都只 diff，绝不浪费一点空间</p>\n</li>\n<li><p>狠。废除幽灵依赖</p>\n</li>\n</ul>\n<p>pnpm 的 <code>node_modules</code> 结构</p>\n<p><img src=\"/img/pnpm-node-modules-structure.jpeg\" alt=\"pnpm-node-modules-structure\"></p>\n<ul>\n<li><p>所有的 package 都安装在全局目录 <code>~/.pnpm/v3/files</code> 下，同一版本的包只存储一份内容，甚至不同版本的包也仅存储 diff 内容</p>\n</li>\n<li><p>每个项目的 <code>node_modules</code> 下有 <code>.pnpm</code> 目录以平级结构管理每个版本的包的源码内容，以<strong>硬连接</strong>方式指向 pnpm-store 中的文件地址</p>\n</li>\n<li><p>每个项目的 <code>node_modules</code> 下安装的包结构为树状，以<strong>软链接</strong>的方式将内容指向 <code>node_modules/.pnpm</code> 中的包（类似于 npm2）</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">寻址方式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>针对于使用 <code>pnpm</code> 管理的包，寻址一般会经历以下步骤：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// index.js</span>\n<span class=\"hljs-keyword\">import</span> { something } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;bar&quot;</span>;\n</code></pre>\n<p>以 <code>bar</code> 这个包为例，寻址时的路径大概是这样的：</p>\n<p><code>node_modules/bar</code> -&gt;(软链) <code>node_modules/.pnpm/bar@1.0.0/node_modules/bar</code> -&gt;(硬链) <code>~/.pnpm-store/v3/files/00/xxx</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">幽灵依赖</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>有些项目中未安装的包（未在 <code>package.json</code> 中声明），但仍然可以在项目里使用</p>\n<p>产生的原因：在安装的时候， npm/yarn 会通过铺平的扁平化的方式来管理 <code>node_modules</code> ，因此项目文件中是可以寻址到这个包的</p>\n<p>因为 pnpm 特殊的寻址设计，使得第一层可以仅包含 <code>package.json</code> 定义的包，使 <code>node_modules</code> 不可能寻址到未定义在 <code>package.json</code> 中的包，自然就解决了幽灵依赖的问题</p>\n<p><img src=\"/img/eslint-no-extraneous-dependencies.png\" alt=\"eslint-no-extraneous-dependencies\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">硬链接/软链接</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>硬链接通过 <code>ls originFilePath sourceFilePath</code> 创建，这样创建出来的两个文件都指向同一个文件存储地址，因此无论修改哪个文件，都相当于直接修改了原始地址的内容，导致两个文件内容同时变化。进一步说，通过硬链接创建的文件都是等效的，通过 <code>ls li ./</code> 查看文件属性时，可看到该文件有几个硬链接引用</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 创建源文件</span>\n<span class=\"hljs-built_in\">touch</span> t.txt\n\n<span class=\"hljs-comment\"># 编辑源文件（输入rererererere）</span>\nvim t.txt\n\n<span class=\"hljs-comment\"># 创建硬链接</span>\n<span class=\"hljs-built_in\">ln</span> t.txt t_h.txt\n\n<span class=\"hljs-comment\"># 查看源/目文件内容</span>\n<span class=\"hljs-built_in\">cat</span> t.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-built_in\">cat</span> <span class=\"hljs-built_in\">cat</span> t_h.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-comment\"># 查看源/目文件信息</span>\n<span class=\"hljs-built_in\">ls</span> -li ./t_h.txt ./t.txt\n\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t.txt</span>\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t_h.txt</span>\n\n<span class=\"hljs-comment\"># 2 则表示该文件有几个硬链接引用</span>\n</code></pre>\n<p>软链接通过 <code>ls -s originFilePath sourceFilePath</code> 创建，可以认为是指向文件地址指针的指针，相当于常见的<em>快捷方式</em></p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 创建软链接</span>\n<span class=\"hljs-built_in\">ln</span> -s t.txt t_s.txt\n\n<span class=\"hljs-comment\"># 查看文件内容</span>\n<span class=\"hljs-built_in\">cat</span> t_s.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-comment\"># 查看文件信息</span>\n<span class=\"hljs-built_in\">ls</span> -li ./t_s.txt ./t.txt\n\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t.txt</span>\n<span class=\"hljs-comment\"># 25881568 lrwxr-xr-x  1 echo  staff   5  8 15 19:46 ./t_s.txt -&gt; t.txt</span>\n</code></pre>\n<p>源文件被删除后，软链接会失效，但硬链接不会，软链接可以对文件夹生效。软链接本身只占很小的存储空间，硬链接 0 占用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm-store</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>该目录可通过 <code>pnpm store path</code> 查看</p>\n<p>TODO</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">总结</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>不同于npm/yarn，pnpm 采用了一种全新的包管理方式，不再是复制了，而是都从全局 store <strong>硬连接</strong>到 <code>node_modules/.pnpm</code> ，然后之间通过<strong>软链接</strong>来组织依赖关系。这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/253.%E7%B2%BE%E8%AF%BB%E3%80%8Apnpm%E3%80%8B.md\">253.精读《pnpm》.md</a></p>\n<p><a href=\"https://rushjs.io/pages/advanced/phantom_deps/\">Phantom dependencies</a></p>\n<p><a href=\"https://nodejs.org/zh-cn/download/releases/\">Node.js version</a></p>\n<p><a href=\"https://www.infoq.cn/article/qj3z2ygrzdgicqauaffn\">npm 依赖管理中被忽略的那些细节</a></p>\n<p><a href=\"https://blog.pusher.com/what-you-need-know-npm-5/#:~:text=%24%20npm%20install%20npm%20added%20125%2C%20removed%2032%2C,network%20if%20something%20is%20missing%20from%20the%20cache.\">Here’s what you need to know about npm 5</a></p>\n"}},"__N_SSG":true}