{"pageProps":{"post":{"title":"Node.js-基础","tags":["Node.js"],"categories":"Node.js","description":"# [Buffer](http://nodejs.cn/api/buffer.html)\nJS自身只能只有字符串数据类型，没有二进制数据类型，因此nodejs提供了一个与string对等的全局构造函数Buffer来提供对二进制数据的操作\n- `Buffer.form` 创建一个buffer\n    ``` javascript\n    Buffer.form([ 0x68, 0x65, 0x6","createDate":"2020-01-14 14:11:45","updateDate":"10/1/2021, 3:34:43 AM","body":"<h1 id=\"buffer\"><a href=\"http://nodejs.cn/api/buffer.html\">Buffer</a></h1>\n<p>JS自身只能只有字符串数据类型，没有二进制数据类型，因此nodejs提供了一个与string对等的全局构造函数Buffer来提供对二进制数据的操作</p>\n<ul>\n<li><code>Buffer.form</code> 创建一个buffer<pre><code class=\"hljs language-javascript\"><span class=\"hljs-title class_\">Buffer</span>.<span class=\"hljs-title function_\">form</span>([ <span class=\"hljs-number\">0x68</span>, <span class=\"hljs-number\">0x65</span>, <span class=\"hljs-number\">0x6c</span>, <span class=\"hljs-number\">0x6c</span>, <span class=\"hljs-number\">0x6f</span> ]).<span class=\"hljs-title function_\">toString</span>()\n<span class=\"hljs-comment\">// hello</span>\n</code></pre>\n</li>\n<li><code>Burrer</code>与<code>String</code>的一个重要区别就是字符串时只读的，并且对于字符串的任何修改得到的都是一个新的字符串，源字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组，例如，可以使用<code>[index]</code>方式直接修改某个位置的字节</li>\n</ul>\n<h1 id=\"stream\"><a href=\"http://nodejs.cn/api/stream.html\">Stream</a></h1>\n<ul>\n<li>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> rs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">copy</span> (src, dst) {\n    fs.<span class=\"hljs-title function_\">createReadStream</span>(src).<span class=\"hljs-title function_\">pipe</span>(fs.<span class=\"hljs-title function_\">createWriteSreeam</span>(dst));\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">main</span> (argv) {\n    <span class=\"hljs-title function_\">copy</span>(argv[<span class=\"hljs-number\">0</span>], argv[<span class=\"hljs-number\">1</span>])\n}\n\n<span class=\"hljs-title function_\">main</span>(process.<span class=\"hljs-property\">argv</span>.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">2</span>));\n</code></pre>\n</li>\n<li><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<a href=\"http://nodejs.cn/api/events.html#events_class_eventemitter\"><code>EventEmitter</code></a></li>\n</ul>\n<h1 id=\"file-system\"><a href=\"http://nodejs.cn/api/fs.html\">File System</a></h1>\n<p>NodeJS通过<code>fs</code>内置模块提供对文件的操作，<code>fs</code>模块提供的API基本上可以分为以下三类：</p>\n<ul>\n<li>文件属性读\n其中常见的有<code>fs.state</code> <code>fs.chmod</code> <code>fs.chown</code></li>\n<li>文件属性写\n其中常见的有<code>fs.readFile</code> <code>fs.readdir</code> <code>fs.writeFile</code> <code>fs.mkdir</code></li>\n<li>底层文件操作\n其中常见的操作有<code>fs.open</code> <code>fs.read</code> <code>fs.write</code> <code>fs.close</code>\n所有的<code>fs</code>模块API的回调参数都有两个，第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果<pre><code class=\"hljs language-javascript\">fs.<span class=\"hljs-title function_\">readFile</span>(pathname, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) {\n    <span class=\"hljs-keyword\">if</span> (err) {}\n    <span class=\"hljs-keyword\">else</span> {}\n})\n</code></pre>\n</li>\n</ul>\n<h2 id=\"path\"><a href=\"http://nodejs.cn/api/path.html\">Path</a></h2>\n<p>操作文件时难免不与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。</p>\n<ul>\n<li><code>path.normalize</code>\n  将传入的参数转为标准路径，具体讲的话，除了解析路径中的<code>.</code>与<code>..</code>外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> cache = {}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">store</span> () {\n    cache[path.<span class=\"hljs-title function_\">normalize</span>(key)] = value\n}\n\n<span class=\"hljs-title function_\">store</span>(<span class=\"hljs-string\">&#x27;foo/bar&#x27;</span>, <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-title function_\">store</span>(<span class=\"hljs-string\">&#x27;foo//baz//../bar&#x27;</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(cache);  <span class=\"hljs-comment\">// =&gt; { &quot;foo/bar&quot;: 2 }</span>\n</code></pre>\n  标准化之后的路径里的斜杠在Windows系统下是\\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用<code>.replace(/\\\\/g, &#39;/&#39;)</code>再替换一下标准路径。</li>\n<li><code>path.join</code>\n  将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。<pre><code class=\"hljs language-javascript\">path.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;foo/&#x27;</span>, <span class=\"hljs-string\">&#x27;baz/&#x27;</span>, <span class=\"hljs-string\">&#x27;../bar&#x27;</span>); <span class=\"hljs-comment\">// =&gt; &quot;foo/bar&quot;</span>\n</code></pre>\n</li>\n<li><code>path.extname</code>\n  当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。<pre><code class=\"hljs language-javascript\">path.<span class=\"hljs-title function_\">extname</span>(<span class=\"hljs-string\">&#x27;foo/bar.js&#x27;</span>); <span class=\"hljs-comment\">// =&gt; &quot;.js&quot;</span>\n</code></pre>\n<h2 id=\"遍历目录\">遍历目录</h2>\n``` javascript\nconst fs = require(&#39;fs&#39;);\nconst path = require(&#39;path&#39;);</li>\n</ul>\n<p>function travel (dir, callback) {\n    fs.readdirSync(dir).forEach(file =&gt; {\n        let pathname = path.join(dir, file)\n        if (fs.statSync(pathname).isDirectory())\n            travel(pathname, callback)\n        else callback(pathname)\n    })\n}</p>\n<p>travel(__dirname, file =&gt; {\n    console.log(file)\n})</p>\n<p>// c:\\Users\\mrrs8\\Desktop\\desktop.ini\n// c:\\Users\\mrrs8\\Desktop\\Postman.lnk\n// c:\\Users\\mrrs8\\Desktop\\test.js\n// c:\\Users\\mrrs8\\Desktop\\微信开发者工具.lnk</p>\n<pre><code># 文本编码\n使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有`UTF8`和`GBK`两种，并且`UTF8`文件还可能带有`BOM`。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的`UTF8`编码字符串后才能正常处理。\n## BOM的移除\nBOM用于标记一个文本文件使用`Unicode`编码，其本身是一个`Unicode`字符`（&quot;\\uFEFF&quot;）`，位于文本文件头部。在不同的`Unicode`编码下，`BOM`字符对应的二进制字节如下：\n``` javascript\n    Bytes      Encoding\n</code></pre>\n"}},"__N_SSG":true}