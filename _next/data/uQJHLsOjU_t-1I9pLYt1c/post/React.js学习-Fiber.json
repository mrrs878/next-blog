{"pageProps":{"post":{"title":"React.js学习-Fiber","tags":["React.js学习","Fiber"],"categories":"React.js","description":"# WHAT\n\n- 一种数据结构，它可以用一个纯 JS 对象来表示\n\n```js\nconst fiber = {\n    stateNode,  // 节点实例\n    child,      // 第一个子节点\n    sibling,    // 第一个兄弟节点\n    return,     // 父节点\n}\n```\n\n- 一种基于`requestIdleCallback`的调度算法","createDate":"2020-09-10 9:48:54","updateDate":"2020-09-22 23:15:01","body":"<h1 id=\"what\">WHAT</h1>\n<ul>\n<li>一种数据结构，它可以用一个纯 JS 对象来表示</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> fiber = {\n    stateNode,  <span class=\"hljs-comment\">// 节点实例</span>\n    child,      <span class=\"hljs-comment\">// 第一个子节点</span>\n    sibling,    <span class=\"hljs-comment\">// 第一个兄弟节点</span>\n    <span class=\"hljs-keyword\">return</span>,     <span class=\"hljs-comment\">// 父节点</span>\n}\n</code></pre>\n<ul>\n<li>一种基于<code>requestIdleCallback</code>的调度算法</li>\n</ul>\n<p>Fiber是一种将recocilation（递归diff）拆分成无数个小任务的算法；它随时能够停止、恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的事件允许计算</p>\n<h1 id=\"why\">WHY</h1>\n<p>React15在页面元素很多，且需要频繁刷新的场景下会出现掉帧的现象：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/react15.gif\" alt=\"React15渲染很多组件会出现掉帧\"></p>\n<p>其根本原因就是大量的同步计算阻塞了浏览器的UI渲染。当我们调用<code>setState</code>更新页面的时候，React会遍历应用的所有节点计算出差异然后更新UI。整个过程是<strong>一气呵成，不能被打断</strong>。如果页面元素很多，整个过程占用的时间就可能超过16ms，就容易出现掉帧的现象</p>\n<p>针对这一问题，React团队从框架层面对web页面的渲染机制做了优化：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/react16.gif\" alt=\"React16优化后的效果\"></p>\n<h1 id=\"how\">HOW</h1>\n<p><strong>递归改循环</strong></p>\n<p>旧版React通过递归的方式进行渲染，使用的是JS引擎自身的函数调用栈，它会一直执行到栈空为止。而Fiber实现了自己组件调用栈，它以<strong>链表</strong>的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。实现的方式是使用了浏览器的<code>requestIdleCallback</code></p>\n<blockquote>\n<p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这些延迟触发但关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间</p>\n</blockquote>\n<p>React内部运作可分为3层：</p>\n<ul>\n<li>virtual DOM，描述页面长什么样</li>\n<li>reconciler，负责调用组件生命周期方法，进行Diff运算</li>\n<li>render，根据不同的平台，渲染出相应的界面</li>\n</ul>\n<h2 id=\"reconciler\">reconciler</h2>\n<p>之前的<code>reconciler</code>被命名为<code>stack reconciler</code>，运行过程不能被打断：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/stackReconciler.png\" alt=\"stackReconciler\"></p>\n<p>而<code>fiber reconciler</code>每执行一段时间都会将执行权交回浏览器，可以分段执行：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberReconciler.png\" alt=\"fiberReconclier\"></p>\n<p><code>fiber reconciler</code>在执行过程中会分为两个阶段：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberReconcilerPhase.png\" alt=\"fiberReconcilerPhase\"></p>\n<ul>\n<li>阶段一，生成<code>fiber</code>树，得出需要更新的节点信息。<strong>可以被打断</strong></li>\n<li>阶段二，将需要更新的节点依次批量更新，<strong>这个过程不能被打断</strong></li>\n</ul>\n<h2 id=\"fiber树\">fiber树</h2>\n<p><code>fiber reconciler</code>在阶段一进行<code>diff</code>计算的时候会生成一颗<code>fiber</code>树。这棵树是在<code>virtual DOM</code>树的基础上增加额外的信息来生成的，本质来说是一个链表</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberTree.png\" alt=\"fiberTree\"></p>\n<p><code>Fiber</code>树在首次渲染的时候会一次性生成。在后续需要<code>diff</code>的时候会根据已有树和最新<code>virtual DOM</code>的信息生成一颗新的树。这棵树每生成一个新的节点都会将控制权交回主线程，去检查有没有优先级更高的任务需要执行，如果没有则继续构建树的过程：</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/fiberBuild.png\" alt=\"fiberTreeBuild\"></p>\n<p>在构建过程中如果有优先级更高的任务需要执行，则<code>fiber reconciler</code>会将需要更新的节点信息保存在<code>effect list中</code>，在阶段二执行的时候会批量更新相应的节点</p>\n<h1 id=\"ref\">Ref</h1>\n<ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000018250127\">React Fiber 原理介绍</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000015057505\">React 重温之 React Fiber</a></p>\n</li>\n</ul>\n"}},"__N_SSG":true}