{"pageProps":{"post":{"title":"vue-router剖析","tags":["Vue.js","vue-router"],"categories":"Vue.js","description":"# 路由\r\n\r\n路由最早由后端提出，用于根据不同的请求返回不同的页面。大致流程如下：\r\n\r\n1. 浏览器发出请求\r\n2. 服务器监听到端口有请求过来\r\n3. 根据服务器的路由配置，返回相应信息（可以是html、json、图片等）\r\n4. 浏览器根据数据包的`Context-Type`来决定如何解析\r\n\r\n# 前端路由\r\n\r\n随着`ajax`的流行，异步数据请求交互在不刷新浏览器的情况下运行","createDate":"2020-03-09 22:05:40","updateDate":"10/1/2021, 3:34:43 AM","body":"<h1 id=\"路由\">路由</h1>\n<p>路由最早由后端提出，用于根据不同的请求返回不同的页面。大致流程如下：</p>\n<ol>\n<li>浏览器发出请求</li>\n<li>服务器监听到端口有请求过来</li>\n<li>根据服务器的路由配置，返回相应信息（可以是html、json、图片等）</li>\n<li>浏览器根据数据包的<code>Context-Type</code>来决定如何解析</li>\n</ol>\n<h1 id=\"前端路由\">前端路由</h1>\n<p>随着<code>ajax</code>的流行，异步数据请求交互在不刷新浏览器的情况下运行。而异步交互体验的高级版本就是SPA-单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。类似于后端路由，前端路由就是匹配不同的url路径进行解析，然后动态渲染html内容。</p>\n<h2 id=\"hash模式\">hash模式</h2>\n<p><code>https://www.xxx.com/#/hash</code></p>\n<p>这种<code>#</code>后面<code>hash</code>值得变化，并不会触发新的请求，因此也不会刷新页面。每次<code>hash</code>值的变化都会触发<code>hashchange</code>事件，通过这个事件就可以知道更新哪些页面内容</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onhashchange</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e.<span class=\"hljs-property\">oldURL</span>, e.<span class=\"hljs-property\">newURL</span>)\n    <span class=\"hljs-keyword\">const</span> hash = location.<span class=\"hljs-property\">hash</span>.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)\n    app.<span class=\"hljs-property\">innerHTML</span> = hash\n}\n</code></pre>\n<h2 id=\"history模式\">history模式</h2>\n<p><code>https://www.xxx.com/login</code></p>\n<p>随着HTML5的发布，带来了两个新的API：<code>pushState</code>和<code>replaceState</code>，通过这两个API可以改变url地址且不会发送请求。同时还有<code>popstate</code>事件用来监听url的改变。使用history模式，url就不会出现丑陋的<code>#</code>，url也变得比较美观。</p>\n<p>通过history api去掉了丑陋的<code>#</code>，但也存在问题：不怕前进/后退，就怕<strong>刷新</strong>。因为刷新是去请求服务器的，在<code>hash</code>下，前端路由修改的是#之后的内容，在发送请求时是不会带上的，但在history下可以自由地修改路径、参数，当刷新时，如果服务器中没有相应的响应或资源，容易爆<code>404</code></p>\n<h1 id=\"vue-router核心原理\">vue-router核心原理</h1>\n<ol>\n<li><p>通过<code>new VueRouter</code>中的<code>mode</code>参数来选择使用那种路由模式</p>\n</li>\n<li><p>在<code>router</code>中使用<code>current</code>保存当前url</p>\n</li>\n<li><p>作为一个插件，大部分功能都在<code>install</code>函数中完成</p>\n</li>\n<li><p>在<code>install</code>中使用<code>Vue.mixin</code>注入的<code>beforeCreate</code>来给组件添加全局唯一的<code>router</code>实例（挂载在根组件上，其余组件通过<code>$parent._routerRoot._router</code>挂载）</p>\n</li>\n<li><p>使用<code>popstate</code>或<code>hashchange</code>两个事件来监听url变化（针对于手动输入url）并设置<code>current</code></p>\n</li>\n<li><p>使用<code>Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)</code>来使<code>router</code>变为响应式</p>\n<p>current变化    👉    重新渲染<code>router-view</code>中的组件 </p>\n</li>\n<li><p>解析路由配置从而可以更加便利地找到url所对应的页面</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Array</span>&lt;{ <span class=\"hljs-attr\">name</span>: component }&gt;\n</code></pre>\n<p>👇</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Map</span>&lt;{ <span class=\"hljs-attr\">name</span>: component }&gt;\n</code></pre>\n</li>\n<li><p>实现<code>&lt;router-link&gt;&lt;/router-link&gt;</code>和<code>&lt;router-view / &gt;</code>两个组件</p>\n</li>\n</ol>\n<h1 id=\"总结\">总结</h1>\n<p><code>vue-router</code>以插件方式侵入<code>Vue</code>，从而支持一个额外的<code>router</code>属性，以提供监听并改变组件路由数据的能力，这样每次路由发生变化后，可以同步到数据，从而响应式地触发组件的更新</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/vue-router.png\" alt=\"vue-router\"></p>\n"}},"__N_SSG":true}