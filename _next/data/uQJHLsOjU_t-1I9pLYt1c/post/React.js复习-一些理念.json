{"pageProps":{"post":{"title":"React.js复习-一些理念","tags":["React.js"],"categories":"2021复习","description":"## 整体架构\n\n- scheduler（调度器）\n    调度任务的优先级，高优任务优先进入reconciler\n- reconciler（协调器）\n    负责找出发生变化的组件\n- renderer（渲染器）\n    负责将变化的组件渲染到页面上\n    \n## Fiber\n\n具有三种不同的含义\n\n1. 一种架构\n    之前React15的reconciler采用递归的方式执行更新DO","createDate":"2021-05-30 14:41:42","updateDate":"2021-06-01 18:00:03","body":"<h2 id=\"整体架构\">整体架构</h2>\n<ul>\n<li>scheduler（调度器）\n  调度任务的优先级，高优任务优先进入reconciler</li>\n<li>reconciler（协调器）\n  负责找出发生变化的组件</li>\n<li>renderer（渲染器）\n  负责将变化的组件渲染到页面上</li>\n</ul>\n<h2 id=\"fiber\">Fiber</h2>\n<p>具有三种不同的含义</p>\n<ol>\n<li>一种架构\n 之前React15的reconciler采用递归的方式执行更新DOM的操作，数据保存在递归调用栈中，所以被称为<strong>stack Reconciler</strong>。React16的reconciler基于Fiber节点实现，被称为<strong>Fiber Reconciler</strong></li>\n<li>一种数据结构\n 每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息</li>\n<li>一个执行任务（工作单元）\n 每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">FiberNode</span>(<span class=\"hljs-params\">\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: <span class=\"hljs-literal\">null</span> | string,\n  mode: TypeOfMode,\n</span>) {\n  <span class=\"hljs-comment\">// 作为静态数据结构的属性</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">tag</span> = tag;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span> = key;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">elementType</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">type</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stateNode</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-comment\">// 用于连接其他Fiber节点形成Fiber树</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">return</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">child</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sibling</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">index</span> = <span class=\"hljs-number\">0</span>;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-comment\">// 作为动态的工作单元的属性</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">pendingProps</span> = pendingProps;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">memoizedProps</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">updateQueue</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">memoizedState</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">dependencies</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mode</span> = mode;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">effectTag</span> = <span class=\"hljs-title class_\">NoEffect</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">nextEffect</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstEffect</span> = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastEffect</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-comment\">// 调度优先级相关</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lanes</span> = <span class=\"hljs-title class_\">NoLanes</span>;\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">childLanes</span> = <span class=\"hljs-title class_\">NoLanes</span>;\n\n  <span class=\"hljs-comment\">// 指向该fiber在另一次更新时对应的fiber</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">alternate</span> = <span class=\"hljs-literal\">null</span>;\n}\n</code></pre>\n<h2 id=\"fiber-reconciler\">Fiber Reconciler</h2>\n<p>分为两个阶段，<code>commit</code>和<code>render</code></p>\n<ul>\n<li><code>commit</code>\n  可中断，生成fiber树，收集effect</li>\n<li><code>render</code>\n  不可中断，根据收集到的effect更新DOM，执行一些生命周期函数和hooks（<code>useEffect</code>在渲染中之后执行）</li>\n</ul>\n<h2 id=\"jsx-vs-fiber\">jsx vs fiber</h2>\n<p>JSX是一种描述当前组件内容的数据结构，它不包含组件<code>schedule</code>、<code>reconcile</code>、<code>render</code>所需的相关信息。</p>\n<p>在组件<strong>mount</strong>时，<code>Reconciler</code>根据JSX描述的组件内容生成组件对应的<code>Fiber</code>节点。</p>\n<p>在<strong>update</strong>时，<code>Reconciler</code>将JSX与<code>Fiber</code>节点保存的数据对比，生成组件对应的<code>Fiber</code>节点，并根据对比结果为<code>Fiber</code>节点打上标记</p>\n<h2 id=\"初次渲染流程\">初次渲染流程</h2>\n<h2 id=\"更新流程\">更新流程</h2>\n<ol>\n<li>调用数据更新的方法(<code>this.setState</code>/<code>useState返回的更新方法</code>)</li>\n<li>进入<strong>render</strong>阶段</li>\n<li>采用<strong>DFS</strong>创建fiber树</li>\n<li>采用<strong>reconcile算法</strong>标记变化</li>\n<li>进入<strong>commit</strong>阶段</li>\n<li>执行4中变化对应的视图操作</li>\n</ol>\n<h2 id=\"参考\">参考</h2>\n<p><a href=\"https://react.iamkasong.com/\">React技术揭秘</a></p>\n"}},"__N_SSG":true}