{"pageProps":{"post":{"title":"ES6重点-0","tags":["ES6"],"categories":"JavaScript","description":"## [Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n\n`Proxy`用于**修改某些操作的默认行为**，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。`Proxy`可以理解成在目标对象之前架设一层","createDate":"2020-02-18 23:43:05","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>Proxy</code>用于<strong>修改某些操作的默认行为</strong>，等同于在语言层面做出修改，所以属于一种“元编程”（meta program），即对编程语言进行编程。<code>Proxy</code>可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\">Reflect</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>**WHAT **😳</p>\n<p>ES6为了<strong>操作对象</strong>而提供的新的API</p>\n<p><strong>WHY</strong>   🤔</p>\n<ol>\n<li>将<code>Object</code>对象的一些明显是语语言内部的方法（比如<code>Object.defineProperty</code>）放到<code>Reflect</code>对象上，现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</li>\n<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></li>\n<li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为</li>\n<li><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为</li>\n</ol>\n<p><strong>HOW</strong>  😮</p>\n<p><code>Reflect</code>对象一共有13个静态方法</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 适用于函数定义了自己的 apply 方法</span>\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">apply</span>(target, thisArg, args)\n<span class=\"hljs-comment\">// 等同于new target(...args) 这提供了一种不使用 new 来调用构造函数的方法</span>\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">construct</span>(target, args)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, name, receiver)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, name, value, receiver)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, name, desc)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">deleteProperty</span>(target, name)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">has</span>(target, name)\n<span class=\"hljs-comment\">// 基本等同于Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和</span>\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">isExtensible</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">prevenExtensions</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptor</span>(target, name)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(target)\n\n<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(target, prototype)\n</code></pre>\n<p><code>Reflect</code> + <code>Proxy</code>实现观察者模式</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> observers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-params\">fn</span>) {\n  observers.<span class=\"hljs-title function_\">add</span>(fn)\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">observable</span>(<span class=\"hljs-params\">obj</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, {\n    <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">target, key, value, receiver</span>) {\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver)\n      observers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> <span class=\"hljs-title function_\">observer</span>())\n      <span class=\"hljs-keyword\">return</span> result\n    }\n  })\n}\n\n<span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-title function_\">observable</span>({\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;tom&quot;</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span>\n})\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${ person.name }</span>, <span class=\"hljs-subst\">${ person.age }</span>`</span>)\n}\n<span class=\"hljs-title function_\">observe</span>(print)\nperson.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;tom1&quot;</span> \n</code></pre>\n<p>📣 在观察者模式中，观察者是知道被观察者的，被观察者一一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过消息代理进行通信。在发布订阅模式中，组件时松散耦合的，正和观察者模式相反。观察者模式大多时候是同步的，比如当事件触发，被观察者就会调用观察者的方法；而发布订阅模式大多时候是异步的（使用消息队列）</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">Symbol</a></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong> 😳</p>\n<p><code>ES6</code>引入的一种新的原始数据类型，表示<strong>独一无二</strong>的值。它是<code>JavaScript</code>语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Object</code>、<code>Number</code></p>\n<p>📣 不支持 <code>new Symbol()</code></p>\n<p><strong>WHY</strong>   🤔</p>\n<p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。Symbol值可作为对象属性名</p>\n<p><strong>HOW</strong>   😮</p>\n<p>Symbol值通过<code>Symbol</code>函数生成</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nameProperty = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\n<span class=\"hljs-keyword\">let</span> a = {\n  [nameProperty]: <span class=\"hljs-string\">&quot;a&quot;</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyNames</span>(a))\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> a) {\n  <span class=\"hljs-keyword\">if</span> (a.<span class=\"hljs-title function_\">hasOwnProperty</span>(key)) {\n    <span class=\"hljs-keyword\">const</span> element = a[key];\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key);\n  }\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">ownKeys</span>(a));\n</code></pre>\n<p>API:</p>\n<ul>\n<li><p><code>Symbol.description</code></p>\n<p>创建<code>Symbol</code>的时候，可以添加一个描述，但读取这个描述需要将<code>Symbol</code>显式转为字符串。<code>Symbol.description</code>可以方便的读取<code>Symbol</code>对应的描述</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nameProp = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\nnameProp.<span class=\"hljs-title function_\">toString</span>()\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nameProp.<span class=\"hljs-property\">description</span>)\n</code></pre>\n</li>\n<li><p><code>Symbol.for</code></p>\n<p>重新使用同一个<code>Symbol</code>值。<code>Symbol.for</code>接受一个字符串作为参数，然后<strong>全局搜索</strong>有没有以该参数作为名称的Symbol值，若有，返回之；若没有，创建之</p>\n<p><code>Symbol.for(&quot;name&quot;)</code>和<code>Symbol(&quot;name&quot;)</code>的区别：两者都会生成<code>Symbol</code>值；前者会被登记在<strong>全局</strong>环境中供搜索，后者不会</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>) === <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\n<span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;name&quot;</span>) === <span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)\n<span class=\"hljs-comment\">// true</span>\n</code></pre>\n</li>\n<li><p><code>Symbol.keyFor</code></p>\n<p>返回一个已<strong>登记</strong>的<code>Symbol</code>的<code>key</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(<span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">keyFor</span>(<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-title function_\">for</span>(<span class=\"hljs-string\">&quot;name&quot;</span>)));\n<span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-comment\">// name</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Set</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong> 😳</p>\n<p>ES6提供的一种数据结构，类似于数组，但成员的值都是唯一的，没有重复的值</p>\n<p>Set使用一种类似于<code>===</code>的算法“Same-value-zero equality”来判断值是否相等</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// &quot;5&quot; 和 5 不相等</span>\n<span class=\"hljs-comment\">// NaN 和 NaN 相等</span>\n<span class=\"hljs-comment\">// 两个空对象不相等</span>\n<span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&quot;5&quot;</span>)\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">5</span>)\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">NaN</span>)\nset.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">NaN</span>)\nset.<span class=\"hljs-title function_\">add</span>({})\nset.<span class=\"hljs-title function_\">add</span>({})\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(set);\n<span class=\"hljs-comment\">// Set { &#x27;5&#x27;, 5, NaN, {}, {} }</span>\n</code></pre>\n<p><strong>WHY</strong>   🤔</p>\n<ul>\n<li>可以用作数组去重<code>[...new Set([1, 1, 2, 2, 3])]</code></li>\n<li>去除字符串里面的重复字符<code>[...new Set(&#39;aaabbbc&#39;)].join(&quot;&quot;)</code></li>\n</ul>\n<p><strong>HOW</strong>   😮</p>\n<p><code>Set</code>函数可以接受一个数组（或<strong>具有interable接口</strong>的其他数据结构）作为参数，用来初始化</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Map</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong> 😳</p>\n<p>ES6提供的一种数据结构，类似于对象，也是键-值对的集合，但键的范围不限于字符串，各章类型的值（包括对象）都可以作为键</p>\n<p><strong>WHY</strong>   🤔</p>\n<p>传统上的Object只能用字符串（[Symbol](## Symbol)）作为键，这给它的使用带来了很大的限制</p>\n<p>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性和原作者的属性同名</p>\n<p><strong>HOW</strong>   😮</p>\n<p>使用 <code>new Map</code> 来创建Map</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;2&quot;</span>]])\nmap.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;1&quot;</span>)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(map.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-number\">2</span>));\n</code></pre>\n<p>事实上，不仅仅是数组，任何具有<code>iterator</code>接口、且每个成员都是一个双元素的数组的数据结构都可以作为<code>Map</code>构造函数的参数</p>\n"}},"__N_SSG":true}