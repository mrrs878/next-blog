{"pageProps":{"post":{"title":"HTML复习-0","tags":["HTML"],"categories":"2021复习","description":"## 节点关系\n\n![节点关系](http://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_relation.png)\n\n## ParentNode.append/Node.appendChild\n\n- `ParentNode.append()`允许追加  `DOMString` 对象，而 `Node.appendChild()` 只接受 `Node`","createDate":"2021-05-18 02:48:23","updateDate":"2021-06-29 19:07:42","body":"<h2 id=\"节点关系\">节点关系</h2>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/node_relation.png\" alt=\"节点关系\"></p>\n<h2 id=\"parentnodeappendnodeappendchild\">ParentNode.append/Node.appendChild</h2>\n<ul>\n<li><code>ParentNode.append()</code>允许追加  <code>DOMString</code> 对象，而 <code>Node.appendChild()</code> 只接受 <code>Node</code> 对象</li>\n<li><code>ParentNode.append()</code> 没有返回值，而 <code>Node.appendChild()</code> 返回追加的 <code>Node</code> 对象</li>\n<li><code>ParentNode.append()</code> 可以追加多个节点和字符串，而 <code>Node.appendChild()</code> 只能追加一个节点</li>\n</ul>\n<h2 id=\"cookie\">cookie</h2>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/cookie_0.png\" alt=\"cookie格式\"></p>\n<ul>\n<li>Name: <code>cookie</code>的名字</li>\n<li>Value: <code>cookie</code>的值</li>\n<li>Domain: 指定了哪些域名可以接收<code>cookie</code>。如果不指定，默认为<code>origin</code>，不包含子域名，如果制定则包含子域名</li>\n<li>Path: 制定了域名下的哪些路径可以接受<code>cookie</code>。子路径也会被匹配</li>\n<li>Expires/Max-Age: 定义<code>cookie</code>的生命周期</li>\n<li>HttpOnly: 限制JavaScript通过<code>document.cookie</code>访问</li>\n<li>Secure: 标记为<code>Secure</code>的<code>cookie</code>只应通过被HTTPS协议加密过的请求发送给服务端</li>\n<li>SameSite: 设置某个<code>cookie</code>在跨站请求时会不会被发送<ul>\n<li>None 浏览器会在同站请求、跨站请求下继续发送<code>cookie</code></li>\n<li>Strict 浏览器将只在访问相同站点时发送<code>cookie</code></li>\n<li>Lax 与Strict类似，但不包括用户从外部站点导航至该URL</li>\n</ul>\n</li>\n<li>Priotity: chrome的提案，<code>Low/Medium/Hight</code>，低优先级的<code>cookie</code>会在<code>cookie</code>数量超出时被移除</li>\n</ul>\n<p>不设置<code>max-age</code>和<code>expires</code>，此<code>cookie</code>就是会话级别的</p>\n<h2 id=\"事件机制\">事件机制</h2>\n<p>IE 事件流被称为<strong>事件冒泡</strong>。事件从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）</p>\n<p>Netscape Communicator提出<strong>事件捕获</strong>机制。最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件</p>\n<p>DOM2 Events规范规定事件流分为个阶段：事件捕获、到达事件目标、事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。</p>\n<p>添加/移除事件处理程序：</p>\n<ul>\n<li>DOM0<pre><code class=\"hljs language-js\">element.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-function\">() =&gt;</span> {};\nelement.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-literal\">null</span>;\n\n<span class=\"hljs-comment\">// 同一事件不能添加多个处理函数</span>\n</code></pre>\n</li>\n<li>DOM2<pre><code class=\"hljs language-js\">element.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, handler);\nelement.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, handler);\n</code></pre>\n</li>\n</ul>\n<h2 id=\"mutationobserver\">MutationObserver</h2>\n<p>可以在DOM被修改时异步执行回调，使用<code>MutationObserver</code>可以观察整个文档、DOM树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> elementRef = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onElementClick</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    elementRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&#x27;observer&#x27;</span>;\n  };\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MutationObserver</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">record</span>) =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(record[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">name</span>);\n    });\n    observer.<span class=\"hljs-title function_\">observe</span>(elementRef.<span class=\"hljs-property\">current</span>, { <span class=\"hljs-attr\">attributes</span>: <span class=\"hljs-literal\">true</span> });\n  }, []);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{elementRef}</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{onElementClick}</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;button&quot;</span>&gt;</span>click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<p>默认情况下，只要被观察元素不被垃圾回收，MutationObserver的回调就会响应DOM变化事件，从而被执行，要提前终止执行回调，可以调用<code>disconnect()</code>方法。</p>\n<p><code>observe</code>配置</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>subtree</td>\n<td><code>boolean</code></td>\n<td>表示除了目标节点，是否观察目标节点的子树(后代)</br>如果是<code>false</code>则只观察目标节点的变化</br>如果是<code>true</code>则观察目标阶段及其整个子树</td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>attributes</td>\n<td><code>boolean</code></td>\n<td>表示是否观察目标阶段的属性变化</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>attributeFilter</td>\n<td><code>Array&lt;string&gt;/boonean</code></td>\n<td>表示要观察哪些属性的变化</br>把这个值置为<code>true</code>也会将<code>attributes</code>的值转换为<code>true</code></td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>attributeOldValue</td>\n<td><code>boolean</code></td>\n<td>表示<code>MutationObserver</code>是否记录变化之前的属性值</br>把这个值置为<code>true</code>也会将<code>attributes</code>置为<code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>characterData</td>\n<td><code>boolean</code></td>\n<td>表示修改字符数据是否触发变化事件</td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>characterDataOldValue</td>\n<td><code>boolean</code></td>\n<td>表示<code>MutationObserver</code>是否记录变化之前的字符数据</br>把这个值置为<code>true</code>也会将<code>characterData</code>的值置为<code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>childList</td>\n<td><code>boolean</code></td>\n<td>表示修改目标节点的子节点是否触发变化事件</td>\n<td><code>false</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"node类型\">Node类型</h2>\n<p>DOM1描述了名为<code>Node</code>的接口，这个接口是所有DOM节点类型都必须实现的。Node接口在JavaScript中被实现为<code>Node</code>类型，在除IE外的所有浏览器中都可以直接访问这个类型。在JavaScript中，所有节点都继承<code>Node</code>类型，因此所有类型都共享相同的基本属性和方法</p>\n<h1 id=\"doctype作用\">DOCTYPE作用</h1>\n<p>浏览器使用<code>DOCTYPE</code>声明来选择是否使用更符合Web标准或兼容旧浏览器的bug的模式。现代浏览器主要有两种渲染模式：</p>\n<ul>\n<li>怪异模式，又称向后兼容模式。旧浏览器使用的非标准渲染规则</li>\n<li>标准模式。严格遵守W3C标准</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- HTML5的doctype声明 --&gt;</span>\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">HTML</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">HTML</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span>\n\n<span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span>\n<span class=\"hljs-string\">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>&gt;</span>\n</code></pre>\n<h2 id=\"html5新特性\">HTML5新特性</h2>\n<ul>\n<li>新的文档类型声明(<code>DOCYPE</code>)</li>\n<li>新的语义元素，比如<code>&lt;header&gt;</code>,<code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>等</li>\n<li>新的表单控件，比如数字、日期、时间、日历和滑块</li>\n<li>强大的图像支持（借由<code>&lt;canvas&gt;</code>和<code>&lt;svg&gt;</code>）</li>\n<li>强大的多媒体支持（借由<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>）</li>\n<li>新的API（如<code>localStorage</code>）</li>\n</ul>\n<h2 id=\"参考\">参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/orphaned/Web/API/ParentNode/append\">MDN-append</a></p>\n"}},"__N_SSG":true}