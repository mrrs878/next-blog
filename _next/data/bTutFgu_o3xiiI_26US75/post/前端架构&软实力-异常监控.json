{"pageProps":{"post":{"title":"前端架构&软实力-异常监控","tags":["异常监控"],"categories":"前端架构&软实力","description":"# JavaScript中的异常处理方式\n\n对于JavaScript而言，我们面对的仅仅只是异常，异常的出现并不会直接导致JavaScript引擎崩溃，最多只会使当前执行的任务终止\n\n1. 当前代码块将作为一个任务压入任务队列中，JavaScript引擎线程会不断地从任务队列中提取任务执行\n2. 当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务地","createDate":"2020-06-08 22:33:01","updateDate":"2021-02-20 17:15:07","body":"<h1 id=\"javascript中的异常处理方式\">JavaScript中的异常处理方式</h1>\n<p>对于JavaScript而言，我们面对的仅仅只是异常，异常的出现并不会直接导致JavaScript引擎崩溃，最多只会使当前执行的任务终止</p>\n<ol>\n<li>当前代码块将作为一个任务压入任务队列中，JavaScript引擎线程会不断地从任务队列中提取任务执行</li>\n<li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务地执行</li>\n<li>JavaScript引擎线程继续从任务队列中取出下一个任务继续执行</li>\n</ol>\n<p>异常主要分为两大中：<strong>运行时错误</strong>和语<strong>法错误</strong>。语法错误在编写代码期间很容易被发现，运行时错误主要由取值/赋值异常、函数执行出错等</p>\n<h1 id=\"如何捕获异常\">如何捕获异常</h1>\n<h2 id=\"捕获普通javascript异常\">捕获普通JavaScript异常</h2>\n<p>对于普通的JavaScript异常，常见的做法是使用<code>try-catch</code>进行包裹，当<code>try</code>中的代码块执行出错后，<code>catch</code>将能捕捉到异常，代码也可以继续执行下去</p>\n<p>但<code>try-catch</code>处理异常的能力有限，<strong>只能捕捉到运行时非异步错误</strong>，对于语法错误和异步错误就显得无能为力，捕捉不到</p>\n<h2 id=\"捕获异步javascript异常\">捕获异步JavaScript异常</h2>\n<p><code>window.onerror</code>捕获异常能力比<code>try-catch</code>稍微强点，无论是异步还是非异步运行时错误，<code>onerror</code>都能捕获到</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg, url, row, col, error</span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;我知道错误了&#x27;</span>);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>({\n    msg,  url,  row, col, error\n  })\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n};\n</code></pre>\n<p>使用注意：</p>\n<ul>\n<li>在实际的使用过程中，<code>windows.onerror</code> 主要是来捕获预料之外的错误，而 <code>try-catch</code> 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</li>\n<li><code>window.onerror</code> 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示</li>\n<li><code>window.onerror</code>无法捕获到网络异常的错误</li>\n<li>无法捕获<code>Promise</code>异常</li>\n</ul>\n<h2 id=\"捕获promise-异常\">捕获<strong>Promise</strong> 异常</h2>\n<p>通过 <code>Promise</code> 可以帮助我们解决异步回调地狱的问题，但是一旦 ~实例抛出异常而你没有用 <code>catch</code> 去捕获的话，<code>onerror</code> 或 <code>try-catch</code> 也无能为力，无法捕捉到错误</p>\n<p>对此可以添加一个 <strong><code>Promise</code> 全局异常捕获事件</strong> <code>unhandledrejection</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;unhandledrejection&quot;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>){\n  e.<span class=\"hljs-title function_\">preventDefault</span>()\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;我知道 promise 的错误了&#x27;</span>);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e.<span class=\"hljs-property\">reason</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n});\n</code></pre>\n<p>|                    | 同步方法 | 异步方法 | 资源加载 | Promise | async/await |\n| </p>\n"}},"__N_SSG":true}