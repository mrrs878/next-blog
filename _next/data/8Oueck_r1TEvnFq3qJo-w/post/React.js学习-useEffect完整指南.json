{"pageProps":{"post":{"title":"React.js学习-useEffect完整指南","tags":["React.js","Hooks"],"categories":"React.js","description":"> 原文链接：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\n\n# 每一次渲染都有它自己的...\n\n``` jsx\nconst Counter = () => {\n\tconst [count, setCount] = useState(0)\n    \n    return (\n    \t<button onClick=","createDate":"2020-10-27 15:21:38","updateDate":"2020-10-30 18:03:54","body":"<blockquote>\n<p>原文链接：<a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">每一次渲染都有它自己的...</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Counter</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)\n    \n    <span class=\"hljs-keyword\">return</span> (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setCount(count+1)}&gt;click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>${ count }<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>\n        <span class=\"hljs-comment\">// 没做任何特殊事件绑定，只是在渲染时拿取独立的count状态</span>\n    )\n}\n</code></pre>\n<ul>\n<li>每一次渲染都有它自己的<code>data</code>和<code>props</code></li>\n<li>每一次渲染都有它自己的事件处理函数</li>\n<li>每一次渲染都有它自己的Effects</li>\n<li>每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的<code>props</code>和<code>state</code></li>\n<li>当更新状态时，React会重新渲染组件。每一次渲染都能拿到独立的<code>count</code>状态，这个状态值是函数中的一个常量</li>\n<li>在单次渲染的范围内，<code>props</code>和<code>state</code>始终保持不变</li>\n</ul>\n<blockquote>\n<p>如果<code>props</code>和<code>state</code>在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的<code>count</code>值。</p>\n</blockquote>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">组件不要将接收到的参数本地化，或者说使组件完全受控</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>如果需要对 props 进行加工，可以利用 useMemo 对加工过程进行缓存，仅当依赖变化时才重新执行</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> textColor = <span class=\"hljs-title function_\">useMemo</span>(\n  <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">slowlyCalculateTextColor</span>(color),\n  [color] <span class=\"hljs-comment\">// ✅ Don’t recalculate until `color` changes</span>\n);\n</code></pre>\n"}},"__N_SSG":true}