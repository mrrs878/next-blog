{"pageProps":{"post":{"title":"网络相关-tcp","tags":["网络","TCP"],"categories":"网络","description":"# TCP的特点\n\n- 三次握手\n- 四次挥手\n- 可靠连接\n- 面向字节流\n- 提供拥塞控制\n- 丢包重传\n\n# TCP如何保证可靠传输\n\ntcp在传输的过程中都有一个ack，接收方通过ack告诉发送方收到哪些包了。这样发送方就能知道丢包情况进而重传\n\n# TCP的三次握手\n\n1. client发送SYN到server发起握手\n2. server回复SYN+ACK给client\n3. cli","createDate":"2020-04-16 21:00:43","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP的特点</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ul>\n<li>三次握手</li>\n<li>四次挥手</li>\n<li>可靠连接</li>\n<li>面向字节流</li>\n<li>提供拥塞控制</li>\n<li>丢包重传</li>\n</ul>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP如何保证可靠传输</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>tcp在传输的过程中都有一个ack，接收方通过ack告诉发送方收到哪些包了。这样发送方就能知道丢包情况进而重传</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP的三次握手</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li>client发送SYN到server发起握手</li>\n<li>server回复SYN+ACK给client</li>\n<li>client回复server一个ACK表示收到了server的SYN+ACK</li>\n</ol>\n<p>握手的核心目的是告知对方SEQ，对方回复ACK（收到的SEQ+包的大小），这样发送端就知道有没有丢包了。次要目的是告知和协商一些信息</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">TCP的四次挥手</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <ol>\n<li>client发送FIN包给server</li>\n<li>sever回复ACK（对应第一步FIN包的ACK）给client，表示server知道client要断开了</li>\n<li>sever发送FIN包给client，表示server也可以断开了</li>\n<li>client回复ACK给server，表示既然双方都发送FIN包表示断开，那就真的断开吧</li>\n</ol>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么要三次握手、四次挥手</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>挥手的时候多一次主要是收到第一个FIN包后单独回复了一个ACK包，如果FIN+ACK和并发送那么四次挥手也变成三次了。关于为什么要分开，收到FIN后，知道对方要关闭了，然后OS通知应用层要关闭啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回ACK，准备好了再发FIN。握手没有这个准备过程（服务端在LISTEN状态下）所以可以立即发送SYN+ACK</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ACK</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p><code>ACK = SEQ + LEN(包的大小)</code>，这样发送方可以明确知道对方收到哪些东西</p>\n\n      <h1>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">拥塞控制</span>\n        <span class=\"suffix\"></span>\n      </h1>\n    <p>拥塞控制主要作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。拥塞处理包括以下算法：慢开始、拥塞避免、快速重传</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">慢开始</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞</p>\n<p>慢开始算法步骤具体如下：</p>\n<ol>\n<li>连接初始设置拥塞窗口（Congestion Window）为1MSS（一个分段的最大数据量）</li>\n<li>每过一个RTT（表示发送端发送数据到接收到对端数据所需的往返时间）就将窗口大小x2</li>\n<li>指数级增长肯定不能没有限制，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">拥塞避免算法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>拥塞避免算法相比简单点，每过一个RTT，拥塞窗口大小+1，这样能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。在传输过程中可能会遇到定时器超时的情况，这时TCP就会认为网络拥塞了，会马上进行以下步骤：</p>\n<ol>\n<li>将阈值设为当前拥塞窗口的一半</li>\n<li>将拥塞窗口设为1MSS</li>\n<li>启动拥塞避免算法</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">快速重传</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>一旦接收端收到的报文出现失序的情况，接收端指会回复最后一个顺序正确的报文序号（没有SACK的情况）。如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。</p>\n"}},"__N_SSG":true}