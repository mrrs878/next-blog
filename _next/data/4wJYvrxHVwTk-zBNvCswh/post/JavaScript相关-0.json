{"pageProps":{"post":{"title":"JavaScript相关-0","tags":["JavaScript"],"categories":"JavaScript","description":"## 事件委托 （event delegation）\n事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器，当触发子元素时，事件会冒泡到父元素，监听器就会触发，这种技术的好处是：\n\n1. 内存占用少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。\n2. 无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。\n\n## JavaScript中","createDate":"2020-02-10 23:18:10","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">事件委托 （event delegation）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器，当触发子元素时，事件会冒泡到父元素，监听器就会触发，这种技术的好处是：</p>\n<ol>\n<li>内存占用少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。</li>\n<li>无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript中的this指向</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单来讲，<code>this</code>的指向取决于函数的调用方式</p>\n<ol start=\"0\">\n<li>如果是箭头函数，<code>this</code>被设置为调用时的上下文</li>\n<li>如果使用<code>new</code>，函数内的<code>this</code>是一个全新的对象</li>\n<li>如果<code>apply、call、bind</code>方法用于调用/创建一个函数，函数内的<code>this</code>就是作为参数传入这些方法的对象</li>\n<li>当函数作为对象里的方法被调用时，函数内的<code>this</code>是调用该函数的对象，比如当<code>obj.method()</code>被调用时，函数内的<code>this</code>将绑定到<code>obj</code>对象</li>\n<li>如果不符合上述规则，那么<code>this</code>的值指向全局对象<code>global object</code>，浏览器环境下<code>this</code>的值指向<code>window</code>对象，但在严格模式下<code>use strict</code>，<code>this</code>的值为<code>undefined</code></li>\n<li>如果符合上述多个规则，从上到下权重依次递减</li>\n</ol>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">原型继承 <code>prototypal inheritance</code></span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>所有的JS对象都有一个<code>prototype</code>对象，指向它的原型对象，当试图访问一个对象的属性时，如果没有在该对象上找到它还会搜索该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或达到原型链的末尾。这种行为是在模拟经典的继承，但与其说时继承还不如说是委托<code>delegation</code></p>\n<p>读取对象的属性值时，会自动到原型链中查找</p>\n<p>设置对象的属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值</p>\n<p><img src=\"./imgs/1581317824537.png\" alt=\"原型\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">JavaScript的模块化机制</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>AMD</p>\n<p><strong>Asynchronous Module Definition 异步模块加载机制</strong>，ReqireJS实现了AMD规范</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//a.js</span>\n<span class=\"hljs-comment\">//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数</span>\n<span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n})\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-comment\">//数组中声明需要加载的模块，可以是模块名、js文件路径</span>\n<span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>], <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a</span>){\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a);<span class=\"hljs-comment\">// 1</span>\n});\n</code></pre>\n<p>特点：</p>\n<p>对于依赖的模块，AMD推崇<strong>依赖前置，提前执行</strong>，也就是说，在<code>define</code>方法里传入的依赖模块（数组）会在一开始就下载并执行。适合在<strong>浏览器端</strong>使用</p>\n</li>\n<li><p>CommonJS</p>\n<p>CommonJS规范为CommonJS小组所提出，目的是弥补JavaScript在服务器端缺少模块化机制，<strong>NodeJS、webpack</strong>都是基于该规范来实现的。</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//a.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>)\n}\n\n<span class=\"hljs-comment\">//b.js</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a&#x27;</span>);\n\n<span class=\"hljs-title function_\">a</span>();<span class=\"hljs-comment\">//&quot;hello world&quot;</span>\n\n<span class=\"hljs-comment\">//或者</span>\n\n<span class=\"hljs-comment\">//a2.js</span>\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">num</span> = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">obj</span> = {<span class=\"hljs-attr\">xx</span>: <span class=\"hljs-number\">2</span>};\n\n<span class=\"hljs-comment\">//b2.js</span>\n<span class=\"hljs-keyword\">var</span> a2 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a2&#x27;</span>);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a2);<span class=\"hljs-comment\">//{ num: 1, obj: { xx: 2 } }</span>\n</code></pre>\n<p>特点：</p>\n<ul>\n<li>所有代码都运行在<strong>模块作用域</strong>，不会污染全局作用域</li>\n<li>模块是<strong>同步加载</strong>的，即只有加载完成才能执行后面的操作</li>\n<li>模块在首次执行后就会<strong>缓存</strong>，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>\n<li><code>require</code>返回的是被输出的<strong>值的拷贝</strong>，模块内部的变化也不会影响这个值</li>\n</ul>\n</li>\n<li><p>ES6 Module</p>\n<p>ES6 Module是<strong>ES6</strong>中规定的模块体系</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">//a.js</span>\n<span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;lin&#x27;</span>;\n<span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">13</span>;\n<span class=\"hljs-keyword\">var</span> job = <span class=\"hljs-string\">&#x27;ninja&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> { name, age, job};\n\n<span class=\"hljs-comment\">//b.js</span>\n<span class=\"hljs-keyword\">import</span> { name, age, job} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a.js&#x27;</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name, age, job);<span class=\"hljs-comment\">// lin 13 ninja</span>\n\n<span class=\"hljs-comment\">//或者</span>\n\n<span class=\"hljs-comment\">//a2.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;default &#x27;</span>);\n}\n\n<span class=\"hljs-comment\">//b2.js</span>\n<span class=\"hljs-keyword\">import</span> customName <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a2.js&#x27;</span>;\n<span class=\"hljs-title function_\">customName</span>(); <span class=\"hljs-comment\">// &#x27;default&#x27;</span>\n</code></pre>\n<p>特点（对比CommonJS）：</p>\n<p>|          | CommonJS     | ES6 Module     |\n|</p>\n</li>\n</ul>\n"}},"__N_SSG":true}