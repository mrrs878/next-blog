{"pageProps":{"post":{"title":"前端架构&软实力-JSBridge原理","tags":["JSBridge"],"categories":"前端架构&软实力","description":"# 什么是JSBridge\n\nJSBridge是一种JavaScript实现的Bridge，连接着桥两端的native和H5。它在APP里方便地让native调用JavaScript，JavaScript调用native，是双向通信的通道。\n\n# JSBridge双向通信原理\n\n## JavaScript调用native\n\nJavaScript调用native的实现方式较多，主要有：\n\n- 拦","createDate":"2020-04-25 23:01:48","updateDate":"2021-02-20 17:16:05","body":"<h1 id=\"什么是jsbridge\">什么是JSBridge</h1>\n<p>JSBridge是一种JavaScript实现的Bridge，连接着桥两端的native和H5。它在APP里方便地让native调用JavaScript，JavaScript调用native，是双向通信的通道。</p>\n<h1 id=\"jsbridge双向通信原理\">JSBridge双向通信原理</h1>\n<h2 id=\"javascript调用native\">JavaScript调用native</h2>\n<p>JavaScript调用native的实现方式较多，主要有：</p>\n<ul>\n<li>拦截<code>URL Scheme</code></li>\n<li>重写<code>prompt</code></li>\n<li>注入API</li>\n</ul>\n<h3 id=\"拦截url-scheme\">拦截<code>URL Scheme</code></h3>\n<p>Android和iOS都可以通过拦截<code>URL Scheme</code>并解析<code>Scheme</code>来决定是否进行对应的native代码逻辑处理。</p>\n<p>Android 的话，<code>Webview</code> 提供了 <code>shouldOverrideUrlLoading</code> 方法来提供给 Native 拦截 H5 发送的 <code>URL Scheme</code> 请求。</p>\n<p>iOS 的 <code>WKWebview</code> 可以根据拦截到的 <code>URL Scheme</code> 和对应的参数执行相关的操作。</p>\n<p>这种方法的优点是不存在漏洞问题、使用灵活，可以实现 H5 和 Native 页面的无缝切换。例如在某一页面需要快速上线的情况下，先开发出 H5 页面。某一链接填写的是 H5 链接，在对应的 Native 页面开发完成前先跳转至 H5 页面，待 Native 页面开发完后再进行拦截，跳转至 Native 页面，此时 H5 的链接无需进行修改。但是使用 iframe.src 来发送 <code>URL Scheme</code> 需要对 URL 的长度作控制，使用复杂，速度较慢。</p>\n<h3 id=\"重写-prompt-等原生-js-方法\">重写 prompt 等原生 JS 方法</h3>\n<p>Android 4.2 之前注入对象的接口是 <code>addJavascriptInterface</code> ，但是由于安全原因慢慢不被使用。一般会通过修改浏览器的部分 <code>Window</code> 对象的方法来完成操作。主要是拦截 <code>alert</code>、<code>confirm</code>、<code>prompt</code>、<code>console.log</code> 四个方法，分别被 <code>Webview</code> 的 <code>onJsAlert</code>、<code>onJsConfirm</code>、<code>onConsoleMessage</code>、<code>onJsPrompt</code> 监听。</p>\n<p>iOS 由于安全机制，<code>WKWebView</code> 对 <code>alert</code>、<code>confirm</code>、<code>prompt</code> 等方法做了拦截，如果通过此方式进行 Native 与 JS 交互，需要实现 <code>WKWebView</code> 的三个 <code>WKUIDelegate</code> 代理方法。</p>\n<p>使用该方式时，可以与 Android 和 iOS 约定好使用传参的格式，这样 H5 可以无需识别客户端，传入不同参数直接调用 Native 即可。剩下的交给客户端自己去拦截相同的方法，识别相同的参数，进行自己的处理逻辑即可实现多端表现一致。另外，如果能与 Native 确定好方法名、传参等调用的协议规范，这样其它格式的 <code>prompt</code> 等方法是不会被识别的，能起到隔离的作用。</p>\n<h3 id=\"注入api\">注入API</h3>\n<p>基于 <code>Webview</code> 提供的能力，可以向 <code>Window</code> 上注入对象或方法。JavaScript 通过这个对象或方法进行调用时，执行对应的逻辑操作，可以直接调用 Native 的方法。使用该方式时，JavaScript 需要等到 Native 执行完对应的逻辑后才能进行回调里面的操作。</p>\n<p>Android 的 <code>Webview</code> 提供了 <code>addJavascriptInterface</code> 方法，支持 Android 4.2 及以上系统。</p>\n<p>iOS 的 <code>UIWebview</code> 提供了 <code>JavaScriptScore</code> 方法，支持 iOS 7.0 及以上系统。<code>WKWebview</code> 提供了 <code>window.webkit.messageHandlers</code> 方法，支持 iOS 8.0 及以上系统。<code>UIWebview</code> 在几年前常用，目前已不常见。</p>\n<h2 id=\"native调用javascript\">native调用JavaScript</h2>\n<p>native调用JavaScript只需H5将JavaScript方法暴露在<code>window</code>上给native调用即可</p>\n<p>Android中主要有两种方式实现。在4.4之前，通过loadUrl方法，执行一段JavaScript代码来实现。在4.4之后，可以使用<code>evaluateJavascript</code>方法实现。loadUrl方法使用起来方便简洁，但是效率低无法获得返回结果且调用的时候会刷新webview。evaluateJavascript方法效率高且获取返回值方便，调用时不刷新<code>webview</code>，支持4.4+</p>\n<p>iOS在<code>WKWebview</code>中可以通过<code>evaluateJavascript:javascriptString</code>来实现，支持8.0+</p>\n"}},"__N_SSG":true}