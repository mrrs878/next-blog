{"pageProps":{"post":{"title":"webpack复习-易混淆知识点","tags":["webpack"],"categories":"2021复习","description":"## module/bundle/chunk的区别\n\n![module、bundle、chunk](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack_1.png)\n\n1. 对于一份同逻辑代码，当我们手写下一个一个的文件，它们无论是ESM还是commonJS或AMD，它们都是module\n2. 当我们写module源文件传到webpack","createDate":"2021-05-17 12:56:41","updateDate":"2021-07-15 13:54:55","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">module/bundle/chunk的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack_1.png\" alt=\"module、bundle、chunk\"></p>\n<ol>\n<li>对于一份同逻辑代码，当我们手写下一个一个的文件，它们无论是ESM还是commonJS或AMD，它们都是module</li>\n<li>当我们写module源文件传到webpack进行打包时，webpack会根据文件引用关系生成chunk文件，webpack会对这个chunk文件进行一些操作</li>\n<li>webpack处理好chunk文件后，最后会输出bundle文件，这个bundle文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行</li>\n</ol>\n<p>一句话总结：<code>module</code>、<code>chunk</code>、<code>bundle</code>其实就是同一份逻辑代码在不同转换场景下取的三个名字：我们直接写出来的是<code>module</code>，<code>webpack</code>处理时是<code>chunk</code>，最后生成浏览器可以直接运行的<code>bundle</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">filename/chunkFilename</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><code>filename</code>对应于<code>entry</code>里面的输入文件，经过webpack 打包后输出文件的文件名</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n    entry<span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;index&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;/path/to/index.js&quot;</span>\n    <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n    output<span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        filename<span class=\"hljs-punctuation\">:</span> &#x27;<span class=\"hljs-punctuation\">[</span>name<span class=\"hljs-punctuation\">]</span>.<span class=\"hljs-punctuation\">[</span>hash<span class=\"hljs-punctuation\">:</span><span class=\"hljs-number\">8</span><span class=\"hljs-punctuation\">]</span>.js&#x27;\n    <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p><code>chunkFilename</code>指未列在<code>entry</code>中却又要被打包出来的<code>chunk</code>文件的名称。一般来说，这个<code>chunk</code>文件指的就是需要<strong>懒加载</strong>的代码</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">webpackPrefetch/webpackPreload/webpackChunkName</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">import</span>(<span class=\"hljs-comment\">/* webpackPrefetch: true */</span> <span class=\"hljs-string\">&#x27;./path/to/LoginModal.js&#x27;</span>);\n</code></pre>\n<p><code>webpackChunkName</code>是为预加载的文件取别名，<code>webpackPrefetch</code>会在浏览器闲置时下载文件，<code>webpackPreload</code>会在父<code>chunk</code>加载时并行下载文件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">hash/chunkhash/contenthash</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>hash一般是结合CDN缓存来使用的。如果文件内容改变的话，那么对应文件hash值也会改变，对应的html引用的url地址也会改变，触发cdn服务器从源服务器上拉取对应数据进而更新本地缓存</p>\n<p><code>hash</code>是整个项目构建使用的，项目中如果有些变动，hash一定会变，比如说改动了utils.js，index.js里的代码虽然没有改变，但是大家都是用的同一份hash，hash一变，缓存一定会失效，这样子CDN就没有意义了</p>\n<p><code>chunkHash</code>就是解决这个问题的，它根据不同的入口文件(<code>entry</code>)进行依赖文件解析、构建对应的chunk，生成对应的hash值。一般用在<code>output</code>配置上</p>\n<p><code>contentHash</code>计算与文件内容本身有关。一般用在抽离<code>css</code>文件的插件配置上</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">sourse-map 中 eval/cheap/inline</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>source-map会生成独立的文件</p>\n<p>cheap-source-map不会产生列映射</p>\n<p>eval-source-map会以<code>eval</code>函数打包运行模块，不产生独立的map文件，会显示报错的行列信息</p>\n<p>inline-source-map映射文件以base64格式编码，加载bundle文件最后，不产生独立的map文件</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">loder vs plugin</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>loder: 文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</p>\n<p>plugin: 在webpack运行的生命周期中会广播许多事件，plugin可以监听这些事件，在合适的时机通过调用webpack提供的api改变输出结果</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s/To_p4eYJx_dkJr1ApcR4jA\">webpack 中最易混淆的 5 个知识点</a></p>\n<p><a href=\"https://webpack.docschina.org\">webpack文档</a></p>\n"}},"__N_SSG":true}