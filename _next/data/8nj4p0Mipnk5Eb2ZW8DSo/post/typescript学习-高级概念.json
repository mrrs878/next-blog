{"pageProps":{"post":{"title":"typescript学习-高级概念","tags":["分发","逆变","协变"],"categories":"typescript","description":"一些 typescript 中的概念\n\n## 分发\n\n先上 demo\n\n```ts\ntype GetSomeType<T extends string | number> = T extends string ? \"a\" : \"b\";\n\nlet one: GetSomeType<string>;\n// 'a'\n\nlet two: GetSomeType<number>;\n// 'b'\n\nlet","createDate":"2022-07-29 20:01:35","updateDate":"2022-08-01 20:54:30","body":"<p>一些 typescript 中的概念</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">分发</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>先上 demo</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">GetSomeType</span>&lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>&gt; = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span> ? <span class=\"hljs-string\">&quot;a&quot;</span> : <span class=\"hljs-string\">&quot;b&quot;</span>;\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">one</span>: <span class=\"hljs-title class_\">GetSomeType</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;;\n<span class=\"hljs-comment\">// &#x27;a&#x27;</span>\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">two</span>: <span class=\"hljs-title class_\">GetSomeType</span>&lt;<span class=\"hljs-built_in\">number</span>&gt;;\n<span class=\"hljs-comment\">// &#x27;b&#x27;</span>\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">three</span>: <span class=\"hljs-title class_\">GetSomeType</span>&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>&gt;;\n<span class=\"hljs-comment\">// ?</span>\n</code></pre>\n<p>对于 <code>three</code> 的类型，感觉会是什么呢？ <code>a</code> or <code>b</code> or <code>&#39;a&#39; | &#39;b&#39;</code> ？</p>\n<p><img src=\"/img/typescript-high-concept-0.png\" alt=\"类型分发\"></p>\n<p>答案是 <code>&#39;a&#39; | &#39;b&#39;</code> !</p>\n<p>有点意思， <code>three</code>的类型竟然被推导成为了 <code>&#39;a&#39; | &#39;b&#39;</code> 组成的联合类型</p>\n<p><strong>其实这就是所谓分发在捣鬼</strong></p>\n<p>抛开晦涩的概念来解读分发，结合上边的 Demo 来说所谓的<strong>分发简单来说就是分别使用 string 和 number 这两个类型进入 GetSomeType 中进行判断，最终返回两次类型结果组成的联合类型</strong></p>\n<p>那么，什么情况下会产生分发呢？满足分发需要一定的条件</p>\n<ol>\n<li><p>毫无疑问分发一定是需要产生在 extends 产生的类型条件判断中，并且是前置类型</p>\n</li>\n<li><p>分发一定是要满足联合类型，只有联合类型才会产生分发</p>\n</li>\n<li><p>分发一定要满足所谓的裸类型中才会产生效果（像 <code>Array&lt;string&gt;</code> 就不属于裸类型）</p>\n</li>\n</ol>\n<p>分发的作用/应用：实现一些工具类型，比如内置的 <code>Exclude</code> 和 <code>Extract</code> 等</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">TypeA</span> = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">boolean</span> | symbol;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">MyExclude</span>&lt;T, U&gt; = T <span class=\"hljs-keyword\">extends</span> U ? <span class=\"hljs-built_in\">never</span> : T;\n</code></pre>\n<p><img src=\"/img/typescript-high-concept-1.png\" alt=\"分发的应用-Exclude\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">逆变</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>首先，思考一下如下场景</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">let</span> a!: { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> };\n<span class=\"hljs-keyword\">let</span> b!: { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> };\n\nb = a;\n\na = b;\n</code></pre>\n<p>对于 <code>a = b</code> 这一赋值 ts 是会报错的</p>\n<p><img src=\"/img/typescript-high-concept-2.png\" alt=\"类型安全性\"></p>\n<p>我们都清楚 TS 属于静态类型检测，所谓类型的赋值是要保证安全性的。</p>\n<p><strong>通俗来说也就是多的可以赋值给少的</strong>，上述代码因为 a 的类型定义中完全包括 b 的类型定义，所以 a 类型完全是可以赋值给 b 类型，这被称为类型兼容性。</p>\n<p>但对于函数而言，刚好相反</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> A = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> };\n<span class=\"hljs-keyword\">type</span> B = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> };\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fn1</span> = (<span class=\"hljs-params\">a: A</span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-property\">name</span>);\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fn2</span> = (<span class=\"hljs-params\">b: B</span>) =&gt; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b.<span class=\"hljs-property\">name</span>);\n\nfn1 = fn2;\n\n<span class=\"hljs-comment\">// 报错</span>\nfn2 = fn1;\n</code></pre>\n<p>对于 <code>fn2 = fn1</code> 是会报错的，如下</p>\n<p><img src=\"/img/typescript-high-concept-3.png\" alt=\"逆变\"></p>\n<p>逆变，描述的是函数之间互相赋值，<strong>参数</strong>之间的类型兼容性，参数少的可以赋值给参数多的，反之则不可</p>\n<p>原因可以简单的理解为：函数之间的赋值复制的是指针，但函数调用时该函数的签名（js中并没有函数签名，只是为了方便解释）并没有跟随一起复制过去。</p>\n<p>因此，拿上面的例子来讲：假设 <code>fn2 = fn1</code> 可以正常执行，在此操作后，执行 <code>fn2(b: B)</code> 实际上执行的是 <code>fn1</code> ，但入参是 <code>B</code> 类型，此时 <code>fn1</code> 内部可能会调用 <code>A</code> 中存在但 <code>B</code> 中不存在的一些属性，可能会报错。为了保证安全性，因此不允许这种赋值</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">协变</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>协变，描述的是函数之间互相赋值，<strong>返回值</strong>之间的类型兼容性，参数多的可以赋值给参数少的，反之则不可</p>\n<p>例如</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> A = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> };\n<span class=\"hljs-keyword\">type</span> B = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> };\n\n<span class=\"hljs-keyword\">let</span> fn1!: <span class=\"hljs-function\">() =&gt;</span> A;\n<span class=\"hljs-keyword\">let</span> fn2!: <span class=\"hljs-function\">() =&gt;</span> B;\n\n<span class=\"hljs-comment\">// 报错</span>\nfn1 = fn2;\n\nfn2 = fn1;\n</code></pre>\n<p><img src=\"/img/typescript-high-concept-4.png\" alt=\"协变\"></p>\n<p>其实这种现象也很好理解：就像普通变量赋值一样，为保证类型安全性，阻止了该行为</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://juejin.cn/post/7089809919251054628\">如何进阶 TypeScript 功底？一文带你理解 TS 中各种高级语法</a></p>\n"}},"__N_SSG":true}