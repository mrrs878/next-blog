{"pageProps":{"post":{"title":"JavaScript复习-0","tags":["JavaScript"],"categories":"2021复习","description":"## JavaScript数据类型\n\n原始Primitive类型：\n\n`Number`、`String`、`Boolean`、`Undefined`、`Null`、`Symbol`、`Bigint`\n\n引用类型\n\n`Object`、`Array`、`Date`、`Function` \n\n## Symbol和Bigint\n\n`Symbol`表示唯一、不可变的值。用于确保对象属性使用唯一标识符，不","createDate":"2021-05-07 14:34:34","updateDate":"2021-06-21 23:49:44","body":"<h2 id=\"javascript数据类型\">JavaScript数据类型</h2>\n<p>原始Primitive类型：</p>\n<p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Undefined</code>、<code>Null</code>、<code>Symbol</code>、<code>Bigint</code></p>\n<p>引用类型</p>\n<p><code>Object</code>、<code>Array</code>、<code>Date</code>、<code>Function</code> </p>\n<h2 id=\"symbol和bigint\">Symbol和Bigint</h2>\n<p><code>Symbol</code>表示唯一、不可变的值。用于确保对象属性使用唯一标识符，不会发生属性名冲突的危险</p>\n<p><code>BigInt</code>是一种数字类型的数据，它可以表示任意精度格式的整数，使用<code>BigInt</code>可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围</p>\n<h2 id=\"var-vs-letconst\">var vs let/const</h2>\n<ul>\n<li>作用域问题</li>\n<li>重复声明/赋值问题</li>\n<li>变量提升</li>\n<li>暂时性死区</li>\n</ul>\n<h2 id=\"数据属性访问器属性\">数据属性/访问器属性</h2>\n<p>对象的属性有两种类型，<strong>数据属性</strong>和<strong>访问器属性</strong></p>\n<ul>\n<li>创建对象时默认就存在的属性为数据属性</li>\n<li>通过<code>Object.defineProperty</code>设置的属性描述符中含有<code>set/get</code>的属性为访问器属性</li>\n</ul>\n<h2 id=\"内部属性class\">内部属性[[Class]]</h2>\n<p><a href=\"\">Object.prototype.toString传送门</a></p>\n<p><del>所有对象(<code>typeof</code>返回为<code>object</code>)都包含有一个内部属性<code>[[Class]]</code>，该属性不能直接访问，\n可使用<code>Object.prototype.toString</code>来查看</del></p>\n<p><strong>ES6移除了这个属性</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>([])  \n<span class=\"hljs-comment\">//&quot;[object Array]&quot;</span>\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-function\">() =&gt;</span> {})\n<span class=\"hljs-comment\">// &quot;[object Function]&quot;</span>\n</code></pre>\n<h2 id=\"objectprototypetostring\">Object.prototype.toString</h2>\n<p>拿到变量准确的类型</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>([])  \n<span class=\"hljs-comment\">//&quot;[object Array]&quot;</span>\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-function\">() =&gt;</span> {})\n<span class=\"hljs-comment\">// &quot;[object Function]&quot;</span>\n\n<span class=\"hljs-comment\">/*\n基本类型值string、number、boolean都可以打印这是因为JavaScript为基本类型值包装\n了一个封装对象使它们变成了对象，而String()、Number()、Boolean()上有属性[[Class]]\n*/</span>\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// &quot;[object Number]&quot;</span>\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;a&quot;</span>)\n<span class=\"hljs-comment\">// &quot;[object String]&quot;</span>\n</code></pre>\n<p>可通过重写变量的toString方法修改输出</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> a = {\n    get [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">toStringTag</span>]() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;A&#x27;</span>;\n    }\n}\n\n<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&quot;a&quot;</span>)\n<span class=\"hljs-comment\">// &quot;[object A]&quot;</span>\n</code></pre>\n<h2 id=\"上下文、作用域链、闭包\">上下文、作用域链、闭包</h2>\n<p>上下文：每个上下文都有一个关联的<strong>变量对象(variable object)<strong>，存储这个上下文中定义的所有变量和函数。函数局部上下文中的叫做</strong>活动对象(activity object)</strong>(活动对象最初只有一个定义变量<code>arguments</code>，全局上下文中没有这个变量)。上下文会在其所有代码都执行完毕后被销毁（全局上下文会在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）</p>\n<p>作用域链：执行上下文的集合。上下文中的代码在执行时会创建变量对象的一个<strong>作用域链</strong>，代码正在执行的上下文的变量对象始终位于作用域链的最前端。全局上下文的变量对象始终位于作用域链尾部</p>\n<p>闭包（JS高程4）：指那些引用了另一个函数作用域中变量的<strong>函数</strong>。在一个函数内定义的函数会把其包含函数的活动(变量)对象添加到自己的作用域链中，外部函数的活动(变量)对象是内部函数作用域链上的第二个对象。闭包的本质是内部函数加长了其作用域链</p>\n<p>闭包（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\">MDN</a>）：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createComparisonFunction</span>(<span class=\"hljs-params\">propertyName</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">object1, object2</span>) {\n        <span class=\"hljs-keyword\">let</span> value1 = object1[propertyName];\n        <span class=\"hljs-keyword\">let</span> values = object2[propertyName];\n        \n        <span class=\"hljs-keyword\">if</span> (value1 &lt; value2) {\n            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (value1 &gt; value2) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> compare = <span class=\"hljs-title function_\">createComparisonFunction</span>(<span class=\"hljs-string\">&quot;name&quot;</span>);\n<span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title function_\">compare</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Nicholas&quot;</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;&quot;</span><span class=\"hljs-title class_\">Matt</span> });\n</code></pre>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/closure.png\" alt=\"closure\"></p>\n<p>作用域和上下文的区别：</p>\n<p>作用域是静态的，只要函数定义好了就一直存在并且不再发生变化。执行上下文是动态的，调用函数时创建，调用结束后会释放</p>\n<h2 id=\"this\">this</h2>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/this.png\" alt=\"this\"></p>\n<ul>\n<li>先判断函数类型(箭头函数？bind生成？普通函数？)</li>\n<li>普通函数判断调用方式(new？foo()？obj.foo()？)</li>\n<li>不管 <code>bind</code> 几次，<code>fn</code>中的<code>this</code>始终由第一次<code>bind</code>决定</li>\n<li>箭头函数中的<code>this</code>一旦被绑定就不会再改变</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>?.<span class=\"hljs-property\">a</span>);\n}\n\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">12</span>;\n\n<span class=\"hljs-keyword\">const</span> obj = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">13</span>,\n  fn\n};\n\n<span class=\"hljs-keyword\">const</span> obj2 = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">14</span>,\n  <span class=\"hljs-attr\">fn</span>: obj.<span class=\"hljs-property\">fn</span>,\n  <span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-title function_\">fn</span>();\n  },\n};\n\n<span class=\"hljs-title function_\">fn</span>(); <span class=\"hljs-comment\">// undefined</span>\nobj.<span class=\"hljs-title function_\">fn</span>(); <span class=\"hljs-comment\">// 13</span>\nobj2.<span class=\"hljs-title function_\">fn</span>(); <span class=\"hljs-comment\">// 14</span>\nobj2.<span class=\"hljs-title function_\">fn2</span>(); <span class=\"hljs-comment\">// undefined</span>\n</code></pre>\n<h2 id=\"时的类型转换\">==时的类型转换</h2>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/%3D%3D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png\" alt=\"==时的类型转换\"></p>\n<h2 id=\"对象转原始类型\">对象转原始类型</h2>\n<p>对象转原始类型会调用内置的[[ToPrimitive]]函数：</p>\n<ol>\n<li>如果存在<code>Symbol.toPrimitive()</code>方法，调用后返回</li>\n<li>调用<code>valueOf()</code>，如果转换为原始类型则返回（使用<code>obj.valueOf = xxx</code>来定义）</li>\n<li>调用<code>toString()</code>，如果转换为原始类型则返回</li>\n<li>如果都没有返回原始类型则报错</li>\n</ol>\n<h2 id=\"原型\">原型</h2>\n<p>每个构造函数都有(<code>prototype</code>)一个原型对象，原型有一个属性(<code>constructor</code>)指回构造函数，而实例有一个内部指针(<code>__proto__</code>)指向原型</p>\n<p>如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地如果另一个原型也有一个指针指向另一个构造函数。这样就在原型和实例之间构造了一条原型链。</p>\n<p><code>__proto_</code>_指向<strong>构造函数</strong>的原型，存在于<strong>对象</strong>中，指向<strong>原型</strong></p>\n<p><code>prototype</code>存在于<strong>函数</strong>中，指向<strong>原型</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">User</span>(<span class=\"hljs-params\"></span>) {}\n\n<span class=\"hljs-keyword\">const</span> tom = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>();\n\ntom.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">User</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-title class_\">User</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">User</span> <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/prototype.png\" alt=\"原型\"></p>\n<p><a href=\"\">new的原理及手动实现</a>\n<a href=\"\">继承</a></p>\n<h2 id=\"new\">new</h2>\n<p>过程：</p>\n<ol>\n<li>在内存中创建一个新的空对象</li>\n<li>这个新对象内部的<code>__proto__</code>指针被赋值为构造函数的<code>prototype</code>值</li>\n<li>构造函数内部的<code>this</code>被赋值为这个新对象（即<code>this</code>指向新对象）</li>\n<li>执行构造函数内部的代码（给新对象添加属性）</li>\n<li>如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> obj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>()\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Con</span> = [].<span class=\"hljs-property\">shift</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>)\n    obj.<span class=\"hljs-property\">__proto__</span> = <span class=\"hljs-title class_\">Con</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>\n    <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title class_\">Con</span>.<span class=\"hljs-title function_\">apply</span>(obj, <span class=\"hljs-variable language_\">arguments</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">&#x27;object&#x27;</span> ? result : obj\n}\n</code></pre>\n"}},"__N_SSG":true}