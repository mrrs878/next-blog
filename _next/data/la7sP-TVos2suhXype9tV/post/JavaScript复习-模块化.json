{"pageProps":{"post":{"title":"JavaScript复习-模块化","tags":["JavaScript","模块化"],"categories":"2021复习","description":"## 模块化解决的问题\n\n- 外部模块的管理\n- 内部模块的组织\n- 模块源码到目标代码的编译和转换\n\n## 时间线\n\n|  生态  |  诞生时间  |\n| -- | -- |\n|Node.js|2009|\n|NPM|2010|\n|requireJS(AMD)|2010|\n|seaJS(cmd)|2011|\n|browserify|2011|\n|webpack|2012|\n|grunt|20","createDate":"2021-05-12 04:30:39","updateDate":"2024-04-01 23:26:16","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">模块化解决的问题</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li>外部模块的管理</li>\n<li>内部模块的组织</li>\n<li>模块源码到目标代码的编译和转换</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">时间线</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <table>\n<thead>\n<tr>\n<th>生态</th>\n<th>诞生时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.js</td>\n<td>2009</td>\n</tr>\n<tr>\n<td>NPM</td>\n<td>2010</td>\n</tr>\n<tr>\n<td>requireJS(AMD)</td>\n<td>2010</td>\n</tr>\n<tr>\n<td>seaJS(cmd)</td>\n<td>2011</td>\n</tr>\n<tr>\n<td>browserify</td>\n<td>2011</td>\n</tr>\n<tr>\n<td>webpack</td>\n<td>2012</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>2012</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>2013</td>\n</tr>\n<tr>\n<td>react</td>\n<td>2013</td>\n</tr>\n<tr>\n<td>vue</td>\n<td>2014</td>\n</tr>\n<tr>\n<td>angular</td>\n<td>2016</td>\n</tr>\n<tr>\n<td>vite</td>\n<td>2020</td>\n</tr>\n<tr>\n<td>snowpack</td>\n<td>2020</td>\n</tr>\n</tbody></table>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">外部模块的管理</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">script标签</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>如果我们要在项目里使用某个外部模块，最简单的方法就是去官网把相关的js文件下载下来放在项目目录，在要使用的html页面里通过script标签引用。这样简单粗暴的方法缺点明显：</p>\n<ul>\n<li>使用上缺乏便利性</li>\n<li>难以跟踪各个外部模块的来源</li>\n<li>没有统一的版本管理机制</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">npm</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>2010年，npm伴随着Node.js的新版本一起发布。此后，外部模块管理从原始社会进入现代社会。</p>\n<ul>\n<li>npm是一个远程的JavaScript代码仓库，所有的开发者都可以向这里提交可共享的模块，供其他开发者下载使用</li>\n<li>npm还包含一个命令行工具，开发者通过运行<code>npm publish</code>将自己写的模块发布到npm仓库，通过运行<code>npm install xxx</code>可以将别人的模块下载到自己项目根目录下一个叫<code>node_modules</code>的文件夹里</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">内部模块的组织</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">script标签</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>同引入外部模块一样，通过IIFE去组织内部模块并通过<code>script</code>标签引用</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-keyword\">var</span> moduleA = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// ...</span>\n})(<span class=\"hljs-variable language_\">window</span>);\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-keyword\">var</span> moduleB = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// ...</span>\n})(<span class=\"hljs-variable language_\">window</span>);\n</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>&quot;/<span class=\"hljs-attr\">path</span>/<span class=\"hljs-attr\">to</span>/<span class=\"hljs-attr\">a.js</span>&quot;&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>&quot;/<span class=\"hljs-attr\">path</span>/<span class=\"hljs-attr\">to</span>/<span class=\"hljs-attr\">b.js</span>&quot;&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>这种简单粗暴的方式缺点比较明显：</p>\n<ul>\n<li>随着项目扩大，html文件中会包含大量<code>script</code>标签</li>\n<li>模块间的复杂依赖关系仅靠<code>script</code>标签引用顺序来组织</li>\n<li>污染全局环境，可能存在命名冲突</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AMD&amp;CMD&amp;CommonJS&amp;ESM</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>AMD/CMD只是一种设计规范，而不是实现。AMD的主要实现有两个(RequireJS和curl.js)，CMD的主要实现有(sea.js)</p>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AMD(Asynchronous Module Define)主要包含两个API：<strong>define</strong>和<strong>require</strong></span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>define方法用于定义一个模块，接收两个参数：</p>\n<ul>\n<li>第一个参数是数组表示这个模块所依赖的其他模块</li>\n<li>第二个参数是一个回调函数，通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，返回值将作为其他依赖模块的引用</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&#x27;Module1&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"><span class=\"hljs-variable language_\">module</span></span>) {\n    <span class=\"hljs-keyword\">return</span> {\n    }\n}); \n\n<span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;math&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">math</span>) {\n　 math.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-number\">15</span>)\n});\n</code></pre>\n<p><code>define</code>能自定义模块而<code>require</code>只能引用其他模块，<code>require</code>的真正作用是执行模块加载</p>\n<p>AMD规范去除了纯粹用script便签顺组组织模块带来的问题</p>\n<ol>\n<li>通过依赖数组的方式声明依赖关系，具体依赖关系交给具体的AMD框架处理</li>\n<li>避免生命全局变量带来的环境污染和变量冲突问题</li>\n<li>模块异步加载，防止JS加载阻塞页面渲染</li>\n</ol>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CMD(Common Module Definition)</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>有一个<code>define</code>API,接收一个<code>factory</code>回调函数，有三个参数：</p>\n<ul>\n<li>require：一个方法标识符，调用它可以动态的获取一个依赖模块的输出</li>\n<li>exports：一个对象，用于对其他模块提供输出接口，例如<code>exports.name = xxx</code></li>\n<li>module：一个对象，存储了当前模块相关的一些属性和方法，其中<code>module.exports</code>等同于<code>exports</code></li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">require</span>, <span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-variable language_\">module</span></span>) {\n    <span class=\"hljs-keyword\">var</span> moduleA = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;/path/to/ModuleA&#x27;</span>);\n    <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {}\n})\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CMD&amp;AMD的区别</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>一方面，在依赖的处理上</p>\n<ul>\n<li>AMD依赖前置，即通过依赖数组的方式提前声明当前模块的依赖</li>\n<li>CMD依赖就近，在需要用到的时候通过调用<code>require</code>方法动态导入</li>\n</ul>\n<p>另一方面，在本模块的输出上</p>\n<ul>\n<li>AMD通过返回值的方式对外输出</li>\n<li>CMD通过给<code>module.exports</code>赋值的方式对外输出</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">CommonJS&amp;ESM</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><code>CommonJS</code>是Node.js使用的模块化方式</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> ramda = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ramda&#x27;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {}\n</code></pre>\n<p><code>ESM</code>是<code>ES6</code>提出的模块化方案</p>\n<pre><code class=\"hljs language-js\">impot { clone } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;ramda&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>CommonJS</th>\n<th>ESM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>加载时间</td>\n<td>运行时加载</td>\n<td>编译时输出接口</td>\n</tr>\n<tr>\n<td>输出方式</td>\n<td>原始类型为值的拷贝，引用类型为值的引用(指针)</td>\n<td>值的引用(指针)</td>\n</tr>\n</tbody></table>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">输出方式比对</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// CommonJS</span>\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">let</span> obj = {\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">increaseA</span>(<span class=\"hljs-params\"></span>) {\n    a += <span class=\"hljs-number\">1</span>;\n    obj.<span class=\"hljs-property\">a</span> += <span class=\"hljs-number\">1</span>;\n}\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = { a, increaseA, obj };\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a, obj); <span class=\"hljs-comment\">// 1 { a: 1 }</span>\n<span class=\"hljs-title function_\">increaseA</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 1 { a: 2 }</span>\n\n<span class=\"hljs-comment\">// ESM</span>\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">let</span> obj = {\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>,\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">increaseB</span>(<span class=\"hljs-params\"></span>) {\n    b += <span class=\"hljs-number\">1</span>;\n    obj.<span class=\"hljs-property\">b</span> += <span class=\"hljs-number\">1</span>;\n}\n<span class=\"hljs-keyword\">export</span> { b, increaseB, obj };\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 1 { b: 1 }</span>\n<span class=\"hljs-title function_\">increaseB</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 2 { b: 1 }</span>\n</code></pre>\n\n      <h4>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">ESM如何解决循环依赖问题</span>\n        <span class=\"suffix\"></span>\n      </h4>\n    <p>ESM 在编译时会构建出一份模块之间的关系图，会标记<em>加载中</em>的模块，这样便可识别出哪些模块间存在循环依赖；同时，在 ESM 模块中，导入的变量实际上是对导出变量的引用，这些引用被称为 <strong>顶层引用</strong> 。当存在循环依赖时，模块将导出一个未完成的值(undefined)给依赖模块，而不是抛出异常。但当引用<em>加载中</em>模块导出的变量时，会报错。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// a.js</span>\n<span class=\"hljs-keyword\">import</span> { foo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./circle-b.mjs&#x27;</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a.js is loading&quot;</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-string\">&#x27;bar&#x27;</span>;\n\n<span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-keyword\">import</span> { bar } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./circle-a.mjs&#x27;</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;b.js is loading&quot;</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;\n\n<span class=\"hljs-comment\">// node circle-a.mjs</span>\n<span class=\"hljs-comment\">// b.js is loading</span>\n<span class=\"hljs-comment\">// a.js is loading</span>\n</code></pre>\n<ol start=\"0\">\n<li>当执行 a.js 时，标记 a.js 为 “获取中”</li>\n<li>当 a.js 导入 b.js 时，ESM 会标记 b.js 为“获取中”，以避免再次进入。</li>\n<li>当 b.js 导入 a.js 时，ESM 会发现 a.js 已经被标记为“获取中”，因此不会再次进入。</li>\n<li>这样，循环引用不会导致死循环。</li>\n</ol>\n<p>但当 <code>circle-b.mjs</code> 引用 <code>bar</code> 时，则会报错</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// b.js</span>\n<span class=\"hljs-keyword\">import</span> { bar } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./circle-a.mjs&#x27;</span>;\n\n<span class=\"hljs-comment\">// 在这里直接引用 foo</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;a.js is loading&quot;</span>, bar);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">&#x27;foo&#x27;</span>;\n\n<span class=\"hljs-comment\">// 报错 ReferenceError: Cannot access &#x27;bar&#x27; before initialization</span>\n</code></pre>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">webpack/browserify</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>AMD/CMD可以看作在线编译模块的方法，也就是等浏览器下载了这些js文件后才进行模块依赖分析，确定加载顺序和执行顺序，带来了一些问题</p>\n<ul>\n<li>增加代码加载时间，影响用户体验</li>\n<li>http请求过多，降低页面性能</li>\n</ul>\n<p>于是有以下对应方法去解决：</p>\n<ul>\n<li>提前将模块组织好</li>\n<li>进行代码合并，把多个<code>script</code>的代码合并到少数几个文件中减少http请求个数</li>\n</ul>\n<p>具有代表性的是<code>webpack</code>和<code>browserify</code></p>\n<p><img src=\"http://mrrsblog.oss-cn-shanghai.aliyuncs.com/webpack.png\" alt=\"webpack\"></p>\n<p>打包工具面临的问题&amp;&amp;解决方案</p>\n<p><strong>打包后的文件体积过大</strong></p>\n<p>代码打包的初衷是减少AMD/CMD等框架造成的加载脚本数量过多的问题，但也带来了打包后单个文件体积过大的问题：如此一来，首屏加载时间缓慢，体验较差</p>\n<p>于是webpack引入了代码拆分的功能(Code Splitting)来解决这个问题, 从全部打包后退一步：可以打包成多个包</p>\n<ul>\n<li>第三方库和业务代码的分离：业务代码更新频率快，而第三方库代码更新频率是比较慢的。分离之后可利用浏览器缓存机制加载第三方库，从而加快页面访问速度</li>\n<li>按需加载: 例如我们经常通过前端路由分割不同页面，除了首页外的很多页面(路由)可能访问频率较低，我们可将其从首次加载的资源中去掉，而等到相应的触发时刻再去加载它们。这样就减少了首屏资源的体积，提高了页面加载速度。</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">bundleless(snowpack/vite)</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>利用现代浏览器对ES6普遍支持良好的现状，开发环境下不进行打包。借助浏览器 ESM 的能力，一些代码基本可以做到无需构建直接运行。代表性工具是vite和snowpack</p>\n<p>为什么要打包？</p>\n<p>对于早期的 web 应用而言，打包模块既能够处理 JS 模块化，又能将多个模块打包合并网络请求。使用这类构建工具打包项目的确是个不错的选择。时至今日基本上主流的浏览器版本都支持 ESM，并且并发网络请求带来的性能问题，在 HTTP/2 普及下不像以前那么凸显的情况下，大家又将目光转向了 ESM。就目前的体验而言，基于原生 ESM 在开发过程中的构建速度似乎远远优于 webpack 之类的打包工具的。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://zhuanlan.zhihu.com/p/265632724\">前端模块化的十年征程</a></p>\n<p><a href=\"https://juejin.cn/post/6947890290896142350\">ESM vs Webpack 面向高性能构建的探索</a></p>\n"}},"__N_SSG":true}