{"pageProps":{"post":{"title":"前端架构&软实力-pnpm","tags":["pnpm"],"categories":"前端架构&软实力","description":"[pnpm](https://pnpm.io) 全称是 “Performant NPM”，即高性能的 npm。它结合软硬链接与新的依赖组织方式，大大提升了包管理的效率，也同时解决了 “幽灵依赖” 的问题，让包管理更加规范，降低潜在风险发生的可能性\n\n## 安装\n\n```bash\nnpm i pnpm -g\n```\n\n## pnpm 在管理 package 时的区别\n\nnpm2 是通过嵌套的方式管","createDate":"2022-08-15 19:11:45","updateDate":"2022-08-15 20:11:45","body":"<p><a href=\"https://pnpm.io\">pnpm</a> 全称是 “Performant NPM”，即高性能的 npm。它结合软硬链接与新的依赖组织方式，大大提升了包管理的效率，也同时解决了 “幽灵依赖” 的问题，让包管理更加规范，降低潜在风险发生的可能性</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">安装</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <pre><code class=\"hljs language-bash\">npm i pnpm -g\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm 在管理 package 时的区别</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>npm2 是通过嵌套的方式管理 <code>node_modules</code> 的，会有依赖复制多次的问题。</p>\n<p>npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 <code>node_modules</code> ，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。</p>\n<p>pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 <code>node_modules/.pnpm</code> ，然后之间通过软链接来组织依赖关系。</p>\n<p>这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm 的优势</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单描述一下 pnpm 的优势：</p>\n<ul>\n<li><p>快。安装速度快</p>\n</li>\n<li><p>准。安装过的依赖会被精准缓存并拿来复用，甚至包版本升级带来的变化都只 diff，绝不浪费一点空间，逻辑上也严丝合缝</p>\n</li>\n<li><p>狠。废除幽灵依赖，提升包管理的效率</p>\n</li>\n</ul>\n<p>pnpm 的 <code>node_modules</code> 结构</p>\n<p><img src=\"/img/pnpm-node-modules-structure.jpeg\" alt=\"pnpm-node-modules-structure\"></p>\n<ul>\n<li><p>所有的 package 都安装在全局目录 <code>~/.pnpm/v3/files</code> 下，同一版本的包只存储一份内容，甚至不同版本的包也仅存储 diff 内容</p>\n</li>\n<li><p>每个项目的 <code>node_modules</code> 下有 <code>.pnpm</code> 目录以平级结构管理每个版本的包的源码内容，以<strong>硬连接</strong>方式指向 pnpm-store 中的文件地址</p>\n</li>\n<li><p>每个项目的 <code>node_modules</code> 下安装的包结构为树状，以<strong>软链接</strong>的方式将内容指向 <code>node_modules/.pnpm</code> 中的包（类似于npm2）</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">寻址方式</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>针对于使用 <code>pnpm</code> 管理的包，寻址一般会经历以下步骤：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// index.js</span>\n<span class=\"hljs-keyword\">import</span> { something } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;bar&quot;</span>;\n</code></pre>\n<p>针对于 <code>bar</code> 这个包，寻址时的路径大概是这样的：</p>\n<p><code>node_modules/bar</code> -&gt;(软链) <code>node_modules/.pnpm/bar@1.0.0/node_modules/bar</code> -&gt;(硬链) <code>~/.pnpm-store/v3/files/00/xxx</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">幽灵依赖</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>有些项目中未安装的包（未在 <code>package.json</code> 中声明），但仍然可以在项目里使用</p>\n<p>产生的原因：在安装的时候， npm/yarn 会通过铺平的扁平化的方式来管理 <code>node_modules</code> ，因此在项目文件中是可以寻址到这个包的</p>\n<p>因为 pnpm 特殊的寻址设计，使得第一层可以仅包含 <code>package.json</code> 定义的包，使 <code>node_modules</code> 不可能寻址到未定义在 <code>package.json</code> 中的包，自然就解决了幽灵依赖的问题</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">硬链接/软链接</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>硬链接通过 <code>ls originFilePath sourceFilePath</code> 创建，这样创建出来的两个文件都指向同一个文件存储地址，因此无论修改哪个文件，都相当于直接修改了原始地址的内容，导致两个文件内容同时变化。进一步说，通过硬链接创建的文件都是等效的，通过 <code>ls li ./</code> 查看文件属性时，可看到该文件有几个硬链接引用</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 创建源文件</span>\n<span class=\"hljs-built_in\">touch</span> t.txt\n\n<span class=\"hljs-comment\"># 编辑源文件（输入rererererere）</span>\nvim t.txt\n\n<span class=\"hljs-comment\"># 创建硬链接</span>\n<span class=\"hljs-built_in\">ln</span> t.txt t_h.txt\n\n<span class=\"hljs-comment\"># 查看源/目文件内容</span>\n<span class=\"hljs-built_in\">cat</span> t.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-built_in\">cat</span> <span class=\"hljs-built_in\">cat</span> t_h.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-comment\"># 查看源/目文件信息</span>\n<span class=\"hljs-built_in\">ls</span> -li ./t_h.txt ./t.txt\n\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t.txt</span>\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t_h.txt</span>\n\n<span class=\"hljs-comment\"># 2 则表示该文件有几个硬链接引用</span>\n</code></pre>\n<p>软链接通过 <code>ls -s originFilePath sourceFilePath</code> 创建，可以认为是指向文件地址指针的指针，相当于常见的<em>快捷方式</em></p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># 创建软链接</span>\n<span class=\"hljs-built_in\">ln</span> -s t.txt t_s.txt\n\n<span class=\"hljs-comment\"># 查看文件内容</span>\n<span class=\"hljs-built_in\">cat</span> t_s.txt <span class=\"hljs-comment\"># rererererere</span>\n\n<span class=\"hljs-comment\"># 查看文件信息</span>\n<span class=\"hljs-built_in\">ls</span> -li ./t_s.txt ./t.txt\n\n<span class=\"hljs-comment\"># 25881318 -rw-r--r--  2 echo  staff  13  8 15 19:41 ./t.txt</span>\n<span class=\"hljs-comment\"># 25881568 lrwxr-xr-x  1 echo  staff   5  8 15 19:46 ./t_s.txt -&gt; t.txt</span>\n</code></pre>\n<p>源文件被删除后，软链接会失效，但硬链接不会，软链接可以对文件夹生效。软链接本身只占很小的存储空间，硬链接 0 占用</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">pnpm-store</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>该目录可通过 <code>pnpm store path</code> 查看</p>\n<p>TODO</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/253.%E7%B2%BE%E8%AF%BB%E3%80%8Apnpm%E3%80%8B.md\">253.精读《pnpm》.md</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/412419619\">幽灵依赖</a></p>\n"}},"__N_SSG":true}