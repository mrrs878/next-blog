{"pageProps":{"post":{"title":"ES6重点-1","tags":["ES6"],"categories":"JavaScript","description":"## 字符串新增方法\n\n- `padStart`\n\n  用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全\n\n  ```js\n  console.log('xxx'.padStart(4, 'ab'));\n  console.log('x'.padStart(4, 'ab')); //补全位数，有需要会重复或截取\n  console.log('x'.padStart(4));","createDate":"2020-02-19 23:01:48","updateDate":"10/1/2021, 3:34:43 AM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">字符串新增方法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>padStart</code></p>\n<p>用于字符串长度补全，如果某个字符串长度不够指定长度会在头部或尾部补全</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>)); <span class=\"hljs-comment\">//补全位数，有需要会重复或截取</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">4</span>)); <span class=\"hljs-comment\">// 不传第二个参数默认使用空格补全</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padStart</span>(<span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 补全后的长度小于源字符串长度则不做任何改变</span>\n\n<span class=\"hljs-comment\">// abax</span>\n<span class=\"hljs-comment\">// axxx</span>\n<span class=\"hljs-comment\">//    x</span>\n<span class=\"hljs-comment\">// xxx</span>\n</code></pre>\n</li>\n<li><p><code>padEnd</code></p>\n<p>和<code>padStart</code>效果相反，从尾部开始补全</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;abc&#x27;</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">2</span>));\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;xxx&#x27;</span>.<span class=\"hljs-title function_\">padEnd</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;ab&#x27;</span>));\n\n<span class=\"hljs-comment\">// xabca</span>\n<span class=\"hljs-comment\">// x   </span>\n<span class=\"hljs-comment\">// xxx</span>\n<span class=\"hljs-comment\">// xxxa</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对象新增扩展</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p>链判断运算符</p>\n<p>在ES5中，取对象属性时，往往需要判断以下该对象是否存在。如下</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = (store \n    &amp;&amp; store.<span class=\"hljs-property\">state</span> \n    &amp;&amp; store.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">user</span> \n    &amp;&amp; store.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">user</span>.<span class=\"hljs-property\">name</span>) || <span class=\"hljs-string\">&quot;tom&quot;</span>\n</code></pre>\n<p>这种层层判断过于麻烦，因此ES2020引入链判断运算符<code>?.</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = store?.<span class=\"hljs-property\">state</span>?.<span class=\"hljs-property\">user</span>?.<span class=\"hljs-property\">name</span>\n</code></pre>\n<p>如果左侧的对象为<code>null</code>或<code>undefined</code>则直接返回<code>undefined</code>，不再往下运算</p>\n</li>\n<li><p><code>null</code>判断运算符</p>\n<p>独去对象属性时，如果某个属性的值时<code>null</code>或<code>undefined</code>，有时需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = user.<span class=\"hljs-property\">name</span> || <span class=\"hljs-string\">&quot;tom&quot;</span>\n<span class=\"hljs-keyword\">const</span> age = user.<span class=\"hljs-property\">age</span> || <span class=\"hljs-number\">20</span>\n</code></pre>\n<p>原意是属性值为<code>null</code>或<code>undefined</code>时默认值就生效，但当<code>user.name</code>为空串或<code>user.age</code>为0时默认值也会生效</p>\n<p>为此ES2020引入新的<code>null</code>判断运算符<code>??</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> name = user.<span class=\"hljs-property\">name</span> ?? <span class=\"hljs-string\">&quot;tom&quot;</span>\n<span class=\"hljs-keyword\">const</span> age = user.<span class=\"hljs-property\">age</span> ?? <span class=\"hljs-number\">20</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">对象新增方法</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>Object.is</code></p>\n<p>用来替代 <code>==</code>和<code>===</code></p>\n<p><code>==</code> 会进行自动类型转换，<code>===</code> 在比较+0和-0时返回<code>true</code>，<code>NaN</code>不等于自身</p>\n</li>\n<li><p><code>Object.assign</code></p>\n<p>用于对象合并</p>\n<ul>\n<li>只拷贝源对象的<strong>自身、可枚举属性（含Symbol）</strong></li>\n<li>浅拷贝</li>\n<li>同名属性会被覆盖</li>\n<li>除首参数外（<code>null</code>、<code>undefined</code>会报错），非对象会被转换为对象</li>\n</ul>\n</li>\n<li><p><code>Object.keys</code></p>\n<p>返回对象<strong>自身的</strong>、<strong>可遍历的</strong>属性的键名<strong>数组</strong></p>\n</li>\n<li><p><code>Object.fromEntries/Object.entries</code></p>\n<p><code>Object.fromEntries</code>将一个键值对数组转换为一个对象，适合将<code>Map</code>转换为<code>Object</code></p>\n<p><code>Object.entries</code>逆操作，用于将<code>Object</code>转换为键值对数组</p>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Array扩展</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><code>Array.of</code></p>\n<p>弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Array</span>() <span class=\"hljs-comment\">//[]</span>\n<span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//[ , , ]</span>\n<span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">//[3, 4, 5]</span>\n\n<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>() <span class=\"hljs-comment\">// []</span>\n<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">//[3]</span>\n<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">//[3, 4, 5]</span>\n</code></pre>\n</li>\n<li><p><code>Array.prototype.copyWithin()</code></p>\n<p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">copyWithin</span>(target, start = <span class=\"hljs-number\">0</span>, end = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">length</span>)\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-comment\">// [4, 5, 3, 4, 5]</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\n<span class=\"hljs-comment\">// [4, 2, 3, 4, 5]</span>\n</code></pre>\n</li>\n<li><p><code>Array.prototype.flat() &amp;&amp; Array.prototype.flatMap()</code></p>\n<p><code>flat()</code>用于将数据降维，参数为降低的维数（默认为1）,如果不管有多少层维，都要转为一维数组，可使用<code>Infinity</code>关键字作为参数</p>\n<p>如果原数组有空位<code>flat()</code>会跳过</p>\n<pre><code class=\"hljs language-js\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]].<span class=\"hljs-title function_\">flat</span>()\n<span class=\"hljs-comment\">// [1, 2, 1, 2]</span>\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>]]].<span class=\"hljs-title function_\">flat</span>()\n<span class=\"hljs-comment\">// [1, 2, 1, 2, 1, [2]]</span>\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>]]].<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// [1, 2, 1, 2, 1, 2]</span>\n\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>]]].<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-title class_\">Infinity</span>)\n<span class=\"hljs-comment\">// [1, 2, 1, 2, 1, 2]</span>\n</code></pre>\n<p><code>flatMap()</code>相当于<code>Array.prorotype.Map</code> + <code>Array.prorotype.flat</code></p>\n<pre><code class=\"hljs language-js\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> [x, x * <span class=\"hljs-number\">2</span>])\n<span class=\"hljs-comment\">// [1, 2, 2, 4, 3, 6]</span>\n[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// [2, 4, 6]</span>\n</code></pre>\n</li>\n</ul>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">iterator</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><strong>WHAT</strong></p>\n<p>遍历器（<code>iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了<code>iterator</code>接口，就可以完成<strong>遍历</strong>操作</p>\n<p><strong>WHY</strong></p>\n<p>JavaScript原有的表示集合的数据结构主要是数组（Array）和对象（Object），ES6又添加了<code>Map</code>、<code>Set</code>。这样就有了四种数据集合，用户可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样需要一种统一的接口机制来处理不同的数据结构</p>\n<p>主要作用</p>\n<ul>\n<li><p>为各种数据结构提供一个统一的、简便的访问接口</p>\n</li>\n<li><p>使得数据结构的成员能够按某种次序排列</p>\n</li>\n<li><p>为<code>for...of</code>所使用</p>\n<p>适合遍历Array，既有<code>forEach</code>的简洁又有<code>for</code>的<code>break</code>、<code>return</code>、<code>continue</code></p>\n</li>\n</ul>\n<p><strong>HOW</strong></p>\n<p><code>iterator</code>的遍历过程</p>\n<ol>\n<li>创建一个指针对象，指向当前的数据结构的起始位置。也就是说遍历器对象本质上就是一个指针对象</li>\n<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</li>\n<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</li>\n<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</li>\n</ol>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象，其中<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示是否遍历结束</p>\n<p>ES6规定，默认的<code>iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是可遍历的（<code>iterable</code>）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = {\n    <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-string\">&#x27;hello&#x27;</span>, <span class=\"hljs-string\">&#x27;world&#x27;</span>],\n    [<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>](): {\n        <span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-variable language_\">this</span>\n        <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-keyword\">if</span> (index &lt; self.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">length</span>) {\n                    <span class=\"hljs-keyword\">return</span> {\n                        <span class=\"hljs-attr\">value</span>: self.<span class=\"hljs-property\">data</span>[index++]\n                        <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>\n                    }\n                }\n                <span class=\"hljs-keyword\">return</span> {\n                    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>,\n                    <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">true</span>\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>原生具备iterator接口的数据结构：<code>Map、Array、Set、String、TypedArray、arguments、NodeList对象</code></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">let VS const</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在let和const之间，建议优先使用const，尤其是在全局环境。const优于let的几个原因：</p>\n<ul>\n<li>const可以提醒阅读程序的人，这个变量不应该改变</li>\n<li>const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式计算</li>\n<li>JavaScript编译器会对const进行优化</li>\n<li>长远来看，JavaScript可能会有多线程的实现，这时let表示的变量只应出现在单线程运行的代码中，不是多线程共享的，这样有利于线程安全</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// bad</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>, b = <span class=\"hljs-number\">2</span>, c = <span class=\"hljs-number\">3</span>\n<span class=\"hljs-comment\">// good</span>\n<span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-number\">3</span>;\n<span class=\"hljs-comment\">// best</span>\n<span class=\"hljs-keyword\">const</span> [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n</code></pre>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">generator</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>ES6提供的一种异步编程解决方案</p>\n<p>形式上，<code>generator</code>函数是一个状态机，封装了多个内部状态。执行<code>generator</code>函数会返回一个<strong>遍历器对象</strong>。</p>\n<p>语法上，<code>generator</code>函数是一个普通函数。<code>function</code>关键字与函数名之间有一个<code>*</code>；函数体内部使用<code>yield</code>表达式定义不同的内部状态</p>\n<p>与普通函数不同，generator函数被调用后并不执行，返回的是一个指向内部状态的指针对象，也就是<strong>遍历器对象</strong>。下一步，必须调用遍历器对象的<code>next</code>方法使得指针移向下一个状态。也就是说每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> str1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;hello&quot;</span>\n  <span class=\"hljs-comment\">// str1 = 222</span>\n  <span class=\"hljs-keyword\">const</span> str2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;world&quot;</span>\n  <span class=\"hljs-comment\">// str2 = 333</span>\n  <span class=\"hljs-keyword\">return</span> str2\n}\n\n<span class=\"hljs-keyword\">const</span> iter = <span class=\"hljs-title function_\">gen</span>()\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>())\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">222</span>))\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iter.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">333</span>))\n</code></pre>\n<p>第一次调用，<code>generator</code>函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>值就是当前<code>yield</code>表达式的值，done的值为<code>false</code></p>\n<p>第二次调用，<code>generator</code>从上次yield表达式停下来的地方一直执行到下一个<code>yield</code>表达式 👆 ……</p>\n<p>第三次调用，<code>generator</code>函数从上次<code>yield</code>表达式停下来的地方一直执行到<code>return</code>语句，next返回的<code>value</code>值就是<code>return</code>后面表达式的值，<code>done</code>为true（如果是<code>yield</code>则为<code>false</code>）</p>\n<p><code>yield</code>表达式本身没有返回值（或者说总是返回undefined）。<code>next</code>方法可以带一个参数，该参数会被当作<strong>上一个</strong><code>yield</code>表达式的返回值</p>\n"}},"__N_SSG":true}