{"pageProps":{"post":{"title":"webpack学习-chunk分包","tags":["webpack","chunk"],"categories":"webpack","description":"学习 webpack5 中 chunk 分包规则\n\n## module vs chunk\n\n在 webpack 中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGra","createDate":"2022-05-31 21:41:47","updateDate":"2022-05-31 21:41:47","body":"<p>学习 webpack5 中 chunk 分包规则</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">module vs chunk</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>在 webpack 中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGraph 对 Chunk 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 Chunks 。运行完毕之后 webpack 继续将 chunk 一一写入物理文件中，完成编译工作。</p>\n<p>综上，Module 主要作用在 webpack 编译过程的前半段，解决原始资源“「如何读」”的问题；而 Chunk 对象则主要作用在编译的后半段，解决编译产物“「如何写」”的问题，两者合作搭建起 webpack 搭建主流程。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">默认分包规则</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>简单总结下:</p>\n<ul>\n<li><p>同一个 <code>entry</code> 下可触达的模块组织成一个 chunk</p>\n</li>\n<li><p>异步模块单独划分为一个 chunk</p>\n</li>\n<li><p><code>entry.runtime</code>单独划分为一个 chunk</p>\n</li>\n</ul>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">entry</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>seal 阶段遍历 entry 对象，为每一个 entry 单独生成 chunk，之后再根据模块依赖图将 entry 触达到的所有模块打包进 chunk 中。</strong></p>\n<p>对于如下打包配置和文件依赖</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;development&quot;</span>,\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">index</span>: <span class=\"hljs-string\">&quot;./src/chunk/index.js&quot;</span>,\n    <span class=\"hljs-attr\">main</span>: <span class=\"hljs-string\">&quot;./src/chunk/main.js&quot;</span>,\n  },\n  <span class=\"hljs-attr\">optimization</span>: {\n    <span class=\"hljs-attr\">usedExports</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-literal\">false</span>,\n};\n</code></pre>\n<p><img src=\"/img/webpack-chunk-1.png\" alt=\"webpack entry划分chunk-文件依赖\"></p>\n<p>在示例中， <code>index.js</code>和 <code>main.js</code> 分别静态引入了几个文件</p>\n<p>在 <code>npx webpack --json &gt; info.json</code> 打包后的输出结果是这样的</p>\n<p><img src=\"/img/webpack-chunk-0.png\" alt=\"webpack entry划分chunk-打包结果\"></p>\n<p>可以看到，一共生成了两个 chunk</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">异步模块</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>每次遇到异步模块都会为之创建单独的 Chunk 对象，单独打包异步模块。</strong></p>\n<p>还以上述配置和代码为例，只是将 <code>a.js</code> 改为动态引入，即<code>import(&#39;a.js&#39;)</code></p>\n<p><img src=\"/img/webpack-chunk-2.png\" alt=\"webpack 动态import分包\"></p>\n<p>此时重新执行<code>npx webpack --json &gt; info.json</code> 打包后的输出结果是这样的</p>\n<p><img src=\"/img/webpack-chunk-3.png\" alt=\"webpack 动态import分包\"></p>\n<p>可以看到新增了一个 chunk</p>\n\n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">entry.runtime</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p><strong>Webpack 5 之后还能根据 entry.runtime 配置单独打包运行时代码。</strong></p>\n<p>除了 entry、异步模块外，webpack 5 之后还支持基于 runtime 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime。虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 entry.runtime 配置项用于声明如何打包运行时代码。用法上只需在 entry 项中增加字符串形式的 runtime 值，例如：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;development&quot;</span>,\n  <span class=\"hljs-attr\">entry</span>: {\n    <span class=\"hljs-attr\">index</span>: {\n      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&quot;./src/chunk/index.js&quot;</span>,\n      <span class=\"hljs-attr\">runtime</span>: <span class=\"hljs-string\">&quot;solid-runtime&quot;</span>,\n    },\n    <span class=\"hljs-attr\">main</span>: {\n      <span class=\"hljs-attr\">import</span>: <span class=\"hljs-string\">&quot;./src/chunk/main.js&quot;</span>,\n      <span class=\"hljs-attr\">runtime</span>: <span class=\"hljs-string\">&quot;solid-runtime&quot;</span>,\n    },\n  },\n  <span class=\"hljs-attr\">optimization</span>: {\n    <span class=\"hljs-attr\">usedExports</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-literal\">false</span>,\n};\n</code></pre>\n<p>此时再次执行 <code>npx webpack --json &gt; info.json</code>，打包结果如下</p>\n<p><img src=\"/img/webpack-chunk-4.png\" alt=\"webpack runtime分包\"></p>\n<p>可以看到，此时又新增了一个包，而且对比一下输出文件的大小，大部分文件输出到 <code>solid-runtime.js</code> 中， <code>index.js</code> 和 <code>main.js</code> 已经缩短到 30 行左右</p>\n<blockquote>\n<p>ps: 此时网站中需要单独引入 solid-runtime.js 文件</p>\n</blockquote>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">SplitChunk</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>// TODO</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3OTYwMjcxMA==&amp;mid=2247484029&amp;idx=1&amp;sn=7862737524e799c5eaf1605325171e32&amp;chksm=cf00bf04f8773612682f4650be2f78255912d0ca8ecafff1bd647a8a692ae28098436975908f&amp;scene=178&amp;cur_album_id=1856066636768722949#rd\">有点难的知识点： Webpack Chunk 分包规则详解</a></p>\n"}},"__N_SSG":true}