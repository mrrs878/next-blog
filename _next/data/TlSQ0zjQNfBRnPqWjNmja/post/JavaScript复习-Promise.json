{"pageProps":{"post":{"title":"JavaScript复习-Promise","tags":["JavaScript","Promise","Generator","Promise"],"categories":"2024复习","description":"深入研究一下 `Promise`\n\n🤔\n\n## 令人疑惑的执行顺序\n\n观察以下代码片段\n\n``` js\nnew Promise((resolve) => {\n  console.log('promise1 resolve');\n  resolve();\n}).then(() => {\n  console.log('promise1 then1');\n  new Promise((resolve","createDate":"2024-04-07 19:38:54","updateDate":"2024-04-09 10:30:28","body":"<p>深入研究一下 <code>Promise</code></p>\n<p>🤔</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">令人疑惑的执行顺序</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>观察以下代码片段</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise1 resolve&#x27;</span>);\n  <span class=\"hljs-title function_\">resolve</span>();\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise1 then1&#x27;</span>);\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise2 resolve&#x27;</span>);\n    <span class=\"hljs-title function_\">resolve</span>();\n  }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise2 then1&#x27;</span>);\n  }).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise2 then2&#x27;</span>);\n  })\n}).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise1 then2&#x27;</span>);\n})\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;hello Promise&#x27;</span>);\n\n<span class=\"hljs-comment\">// promise1 resolve</span>\n<span class=\"hljs-comment\">// hello Promise</span>\n<span class=\"hljs-comment\">// promise1 then1</span>\n<span class=\"hljs-comment\">// promise2 resolve</span>\n<span class=\"hljs-comment\">// promise2 then1</span>\n<span class=\"hljs-comment\">// promise1 then2</span>\n<span class=\"hljs-comment\">// promise2 then2</span>\n</code></pre>\n<p>Q1: 为什么 <code>hello Promise</code> 在较前打印？</p>\n<p>A1: 因为 <strong>非重入期约方法</strong> 机制，即： 当 <code>Promise</code> 进入 <code>Settled</code> 状态时，与该状态相关的处理程序仅仅会被排期（进入微任务队列），而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前执行。 <code>new Promise</code> 中的代码是同步的， <code>then</code> 方法中的处理程序是才是异步的。</p>\n<p>Q2: 为什么 <code>promise2 then1</code> 在 <code>promise1 then2</code> 前打印</p>\n<p>A2: 当打印 <code>promise2 resolve</code> 后，此时 <code>promise2</code> 进入 <code>Settled</code> 状态，此时会将 <code>promise2-then1</code> 添加进微任务队列，注意此时仍在<strong>执行微任务队列中</strong>的任务中，因此，接下来会打印 <code>promise2 then1</code> 。</p>\n<p>Q3: 为什么 <code>promise1 then2</code> 在 <code>promise2 then2</code> 前打印</p>\n<p>A3: 当打印完 <code>promise2 then1</code> 时，按理说应该注册 <code>promise2-then2</code> 回调，但编译器会优化，防止一个 <code>Promise</code> 占据过多时间。即<strong>如果有多个fulfilled的Promise实例，同时执行then链式调用，then会交替执行。</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么 Promise 状态不可逆</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>确保 <code>Promise</code> 的行为是可预测和可靠的。这个设计决定主要有以下几个原因:</p>\n<ul>\n<li><p>保证异步执行结果的可靠性:一旦 <code>Promise</code> 的状态被改变( <code>fulfilled</code> 或 <code>rejected</code> ),就不会再发生变化。这样可以确保异步操作的结果一定会被可靠地传递给后续的 then 或 catch 回调函数。</p>\n</li>\n<li><p>简化错误处理: <code>Promise</code> 的状态一旦改变就不可逆,这意味着一个 <code>Promise</code> 对象只会触发一次 <code>then</code> 或 <code>catch</code> 回调。这简化了错误处理的逻辑,开发者不需要担心状态再次改变而引发新的错误。</p>\n</li>\n<li><p>避免竞态条件: 如果 <code>Promise</code> 状态可逆,就可能出现竞态条件,即多个异步操作同时修改 <code>Promise</code> 状态,导致结果不可预测。状态不可逆可以避免这种情况的发生。</p>\n</li>\n<li><p>更好的并行和串行组合: <code>Promise</code> 的状态不可逆使得多个 <code>Promise</code> 的并行和串行组合变得更加简单和可靠。开发者可以放心地使用 <code>Promise.all</code> 、 <code>Promise.race</code> 等方法,不必担心状态的变化会影响结果。</p>\n</li>\n</ul>\n<p>总之, <code>Promise</code> 状态不可逆是为了确保异步编程中的可靠性和可预测性,这是 <code>Promise</code> 设计的一个重要特性。虽然有时会给开发带来一些限制,但总的来说这是一个合理的设计决定。</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么 try/catch 无法捕获 Promise.reject</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>如下所示</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;foo&quot;</span>));\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);\n}\n\n<span class=\"hljs-comment\">// Uncaught (in promise) Error: foo</span>\n</code></pre>\n<p><code>Promise.reject</code> 并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，代码一旦以异步模式执行，则唯一与之交互的方式就是使用异步结构--更具体地说，就是 <code>Promise</code> 的方法</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">为什么 Promise 不可取消</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <blockquote>\n<p>我们经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。这时候如果能够取消期约就好了。某些第三方库，比如Bluebird，就提供了这个特性。实际上，TC39 委员会也曾准备增加这个特性，但相关提案最终被撤回了。结果，ES6期约被认为是“激进的”: 只要期约的逻辑开始执行，就没有办法阻止它执行到完成 --JS高程4</p>\n</blockquote>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">一个 Promise 一直没有被 resolve 或 reject 会造成内存泄漏吗</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>分情况， <code>Promise</code> 可以认为是一个普通的对象，也遵循垃圾回收机制，当没有引用时，在合适的时机即被回收。但一些不规范的写法会造成内存泄漏，但却不是 <code>Promise</code> 引起的，比如下面的🌰</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(resolve, <span class=\"hljs-number\">100000000</span>, <span class=\"hljs-literal\">null</span>);\n});\n</code></pre>\n<p>这个 <code>Promise</code> 实例可能会长时间不会被回收从而造成内存泄漏，但本质原因在于 <code>setTimeout</code> 内部引用了 <code>resolve</code> 导致 <code>Promise</code> 无法被回收</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">参考</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises#%E6%97%B6%E5%BA%8F\">MDN-使用Promise-时序</a></p>\n"}},"__N_SSG":true}