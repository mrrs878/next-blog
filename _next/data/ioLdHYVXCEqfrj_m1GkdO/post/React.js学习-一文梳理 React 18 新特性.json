{"pageProps":{"post":{"title":"(转载)React.js学习-一文梳理 React 18 新特性","tags":["React.js学习","React.js18"],"categories":"React.js","description":"转载自: https://blog.csdn.net/qq_41257129/article/details/123371328\n\nReact 的迭代过程\n\nReact 从 v16 到 v18 主打的特性包括三个变化：\n\n- v16: Async Mode (异步模式)\n- v17: Concurrent Mode (并发模式)\n- v18: Concurrent Render (并发更新)","createDate":"2022-05-16 22:23:31","updateDate":"2022-05-16 22:38:14","body":"<p>转载自: <a href=\"https://blog.csdn.net/qq_41257129/article/details/123371328\">https://blog.csdn.net/qq_41257129/article/details/123371328</a></p>\n<p>React 的迭代过程</p>\n<p>React 从 v16 到 v18 主打的特性包括三个变化：</p>\n<ul>\n<li>v16: Async Mode (异步模式)</li>\n<li>v17: Concurrent Mode (并发模式)</li>\n<li>v18: Concurrent Render (并发更新)</li>\n</ul>\n<p>React 中 <code>Fiber</code> 树的更新流程分为两个阶段 <code>render</code> 阶段和 <code>commit</code> 阶段。组件的 <code>render</code> 函数执行时称为 <code>render</code> （本次更新需要做哪些变更），纯 js 计算；而将 <code>render</code> 的结果渲染到页面的过程称为 <code>commit</code> （变更到真实的宿主环境中，在浏览器中就是操作 DOM）。</p>\n<p>在 Sync 模式下， <code>render</code> 阶段是一次性执行完成；而在 <code>Concurrent</code> 模式下 <code>render</code> 阶段可以被拆解，每个时间片内执行一部分，直到执行完毕。由于 <code>commit</code> 阶段有 DOM 的更新，不可能让 DOM 更新到一半中断，必须一次性执行完毕。</p>\n<ul>\n<li>Async Mode: 让 render 变为异步、可中断的。</li>\n<li>Concurrent Mode : 让 commit 在用户的感知上是并发的。</li>\n<li>Concurrent Render : Concurrent Mode 中包含 breaking change，比如很多库不兼容（mobx 等），所以 v18 提出了 Concurrent Render ，减少了开发者的迁移成本。</li>\n</ul>\n<h2 id=\"react-并发新特性\">React 并发新特性</h2>\n<p>并发渲染机制（concurrent rendering）的目的：根据用户的设备性能和网速对渲染过程进行适当的调整， 保证 React 应用在长时间的渲染过程中依旧保持可交互性，避免页面出现卡顿或无响应的情况，从而提升用户体验。</p>\n<p>v18 正式引入了的并发渲染机制，并基于此给我们带来了很多新特性。这些新特性都是可选的并发功能，使用了这些新特性的组件并能触发并发渲染，并且与其整个子树都将自动开启 <code>strictMode</code> 。</p>\n<h2 id=\"新-root-api\">新 root API</h2>\n<p>v18 之前 root 节点对用户不透明。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./App&#x27;</span>\n​\n<span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;app&#x27;</span>)\n<span class=\"hljs-comment\">// v18 之前的方法</span>\n<span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span>/&gt;</span></span>,root)\nv18 中我们可以通过 createRoot <span class=\"hljs-title class_\">Api</span> 手动创建 root 节点。\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./App&#x27;</span>\n​\n<span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;app&#x27;</span>))\n<span class=\"hljs-comment\">// v18 的新方法</span>\nroot.<span class=\"hljs-title function_\">render</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span>/&gt;</span></span>,root)\n</code></pre>\n<p>想要使用 v18 中其他新特性 API， 前提是要使用新的 Root API 来创建根节点。</p>\n<h2 id=\"automatic-batching-自动批处理优化\">Automatic batching 自动批处理优化</h2>\n<p>批处理： React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 <code>setState</code> 事件合并）</p>\n<p>在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 <code>promise</code> 链、 <code>setTimeout</code> 等异步代码以及原生事件处理函数。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-comment\">// v18 之前</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span> () {\n\n  <span class=\"hljs-title function_\">fetchSomething</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n      <span class=\"hljs-comment\">// React 17 及之前的版本不会批处理以下的 state:</span>\n      <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 重新渲染</span>\n      <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 二次重新渲染</span>\n    })\n}\n<span class=\"hljs-comment\">// v18下</span>\n<span class=\"hljs-comment\">// 1、promise链中</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span> () {\n\n  <span class=\"hljs-title function_\">fetchSomething</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n      <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n      <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 合并为一次重新渲染</span>\n    })\n}\n<span class=\"hljs-comment\">// 2、setTimeout等异步代码中</span>\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n  <span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 合并为一次重新渲染</span>\n}, <span class=\"hljs-number\">5000</span>)\n<span class=\"hljs-comment\">// 3、原生事件中</span>\nelement.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n\n<span class=\"hljs-title function_\">setCount</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">c</span>) =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">f</span>) =&gt;</span> !f) <span class=\"hljs-comment\">// 合并为一次重新渲染</span>\n})\n</code></pre>\n<p>如果想退出自动批处理立即更新的话，可以使用 <code>ReactDOM.flushSync()</code> 进行包裹。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>\n​\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span> () {\n\n  <span class=\"hljs-comment\">// 立即更新</span>\n  <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">flushSync</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n    <span class=\"hljs-title function_\">setCounter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + <span class=\"hljs-number\">1</span>)\n  })\n  <span class=\"hljs-comment\">// 立即更新</span>\n  <span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">flushSync</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n    <span class=\"hljs-title function_\">setFlag</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">f</span> =&gt;</span> !f)\n  })\n}\n</code></pre>\n<h2 id=\"starttransition\">startTransition</h2>\n<p>可以用来降低渲染优先级。分别用来包裹计算量大的 <code>function</code> 和 <code>value</code> ，降低优先级，减少重复渲染次数。</p>\n<p>举个例子：搜索引擎的关键词联想。一般来说，对于用户在输入框中输入都希望是实时更新的，如果此时联想词比较多同时也要实时更新的话，这就可能会导致用户的输入会卡顿。这样一来用户的体验会变差，这并不是我们想要的结果。</p>\n<p>我们将这个场景的状态更新提取出来：一个是用户输入的更新；一个是联想词的更新。这个两个更新紧急程度显然前者大于后者。</p>\n<p>以前我们可以使用防抖的操作来过滤不必要的更新，但防抖有一个弊端，当我们长时间的持续输入（时间间隔小于防抖设置的时间），页面就会长时间都不到响应。而 <code>startTransition</code> 可以指定 UI 的渲染优先级，哪些需要实时更新，哪些需要延迟更新。即使用户长时间输入最迟 5s 也会更新一次，官方还提供了 hook 版本的 <code>useTransition</code> ，接受传入一个毫秒的参数用来修改最迟更新时间，返回一个过渡期的 <code>pending</code> 状态和 <code>startTransition</code> 函数。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./styles.css&quot;</span>;\n​\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n\n  <span class=\"hljs-keyword\">const</span> [value, setValue] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>();\n  <span class=\"hljs-keyword\">const</span> [searchQuery, setSearchQuery] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>([]);\n  <span class=\"hljs-keyword\">const</span> [loading, startTransition] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useTransition</span>(<span class=\"hljs-number\">2000</span>);\n​\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleChange</span> = (<span class=\"hljs-params\">e</span>) =&gt; {\n\n    <span class=\"hljs-title function_\">setValue</span>(e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>);\n    <span class=\"hljs-comment\">// 延迟更新</span>\n    <span class=\"hljs-title function_\">startTransition</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n      <span class=\"hljs-title function_\">setSearchQuery</span>(<span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">20000</span>).<span class=\"hljs-title function_\">fill</span>(e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>));\n    });\n  };\n​\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">value</span>} <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">handleChange</span>} /&gt;</span>\n      {\n    loading ? (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      ) : (\n        searchQuery.map((item, index) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">index</span>}&gt;</span>{\n    item}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>)\n      )}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p>所有在 <code>startTransition</code> 回调中更新的都会被认为是非紧急处理，如果一旦出现更紧急的处理（比如这里的用户输入）， <code>startTransition</code> 就会中断之前的更新，只会渲染最新一次的状态更新。</p>\n<p><code>startTransition</code> 的原理就是利用了 React 底层的优先级调度模型。</p>\n<p>更多例子： <a href=\"https://github.com/reactwg/react-18/discussions/65\">真实世界示例：为慢速渲染添加 startTransition</a></p>\n<h2 id=\"ssr-下的-suspense-组件\">SSR 下的 Suspense 组件</h2>\n<p><code>Suspense</code> 的作用： 划分页面中需要并发渲染的部分。</p>\n<p><code>hydration</code>[水化]：ssr 时服务器输出的是字符串（html），客户端（一般是浏览器）根据这些字符串并结合加载的 JavaScript 来完成 React 的初始化工作这一阶段为水化。</p>\n<p>React v18 之前的 SSR， 客户端必须一次性的等待 HTML 数据加载到服务器上并且等待所有 JavaScript 加载完毕之后再开始 <code>hydration</code> ， 等待所有组件 <code>hydration</code> 后，才能进行交互。即整个过程需要完成从获取数据（服务器）→ 渲染到 HTML（服务器）→ 加载代码（客户端）→ 水合物（客户端）这一套流程。这样的 SSR 并不能使我们的完全可交互变快，只是提高了用户的感知静态页面内容的速度。</p>\n<p>React v18 在 SSR 下支持了 <code>Suspense</code> ，最大的区别是什么呢？</p>\n<ol>\n<li><p>服务器不需要等待被 Suspense 包裹组件是否加载到完毕，即可发送 HTML，而代替 suspense 包裹的组件是 fallback 中的内容，一般是一个占位符（spinner），以最小内联<script>标签标记此 HTML 的位置。等待服务器上组件的数据准备好后，React 再将剩余的 HTML 发送到同一个流中。</p>\n</li>\n<li><p>hydration 的过程是逐步的，不需要等待所有的 js 加载完毕再开始 hydration，避免了页面的卡顿。</p>\n</li>\n<li><p>React 会提前监听页面上交互事件（如鼠标的点击），对发生交互的区域优先级进行 hydration。</p>\n</li>\n</ol>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/37\">https://github.com/reactwg/react-18/discussions/37</a></p>\n<h2 id=\"usesyncexternalstore\">useSyncExternalStore</h2>\n<p>这个 API 可以防止在 <code>concurrent</code> 模式下，任务中断后第三方 <code>store</code> 被修改，恢复任务时出现 <code>tearing</code> 从而数据不一致问题。用户一般很少使用，大多情况下提供给像 Redux 这样的状态管理库使用，通过 <code>useSyncExternalStore</code> 可以使 React 在 <code>concurrent mode</code> 下，保持自身 <code>state</code> 和来自 Redux 的状态同步。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>\n​\n<span class=\"hljs-comment\">// 基础用法，getSnapshot 返回一个缓存的值</span>\n<span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useSyncExternalStore</span>(store.<span class=\"hljs-property\">subscribe</span>, store.<span class=\"hljs-property\">getSnapshot</span>)\n​\n<span class=\"hljs-comment\">// 根据数据字段，使用内联的 getSnapshot 返回缓存的数据</span>\n<span class=\"hljs-keyword\">const</span> selectedField = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useSyncExternalStore</span>(store.<span class=\"hljs-property\">subscribe</span>, <span class=\"hljs-function\">() =&gt;</span> store.<span class=\"hljs-title function_\">getSnapshot</span>().<span class=\"hljs-property\">selectedField</span>)\n</code></pre>\n<ul>\n<li>第一个参数是一个订阅函数，订阅触发时会引起该组件的更新。</li>\n<li>第二个函数返回一个 immutable 快照， 返回值是我们想要订阅的数据，只有数据发生变化时才需要重新渲染。</li>\n</ul>\n<h2 id=\"useinsertioneffect\">useInsertionEffect</h2>\n<p>这个 hook 对现有的专为 React 设计的 css-in-js 库有着很大的作用，可以动态生成新规则与<code>&lt;style&gt;</code>标签一起插入到文档中。</p>\n<p>假设现在我们要插入一段 css ，并且将这个操作放在渲染期间去执行。</p>\n<pre><code class=\"hljs language-JSX\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">css</span>(<span class=\"hljs-params\">rule</span>) {\n\n  <span class=\"hljs-keyword\">if</span> (!isInserted.<span class=\"hljs-title function_\">has</span>(rule)) {\n\n    isInserted.<span class=\"hljs-title function_\">add</span>(rule)\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">head</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-title function_\">getStyleForRule</span>(rule))\n  }\n  <span class=\"hljs-keyword\">return</span> rule\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Component</span>(<span class=\"hljs-params\"></span>) {\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">css</span>(&#x27;<span class=\"hljs-attr\">...</span>&#x27;)} /&gt;</span></span>\n}\n</code></pre>\n<p>这样会导致每次修改 css 样式时，react 需要在渲染的每一帧中对所有的节点重新计算所有 CSS 规则，这并不是我们想要的结果。</p>\n<p>那我们是不是可以在所有 DOM 生成前就插入这些 css 样式，此时我们可能会想到 <code>useLayoutEffect</code> ，但 <code>useLayoutEffect</code> 中可以访问 DOM，如果在这个 hook 中访问了某个 DOM 的布局样式（比如<code>clientWidth</code>），这样会导致我们读取的信息是错误的。</p>\n<pre><code class=\"hljs language-JSX\">useLayoutEffect ( <span class=\"hljs-function\">( )  =&gt;</span>  {\n\n  <span class=\"hljs-keyword\">if</span>  ( ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">clientWidth</span>  &lt;  <span class=\"hljs-number\">100</span> )  {\n\n    setCollapsed ( <span class=\"hljs-literal\">true</span> ) ;\n  }\n} ) ;\nuseInsertionEffect 可以帮助我们避免上述问题 ，既可以满足在所有 <span class=\"hljs-variable constant_\">DOM</span> 生成前插入并且不访问 <span class=\"hljs-variable constant_\">DOM</span>。其工作原理大致与 useLayoutEffect 相同，只是此时没法访问 <span class=\"hljs-variable constant_\">DOM</span>节点的引用。我们可以在这个 hook 中插入全局的<span class=\"hljs-variable constant_\">DOM</span>节点，比如如&lt;style&gt; ，或<span class=\"hljs-variable constant_\">SVG</span>&lt;defs&gt; 。\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">useCSS</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">rule</span>) =&gt;</span> {\n\n  <span class=\"hljs-title function_\">useInsertionEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\n    <span class=\"hljs-keyword\">if</span> (!isInserted.<span class=\"hljs-title function_\">has</span>(rule)) {\n\n      isInserted.<span class=\"hljs-title function_\">add</span>(rule)\n      <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">head</span>.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-title function_\">getStyleForRule</span>(rule))\n    }\n  })\n  <span class=\"hljs-keyword\">return</span> rule\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Component</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> {\n\n  <span class=\"hljs-keyword\">let</span> className = <span class=\"hljs-title function_\">useCSS</span>(rule)\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">className</span>} /&gt;</span></span>\n}\n</code></pre>\n<p><a href=\"https://github.com/reactwg/react-18/discussions/110\">https://github.com/reactwg/react-18/discussions/110</a></p>\n<h2 id=\"useid\">useId</h2>\n<p>React 一直在向着 SSR 的领域发展，但 SSR 渲染必须保证客户端与服务端生成的 HTML 结构相匹配。我们平时使用的如 <code>Math.random()</code> 在 SSR 面前是没法保证客户端与服务端之间的 <code>id</code> 唯一性。</p>\n<p>React 为了解决这个问题，提出来 <code>useOpaqueIdentifier</code> 这个 hook, 不过它在不同环境会产生不同的结果.</p>\n<ul>\n<li><p>在服务端会生成一个字符串</p>\n</li>\n<li><p>在客户端会生成一个对象，必须直接传递给 DOM 属性</p>\n</li>\n</ul>\n<p>这样一来，在客户端如果需要生成多个标识，就需要调多次这个 hook，因为它不支持转化为字符串，就无法使用字符串拼接。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">App</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> {\n\n  <span class=\"hljs-keyword\">const</span> tabIdOne = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n  <span class=\"hljs-keyword\">const</span> panelIdOne = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n  <span class=\"hljs-keyword\">const</span> tabIdTwo = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n  <span class=\"hljs-keyword\">const</span> panelIdTwo = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">unstable_useOpaqueIdentifier</span>();\n​\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.Fragment</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabs</span> <span class=\"hljs-attr\">defaultValue</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;tablist&quot;</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">tabIdOne</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">tabIdTwo</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">panelIdOne</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n          Content One\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>\n    <span class=\"hljs-attr\">panelIdTwo</span>} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;two&quot;</span>&gt;</span>\n          Content Two\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tabs</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.Fragment</span>&gt;</span></span>\n  );\n}\n</code></pre>\n<p>而 <code>useId</code> 可以生成客户端与服务端之间的唯一 <code>id</code> ，并且返回一个字符串。这样一个组件可以只需调用一次 <code>useId</code> ，并将其结果作为整个组件所需的标识符基础（比如拼接不同的字符串），以便生成唯一 <code>id</code> 。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">App</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useId</span>();\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.Fragment</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabs</span> <span class=\"hljs-attr\">defaultValue</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;tablist&quot;</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">tab1</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tab</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">tab2</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n            One\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tab</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">panel1</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;one&quot;</span>&gt;</span>\n          Content One\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TabPanel</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>`${<span class=\"hljs-attr\">id</span>}<span class=\"hljs-attr\">panel2</span>`} <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;two&quot;</span>&gt;</span>\n          Content Two\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TabPanel</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tabs</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.Fragment</span>&gt;</span></span>\n  );\n};\n</code></pre>\n<h2 id=\"usedefferdvalue\">useDefferdValue</h2>\n<p>React 可以通过 <code>useDefferdValue</code> 允许变量延时更新，同时接受一个可选的延迟更新的最大值。React 将尝试尽快更新延迟值，如果在给定的 <code>timeoutMs</code> 期限内未能完成，它将强制更新。</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> defferValue = <span class=\"hljs-title function_\">useDeferredValue</span>(value, {\n  <span class=\"hljs-attr\">timeoutMs</span>: <span class=\"hljs-number\">1000</span>,\n});\n</code></pre>\n<p><code>useDefferdValue</code> 能够很好的展现并发渲染时优先级调整的特性，可以用于延迟计算逻辑比较复杂的状态，让其他组件优先渲染，等待这个状态更新完毕之后再渲染。</p>\n"}},"__N_SSG":true}