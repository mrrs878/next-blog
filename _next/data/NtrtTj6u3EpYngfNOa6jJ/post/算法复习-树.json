{"pageProps":{"post":{"title":"算法复习-树","tags":["算法","树"],"categories":"2021复习","description":"## BST\n\n二叉搜索树\n\n在⼆叉树的基础上，增加了对⼆叉树上节点存储位置的限制：\n\n- 左子节点值小于父节点的值\n- 右节点的值大于父节点的值\n\n![BST](https://mrrsblog.oss-cn-shanghai.aliyuncs.com/bst.png)\n\n在理想情况下，⼆叉树每多⼀层，可以存储的元素都增加⼀倍。也就是说 n 个元素的⼆叉搜索树，对应的树⾼为 O(logn)。","createDate":"2021-06-13 15:12:50","updateDate":"6/8/2021, 2:52:43 PM","body":"\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">BST</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>二叉搜索树</p>\n<p>在⼆叉树的基础上，增加了对⼆叉树上节点存储位置的限制：</p>\n<ul>\n<li>左子节点值小于父节点的值</li>\n<li>右节点的值大于父节点的值</li>\n</ul>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/bst.png\" alt=\"BST\"></p>\n<p>在理想情况下，⼆叉树每多⼀层，可以存储的元素都增加⼀倍。也就是说 n 个元素的⼆叉搜索树，对应的树⾼为 O(logn)。所以我们查找元素、插⼊元素的时间也为 O(logn)。当然这是理想情况下，但在实际应⽤中，并不是那么理想，例如⼀直递增或递减的给⼀个⼆叉查找树插⼊数据，那么所有插⼊的元素就会⼀直出现在⼀个树的左节点上，数型结构就会退化为链表结构，时间复杂度就会趋于 O(n)，这是不好的。</p>\n<p>AVL树用来解决这个问题</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">AVL</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>平衡搜索二叉树</p>\n<p>在二叉搜索树的基础上满⾜左右⼦树⾼度不⼤于1</p>\n<p><img src=\"https://mrrsblog.oss-cn-shanghai.aliyuncs.com/avl.png\" alt=\"AVL\"></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">红黑树</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>红黑树也是一种特殊的二叉搜索树</p>\n<p>在二叉搜索树的基础上添加以下限制：</p>\n<ul>\n<li>节点是红⾊或⿊⾊</li>\n<li>根节点必须是⿊⾊节点</li>\n<li>所有的叶⼦节点都必须是值为<code>NULL</code>的⿊节点</li>\n<li>如果⼀个节点是红⾊的，则它两个⼦节点都是⿊⾊的</li>\n<li>从任⼀节点到达它的每个叶⼦节点的所有的路径，都有相同数⽬的⿊⾊节点</li>\n</ul>\n"}},"__N_SSG":true}