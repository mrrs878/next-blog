{"pageProps":{"post":{"title":"React.js学习-StreamingSSR","tags":["React.js","StreamingSSR","SSR"],"categories":"React.js","description":"流式服务端渲染\n\n首先，让我们看一下 React18 之前是怎么实现 SSR 的\n\n## HTTP分块传输\n\n不过在此之前，我们可能需要先了解一下**HTTP分块传输**\n\n> 分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP 由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只","createDate":"2023-02-07 20:41:44","updateDate":"2023-02-17 19:57:42","body":"<p>流式服务端渲染</p>\n<p>首先，让我们看一下 React18 之前是怎么实现 SSR 的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">HTTP分块传输</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>不过在此之前，我们可能需要先了解一下<strong>HTTP分块传输</strong></p>\n<blockquote>\n<p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP 由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在 HTTP 协议 1.1 版本（HTTP/1.1）中提供。</p>\n</blockquote>\n<p>当 HTTP 的响应头设置 <code>Transfer-Encoding: chunked</code> 时，服务器端就可以将 Response 分段返回</p>\n<p>如下示例</p>\n<pre><code class=\"hljs language-js\">app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-keyword\">async</span> (req, res) =&gt; {\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>);\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Transfer-Encoding&quot;</span>, <span class=\"hljs-string\">&quot;chunked&quot;</span>);\n\n  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;&lt;html&gt;&lt;body&gt;&lt;div&gt;First segment&lt;/div&gt;&quot;</span>);\n  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;&lt;div&gt;Second segment&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);\n\n  res.<span class=\"hljs-title function_\">end</span>();\n});\n</code></pre>\n<p>完整版 demo<a href=\"https://github.com/mrrs878/snippets/tree/main/demos/node-streaming\">看这里</a></p>\n<p>在使用 telnet 测试时，可以清楚地看到响应报文中的 <code>chunked</code> 数据格式: 先是一行 16 进制数据（表示接下来数据的长度），然后是数据；然后再是 16 进制长度和数据，如此重复，最后是 0 长度分块结束</p>\n<p><img src=\"/img/streaming-ssr-4.png\" alt=\"renderString timing\"></p>\n<p>这样，针对于页面渲染，<strong>浏览器就可以先渲染部分，而后持续接收服务端返回的数据来继续渲染</strong></p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">renderToString &amp; renderToNodeStream</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <p>这是 React18 之前提供的用于 SSR 的 API ，两个方法都可用于在服务端渲染组件，两者的区别在于 <code>renderToString</code> 会将一个组件渲染为 HTML 字符串， 而 <code>renderToNodeStream</code> 会将一个组件渲染称为一个 Node.js 可读流，可通过 <code>res.write</code> 将数据传递给客户端</p>\n<p>一个使用 <code>renderToNodeStream</code> 实现的SSR 服务端 demo</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> { renderToNodeStream } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/server&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">App</span>: <span class=\"hljs-variable constant_\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> (\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    {new Array(10).fill(0).map(() =&gt; (\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Table</span> <span class=\"hljs-attr\">dataSource</span>=<span class=\"hljs-string\">{dataSource}</span> <span class=\"hljs-attr\">columns</span>=<span class=\"hljs-string\">{columns}</span> /&gt;</span>\n    ))}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n);\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/renderToString&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>);\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Transfer-Encoding&quot;</span>, <span class=\"hljs-string\">&quot;chunked&quot;</span>);\n\n  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;div&gt;First segment&lt;/div&gt;\n  `</span>);\n\n  <span class=\"hljs-keyword\">const</span> html = <span class=\"hljs-title function_\">renderToString</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>);\n\n  res.<span class=\"hljs-title function_\">write</span>(html);\n  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);\n  res.<span class=\"hljs-title function_\">end</span>();\n});\n</code></pre>\n<p>完整版 demo 看<a href=\"https://github.com/mrrs878/snippets/blob/7290212d81dd1a290d5930fc55cf6d4c9ecd1797/demos/react-streaming-ssr/index.tsx#L57\">这里</a></p>\n<p>下图是该方式下的请求时间图</p>\n<p><img src=\"/img/streaming-ssr-1.png\" alt=\"renderToNodeStream timing\"></p>\n<p>这是一个典型的SSR应用架构。在用户访问页面时，先在服务端使用一些 React 提供的 API 将将组件渲染为 html 发送给客户端，这样客户端能够在 javascript 执行完毕前展示基本的 html 内容，减少白屏等待时间。然后在 javascript 加载完毕后对现有的 html 元素进行事件绑定（注水），注水完毕后才是一个正常的 React 应用</p>\n<p>虽然可以实现 SSR ，但存在一些弊端： </p>\n<ol>\n<li><p><strong>存在大量的阻塞性行为：服务端需要等待组件全部渲染完毕后才能发送给客户端；客户端需要等待所有组件的 javascript 加载完毕后才能进行注水操作（渲染逻辑复杂时，页面首次渲染到可交互之间可能存在较长的不可交互时间）</strong></p>\n</li>\n<li><p><strong>不支持懒加载/代码分割</strong></p>\n</li>\n</ol>\n<p>好消息是 React18 中的 <a href=\"https://github.com/facebook/react/pull/14144\">Fizz</a> 架构带来了两个新的特性可以完美解决这些问题，即<strong>Streaming HTML（流式渲染）</strong>和<strong>Selective Hydration（选择性注水）</strong></p>\n<p>接下来让我们看看 React18 是如何解决这些问题的</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">流式渲染（Streaming HTML）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h3>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">renderToPipeableStream</span>\n        <span class=\"suffix\"></span>\n      </h3>\n    <p>虽然 <code>renderToNodeStream</code> 相对于 <code>renderToString</code> 有一定的性能提升，但还存在一个问题<strong>需要等服务端将整个页面渲染完毕后才会开始传输数据</strong>，复杂情况下，如果某个组件内有耗时的操作，这样就会阻塞 HTML 的生成。对此，React18 提供了一个新的 API <code>renderToPipeableStream</code> ，相较于 <code>renderToNodeStream</code> 该方法可以分段传输 HTML 到浏览器，这样浏览器就可以更快地启动 HTML 的渲染，提高性能</p>\n<p>该 API 的使用方式如下所示</p>\n<pre><code class=\"hljs language-tsx\">app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/renderToPipeableStream&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;text/html&quot;</span>);\n  res.<span class=\"hljs-title function_\">setHeader</span>(<span class=\"hljs-string\">&quot;Transfer-Encoding&quot;</span>, <span class=\"hljs-string\">&quot;chunked&quot;</span>);\n\n  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`\n  &lt;html&gt;\n    &lt;head&gt;\n      &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;div&gt;First segment&lt;/div&gt;\n  `</span>);\n\n  <span class=\"hljs-keyword\">let</span> didError = <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">const</span> stream = <span class=\"hljs-title function_\">renderToPipeableStream</span>(<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>, {\n    <span class=\"hljs-attr\">bootstrapScripts</span>: [<span class=\"hljs-string\">&quot;main.js&quot;</span>],\n    <span class=\"hljs-title function_\">onShellReady</span>(<span class=\"hljs-params\"></span>) {\n      res.<span class=\"hljs-property\">statusCode</span> = didError ? <span class=\"hljs-number\">500</span> : <span class=\"hljs-number\">200</span>;\n      stream.<span class=\"hljs-title function_\">pipe</span>(res);\n    },\n    <span class=\"hljs-title function_\">onShellError</span>(<span class=\"hljs-params\"></span>) {\n      res.<span class=\"hljs-property\">statusCode</span> = <span class=\"hljs-number\">500</span>;\n      res.<span class=\"hljs-title function_\">send</span>(\n        <span class=\"hljs-string\">&#x27;&lt;!doctype html&gt;&lt;p&gt;Loading...&lt;/p&gt;&lt;script src=&quot;clientrender.js&quot;&gt;&lt;/script&gt;&#x27;</span>\n      );\n    },\n    <span class=\"hljs-title function_\">onAllReady</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// stream.pipe(res);</span>\n    },\n    <span class=\"hljs-title function_\">onError</span>(<span class=\"hljs-params\">err</span>) {\n      didError = <span class=\"hljs-literal\">true</span>;\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err);\n    },\n  });\n});\n</code></pre>\n<p>完整版 demo 看<a href=\"https://github.com/mrrs878/snippets/blob/7290212d81dd1a290d5930fc55cf6d4c9ecd1797/demos/react-streaming-ssr/index.tsx#L101\">这里</a></p>\n<p>下图是该方式下的请求时间图</p>\n<p><img src=\"/img/streaming-ssr-2.png\" alt=\"renderToNodeStream timing\"></p>\n<p>可以看出，在使用 <code>renderToPipeableStream</code> 后，响应的 TTFB 获得了极大的提升</p>\n\n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">选择性注水 （Selective Hydration）</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    \n      <h2>\n        <span class=\"prefix\"></span>\n        <span class=\"content\">Ref</span>\n        <span class=\"suffix\"></span>\n      </h2>\n    <ul>\n<li><p><a href=\"https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81\">分块传输编码</a></p>\n</li>\n<li><p><a href=\"https://zh-hans.reactjs.org/docs/react-dom-server.html#rendertonodestream\">rendertonodestream</a></p>\n</li>\n<li><p><a href=\"https://juejin.cn/post/7064759195710521381\">浅析 React 18 Streaming SSR（流式服务端渲染）</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2ODQ1OTExOA==&amp;mid=2247501565&amp;idx=1&amp;sn=b9488bb90455e33eb94ec379c46ce42b&amp;chksm=cea971fcf9def8ea0f176bb06ab65ab4bcf20bfc605f8d728ca382a9de8e72cdfd7c1d1b0930&amp;token=805012839&amp;lang=zh_CN#rd\">React Streaming SSR 原理解析</a></p>\n</li>\n</ul>\n"}},"__N_SSG":true}